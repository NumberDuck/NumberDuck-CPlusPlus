/*
Number Duck
Copyright (c) 2012-2025 File Scribe

Closed source licenses may be purchased from https://numberduck.com

Otherwise:

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/



#include "NumberDuck.hpp"

namespace NumberDuck
{
	namespace Secret
	{
		class OfficeArtRecordHeaderStruct;
		class OfficeArtRecord;
		class Token;
		class WorkbookGlobals;
		class ParsedExpressionRecord;
		class BiffHeader;
		class BiffRecord_ContinueInfo;
		class Stream;
		class BiffRecord;
		class SharedStringContainer;
		class WorksheetRange;
		class BiffWorksheetStreamSize;
		class BiffRecordContainer;
		class InternalString;
		class MsoDrawingGroupRecord;
		class PaletteRecord;
		class FontRecord;
		class Format;
		class XF;
		class XFExt;
		class BoundSheet8Record;
		class Sector;
		class StreamDataStruct;
		class SectorChain;
		class CompoundFile;
		class OfficeArtFOPTEStruct;
		class MSOCRStruct;
		class OfficeArtFRITStruct;
		class OfficeArtIDCLStruct;
		class MD4DigestStruct;
		class OfficeArtBlipRecord;
		class ShortXLUnicodeStringStruct;
		class RgceLocStruct;
		class Coordinate;
		class Coordinate3d;
		class PtgAttrSpaceTypeStruct;
		class RgceAreaStruct;
		class Area;
		class Area3d;
		class FrtHeaderStruct;
		class ExtPropStruct;
		class Theme;
		class XLUnicodeStringStruct;
		class BuiltInStyleStruct;
		class FrtHeaderOldStruct;
		class XLUnicodeRichExtendedString;
		class RwStruct;
		class FtCmoStruct;
		class FtCfStruct;
		class FtPioGrbitStruct;
		class CellStruct;
		class ColStruct;
		class RkRecStruct;
		class IXFCellStruct;
		class MsoDrawingRecord_Position;
		class OfficeArtDgContainerRecord;
		class OfficeArtSpContainerRecord;
		class OfficeArtDggContainerRecord;
		class Ref8Struct;
		class BiffWorkbookGlobals;
		class OfficeArtFOPTRecord;
		class OfficeArtTertiaryFOPTRecord;
		class FormulaValueStruct;
		class CellParsedFormulaStruct;
		class Formula;
		class IcvFontStruct;
		class XTIStruct;
		class XLUnicodeRichExtendedString_ContinueInfo;
		class RwUStruct;
		class ColRelUStruct;
		class OfficeArtFOPTEOPIDStruct;
		class HyperlinkObjectStruct;
		class HyperlinkStringStruct;
		class FrtFlagsStruct;
		class FullColorExtStruct;
		class RgceStruct;
		class RowInfo;
		class ColumnInfo;
		class RowRecord;
		class OfficeArtDimensions;
		class RedBlackNode;
		class StreamDirectoryImplementation;
		class SectorImplementation;
		class CompoundFileHeader;
		class MasterSectorAllocationTable;
		class SectorAllocationTable;
		class StreamDirectory;
		class WorksheetImplementation;
		class ParseFunctionData;
		class ParseSpaceData;
		class RedBlackNodeImplementation;
		class RedBlackTreeImplementation;
		template <class T>
		class TableElement;
		class PngImageInfo;
		class JpegImageInfo;
		class XlsxWorkbookGlobals;
		class XmlNode;
		class SharedString;
		class MarkerImplementation;
		class LineImplementation;
		class FillImplementation;
		class ZipFileInfo;
	}
	class BlobView;
	class Blob;
	class Picture;
	class Style;
	class Font;
	class Worksheet;
	class Color;
	class MergedCell;
	class Marker;
	class Line;
	class Legend;
	class Fill;
	class Workbook;
	class Cell;
	class Value;
	class Chart;
	class Series;
}
namespace NumberDuck
{
	namespace Secret
	{
		class OfficeArtRecord
		{
			public: static const unsigned short MAX_DATA_SIZE = 8224;
			public: enum Type
			{
				TYPE_OFFICE_ART_DGG_CONTAINER = 0xF000,
				TYPE_OFFICE_ART_B_STORE_CONTAINER = 0xF001,
				TYPE_OFFICE_ART_DG_CONTAINER = 0xF002,
				TYPE_OFFICE_ART_SPGR_CONTAINER = 0xF003,
				TYPE_OFFICE_ART_SP_CONTAINER = 0xF004,
				TYPE_OFFICE_ART_FDGG_BLOCK = 0xF006,
				TYPE_OFFICE_ART_FBSE = 0xF007,
				TYPE_OFFICE_ART_FDG = 0xF008,
				TYPE_OFFICE_ART_FSPGR = 0xF009,
				TYPE_OFFICE_ART_FSP = 0xF00A,
				TYPE_OFFICE_ART_FOPT = 0xF00B,
				TYPE_OFFICE_ART_TERTIARY_FOPT = 0xF122,
				TYPE_OFFICE_ART_CLIENT_ANCHOR_SHEET = 0xF010,
				TYPE_OFFICE_ART_CLIENT_DATA = 0xF011,
				TYPE_OFFICE_ART_BLIP_EMF = 0xF01A,
				TYPE_OFFICE_ART_BLIP_WMF = 0xF01B,
				TYPE_OFFICE_ART_BLIP_PICT = 0xF01C,
				TYPE_OFFICE_ART_BLIP_JPEG = 0xF01D,
				TYPE_OFFICE_ART_BLIP_PNG = 0xF01E,
				TYPE_OFFICE_ART_BLIP_DIB = 0xF01F,
				TYPE_OFFICE_ART_BLIP_TIFF = 0xF029,
				TYPE_OFFICE_ART_BLIP_JPEG_CMYK = 0xF02A,
				TYPE_OFFICE_ART_FRIT_CONTAINER = 0xF118,
				TYPE_OFFICE_ART_SPLIT_MENU_COLOR_CONTAINER = 0xF11E,
			};

			public: enum OPIDType
			{
				OPID_PROTECTION_BOOLEAN_PROPERTIES = 0x007F,
				OPID_TEXT_BOOLEAN_PROPERTIES = 0x00BF,
				OPID_PIB = 0x0104,
				OPID_PIB_NAME = 0x0105,
				OPID_BLIP_BOOLEAN_PROPERTIES = 0x013F,
				OPID_FILL_COLOR = 0x0181,
				OPID_FILL_OPACITY = 0x0182,
				OPID_FILL_BACK_COLOR = 0x0183,
				OPID_FILL_BACK_OPACITY = 0x0184,
				OPID_FILL_STYLE_BOOLEAN_PROPERTIES = 0x01BF,
				OPID_LINE_COLOR = 0x01C0,
				OPID_LINE_STYLE_BOOLEAN_PROPERTIES = 0x01FF,
				OPID_SHADOW_STYLE_BOOLEAN_PROPERTIES = 0x023F,
				OPID_SHAPE_BOOLEAN_PROPERTIES = 0x033F,
				OPID_WZ_NAME = 0x0380,
				OPID_HYPERLINK = 0x0382,
				OPID_GROUP_SHAPE_BOOLEAN_PROPERTIES = 0x03BF,
			};

			protected: OfficeArtRecordHeaderStruct* m_pHeader;
			protected: bool m_bIsContainer;
			protected: OwnedVector<OfficeArtRecord*>* m_pOfficeArtRecordVector;
			public: const char* GetTypeName();
			public: OfficeArtRecord(OfficeArtRecordHeaderStruct* pHeader, bool bIsContainer, BlobView* pBlobView);
			public: OfficeArtRecord(Type nType, bool bIsContainer, unsigned int nSize, bool bHax);
			public: unsigned short GetVersion();
			public: unsigned short GetInstance();
			public: OfficeArtRecord::Type GetType();
			public: bool GetIsContainer();
			public: unsigned int GetSize();
			public: virtual unsigned int GetRecursiveSize();
			public: virtual void RecursiveWrite(BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: unsigned short GetNumOfficeArtRecord();
			public: OfficeArtRecord* GetOfficeArtRecordByIndex(unsigned short nIndex);
			public: OfficeArtRecord* FindOfficeArtRecordByType(Type eType);
			public: virtual void AddOfficeArtRecord(OfficeArtRecord* pOfficeArtRecord);
			public: static OfficeArtRecord* CreateOfficeArtRecord(BlobView* pBlobView);
			public: virtual ~OfficeArtRecord();
		};
		class ParsedExpressionRecord
		{
			public: enum Type
			{
				TYPE_PtgExp,
				TYPE_PtgAdd,
				TYPE_PtgSub,
				TYPE_PtgMul,
				TYPE_PtgDiv,
				TYPE_PtgPower,
				TYPE_PtgConcat,
				TYPE_PtgLt,
				TYPE_PtgLe,
				TYPE_PtgEq,
				TYPE_PtgGe,
				TYPE_PtgGt,
				TYPE_PtgNe,
				TYPE_PtgParen,
				TYPE_PtgMissArg,
				TYPE_PtgStr,
				TYPE_PtgAttrSemi,
				TYPE_PtgAttrIf,
				TYPE_PtgAttrGoto,
				TYPE_PtgAttrSum,
				TYPE_PtgAttrSpace,
				TYPE_PtgBool,
				TYPE_PtgInt,
				TYPE_PtgNum,
				TYPE_PtgArea,
				TYPE_PtgArea3d,
				TYPE_PtgFunc,
				TYPE_PtgFuncVar,
				TYPE_PtgRef,
				TYPE_PtgRef3d,
				TYPE_UNKNOWN,
			};

			protected: Type m_eType;
			protected: unsigned short m_nSize;
			protected: unsigned char m_nFirstByte;
			protected: unsigned char m_nSecondByte;
			public: ParsedExpressionRecord(Type eType, unsigned short nSize, bool bHax);
			public: virtual ~ParsedExpressionRecord();
			public: virtual Token* GetToken(WorkbookGlobals* pWorkbookGlobals);
			public: ParsedExpressionRecord::Type GetType();
			public: const char* GetTypeName();
			public: unsigned short GetDataSize();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static ParsedExpressionRecord* CreateParsedExpressionRecord(BlobView* pBlobView);
		};
		class BiffHeader
		{
			public: unsigned short m_nType;
			public: unsigned int m_nSize;
			public: BiffHeader();
		};
		class BiffRecord
		{
			public: static const unsigned short MAX_DATA_SIZE = 8224;
			public: enum Type
			{
				TYPE_DIMENSIONS_B2 = 0x0000,
				TYPE_BLANK_B2 = 0x0001,
				TYPE_INTEGER_B2_ONLY = 0x0002,
				TYPE_NUMBER_B2 = 0x0003,
				TYPE_LABEL_B2 = 0x0004,
				TYPE_BOOLERR_B2 = 0x0005,
				TYPE_FORMULA = 0x0006,
				TYPE_STRING_B2 = 0x0007,
				TYPE_ROW_B2 = 0x0008,
				TYPE_BOF_B2 = 0x0009,
				TYPE_EOF = 0x000A,
				TYPE_INDEX_B2_ONLY = 0x000B,
				TYPE_CALCCOUNT = 0x000C,
				TYPE_CALCMODE = 0x000D,
				TYPE_CALC_PRECISION = 0x000E,
				TYPE_REFMODE = 0x000F,
				TYPE_DELTA = 0x0010,
				TYPE_ITERATION = 0x0011,
				TYPE_PROTECT = 0x0012,
				TYPE_PASSWORD = 0x0013,
				TYPE_HEADER = 0x0014,
				TYPE_FOOTER = 0x0015,
				TYPE_EXTERNCOUNT = 0x0016,
				TYPE_EXTERN_SHEET = 0x0017,
				TYPE_NAME_B2 = 0x0018,
				TYPE_WIN_PROTECT = 0x0019,
				TYPE_VERTICALPAGEBREAKS = 0x001A,
				TYPE_HORIZONTALPAGEBREAKS = 0x001B,
				TYPE_NOTE = 0x001C,
				TYPE_SELECTION = 0x001D,
				TYPE_FORMAT_B2 = 0x001E,
				TYPE_BUILTINFMTCOUNT_B2 = 0x001F,
				TYPE_COLUMNDEFAULT_B2_ONLY = 0x0020,
				TYPE_ARRAY_B2_ONLY = 0x0021,
				TYPE_DATE_1904 = 0x0022,
				TYPE_EXTERN_NAME = 0x0023,
				TYPE_COLWIDTH_B2_ONLY = 0x0024,
				TYPE_DEFAULTROWHEIGHT_B2_ONLY = 0x0025,
				TYPE_LEFT_MARGIN = 0x0026,
				TYPE_RIGHT_MARGIN = 0x0027,
				TYPE_TOP_MARGIN = 0x0028,
				TYPE_BOTTOM_MARGIN = 0x0029,
				TYPE_PrintRowCol = 0x002A,
				TYPE_PrintGrid = 0x002B,
				TYPE_FILEPASS = 0x002F,
				TYPE_FONT = 0x0031,
				TYPE_FONT2_B2_ONLY = 0x0032,
				TYPE_PRINT_SIZE = 0x0033,
				TYPE_TABLEOP_B2 = 0x0036,
				TYPE_TABLEOP2_B2 = 0x0037,
				TYPE_CONTINUE = 0x003C,
				TYPE_WINDOW1 = 0x003D,
				TYPE_WINDOW2_B2 = 0x003E,
				TYPE_BACKUP = 0x0040,
				TYPE_PANE = 0x0041,
				TYPE_CODE_PAGE = 0x0042,
				TYPE_XF_B2 = 0x0043,
				TYPE_IXFE_B2_ONLY = 0x0044,
				TYPE_EFONT_B2_ONLY = 0x0045,
				TYPE_PLS = 0x004D,
				TYPE_DCONREF = 0x0051,
				TYPE_DEFCOLWIDTH = 0x0055,
				TYPE_BUILTINFMTCOUNT_B3 = 0x0056,
				TYPE_XCT = 0x0059,
				TYPE_CRN = 0x005A,
				TYPE_FILESHARING = 0x005B,
				TYPE_WRITE_ACCESS = 0x005C,
				TYPE_OBJ = 0x005D,
				TYPE_UNCALCED = 0x005E,
				TYPE_SAVERECALC = 0x005F,
				TYPE_OBJECTPROTECT = 0x0063,
				TYPE_COLINFO = 0x007D,
				TYPE_RK2_mythical = 0x007E,
				TYPE_GUTS = 0x0080,
				TYPE_WSBOOL = 0x0081,
				TYPE_GRIDSET = 0x0082,
				TYPE_HCENTER = 0x0083,
				TYPE_VCENTER = 0x0084,
				TYPE_BOUND_SHEET_8 = 0x0085,
				TYPE_WRITEPROT = 0x0086,
				TYPE_COUNTRY = 0x008C,
				TYPE_HIDE_OBJ = 0x008D,
				TYPE_SHEETSOFFSET = 0x008E,
				TYPE_SHEETHDR = 0x008F,
				TYPE_SORT = 0x0090,
				TYPE_PALETTE = 0x0092,
				TYPE_STANDARDWIDTH = 0x0099,
				TYPE_FILTERMODE = 0x009B,
				TYPE_BUILT_IN_FN_GROUP_COUNT = 0x009C,
				TYPE_AUTOFILTERINFO = 0x009D,
				TYPE_AUTOFILTER = 0x009E,
				TYPE_SCL = 0x00A0,
				TYPE_SETUP = 0x00A1,
				TYPE_GCW = 0x00AB,
				TYPE_MULRK = 0x00BD,
				TYPE_MULBLANK = 0x00BE,
				TYPE_MMS = 0x00C1,
				TYPE_RSTRING = 0x00D6,
				TYPE_DBCELL = 0x00D7,
				TYPE_BOOK_BOOL = 0x00DA,
				TYPE_SCENPROTECT = 0x00DD,
				TYPE_XF = 0x00E0,
				TYPE_INTERFACE_HDR = 0x00E1,
				TYPE_INTERFACE_END = 0x00E2,
				TYPE_MergeCells = 0x00E5,
				TYPE_BITMAP = 0x00E9,
				TYPE_MSO_DRAWING_GROUP = 0x00EB,
				TYPE_MSO_DRAWING = 0x00EC,
				TYPE_MSO_DRAWING_SELECTION = 0x00ED,
				TYPE_PHONETIC = 0x00EF,
				TYPE_SST = 0x00FC,
				TYPE_LABELSST = 0x00FD,
				TYPE_EXT_SST = 0x00FF,
				TYPE_RR_TAB_ID = 0x013D,
				TYPE_LABELRANGES = 0x015F,
				TYPE_USESELFS = 0x0160,
				TYPE_DSF = 0x0161,
				TYPE_SUP_BOOK = 0x01AE,
				TYPE_PROT_4_REV = 0x01AF,
				TYPE_CONDFMT = 0x01B0,
				TYPE_CF = 0x01B1,
				TYPE_DVAL = 0x01B2,
				TYPE_TXO = 0x01B6,
				TYPE_REFRESH_ALL = 0x01B7,
				TYPE_HLINK = 0x01B8,
				TYPE_PROT_4_REV_PASS = 0x01BC,
				TYPE_DV = 0x01BE,
				TYPE_EXCEL9_FILE = 0x01C0,
				TYPE_RECALCID = 0x01C1,
				TYPE_DIMENSION = 0x0200,
				TYPE_BLANK = 0x0201,
				TYPE_NUMBER = 0x0203,
				TYPE_LABEL = 0x0204,
				TYPE_BOOLERR = 0x0205,
				TYPE_FORMULA_B3 = 0x0206,
				TYPE_STRING = 0x0207,
				TYPE_ROW = 0x0208,
				TYPE_INDEX_B3 = 0x020B,
				TYPE_NAME = 0x0218,
				TYPE_ARRAY = 0x0221,
				TYPE_EXTERNNAME_B3 = 0x0223,
				TYPE_DEFAULTROWHEIGHT = 0x0225,
				TYPE_FONT_B3B4 = 0x0231,
				TYPE_TABLEOP = 0x0236,
				TYPE_WINDOW2 = 0x023E,
				TYPE_XF_B3 = 0x0243,
				TYPE_RK = 0x027E,
				TYPE_STYLE = 0x0293,
				TYPE_STYLE_EXT = 0x0892,
				TYPE_FORMULA_B4 = 0x0406,
				TYPE_FORMAT = 0x041E,
				TYPE_XF_B4 = 0x0443,
				TYPE_SHRFMLA = 0x04BC,
				TYPE_QUICKTIP = 0x0800,
				TYPE_BOF = 0x0809,
				TYPE_SHEETLAYOUT = 0x0862,
				TYPE_SHEETPROTECTION = 0x0867,
				TYPE_RANGEPROTECTION = 0x0868,
				TYPE_XF_CRC = 0x087C,
				TYPE_XF_EXT = 0x087D,
				TYPE_BOOK_EXT = 0x0863,
				TYPE_THEME = 0x0896,
				TYPE_COMPRESS_PICTURES = 0x089B,
				TYPE_PLV = 0x088B,
				TYPE_COMPAT12 = 0x088C,
				TYPE_MTR_SETTINGS = 0x089A,
				TYPE_FORCE_FULL_CALCULATION = 0x08A3,
				TYPE_TABLE_STYLES = 0x088E,
				TYPE_ChartColors = 684,
				TYPE_ChartFrtInfo = 2128,
				TYPE_StartBlock = 2130,
				TYPE_EndBlock = 2131,
				TYPE_StartObject = 2132,
				TYPE_EndObject = 2133,
				TYPE_CatLab = 2134,
				TYPE_YMult = 2135,
				TYPE_FrtFontList = 2138,
				TYPE_DataLabExt = 2154,
				TYPE_DataLabExtContents = 2155,
				TYPE_NamePublish = 2195,
				TYPE_HeaderFooter = 2204,
				TYPE_CrtMlFrt = 2206,
				TYPE_ShapePropsStream = 2212,
				TYPE_TextPropsStream = 2213,
				TYPE_CrtLayout12A = 2215,
				TYPE_Units = 4097,
				TYPE_Chart = 4098,
				TYPE_Series = 4099,
				TYPE_DataFormat = 4102,
				TYPE_LineFormat = 4103,
				TYPE_MarkerFormat = 4105,
				TYPE_AreaFormat = 4106,
				TYPE_PieFormat = 4107,
				TYPE_AttachedLabel = 4108,
				TYPE_SeriesText = 4109,
				TYPE_ChartFormat = 4116,
				TYPE_Legend = 4117,
				TYPE_SeriesList = 4118,
				TYPE_Bar = 4119,
				TYPE_Line = 4120,
				TYPE_Pie = 4121,
				TYPE_Area = 4122,
				TYPE_Scatter = 4123,
				TYPE_CrtLine = 4124,
				TYPE_Axis = 4125,
				TYPE_Tick = 4126,
				TYPE_ValueRange = 4127,
				TYPE_CatSerRange = 4128,
				TYPE_AxisLine = 4129,
				TYPE_CrtLink = 4130,
				TYPE_DefaultText = 4132,
				TYPE_Text = 4133,
				TYPE_FontX = 4134,
				TYPE_ObjectLink = 4135,
				TYPE_Frame = 4146,
				TYPE_Begin = 4147,
				TYPE_End = 4148,
				TYPE_PlotArea = 4149,
				TYPE_Chart3d = 4154,
				TYPE_PicF = 4156,
				TYPE_DropBar = 4157,
				TYPE_Radar = 4158,
				TYPE_Surf = 4159,
				TYPE_RadarArea = 4160,
				TYPE_AxisParent = 4161,
				TYPE_LegendException = 4163,
				TYPE_ShtProps = 4164,
				TYPE_SerToCrt = 4165,
				TYPE_AxesUsed = 4166,
				TYPE_SerParent = 4170,
				TYPE_SerAuxTrend = 4171,
				TYPE_IFmtRecord = 4174,
				TYPE_Pos = 4175,
				TYPE_AlRuns = 4176,
				TYPE_BRAI = 4177,
				TYPE_BOFDatasheet = 4178,
				TYPE_ExcludeRows = 4179,
				TYPE_ExcludeColumns = 4180,
				TYPE_Orient = 4181,
				TYPE_WinDoc = 4183,
				TYPE_MaxStatus = 4184,
				TYPE_MainWindow = 4185,
				TYPE_SerAuxErrBar = 4187,
				TYPE_ClrtClient = 4188,
				TYPE_SerFmt = 4189,
				TYPE_LinkedSelection = 4190,
				TYPE_Chart3DBarShape = 4191,
				TYPE_Fbi = 4192,
				TYPE_BopPop = 4193,
				TYPE_AxcExt = 4194,
				TYPE_Dat = 4195,
				TYPE_PlotGrowth = 4196,
				TYPE_SIIndex = 4197,
				TYPE_GelFrame = 4198,
				TYPE_BopPopCustom = 4199,
				TYPE_Fbi2 = 4200,
			};

			public: const char* GetTypeName();
			public: static const int SIZEOF_HEADER = 2 + 2;
			protected: BiffHeader* m_pHeader;
			protected: Blob* m_pContinueBlob;
			protected: BlobView* m_pBlobView;
			protected: OwnedVector<BiffRecord_ContinueInfo*>* m_pContinueInfoVector;
			public: BiffRecord(BiffHeader* pHeader, Stream* pStream);
			public: BiffRecord(Type nType, unsigned int nSize);
			public: BiffRecord::Type GetType();
			public: unsigned int GetSize();
			public: static BiffRecord* CreateBiffRecord(Stream* pStream);
			public: virtual void Write(Stream* pStream, BlobView* pTempBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: void Extend(BiffRecord* pBiffRecord);
			public: virtual ~BiffRecord();
		};
		class BiffWorksheetStreamSize
		{
			public: unsigned int m_nSize;
			public: BiffWorksheetStreamSize();
		};
		class WorkbookGlobals
		{
			public: SharedStringContainer* m_pSharedStringContainer;
			public: Vector<Picture*>* m_pSharedPictureVector;
			public: OwnedVector<WorksheetRange*>* m_pWorksheetRangeVector;
			public: OwnedVector<BiffWorksheetStreamSize*>* m_pBiffWorksheetStreamSizeVector;
			public: OwnedVector<Style*>* m_pStyleVector;
			public: Font* m_pHeaderFont;
			public: unsigned short m_Window1_nTabRatio;
			public: WorkbookGlobals();
			public: virtual ~WorkbookGlobals();
			public: void Clear();
			public: void PushBiffWorksheetStreamSize(unsigned int nStreamSize);
			public: const char* GetSharedStringByIndex(unsigned int nIndex);
			public: unsigned int GetSharedStringIndex(const char* szString);
			public: unsigned int PushSharedString(const char* szString);
			public: unsigned int PushPicture(Picture* pPicture);
			public: WorksheetRange* GetWorksheetRangeByIndex(unsigned short nIndex);
			public: unsigned short GetWorksheetRangeIndex(unsigned short nFirst, unsigned short nLast);
			public: Style* GetStyleByIndex(unsigned short nIndex);
			public: unsigned short GetStyleIndex(Style* pStyle);
			public: unsigned short GetNumStyle();
			public: Style* CreateStyle();
		};
		class BiffWorkbookGlobals : public WorkbookGlobals
		{
			public: static const unsigned short NUM_DEFAULT_PALETTE_ENTRY = 8;
			public: static const unsigned short NUM_CUSTOM_PALETTE_ENTRY = 56;
			public: static const unsigned short PALETTE_INDEX_ERROR = 0xFF;
			public: static const unsigned short PALETTE_INDEX_DEFAULT = 0xFE;
			public: static const unsigned char PALETTE_INDEX_DEFAULT_FOREGROUND = 0x0040;
			public: static const unsigned char PALETTE_INDEX_DEFAULT_BACKGROUND = 0x0041;
			public: static const unsigned short PALETTE_INDEX_DEFAULT_CHART_FOREGROUND = 0x004D;
			public: static const unsigned short PALETTE_INDEX_DEFAULT_CHART_BACKGROUND = 0x004E;
			public: static const unsigned short PALETTE_INDEX_DEFAULT_NEUTRAL = 0x004F;
			public: static const unsigned short PALETTE_INDEX_DEFAULT_TOOL_TIP_TEXT = 0x0051;
			public: static const unsigned short PALETTE_INDEX_DEFAULT_FONT_AUTOMATIC = 0x7FFF;
			public: static const unsigned int DEFAULT_COLOR[NUM_DEFAULT_PALETTE_ENTRY];
			public: static const unsigned int DEFAULT_CUSTOM_COLOR[NUM_CUSTOM_PALETTE_ENTRY];
			protected: BiffRecordContainer* m_pBiffRecordContainer;
			protected: OwnedVector<InternalString*>* m_sWorkheetNameVector;
			protected: InternalString* m_sTempWorksheetName;
			protected: MsoDrawingGroupRecord* m_MsoDrawingGroupRecord;
			protected: PaletteRecord* m_pPaletteRecord;
			public: BiffWorkbookGlobals(BiffRecord* pInitialBiffRecord, Stream* pStream);
			public: static void Write(WorkbookGlobals* pWorkbookGlobals, OwnedVector<Worksheet*>* pWorksheetVector, Stream* pStream);
			public: const char* GetNextWorksheetName();
			public: Style* GetStyleByXfIndex(unsigned short nXfIndex);
			public: MsoDrawingGroupRecord* GetMsoDrawingGroupRecord();
			public: static unsigned char SnapToPalette(Color* pColor);
			public: static unsigned int GetDefaultPaletteColorByIndex(unsigned short nIndex);
			public: unsigned int GetPaletteColorByIndex(unsigned short nIndex);
			public: virtual ~BiffWorkbookGlobals();
		};
		class BiffStruct
		{
			public: enum FontScheme
			{
				XFSNONE = 0x00,
				XFSMAJOR = 0x01,
				XFSMINOR = 0x02,
				XFSNIL = 0xFF,
			};

			public: enum XColorType
			{
				XCLRAUTO = 0x00000000,
				XCLRINDEXED = 0x00000001,
				XCLRRGB = 0x00000002,
				XCLRTHEMED = 0x00000003,
				XCLRNINCHED = 0x00000004,
			};

			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
		};
		class FtCmoStruct : public BiffStruct
		{
			public: FtCmoStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 22;
			public: void SetDefaults();
			public: unsigned short m_ft;
			public: unsigned short m_cb;
			public: unsigned short m_ot;
			public: unsigned short m_id;
			public: unsigned short m_fLocked;
			public: unsigned short m_reserved;
			public: unsigned short m_fDefaultSize;
			public: unsigned short m_fPublished;
			public: unsigned short m_fPrint;
			public: unsigned short m_unused1;
			public: unsigned short m_unused2;
			public: unsigned short m_fDisabled;
			public: unsigned short m_fUIObj;
			public: unsigned short m_fRecalcObj;
			public: unsigned short m_unused3;
			public: unsigned short m_unused4;
			public: unsigned short m_fRecalcObjAlways;
			public: unsigned short m_unused5;
			public: unsigned short m_unused6;
			public: unsigned short m_unused7;
			public: unsigned int m_unused8;
			public: unsigned int m_unused9;
			public: unsigned int m_unused10;
			public: enum ObjType
			{
				OBJ_TYPE_GROUP = 0x0000,
				OBJ_TYPE_LINE = 0x0001,
				OBJ_TYPE_RECTANGLE = 0x0002,
				OBJ_TYPE_OVAL = 0x0003,
				OBJ_TYPE_ARC = 0x0004,
				OBJ_TYPE_CHART = 0x0005,
				OBJ_TYPE_TEXT = 0x0006,
				OBJ_TYPE_BUTTON = 0x0007,
				OBJ_TYPE_PICTURE = 0x0008,
				OBJ_TYPE_POLYGON = 0x0009,
				OBJ_TYPE_CHECKBOX = 0x000B,
				OBJ_TYPE_RADIO_BUTTON = 0x000C,
				OBJ_TYPE_EDIT_BOX = 0x000D,
				OBJ_TYPE_LABEL = 0x000E,
				OBJ_TYPE_DIALOG_BOX = 0x000F,
				OBJ_TYPE_SPIN_CONTROL = 0x0010,
				OBJ_TYPE_SCROLLBAR = 0x0011,
				OBJ_TYPE_LIST = 0x0012,
				OBJ_TYPE_GROUP_BOX = 0x0013,
				OBJ_TYPE_DROPDOWN_LIST = 0x0014,
				OBJ_TYPE_NOTE = 0x0019,
				OBJ_TYPE_OFFICE_ART_OBJECT = 0x001E,
			};

		};
		class SectorChain
		{
			protected: int m_nSectorSize;
			protected: Vector<Sector*>* m_pSectorVector;
			protected: Blob* m_pBlob;
			public: SectorChain(int nSectorSize);
			public: int GetNumSector();
			public: Sector* GetSectorByIndex(int nIndex);
			public: int GetSectorSize();
			public: int GetDataSize();
			public: void Read(int nSize, BlobView* pBlobView);
			public: void ReadAt(int nOffset, int nSize, BlobView* pBlobView);
			public: void Write(int nSize, BlobView* pBlobView);
			public: void WriteAt(int nOffset, int nSize, BlobView* pBlobView);
			public: int GetOffset();
			public: void SetOffset(int nOffset);
			public: virtual void AppendSector(Sector* pSector);
			public: virtual void Extend(Sector* pSector);
			public: BlobView* GetBlobView();
			public: void WriteToSectors();
			public: virtual ~SectorChain();
		};
		class StreamDataStruct
		{
			public: static const int MAX_NAME_LENGTH = 32;
			public: unsigned short m_pName[MAX_NAME_LENGTH];
			public: unsigned short m_nNameDataSize;
			public: unsigned char m_nType;
			public: unsigned char m_nNodeColour;
			public: int m_nLeftChildNodeStreamId;
			public: int m_nRightChildNodeStreamId;
			public: int m_nRootNodeStreamId;
			public: unsigned char m_pUniqueIdentifier[16];
			public: unsigned char m_pUserFlags[4];
			public: unsigned char m_pCreationDate[8];
			public: unsigned char m_pModificationDate[8];
			public: int m_nSectorId;
			public: unsigned int m_nStreamSize;
			public: unsigned char m_pUnused[4];
			public: StreamDataStruct();
		};
		class Stream
		{
			public: enum Type
			{
				TYPE_EMPTY = 0,
				TYPE_USER_STORAGE,
				TYPE_USER_STREAM,
				TYPE_LOCK_BYTES,
				TYPE_PROPERTY,
				TYPE_ROOT_STORAGE,
			};

			public: static const int DATA_SIZE = 128;
			protected: int m_nStreamId;
			protected: int m_nMinimumStandardStreamSize;
			protected: StreamDataStruct* m_pDataStruct;
			protected: BlobView* m_pBlobView;
			protected: SectorChain* m_pSectorChain;
			protected: InternalString* m_sNameTemp;
			protected: CompoundFile* m_pCompoundFile;
			public: Stream(int nStreamId, int nMinimumStandardStreamSize, Blob* pBlob, int nOffset, CompoundFile* pCompoundFile);
			public: void Allocate(Type eType, int nStreamSize);
			public: void FillSectorChain();
			public: void WriteToSectors();
			public: int GetStreamId();
			public: const char* GetName();
			public: void SetName(const char* sxName);
			public: Stream::Type GetType();
			public: int GetSectorId();
			public: bool GetShortSector();
			public: int GetStreamSize();
			public: int GetSize();
			public: SectorChain* GetSectorChain();
			public: int GetOffset();
			public: void SetOffset(int nOffset);
			public: void SizeToFit(int nSize);
			public: bool Resize(int nSize);
			public: void SetNodeColour(unsigned char nColour);
			public: void SetLeftChildNodeStreamId(int nStreamId);
			public: void SetRightChildNodeStreamId(int nStreamId);
			public: void SetRootNodeStreamId(int nStreamId);
			public: unsigned short GetNameLengthUtf16();
			public: unsigned short GetNameUtf16(unsigned short nIndex);
			public: virtual ~Stream();
		};
		class OfficeArtTertiaryFOPTRecord : public OfficeArtRecord
		{
			public: OfficeArtTertiaryFOPTRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 0;
			protected: static const bool IS_CONTAINER = false;
			protected: static const OfficeArtRecord::Type TYPE = OfficeArtRecord::Type::TYPE_OFFICE_ART_TERTIARY_FOPT;
			protected: void SetDefaults();
			protected: OwnedVector<OfficeArtFOPTEStruct*>* m_pFoptVector;
			public: OfficeArtTertiaryFOPTRecord();
			protected: void PostSetDefaults();
			protected: void PostBlobWrite(BlobView* pBlobView);
			protected: void PostBlobRead(BlobView* pBlobView);
			public: void AddProperty(unsigned short opid, unsigned char fBid, int op);
			public: OfficeArtFOPTEStruct* GetProperty(OfficeArtRecord::OPIDType eType);
			public: virtual ~OfficeArtTertiaryFOPTRecord();
		};
		class OfficeArtSplitMenuColorContainerRecord : public OfficeArtRecord
		{
			public: OfficeArtSplitMenuColorContainerRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 16;
			protected: static const bool IS_CONTAINER = false;
			protected: static const OfficeArtRecord::Type TYPE = OfficeArtRecord::Type::TYPE_OFFICE_ART_SPLIT_MENU_COLOR_CONTAINER;
			protected: void SetDefaults();
			protected: MSOCRStruct* m_smca0;
			protected: MSOCRStruct* m_smca1;
			protected: MSOCRStruct* m_smca2;
			protected: MSOCRStruct* m_smca3;
			public: OfficeArtSplitMenuColorContainerRecord();
			public: virtual ~OfficeArtSplitMenuColorContainerRecord();
		};
		class OfficeArtSpgrContainerRecord : public OfficeArtRecord
		{
			public: OfficeArtSpgrContainerRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 0;
			protected: static const bool IS_CONTAINER = true;
			protected: static const OfficeArtRecord::Type TYPE = OfficeArtRecord::Type::TYPE_OFFICE_ART_SPGR_CONTAINER;
			protected: void SetDefaults();
			public: OfficeArtSpgrContainerRecord();
		};
		class OfficeArtSpContainerRecord : public OfficeArtRecord
		{
			public: OfficeArtSpContainerRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 0;
			protected: static const bool IS_CONTAINER = true;
			protected: static const OfficeArtRecord::Type TYPE = OfficeArtRecord::Type::TYPE_OFFICE_ART_SP_CONTAINER;
			protected: void SetDefaults();
			public: OfficeArtSpContainerRecord();
		};
		class OfficeArtFSPRecord : public OfficeArtRecord
		{
			public: OfficeArtFSPRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 8;
			protected: static const bool IS_CONTAINER = false;
			protected: static const OfficeArtRecord::Type TYPE = OfficeArtRecord::Type::TYPE_OFFICE_ART_FSP;
			protected: void SetDefaults();
			protected: unsigned int m_spid;
			protected: unsigned int m_fGroup;
			protected: unsigned int m_fChild;
			protected: unsigned int m_fPatriarch;
			protected: unsigned int m_fDeleted;
			protected: unsigned int m_fOleShape;
			protected: unsigned int m_fHaveMaster;
			protected: unsigned int m_fFlipH;
			protected: unsigned int m_fFlipV;
			protected: unsigned int m_fConnector;
			protected: unsigned int m_fHaveAnchor;
			protected: unsigned int m_fBackground;
			protected: unsigned int m_fHaveSpt;
			protected: unsigned int m_unused1;
			public: OfficeArtFSPRecord(unsigned short recInstance, unsigned int spid, unsigned char fGroup, unsigned char fPatriarch, unsigned char fHaveAnchor, unsigned char fHaveSpt);
		};
		class OfficeArtFSPGRRecord : public OfficeArtRecord
		{
			public: OfficeArtFSPGRRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 16;
			protected: static const bool IS_CONTAINER = false;
			protected: static const OfficeArtRecord::Type TYPE = OfficeArtRecord::Type::TYPE_OFFICE_ART_FSPGR;
			protected: void SetDefaults();
			protected: unsigned int m_xLeft;
			protected: unsigned int m_yTop;
			protected: unsigned int m_xRight;
			protected: unsigned int m_yBottom;
			public: OfficeArtFSPGRRecord();
		};
		class OfficeArtFRITContainerRecord : public OfficeArtRecord
		{
			public: OfficeArtFRITContainerRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 0;
			protected: static const bool IS_CONTAINER = false;
			protected: static const OfficeArtRecord::Type TYPE = OfficeArtRecord::Type::TYPE_OFFICE_ART_FRIT_CONTAINER;
			protected: void SetDefaults();
			protected: OwnedVector<OfficeArtFRITStruct*>* m_pRgfritVector;
			protected: void PostSetDefaults();
			protected: void PostBlobWrite(BlobView* pBlobView);
			protected: void PostBlobRead(BlobView* pBlobView);
			public: unsigned short GetNumFRIT();
			public: OfficeArtFRITStruct* GetFRITByIndex(unsigned short nIndex);
			public: virtual ~OfficeArtFRITContainerRecord();
		};
		class OfficeArtFOPTRecord : public OfficeArtRecord
		{
			public: OfficeArtFOPTRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 0;
			protected: static const bool IS_CONTAINER = false;
			protected: static const OfficeArtRecord::Type TYPE = OfficeArtRecord::Type::TYPE_OFFICE_ART_FOPT;
			protected: void SetDefaults();
			protected: OwnedVector<OfficeArtFOPTEStruct*>* m_pFoptVector;
			public: OfficeArtFOPTRecord();
			protected: void PostSetDefaults();
			protected: void PostBlobWrite(BlobView* pBlobView);
			protected: void PostBlobRead(BlobView* pBlobView);
			public: void AddProperty(unsigned short opid, unsigned char fBid, int op);
			public: void AddStringProperty(unsigned short opid, const char* szString);
			public: void AddBlobProperty(unsigned short opid, unsigned char fBid, Blob* pBlob);
			public: OfficeArtFOPTEStruct* GetProperty(OfficeArtRecord::OPIDType eType);
			public: virtual ~OfficeArtFOPTRecord();
		};
		class OfficeArtFDGRecord : public OfficeArtRecord
		{
			public: OfficeArtFDGRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 8;
			protected: static const bool IS_CONTAINER = false;
			protected: static const OfficeArtRecord::Type TYPE = OfficeArtRecord::Type::TYPE_OFFICE_ART_FDG;
			protected: void SetDefaults();
			protected: unsigned int m_csp;
			protected: unsigned int m_spidCur;
			public: OfficeArtFDGRecord(unsigned short recInstance, unsigned int csp, unsigned int spidCur);
		};
		class OfficeArtFDGGBlockRecord : public OfficeArtRecord
		{
			public: OfficeArtFDGGBlockRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 16;
			protected: static const bool IS_CONTAINER = false;
			protected: static const OfficeArtRecord::Type TYPE = OfficeArtRecord::Type::TYPE_OFFICE_ART_FDGG_BLOCK;
			protected: void SetDefaults();
			protected: unsigned int m_spidMax;
			protected: unsigned int m_cidcl;
			protected: unsigned int m_cspSaved;
			protected: unsigned int m_cdgSaved;
			protected: OwnedVector<OfficeArtIDCLStruct*>* m_pRgidclVector;
			public: OfficeArtFDGGBlockRecord(unsigned int nNumPicture);
			protected: void PostSetDefaults();
			protected: void PostBlobWrite(BlobView* pBlobView);
			protected: void PostBlobRead(BlobView* pBlobView);
			public: virtual ~OfficeArtFDGGBlockRecord();
		};
		class OfficeArtFBSERecord : public OfficeArtRecord
		{
			public: OfficeArtFBSERecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 36;
			protected: static const bool IS_CONTAINER = false;
			protected: static const OfficeArtRecord::Type TYPE = OfficeArtRecord::Type::TYPE_OFFICE_ART_FBSE;
			protected: void SetDefaults();
			protected: unsigned char m_btWin32;
			protected: unsigned char m_btMacOS;
			protected: MD4DigestStruct* m_rgbUid;
			protected: unsigned short m_tag;
			protected: unsigned int m_size;
			protected: unsigned int m_cRef;
			protected: unsigned int m_foDelay;
			protected: unsigned char m_unused1;
			protected: unsigned char m_cbName;
			protected: unsigned char m_unused2;
			protected: unsigned char m_unused3;
			protected: OfficeArtBlipRecord* m_pEmbeddedBlip;
			public: OfficeArtFBSERecord(Picture* pPicture);
			protected: void PostSetDefaults();
			protected: void PostBlobWrite(BlobView* pBlobView);
			protected: void PostBlobRead(BlobView* pBlobView);
			public: OfficeArtBlipRecord* GetEmbeddedBlip();
			public: virtual ~OfficeArtFBSERecord();
		};
		class OfficeArtDggContainerRecord : public OfficeArtRecord
		{
			public: OfficeArtDggContainerRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 0;
			protected: static const bool IS_CONTAINER = true;
			protected: static const OfficeArtRecord::Type TYPE = OfficeArtRecord::Type::TYPE_OFFICE_ART_DGG_CONTAINER;
			protected: void SetDefaults();
			public: OfficeArtDggContainerRecord();
		};
		class OfficeArtDgContainerRecord : public OfficeArtRecord
		{
			public: OfficeArtDgContainerRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 0;
			protected: static const bool IS_CONTAINER = true;
			protected: static const OfficeArtRecord::Type TYPE = OfficeArtRecord::Type::TYPE_OFFICE_ART_DG_CONTAINER;
			protected: void SetDefaults();
			public: OfficeArtDgContainerRecord();
		};
		class OfficeArtClientDataRecord : public OfficeArtRecord
		{
			public: OfficeArtClientDataRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 0;
			protected: static const bool IS_CONTAINER = false;
			protected: static const OfficeArtRecord::Type TYPE = OfficeArtRecord::Type::TYPE_OFFICE_ART_CLIENT_DATA;
			protected: void SetDefaults();
			public: OfficeArtClientDataRecord();
		};
		class OfficeArtClientAnchorSheetRecord : public OfficeArtRecord
		{
			public: OfficeArtClientAnchorSheetRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 18;
			protected: static const bool IS_CONTAINER = false;
			protected: static const OfficeArtRecord::Type TYPE = OfficeArtRecord::Type::TYPE_OFFICE_ART_CLIENT_ANCHOR_SHEET;
			protected: void SetDefaults();
			protected: unsigned short m_fMove;
			protected: unsigned short m_fSize;
			protected: unsigned short m_reserved1;
			protected: unsigned short m_reserved2;
			protected: unsigned short m_reserved3;
			protected: unsigned short m_unused;
			protected: unsigned short m_colL;
			protected: unsigned short m_dxL;
			protected: unsigned short m_rwT;
			protected: unsigned short m_dyT;
			protected: unsigned short m_colR;
			protected: unsigned short m_dxR;
			protected: unsigned short m_rwB;
			protected: unsigned short m_dyB;
			public: OfficeArtClientAnchorSheetRecord(unsigned short colL, unsigned short dxL, unsigned short rwT, unsigned short dyT, unsigned short colR, unsigned short dxR, unsigned short rwB, unsigned short dyB);
			public: unsigned short GetCellX1();
			public: unsigned short GetSubCellX1();
			public: unsigned short GetCellY1();
			public: unsigned short GetSubCellY1();
			public: unsigned short GetCellX2();
			public: unsigned short GetSubCellX2();
			public: unsigned short GetCellY2();
			public: unsigned short GetSubCellY2();
		};
		class OfficeArtBlipRecord : public OfficeArtRecord
		{
			public: OfficeArtBlipRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 16;
			protected: static const bool IS_CONTAINER = false;
			protected: static const OfficeArtRecord::Type TYPE = OfficeArtRecord::Type::TYPE_OFFICE_ART_BLIP_EMF;
			protected: void SetDefaults();
			protected: MD4DigestStruct* m_rgbUid1;
			protected: MD4DigestStruct* m_rgbUid2;
			protected: unsigned char m_tag;
			protected: Blob* m_BLIPFileData_;
			protected: Blob* m_OwnedBLIPFileData;
			public: OfficeArtBlipRecord(Picture* pPicture);
			protected: void PostSetDefaults();
			protected: void PostBlobWrite(BlobView* pBlobView);
			protected: void PostBlobRead(BlobView* pBlobView);
			public: Blob* GetBlob();
			public: virtual ~OfficeArtBlipRecord();
		};
		class OfficeArtBStoreContainerRecord : public OfficeArtRecord
		{
			public: OfficeArtBStoreContainerRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 0;
			protected: static const bool IS_CONTAINER = true;
			protected: static const OfficeArtRecord::Type TYPE = OfficeArtRecord::Type::TYPE_OFFICE_ART_B_STORE_CONTAINER;
			protected: void SetDefaults();
			public: OfficeArtBStoreContainerRecord();
			protected: void PreBlobWrite(BlobView* pBlobView);
			public: virtual void AddOfficeArtRecord(OfficeArtRecord* pOfficeArtRecord);
		};
		class PtgStrRecord : public ParsedExpressionRecord
		{
			public: PtgStrRecord(BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 1;
			protected: static const ParsedExpressionRecord::Type TYPE = ParsedExpressionRecord::Type::TYPE_PtgStr;
			protected: void SetDefaults();
			protected: unsigned char m_ptg;
			protected: unsigned char m_reserved0;
			protected: ShortXLUnicodeStringStruct* m_string;
			public: PtgStrRecord(const char* szString);
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: virtual Token* GetToken(WorkbookGlobals* pWorkbookGlobals);
			public: virtual ~PtgStrRecord();
		};
		class PtgRefRecord : public ParsedExpressionRecord
		{
			public: PtgRefRecord(BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 5;
			protected: static const ParsedExpressionRecord::Type TYPE = ParsedExpressionRecord::Type::TYPE_PtgRef;
			protected: void SetDefaults();
			protected: unsigned char m_ptg;
			protected: unsigned char m_type;
			protected: unsigned char m_reserved;
			protected: RgceLocStruct* m_loc;
			public: PtgRefRecord(Coordinate* pCoordinate);
			public: virtual Token* GetToken(WorkbookGlobals* pWorkbookGlobals);
			public: virtual ~PtgRefRecord();
		};
		class PtgRef3dRecord : public ParsedExpressionRecord
		{
			public: PtgRef3dRecord(BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 7;
			protected: static const ParsedExpressionRecord::Type TYPE = ParsedExpressionRecord::Type::TYPE_PtgRef3d;
			protected: void SetDefaults();
			protected: unsigned char m_ptg;
			protected: unsigned char m_type;
			protected: unsigned char m_reserved;
			protected: unsigned short m_ixti;
			protected: RgceLocStruct* m_loc;
			public: PtgRef3dRecord(Coordinate3d* pCoordinate3d, WorkbookGlobals* pWorkbookGlobals);
			public: virtual Token* GetToken(WorkbookGlobals* pWorkbookGlobals);
			public: virtual ~PtgRef3dRecord();
		};
		class PtgParenRecord : public ParsedExpressionRecord
		{
			public: PtgParenRecord();
			public: PtgParenRecord(BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 1;
			protected: static const ParsedExpressionRecord::Type TYPE = ParsedExpressionRecord::Type::TYPE_PtgParen;
			protected: void SetDefaults();
			protected: unsigned char m_ptg;
			protected: unsigned char m_reserved0;
			public: PtgParenRecord(unsigned char ptg);
			public: void PostBlobRead(BlobView* pBlobView);
			public: virtual Token* GetToken(WorkbookGlobals* pWorkbookGlobals);
		};
		class PtgOperatorRecord : public ParsedExpressionRecord
		{
			public: PtgOperatorRecord(BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 1;
			protected: static const ParsedExpressionRecord::Type TYPE = ParsedExpressionRecord::Type::TYPE_UNKNOWN;
			protected: void SetDefaults();
			protected: unsigned char m_ptg;
			protected: unsigned char m_reserved0;
			public: PtgOperatorRecord(unsigned char ptg);
			public: void PostBlobRead(BlobView* pBlobView);
			public: virtual Token* GetToken(WorkbookGlobals* pWorkbookGlobals);
		};
		class PtgNumRecord : public ParsedExpressionRecord
		{
			public: PtgNumRecord(BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 9;
			protected: static const ParsedExpressionRecord::Type TYPE = ParsedExpressionRecord::Type::TYPE_PtgNum;
			protected: void SetDefaults();
			protected: unsigned char m_ptg;
			protected: unsigned char m_reserved0;
			protected: double m_value;
			public: PtgNumRecord(double value);
			public: virtual Token* GetToken(WorkbookGlobals* pWorkbookGlobals);
		};
		class PtgMissArgRecord : public ParsedExpressionRecord
		{
			public: PtgMissArgRecord();
			public: PtgMissArgRecord(BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 1;
			protected: static const ParsedExpressionRecord::Type TYPE = ParsedExpressionRecord::Type::TYPE_PtgMissArg;
			protected: void SetDefaults();
			protected: unsigned char m_ptg;
			protected: unsigned char m_reserved0;
			public: virtual Token* GetToken(WorkbookGlobals* pWorkbookGlobals);
		};
		class PtgIntRecord : public ParsedExpressionRecord
		{
			public: PtgIntRecord(BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 3;
			protected: static const ParsedExpressionRecord::Type TYPE = ParsedExpressionRecord::Type::TYPE_PtgInt;
			protected: void SetDefaults();
			protected: unsigned char m_ptg;
			protected: unsigned char m_reserved0;
			protected: unsigned short m_integer;
			public: PtgIntRecord(unsigned short nInt);
			public: virtual Token* GetToken(WorkbookGlobals* pWorkbookGlobals);
		};
		class PtgFuncVarRecord : public ParsedExpressionRecord
		{
			public: PtgFuncVarRecord(BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 4;
			protected: static const ParsedExpressionRecord::Type TYPE = ParsedExpressionRecord::Type::TYPE_PtgFuncVar;
			protected: void SetDefaults();
			protected: unsigned char m_ptg;
			protected: unsigned char m_type;
			protected: unsigned char m_reserved0;
			protected: unsigned char m_cparams;
			protected: unsigned short m_tab;
			protected: unsigned short m_fCeFunc;
			public: PtgFuncVarRecord(unsigned short iftab, unsigned char cparams);
			public: virtual Token* GetToken(WorkbookGlobals* pWorkbookGlobals);
		};
		class PtgFuncRecord : public ParsedExpressionRecord
		{
			public: PtgFuncRecord(BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 3;
			protected: static const ParsedExpressionRecord::Type TYPE = ParsedExpressionRecord::Type::TYPE_PtgFunc;
			protected: void SetDefaults();
			protected: unsigned char m_ptg;
			protected: unsigned char m_type;
			protected: unsigned char m_reserved0;
			protected: unsigned short m_iftab;
			public: virtual Token* GetToken(WorkbookGlobals* pWorkbookGlobals);
		};
		class PtgBoolRecord : public ParsedExpressionRecord
		{
			public: PtgBoolRecord(BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const ParsedExpressionRecord::Type TYPE = ParsedExpressionRecord::Type::TYPE_PtgBool;
			protected: void SetDefaults();
			protected: unsigned char m_ptg;
			protected: unsigned char m_reserved0;
			protected: unsigned char m_boolean;
			public: PtgBoolRecord(bool bBool);
			public: virtual Token* GetToken(WorkbookGlobals* pWorkbookGlobals);
		};
		class PtgAttrSumRecord : public ParsedExpressionRecord
		{
			public: PtgAttrSumRecord();
			public: PtgAttrSumRecord(BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 4;
			protected: static const ParsedExpressionRecord::Type TYPE = ParsedExpressionRecord::Type::TYPE_PtgAttrSum;
			protected: void SetDefaults();
			protected: unsigned char m_ptg;
			protected: unsigned char m_reserved0;
			protected: unsigned char m_reserved2;
			protected: unsigned char m_bitIf;
			protected: unsigned char m_reserved3;
			protected: unsigned short m_unused;
			public: virtual Token* GetToken(WorkbookGlobals* pWorkbookGlobals);
		};
		class PtgAttrSpaceRecord : public ParsedExpressionRecord
		{
			public: PtgAttrSpaceRecord(BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 4;
			protected: static const ParsedExpressionRecord::Type TYPE = ParsedExpressionRecord::Type::TYPE_PtgAttrSpace;
			protected: void SetDefaults();
			protected: unsigned char m_ptg;
			protected: unsigned char m_reserved0;
			protected: unsigned char m_reserved2;
			protected: unsigned char m_bitSpace;
			protected: unsigned char m_reserved3;
			protected: PtgAttrSpaceTypeStruct* m_type;
			public: PtgAttrSpaceRecord(unsigned char nType, unsigned char nCount);
			public: virtual Token* GetToken(WorkbookGlobals* pWorkbookGlobals);
			public: virtual ~PtgAttrSpaceRecord();
		};
		class PtgAttrSemiRecord : public ParsedExpressionRecord
		{
			public: PtgAttrSemiRecord();
			public: PtgAttrSemiRecord(BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 4;
			protected: static const ParsedExpressionRecord::Type TYPE = ParsedExpressionRecord::Type::TYPE_PtgAttrSemi;
			protected: void SetDefaults();
			protected: unsigned char m_ptg;
			protected: unsigned char m_reserved0;
			protected: unsigned char m_bitSemi;
			protected: unsigned char m_reserved2;
			protected: unsigned short m_unused;
		};
		class PtgAttrIfRecord : public ParsedExpressionRecord
		{
			public: PtgAttrIfRecord();
			public: PtgAttrIfRecord(BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 4;
			protected: static const ParsedExpressionRecord::Type TYPE = ParsedExpressionRecord::Type::TYPE_PtgAttrIf;
			protected: void SetDefaults();
			protected: unsigned char m_ptg;
			protected: unsigned char m_reserved0;
			protected: unsigned char m_reserved2;
			protected: unsigned char m_bitIf;
			protected: unsigned char m_reserved3;
			protected: unsigned short m_offset;
			public: virtual Token* GetToken(WorkbookGlobals* pWorkbookGlobals);
		};
		class PtgAttrGotoRecord : public ParsedExpressionRecord
		{
			public: PtgAttrGotoRecord();
			public: PtgAttrGotoRecord(BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 4;
			protected: static const ParsedExpressionRecord::Type TYPE = ParsedExpressionRecord::Type::TYPE_PtgAttrGoto;
			protected: void SetDefaults();
			protected: unsigned char m_ptg;
			protected: unsigned char m_reserved0;
			protected: unsigned char m_reserved2;
			protected: unsigned char m_bitGoto;
			protected: unsigned char m_reserved3;
			protected: unsigned short m_unused;
		};
		class PtgAreaRecord : public ParsedExpressionRecord
		{
			public: PtgAreaRecord(BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 9;
			protected: static const ParsedExpressionRecord::Type TYPE = ParsedExpressionRecord::Type::TYPE_PtgArea;
			protected: void SetDefaults();
			protected: unsigned char m_ptg;
			protected: unsigned char m_type;
			protected: unsigned char m_reserved;
			protected: RgceAreaStruct* m_area;
			public: PtgAreaRecord(Area* pArea);
			public: virtual Token* GetToken(WorkbookGlobals* pWorkbookGlobals);
			public: virtual ~PtgAreaRecord();
		};
		class PtgArea3dRecord : public ParsedExpressionRecord
		{
			public: PtgArea3dRecord(BlobView* pBlobView);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 11;
			protected: static const ParsedExpressionRecord::Type TYPE = ParsedExpressionRecord::Type::TYPE_PtgArea3d;
			protected: void SetDefaults();
			protected: unsigned char m_ptg;
			protected: unsigned char m_type;
			protected: unsigned char m_reserved;
			protected: unsigned short m_ixti;
			protected: RgceAreaStruct* m_area;
			public: PtgArea3dRecord(Area3d* pArea3d, WorkbookGlobals* pWorkbookGlobals);
			public: virtual Token* GetToken(WorkbookGlobals* pWorkbookGlobals);
			public: virtual ~PtgArea3dRecord();
		};
		class Hsl
		{
			public: double m_fH;
			public: double m_fS;
			public: double m_fL;
			public: void ToColor(Color* pColor);
			public: void Set(const Color* pColor);
			protected: double haxmax(double a, double b);
			protected: double haxmin(double a, double b);
			protected: double hue2rgb(double p, double q, double t);
			public: Hsl();
		};
		class XFExt : public BiffRecord
		{
			public: XFExt(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 20;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_XF_EXT;
			protected: void SetDefaults();
			protected: FrtHeaderStruct* m_frtHeader;
			protected: unsigned short m_reserved1;
			protected: unsigned short m_ixfe;
			protected: unsigned short m_reserved2;
			protected: unsigned short m_cexts;
			protected: Color* m_pTempColor;
			protected: OwnedVector<ExtPropStruct*>* m_pExtPropVector;
			public: XFExt(unsigned short nXFIndex, const Color* pForegroundColor, const Color* pBackgroundColor, const Color* pTextColor);
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: unsigned short GetXFIndex();
			public: const Color* GetForegroundColor(Theme* pTheme);
			public: const Color* GetTextColor(Theme* pTheme);
			protected: ExtPropStruct* GetExtPropByType(unsigned short nType);
			protected: const Color* GetColorByType(unsigned short nType, Theme* pTheme);
			public: virtual ~XFExt();
		};
		class XFCRC : public BiffRecord
		{
			public: XFCRC(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 20;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_XF_CRC;
			protected: void SetDefaults();
			protected: FrtHeaderStruct* m_frtHeader;
			protected: unsigned short m_reserved;
			protected: unsigned short m_cxfs;
			protected: unsigned int m_crc;
			public: XFCRC(OwnedVector<XF*>* pXFVector);
			public: bool ValidateCrc(Vector<XF*>* pXFVector);
			protected: unsigned int ComputateCrc(OwnedVector<XF*>* pXFVector);
			protected: unsigned int ComputateCrc(Vector<XF*>* pXFVector);
			public: virtual ~XFCRC();
		};
		class XF : public BiffRecord
		{
			public: XF(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 20;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_XF;
			protected: void SetDefaults();
			protected: unsigned short m_ifnt;
			protected: unsigned short m_ifmt;
			protected: unsigned short m_fLocked;
			protected: unsigned short m_fHidden;
			protected: unsigned short m_fStyle;
			protected: unsigned short m_f123Prefix;
			protected: unsigned short m_ixfParent;
			protected: unsigned char m_alc;
			protected: unsigned char m_fWrap;
			protected: unsigned char m_alcV;
			protected: unsigned char m_fJustLast;
			protected: unsigned char m_trot;
			protected: unsigned char m_cIndent;
			protected: unsigned char m_fShrinkToFit;
			protected: unsigned char m_reserved1;
			protected: unsigned char m_iReadOrder;
			protected: unsigned char m_reserved2;
			protected: unsigned char m_fAtrNum;
			protected: unsigned char m_fAtrFnt;
			protected: unsigned char m_fAtrAlc;
			protected: unsigned char m_fAtrBdr;
			protected: unsigned char m_fAtrPat;
			protected: unsigned char m_fAtrProt;
			protected: unsigned int m_dgLeft;
			protected: unsigned int m_dgRight;
			protected: unsigned int m_dgTop;
			protected: unsigned int m_dgBottom;
			protected: unsigned int m_icvLeft;
			protected: unsigned int m_icvRight;
			protected: unsigned int m_grbitDiag;
			protected: unsigned int m_icvTop;
			protected: unsigned int m_icvBottom;
			protected: unsigned int m_icvDiag;
			protected: unsigned int m_dgDiag;
			protected: unsigned int m_fHasXFExt;
			protected: unsigned int m_fls;
			protected: unsigned short m_icvFore;
			protected: unsigned short m_icvBack;
			protected: unsigned short m_fsxButton;
			protected: unsigned short m_reserved3;
			public: XF(unsigned short ifnt, unsigned short ifmt, unsigned char fStyle, unsigned short ixfParent, unsigned char fAtrNum, unsigned char fAtrFnt, unsigned char fAtrAlc, unsigned char fAtrBdr, unsigned char fAtrPat, unsigned char fAtrProt, unsigned char dgLeft, unsigned char dgRight, unsigned char dgTop, unsigned char dgBottom, unsigned char icvLeft, unsigned char icvRight, unsigned char icvTop, unsigned char icvBottom, unsigned char fHasXFExt, unsigned char fls, unsigned char icvFore, unsigned char icvBack);
			public: XF(unsigned short nFontIndex, unsigned short nFormatIndex, Style* pStyle, bool bHasXFExt);
			public: unsigned short GetFontIndex();
			public: unsigned short GetFormatIndex();
			public: unsigned short GetBackgroundPaletteIndex();
			public: Style::FillPattern GetFillPattern();
			public: unsigned short GetForegroundPaletteIndex();
			public: unsigned char GetHorizontalAlign();
			public: unsigned char GetVerticalAlign();
			protected: Line::Type BorderStyleToLineType(unsigned char nBorderStyle);
			protected: unsigned char LineTypeToBorderStyle(Line::Type eLineType);
			public: Line::Type GetTopBorderType();
			public: Line::Type GetRightBorderType();
			public: Line::Type GetBottomBorderType();
			public: Line::Type GetLeftBorderType();
			public: unsigned short GetTopBorderPaletteIndex();
			public: unsigned short GetRightBorderPaletteIndex();
			public: unsigned short GetBottomBorderPaletteIndex();
			public: unsigned short GetLeftBorderPaletteIndex();
			public: bool GetHasXFExt();
		};
		class WsBoolRecord : public BiffRecord
		{
			public: WsBoolRecord();
			public: WsBoolRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_WSBOOL;
			protected: void SetDefaults();
			protected: unsigned short m_haxFlags;
		};
		class WriteAccess : public BiffRecord
		{
			public: WriteAccess(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 3;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_WRITE_ACCESS;
			protected: void SetDefaults();
			protected: XLUnicodeStringStruct* m_userName;
			protected: static const unsigned int FORCE_SIZE = 112;
			public: WriteAccess();
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: virtual ~WriteAccess();
		};
		class Window2Record : public BiffRecord
		{
			public: Window2Record(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 18;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_WINDOW2;
			protected: void SetDefaults();
			protected: unsigned short m_fDspFmlaRt;
			protected: unsigned short m_fDspGridRt;
			protected: unsigned short m_fDspRwColRt;
			protected: unsigned short m_fFrozenRt;
			protected: unsigned short m_fDspZerosRt;
			protected: unsigned short m_fDefaultHdr;
			protected: unsigned short m_fRightToLeft;
			protected: unsigned short m_fDspGuts;
			protected: unsigned short m_fFrozenNoSplit;
			protected: unsigned short m_fSelected;
			protected: unsigned short m_fPaged;
			protected: unsigned short m_fSLV;
			protected: unsigned short m_reserved1;
			protected: unsigned short m_rwTop;
			protected: unsigned short m_colLeft;
			protected: unsigned short m_icvHdr;
			protected: unsigned short m_reserved2;
			protected: unsigned short m_wScaleSLV;
			protected: unsigned short m_wScaleNormal;
			protected: unsigned short m_unused;
			protected: unsigned short m_reserved3;
			public: Window2Record(bool fSelected, bool fPaged, bool bShowGridlines);
			public: bool GetShowGridlines();
		};
		class Window1 : public BiffRecord
		{
			public: Window1(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 18;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_WINDOW1;
			protected: void SetDefaults();
			protected: short m_xWn;
			protected: short m_yWn;
			protected: short m_dxWn;
			protected: short m_dyWn;
			protected: unsigned short m_fHidden;
			protected: unsigned short m_fIconic;
			protected: unsigned short m_fVeryHidden;
			protected: unsigned short m_fDspHScroll;
			protected: unsigned short m_fDspVScroll;
			protected: unsigned short m_fBotAdornment;
			protected: unsigned short m_fNoAFDateGroup;
			protected: unsigned short m_reserved;
			protected: unsigned short m_itabCur;
			protected: unsigned short m_itabFirst;
			protected: unsigned short m_ctabSel;
			protected: unsigned short m_wTabRatio;
			public: Window1(unsigned short nTabRatio);
			public: unsigned short GetTabRatio();
		};
		class WinProtect : public BiffRecord
		{
			public: WinProtect();
			public: WinProtect(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_WIN_PROTECT;
			protected: void SetDefaults();
			protected: unsigned short m_fLockWn;
		};
		class ValueRangeRecord : public BiffRecord
		{
			public: ValueRangeRecord();
			public: ValueRangeRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 42;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_ValueRange;
			protected: void SetDefaults();
			protected: double m_numMin;
			protected: double m_numMax;
			protected: double m_numMajor;
			protected: double m_numMinor;
			protected: double m_numCross;
			protected: unsigned short m_fAutoMin;
			protected: unsigned short m_fAutoMax;
			protected: unsigned short m_fAutoMajor;
			protected: unsigned short m_fAutoMinor;
			protected: unsigned short m_fAutoCross;
			protected: unsigned short m_fLog;
			protected: unsigned short m_fReversed;
			protected: unsigned short m_fMaxCross;
			protected: unsigned short m_unused;
		};
		class VCenterRecord : public BiffRecord
		{
			public: VCenterRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_VCENTER;
			protected: void SetDefaults();
			protected: unsigned short m_vcenter;
			public: VCenterRecord(bool bCenter);
		};
		class UnitsRecord : public BiffRecord
		{
			public: UnitsRecord();
			public: UnitsRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_Units;
			protected: void SetDefaults();
			protected: unsigned short m_unused;
		};
		class TopMarginRecord : public BiffRecord
		{
			public: TopMarginRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 8;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_TOP_MARGIN;
			protected: void SetDefaults();
			protected: double m_num;
			public: TopMarginRecord(double num);
		};
		class TickRecord : public BiffRecord
		{
			public: TickRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 30;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_Tick;
			protected: void SetDefaults();
			protected: unsigned char m_tktMajor;
			protected: unsigned char m_tktMinor;
			protected: unsigned char m_tlt;
			protected: unsigned char m_wBkgMode;
			protected: unsigned int m_rgb;
			protected: unsigned int m_reserved1;
			protected: unsigned int m_reserved2;
			protected: unsigned int m_reserved3;
			protected: unsigned int m_reserved4;
			protected: unsigned short m_fAutoCo;
			protected: unsigned short m_fAutoMode;
			protected: unsigned short m_rot;
			protected: unsigned short m_fAutoRot;
			protected: unsigned short m_unused;
			protected: unsigned short m_iReadingOrder;
			protected: unsigned short m_icv;
			protected: unsigned short m_trot;
			public: TickRecord(bool fAutoRot);
		};
		class Theme : public BiffRecord
		{
			public: Theme(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 16;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_THEME;
			protected: void SetDefaults();
			protected: FrtHeaderStruct* m_frtHeader;
			protected: unsigned int m_dwThemeVersion;
			public: Vector<unsigned int>* m_nColorVector;
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: unsigned int GetColorByIndex(int nIndex);
			public: virtual ~Theme();
		};
		class TextRecord : public BiffRecord
		{
			public: TextRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 32;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_Text;
			protected: void SetDefaults();
			protected: unsigned char m_at;
			protected: unsigned char m_vat;
			protected: unsigned short m_wBkgMode;
			protected: unsigned int m_rgbText;
			protected: int m_x;
			protected: int m_y;
			protected: int m_dx;
			protected: int m_dy;
			protected: unsigned short m_fAutoColor;
			protected: unsigned short m_fShowKey;
			protected: unsigned short m_fShowValue;
			protected: unsigned short m_unused1;
			protected: unsigned short m_fAutoText;
			protected: unsigned short m_fGenerated;
			protected: unsigned short m_fDeleted;
			protected: unsigned short m_fAutoMode;
			protected: unsigned short m_unused2;
			protected: unsigned short m_fShowLabelAndPerc;
			protected: unsigned short m_fShowPercent;
			protected: unsigned short m_fShowBubbleSizes;
			protected: unsigned short m_fShowLabel;
			protected: unsigned short m_reserved;
			protected: unsigned short m_icvText;
			protected: unsigned short m_dlp;
			protected: unsigned short m_unused3;
			protected: unsigned short m_iReadingOrder;
			protected: unsigned short m_trot;
			public: TextRecord(int x, int y, unsigned int rgbText, bool fAutoColor, bool fAutoText, bool fGenerated, bool fAutoMode, unsigned short icvText, unsigned short trot);
		};
		class SupBookRecord : public BiffRecord
		{
			public: SupBookRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 4;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_SUP_BOOK;
			protected: void SetDefaults();
			protected: unsigned short m_ctab;
			protected: unsigned short m_cch;
			public: SupBookRecord(unsigned short nNumWorksheet);
		};
		class StyleRecord : public BiffRecord
		{
			public: StyleRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_STYLE;
			protected: void SetDefaults();
			protected: unsigned short m_ixfe;
			protected: unsigned short m_unused;
			protected: unsigned short m_fBuiltIn;
			protected: BuiltInStyleStruct* m_builtInData;
			protected: XLUnicodeStringStruct* m_user;
			public: StyleRecord(unsigned short nXFIndex, const char* szName);
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: virtual ~StyleRecord();
		};
		class StartBlockRecord : public BiffRecord
		{
			public: StartBlockRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 12;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_StartBlock;
			protected: void SetDefaults();
			protected: FrtHeaderOldStruct* m_frtHeaderOld;
			protected: unsigned short m_iObjectKind;
			protected: unsigned short m_iObjectContext;
			protected: unsigned short m_iObjectInstance1;
			protected: unsigned short m_iObjectInstance2;
			public: StartBlockRecord(unsigned short iObjectKind, unsigned short iObjectContext, unsigned short iObjectInstance1, unsigned short iObjectInstance2);
			protected: void PostSetDefaults();
			public: virtual ~StartBlockRecord();
		};
		class SstRecord : public BiffRecord
		{
			public: SstRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 8;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_SST;
			protected: void SetDefaults();
			protected: int m_cstTotal;
			protected: int m_cstUnique;
			protected: Blob* m_pHaxBlob;
			protected: OwnedVector<XLUnicodeRichExtendedString*>* m_pRgb;
			public: SstRecord(SharedStringContainer* pSharedStringContainer);
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: int GetNumString();
			public: const char* GetString(int nIndex);
			public: virtual ~SstRecord();
		};
		class ShtPropsRecord : public BiffRecord
		{
			public: ShtPropsRecord();
			public: ShtPropsRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 4;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_ShtProps;
			protected: void SetDefaults();
			protected: unsigned short m_fManSerAlloc;
			protected: unsigned short m_fPlotVisOnly;
			protected: unsigned short m_fNotSizeWith;
			protected: unsigned short m_fManPlotArea;
			protected: unsigned short m_fAlwaysAutoPlotArea;
			protected: unsigned short m_reserved1;
			protected: unsigned char m_mdBlank;
			protected: unsigned char m_reserved2;
		};
		class ShapePropsStreamRecord : public BiffRecord
		{
			public: ShapePropsStreamRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 24;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_ShapePropsStream;
			protected: void SetDefaults();
			protected: FrtHeaderStruct* m_frtHeader;
			protected: unsigned short m_wObjContext;
			protected: unsigned short m_unused;
			protected: unsigned int m_dwChecksum;
			protected: unsigned int m_cb;
			protected: InternalString* m_rgb;
			public: ShapePropsStreamRecord(unsigned short wObjContext, unsigned short unused, unsigned int dwChecksum);
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			public: virtual ~ShapePropsStreamRecord();
		};
		class SetupRecord : public BiffRecord
		{
			public: SetupRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 34;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_SETUP;
			protected: void SetDefaults();
			protected: unsigned short m_iPaperSize;
			protected: unsigned short m_iScale;
			protected: short m_iPageStart;
			protected: unsigned short m_iFitWidth;
			protected: unsigned short m_iFitHeight;
			protected: unsigned short m_fLeftToRight;
			protected: unsigned short m_fPortrait;
			protected: unsigned short m_fNoPls;
			protected: unsigned short m_fNoColor;
			protected: unsigned short m_fDraft;
			protected: unsigned short m_fNotes;
			protected: unsigned short m_fNoOrient;
			protected: unsigned short m_fUsePage;
			protected: unsigned short m_unused1;
			protected: unsigned short m_fEndNotes;
			protected: unsigned short m_iErrors;
			protected: unsigned short m_reserved;
			protected: unsigned short m_iRes;
			protected: unsigned short m_iVRes;
			protected: double m_numHdr;
			protected: double m_numFtr;
			protected: unsigned short m_iCopies;
			public: SetupRecord(bool bPortrait);
			public: bool GetPortrait();
		};
		class SeriesTextRecord : public BiffRecord
		{
			public: SeriesTextRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 4;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_SeriesText;
			protected: void SetDefaults();
			protected: unsigned short m_reserved;
			protected: ShortXLUnicodeStringStruct* m_stText;
			public: SeriesTextRecord(const char* szText);
			public: virtual ~SeriesTextRecord();
		};
		class SeriesRecord : public BiffRecord
		{
			public: SeriesRecord();
			public: SeriesRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 12;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_Series;
			protected: void SetDefaults();
			protected: unsigned short m_sdtX;
			protected: unsigned short m_sdtY;
			protected: unsigned short m_cValx;
			protected: unsigned short m_cValy;
			protected: unsigned short m_sdtBSize;
			protected: unsigned short m_cValBSize;
		};
		class SerToCrtRecord : public BiffRecord
		{
			public: SerToCrtRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_SerToCrt;
			protected: void SetDefaults();
			protected: unsigned short m_id;
			public: SerToCrtRecord(unsigned short id);
		};
		class SelectionRecord : public BiffRecord
		{
			public: SelectionRecord();
			public: SelectionRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 15;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_SELECTION;
			protected: void SetDefaults();
			protected: unsigned char m_pnn;
			protected: unsigned short m_rwAct;
			protected: unsigned short m_colAct;
			protected: unsigned short m_irefAct;
			protected: unsigned short m_cref;
			protected: unsigned short m_rwFirst;
			protected: unsigned short m_rwLast;
			protected: unsigned char m_colFirst;
			protected: unsigned char m_colLast;
		};
		class SclRecord : public BiffRecord
		{
			public: SclRecord();
			public: SclRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 4;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_SCL;
			protected: void SetDefaults();
			protected: short m_nscl;
			protected: short m_dscl;
		};
		class ScatterRecord : public BiffRecord
		{
			public: ScatterRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 6;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_Scatter;
			protected: void SetDefaults();
			protected: unsigned short m_pcBubbleSizeRatio;
			protected: unsigned short m_wBubbleSize;
			protected: unsigned short m_fBubbles;
			protected: unsigned short m_fShowNegBubbles;
			protected: unsigned short m_fHasShadow;
			protected: unsigned short m_reserved;
			public: ScatterRecord(Chart::Type eType);
			public: Chart::Type GetChartType();
		};
		class SIIndexRecord : public BiffRecord
		{
			public: SIIndexRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_SIIndex;
			protected: void SetDefaults();
			protected: unsigned short m_numIndex;
			public: SIIndexRecord(unsigned short numIndex);
		};
		class RowRecord : public BiffRecord
		{
			public: RowRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 16;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_ROW;
			protected: void SetDefaults();
			protected: RwStruct* m_rw;
			protected: unsigned short m_colMic;
			protected: unsigned short m_colMac;
			protected: unsigned short m_miyRw;
			protected: unsigned short m_reserved1;
			protected: unsigned short m_unused1;
			protected: unsigned char m_iOutLevel;
			protected: unsigned char m_reserved2;
			protected: unsigned char m_fCollapsed;
			protected: unsigned char m_fDyZero;
			protected: unsigned char m_fUnsynced;
			protected: unsigned char m_fGhostDirty;
			protected: unsigned char m_reserved3;
			protected: unsigned short m_ixfe_val;
			protected: unsigned short m_fExAsc;
			protected: unsigned short m_fExDes;
			protected: unsigned short m_fPhonetic;
			protected: unsigned short m_unused2;
			public: bool m_bTopMedium;
			public: bool m_bTopThick;
			public: bool m_bBottomMedium;
			public: bool m_bBottomThick;
			public: RowRecord(unsigned short nRow, unsigned short nHeight);
			protected: void PostSetDefaults();
			public: unsigned short GetRow();
			public: unsigned short GetHeight();
			public: void SetHeight(unsigned short nHeight);
			public: void SetTopMedium();
			public: void SetTopThick();
			public: void SetBottomMedium();
			public: void SetBottomThick();
			public: bool GetBottomThick();
			public: virtual ~RowRecord();
		};
		class RkRecord : public BiffRecord
		{
			public: RkRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 10;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_RK;
			protected: void SetDefaults();
			protected: unsigned short m_nRowIndex;
			protected: unsigned short m_nColumnIndex;
			protected: unsigned short m_nXfIndex;
			protected: unsigned int m_nRkValue;
			public: unsigned short GetX();
			public: unsigned short GetY();
			public: unsigned short GetXfIndex();
			public: unsigned int GetRkValue();
		};
		class RightMarginRecord : public BiffRecord
		{
			public: RightMarginRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 8;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_RIGHT_MARGIN;
			protected: void SetDefaults();
			protected: double m_num;
			public: RightMarginRecord(double num);
		};
		class RefreshAllRecord : public BiffRecord
		{
			public: RefreshAllRecord();
			public: RefreshAllRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_REFRESH_ALL;
			protected: void SetDefaults();
			protected: unsigned short m_refreshAll;
		};
		class RRTabId : public BiffRecord
		{
			public: RRTabId(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 0;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_RR_TAB_ID;
			protected: void SetDefaults();
			public: unsigned short m_nNumWorksheet;
			public: RRTabId(unsigned short nNumWorksheet);
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
		};
		class ProtectRecord : public BiffRecord
		{
			public: ProtectRecord();
			public: ProtectRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_PROTECT;
			protected: void SetDefaults();
			protected: unsigned short m_fLock;
		};
		class Prot4RevRecord : public BiffRecord
		{
			public: Prot4RevRecord();
			public: Prot4RevRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_PROT_4_REV;
			protected: void SetDefaults();
			protected: unsigned short m_fRevLock;
		};
		class Prot4RevPassRecord : public BiffRecord
		{
			public: Prot4RevPassRecord();
			public: Prot4RevPassRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_PROT_4_REV_PASS;
			protected: void SetDefaults();
			protected: unsigned short m_protPwdRev;
		};
		class PrintSizeRecord : public BiffRecord
		{
			public: PrintSizeRecord();
			public: PrintSizeRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_PRINT_SIZE;
			protected: void SetDefaults();
			protected: unsigned short m_printSize;
		};
		class PrintRowColRecord : public BiffRecord
		{
			public: PrintRowColRecord();
			public: PrintRowColRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_PrintRowCol;
			protected: void SetDefaults();
			protected: unsigned short m_printRwCol;
		};
		class PrintGridRecord : public BiffRecord
		{
			public: PrintGridRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_PrintGrid;
			protected: void SetDefaults();
			protected: unsigned short m_fPrintGrid;
			protected: unsigned short m_unused;
			public: PrintGridRecord(bool bPrintGridlines);
			public: bool GetPrintGridlines();
		};
		class PosRecord : public BiffRecord
		{
			public: PosRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 20;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_Pos;
			protected: void SetDefaults();
			protected: unsigned short m_mdTopLt;
			protected: unsigned short m_mdBotRt;
			protected: short m_x1;
			protected: unsigned short m_unused1;
			protected: short m_y1;
			protected: unsigned short m_unused2;
			protected: short m_x2;
			protected: unsigned short m_unused3;
			protected: short m_y2;
			protected: unsigned short m_unused4;
			public: PosRecord(short x1, short y1, unsigned short unused2, short x2, short y2);
		};
		class PlotGrowthRecord : public BiffRecord
		{
			public: PlotGrowthRecord();
			public: PlotGrowthRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 8;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_PlotGrowth;
			protected: void SetDefaults();
			protected: int m_dxPlotGrowth;
			protected: int m_dyPlotGrowth;
		};
		class PlotAreaRecord : public BiffRecord
		{
			public: PlotAreaRecord();
			public: PlotAreaRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 0;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_PlotArea;
			protected: void SetDefaults();
		};
		class PieFormatRecord : public BiffRecord
		{
			public: PieFormatRecord();
			public: PieFormatRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_PieFormat;
			protected: void SetDefaults();
			protected: unsigned short m_pcExplode;
		};
		class PasswordRecord : public BiffRecord
		{
			public: PasswordRecord();
			public: PasswordRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_PASSWORD;
			protected: void SetDefaults();
			protected: unsigned short m_wPassword;
		};
		class PaletteRecord : public BiffRecord
		{
			public: PaletteRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_PALETTE;
			protected: void SetDefaults();
			protected: unsigned short m_ccv;
			protected: unsigned int m_rgColor[BiffWorkbookGlobals::NUM_CUSTOM_PALETTE_ENTRY];
			public: PaletteRecord();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			protected: void PostSetDefaults();
			public: unsigned int GetColorByIndex(unsigned short nIndex);
		};
		class ObjectLinkRecord : public BiffRecord
		{
			public: ObjectLinkRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 6;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_ObjectLink;
			protected: void SetDefaults();
			protected: unsigned short m_wLinkObj;
			protected: unsigned short m_wLinkVar1;
			protected: unsigned short m_wLinkVar2;
			public: ObjectLinkRecord(unsigned short nLinkObject, unsigned short nSeriesIndex, unsigned short nCategoryIndex);
		};
		class ObjRecord : public BiffRecord
		{
			public: ObjRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 22;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_OBJ;
			protected: void SetDefaults();
			protected: FtCmoStruct* m_cmo;
			protected: FtCfStruct* m_pictFormat;
			protected: FtPioGrbitStruct* m_pictFlags;
			public: ObjRecord(unsigned short nIndex, FtCmoStruct::ObjType eType);
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			protected: void PostSetDefaults();
			public: FtCmoStruct::ObjType GetType();
			public: virtual ~ObjRecord();
		};
		class NumberRecord : public BiffRecord
		{
			public: NumberRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 14;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_NUMBER;
			protected: void SetDefaults();
			protected: CellStruct* m_cell;
			protected: double m_num;
			public: NumberRecord(unsigned short nX, unsigned short nY, unsigned short nXfIndex, double fNumber);
			public: unsigned short GetX();
			public: unsigned short GetY();
			public: unsigned short GetXfIndex();
			public: double GetNumber();
			public: virtual ~NumberRecord();
		};
		class MulRkRecord : public BiffRecord
		{
			public: MulRkRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 4;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_MULRK;
			protected: void SetDefaults();
			protected: RwStruct* m_rw;
			protected: ColStruct* m_col;
			protected: OwnedVector<RkRecStruct*>* m_pRkRecVector;
			protected: unsigned short m_colLast;
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: unsigned short GetX();
			public: unsigned short GetY();
			public: unsigned short GetNumRk();
			public: unsigned short GetXfIndexByIndex(unsigned short nIndex);
			public: unsigned int GetRkValueByIndex(unsigned short nIndex);
			public: virtual ~MulRkRecord();
		};
		class MulBlank : public BiffRecord
		{
			public: MulBlank(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 4;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_MULBLANK;
			protected: void SetDefaults();
			protected: RwStruct* m_rw;
			protected: ColStruct* m_col;
			protected: OwnedVector<IXFCellStruct*>* m_pIXFCellVector;
			protected: unsigned short m_colLast;
			public: MulBlank(unsigned short nX, unsigned short nY, Vector<int>* pXfIndexVector);
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: unsigned short GetX();
			public: unsigned short GetY();
			public: unsigned short GetNumColumn();
			public: unsigned short GetXfIndexByIndex(unsigned short nIndex);
			public: virtual ~MulBlank();
		};
		class MsoDrawingRecord_Position
		{
			public: unsigned short m_nCellX1;
			public: unsigned short m_nSubCellX1;
			public: unsigned short m_nCellY1;
			public: unsigned short m_nSubCellY1;
			public: unsigned short m_nCellX2;
			public: unsigned short m_nSubCellX2;
			public: unsigned short m_nCellY2;
			public: unsigned short m_nSubCellY2;
			public: MsoDrawingRecord_Position();
		};
		class MsoDrawingRecord : public BiffRecord
		{
			public: MsoDrawingRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 0;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_MSO_DRAWING;
			protected: void SetDefaults();
			protected: OfficeArtRecord* m_pOfficeArtRecord;
			protected: MsoDrawingRecord_Position* m_pPosition;
			protected: Blob* m_pBlob;
			public: MsoDrawingRecord(OfficeArtDgContainerRecord* pOfficeArtDgContainerRecord, unsigned int nWriteSize);
			public: MsoDrawingRecord(OfficeArtSpContainerRecord* pOfficeArtSpContainerRecord);
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: const MsoDrawingRecord_Position* GetPosition();
			public: OfficeArtFOPTEStruct* GetProperty(OfficeArtRecord::OPIDType eType);
			public: virtual ~MsoDrawingRecord();
		};
		class MsoDrawingGroupRecord : public BiffRecord
		{
			public: MsoDrawingGroupRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 0;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_MSO_DRAWING_GROUP;
			protected: void SetDefaults();
			protected: OfficeArtDggContainerRecord* m_pOfficeArtDggContainerRecord;
			public: MsoDrawingGroupRecord(Vector<Picture*>* pPictureVector);
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: OfficeArtDggContainerRecord* GetOfficeArtDggContainerRecord();
			public: virtual ~MsoDrawingGroupRecord();
		};
		class Mms : public BiffRecord
		{
			public: Mms();
			public: Mms(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_MMS;
			protected: void SetDefaults();
			protected: unsigned char m_reserved1;
			protected: unsigned char m_reserved2;
		};
		class MergeCellsRecord : public BiffRecord
		{
			public: MergeCellsRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_MergeCells;
			protected: void SetDefaults();
			protected: unsigned short m_cmcs;
			protected: OwnedVector<Ref8Struct*>* m_pRef8Vector;
			public: MergeCellsRecord(OwnedVector<MergedCell*>* pMergedCellVector, int nOffset, int nSize);
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: unsigned short GetNumMergedCell();
			public: const Ref8Struct* GetMergedCell(unsigned short nIndex);
			public: virtual ~MergeCellsRecord();
		};
		class MarkerFormatRecord : public BiffRecord
		{
			public: MarkerFormatRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 20;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_MarkerFormat;
			protected: void SetDefaults();
			protected: unsigned int m_rgbFore;
			protected: unsigned int m_rgbBack;
			protected: unsigned short m_imk;
			protected: unsigned short m_fAuto;
			protected: unsigned short m_reserved1;
			protected: unsigned short m_fNotShowInt;
			protected: unsigned short m_fNotShowBrd;
			protected: unsigned short m_reserved2;
			protected: unsigned short m_icvFore;
			protected: unsigned short m_icvBack;
			protected: unsigned int m_miSize;
			public: MarkerFormatRecord(Marker* pMarker);
			public: void ModifyMarker(Marker* pMarker, BiffWorkbookGlobals* pBiffWorkbookGlobals);
		};
		class LineRecord : public BiffRecord
		{
			public: LineRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_Line;
			protected: void SetDefaults();
			protected: unsigned short m_fStacked;
			protected: unsigned short m_f100;
			protected: unsigned short m_fHasShadow;
			protected: unsigned short m_reserved;
			public: LineRecord(Chart::Type eType);
			public: Chart::Type GetChartType();
		};
		class LineFormatRecord : public BiffRecord
		{
			public: LineFormatRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 12;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_LineFormat;
			protected: void SetDefaults();
			protected: unsigned int m_rgb;
			protected: unsigned short m_lns;
			protected: short m_we;
			protected: unsigned short m_fAuto;
			protected: unsigned short m_reserved1;
			protected: unsigned short m_fAxisOn;
			protected: unsigned short m_fAutoCo;
			protected: unsigned short m_reserved2;
			protected: unsigned short m_icv;
			public: LineFormatRecord(unsigned int rgb, unsigned short lns, short we, bool fAuto, bool fAxisOn, bool fAutoCo, unsigned short icv);
			public: LineFormatRecord(Line* pLine, bool bAxis);
			public: void ModifyLine(Line* pLine, BiffWorkbookGlobals* pBiffWorkbookGlobals);
			public: void PackForChecksum(BlobView* pBlobView);
		};
		class LegendRecord : public BiffRecord
		{
			public: LegendRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 20;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_Legend;
			protected: void SetDefaults();
			protected: unsigned int m_x;
			protected: unsigned int m_y;
			protected: unsigned int m_dx;
			protected: unsigned int m_dy;
			protected: unsigned char m_unused;
			protected: unsigned char m_wSpace;
			protected: unsigned short m_fAutoPosition;
			protected: unsigned short m_reserved1;
			protected: unsigned short m_fAutoPosX;
			protected: unsigned short m_fAutoPosY;
			protected: unsigned short m_fVert;
			protected: unsigned short m_fWasDataTable;
			protected: unsigned short m_reserved2;
			public: LegendRecord(const Legend* pLegend);
			public: void ModifyLegend(Legend* pLegend, BiffWorkbookGlobals* pBiffWorkbookGlobals);
		};
		class LeftMarginRecord : public BiffRecord
		{
			public: LeftMarginRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 8;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_LEFT_MARGIN;
			protected: void SetDefaults();
			protected: double m_num;
			public: LeftMarginRecord(double num);
		};
		class LabelSstRecord : public BiffRecord
		{
			public: LabelSstRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 10;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_LABELSST;
			protected: void SetDefaults();
			protected: unsigned short m_nRowIndex;
			protected: unsigned short m_nColumnIndex;
			protected: unsigned short m_nXfIndex;
			protected: unsigned int m_nSstIndex;
			public: LabelSstRecord(unsigned short nX, unsigned short nY, unsigned short nXfIndex, unsigned int nSstIndex);
			public: unsigned short GetX();
			public: unsigned short GetY();
			public: unsigned short GetXfIndex();
			public: unsigned int GetSstIndex();
		};
		class InterfaceHdr : public BiffRecord
		{
			public: InterfaceHdr();
			public: InterfaceHdr(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_INTERFACE_HDR;
			protected: void SetDefaults();
			protected: unsigned short m_codePage;
		};
		class InterfaceEnd : public BiffRecord
		{
			public: InterfaceEnd();
			public: InterfaceEnd(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 0;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_INTERFACE_END;
			protected: void SetDefaults();
		};
		class HideObj : public BiffRecord
		{
			public: HideObj();
			public: HideObj(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_HIDE_OBJ;
			protected: void SetDefaults();
			protected: unsigned short m_hideObj;
		};
		class HeaderFooterRecord : public BiffRecord
		{
			public: HeaderFooterRecord();
			public: HeaderFooterRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 38;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_HeaderFooter;
			protected: void SetDefaults();
			protected: FrtHeaderStruct* m_frtHeader;
			protected: unsigned char m_guidSView_0;
			protected: unsigned char m_guidSView_1;
			protected: unsigned char m_guidSView_2;
			protected: unsigned char m_guidSView_3;
			protected: unsigned char m_guidSView_4;
			protected: unsigned char m_guidSView_5;
			protected: unsigned char m_guidSView_6;
			protected: unsigned char m_guidSView_7;
			protected: unsigned char m_guidSView_8;
			protected: unsigned char m_guidSView_9;
			protected: unsigned char m_guidSView_10;
			protected: unsigned char m_guidSView_11;
			protected: unsigned char m_guidSView_12;
			protected: unsigned char m_guidSView_13;
			protected: unsigned char m_guidSView_14;
			protected: unsigned char m_guidSView_15;
			protected: unsigned short m_fHFDiffOddEven;
			protected: unsigned short m_fHFDiffFirst;
			protected: unsigned short m_fHFScaleWithDoc;
			protected: unsigned short m_fHFAlignMargins;
			protected: unsigned short m_unused;
			protected: unsigned short m_cchHeaderEven;
			protected: unsigned short m_cchFooterEven;
			protected: unsigned short m_cchHeaderFirst;
			protected: unsigned short m_cchFooterFirst;
			protected: void PostSetDefaults();
			public: virtual ~HeaderFooterRecord();
		};
		class HCenterRecord : public BiffRecord
		{
			public: HCenterRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_HCENTER;
			protected: void SetDefaults();
			protected: unsigned short m_hcenter;
			public: HCenterRecord(bool bCenter);
		};
		class GelFrameRecord : public BiffRecord
		{
			public: GelFrameRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 0;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_GelFrame;
			protected: void SetDefaults();
			protected: OfficeArtFOPTRecord* m_OPT1;
			protected: OfficeArtTertiaryFOPTRecord* m_OPT2;
			public: GelFrameRecord(Fill* pFill, WorkbookGlobals* pWorkbookGlobals);
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: void ModifyFill(Fill* pFill, WorkbookGlobals* pWorkbookGlobals);
			public: void PackForChecksum(BlobView* pBlobView);
			public: virtual ~GelFrameRecord();
		};
		class FrameRecord : public BiffRecord
		{
			public: FrameRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 4;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_Frame;
			protected: void SetDefaults();
			protected: unsigned short m_frt;
			protected: unsigned short m_fAutoSize;
			protected: unsigned short m_fAutoPosition;
			protected: unsigned short m_reserved;
			public: FrameRecord(bool fAutoSize);
			public: bool GetDropShadow();
			public: bool GetAutoSize();
			public: bool GetAutoPosition();
		};
		class FormulaRecord : public BiffRecord
		{
			public: FormulaRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 20;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_FORMULA;
			protected: void SetDefaults();
			protected: CellStruct* m_cell;
			protected: FormulaValueStruct* m_val;
			protected: unsigned short m_fAlwaysCalc;
			protected: unsigned short m_reserved1;
			protected: unsigned short m_fFill;
			protected: unsigned short m_fShrFmla;
			protected: unsigned short m_reserved2;
			protected: unsigned short m_fClearErrors;
			protected: unsigned short m_reserved3;
			protected: unsigned int m_chn;
			protected: CellParsedFormulaStruct* m_formula;
			public: FormulaRecord(unsigned short nX, unsigned short nY, unsigned short nXfIndex, Formula* pFormula, WorkbookGlobals* pWorkbookGlobals);
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: unsigned short GetX();
			public: unsigned short GetY();
			public: unsigned short GetXfIndex();
			public: Formula* GetFormula(WorkbookGlobals* pWorkbookGlobals);
			public: virtual ~FormulaRecord();
		};
		class Format : public BiffRecord
		{
			public: Format(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 5;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_FORMAT;
			protected: void SetDefaults();
			protected: unsigned short m_ifmt;
			protected: XLUnicodeStringStruct* m_stFormat;
			public: Format(unsigned short ifmt, const char* szFormat);
			public: unsigned short GetFormatIndex();
			public: const char* GetFormat();
			public: virtual ~Format();
		};
		class FontXRecord : public BiffRecord
		{
			public: FontXRecord();
			public: FontXRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_FontX;
			protected: void SetDefaults();
			protected: unsigned short m_iFont;
		};
		class FontRecord : public BiffRecord
		{
			public: FontRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 16;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_FONT;
			protected: void SetDefaults();
			protected: unsigned short m_dyHeight;
			protected: unsigned short m_unused1;
			protected: unsigned short m_fItalic;
			protected: unsigned short m_unused2;
			protected: unsigned short m_fStrikeOut;
			protected: unsigned short m_fOutline;
			protected: unsigned short m_fShadow;
			protected: unsigned short m_fCondense;
			protected: unsigned short m_fExtend;
			protected: unsigned short m_reserved;
			protected: IcvFontStruct* m_icv;
			protected: unsigned short m_bls;
			protected: unsigned short m_sss;
			protected: unsigned char m_uls;
			protected: unsigned char m_bFamily;
			protected: unsigned char m_bCharSet;
			protected: unsigned char m_unused3;
			protected: ShortXLUnicodeStringStruct* m_fontName;
			public: FontRecord(const char* szFontName, unsigned short nSizeTwips, unsigned short nColourIndex, bool bBold, bool bItalic, Font::Underline eUnderline, unsigned char unused1 = 0, unsigned char unused3 = 181);
			public: unsigned short GetColourIndex();
			public: const char* GetName();
			public: unsigned short GetSizeTwips();
			public: bool GetBold();
			public: bool GetItalic();
			public: Font::Underline GetUnderline();
			public: virtual ~FontRecord();
		};
		class ExternSheetRecord : public BiffRecord
		{
			public: ExternSheetRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_EXTERN_SHEET;
			protected: void SetDefaults();
			protected: unsigned short m_cXTI;
			protected: OwnedVector<XTIStruct*>* m_pXTIVector;
			public: ExternSheetRecord(OwnedVector<WorksheetRange*>* pWorksheetRangeVector);
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: unsigned short GetNumXTI();
			public: XTIStruct* GetXTIByIndex(unsigned short nIndex);
			public: virtual ~ExternSheetRecord();
		};
		class Excel9File : public BiffRecord
		{
			public: Excel9File();
			public: Excel9File(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 0;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_EXCEL9_FILE;
			protected: void SetDefaults();
		};
		class EndBlockRecord : public BiffRecord
		{
			public: EndBlockRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 12;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_EndBlock;
			protected: void SetDefaults();
			protected: FrtHeaderOldStruct* m_frtHeaderOld;
			protected: unsigned short m_iObjectKind;
			protected: unsigned short m_unused1;
			protected: unsigned short m_unused2;
			protected: unsigned short m_unused3;
			public: EndBlockRecord(unsigned short iObjectKind);
			public: virtual ~EndBlockRecord();
		};
		class DimensionRecord : public BiffRecord
		{
			public: DimensionRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 14;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_DIMENSION;
			protected: void SetDefaults();
			protected: unsigned int m_nFirstUsedRow;
			protected: unsigned int m_nLastUsedRow;
			protected: unsigned short m_nFirstUsedColumn;
			protected: unsigned short m_nLastUsedColumn;
			protected: unsigned short m_nUnused;
			public: DimensionRecord(unsigned int nFirstUsedRow, unsigned int nLastUsedRow, unsigned short nFirstUsedColumn, unsigned short nLastUsedColumn, unsigned short nUnused);
		};
		class DefaultTextRecord : public BiffRecord
		{
			public: DefaultTextRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_DefaultText;
			protected: void SetDefaults();
			protected: unsigned short m_id;
			public: DefaultTextRecord(unsigned short id);
		};
		class DefaultRowHeight : public BiffRecord
		{
			public: DefaultRowHeight(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_DEFAULTROWHEIGHT;
			protected: void SetDefaults();
			protected: unsigned short m_fUnsynced;
			protected: unsigned short m_fDyZero;
			protected: unsigned short m_fExAsc;
			protected: unsigned short m_fExDsc;
			protected: unsigned short m_reserved;
			protected: short m_miyRw;
			protected: short m_miyRwHidden;
			public: DefaultRowHeight(short nRowHeight);
			public: void PostBlobRead(BlobView* pBlobView);
			public: void PostBlobWrite(BlobView* pBlobView);
			public: short GetRowHeight();
		};
		class DefColWidthRecord : public BiffRecord
		{
			public: DefColWidthRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_DEFCOLWIDTH;
			protected: void SetDefaults();
			protected: unsigned short m_cchdefColWidth;
			public: DefColWidthRecord(unsigned short cchdefColWidth);
			public: unsigned short GetColumnWidth();
		};
		class Date1904 : public BiffRecord
		{
			public: Date1904();
			public: Date1904(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_DATE_1904;
			protected: void SetDefaults();
			protected: unsigned short m_f1904DateSystem;
		};
		class DataFormatRecord : public BiffRecord
		{
			public: DataFormatRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 8;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_DataFormat;
			protected: void SetDefaults();
			protected: unsigned short m_xi;
			protected: unsigned short m_yi;
			protected: unsigned short m_iss;
			protected: unsigned short m_fXL4iss;
			protected: unsigned short m_reserved;
			public: DataFormatRecord(unsigned short nIndex);
		};
		class DSF : public BiffRecord
		{
			public: DSF();
			public: DSF(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_DSF;
			protected: void SetDefaults();
			protected: short m_reserved;
		};
		class CrtMlFrtRecord : public BiffRecord
		{
			public: CrtMlFrtRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 16;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_CrtMlFrt;
			protected: void SetDefaults();
			protected: FrtHeaderStruct* m_frtHeader;
			protected: unsigned int m_cb;
			protected: void PostSetDefaults();
			public: virtual ~CrtMlFrtRecord();
		};
		class CrtLinkRecord : public BiffRecord
		{
			public: CrtLinkRecord();
			public: CrtLinkRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 10;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_CrtLink;
			protected: void SetDefaults();
			protected: unsigned short m_unused0;
			protected: unsigned short m_unused1;
			protected: unsigned short m_unused2;
			protected: unsigned short m_unused3;
			protected: unsigned short m_unused4;
		};
		class CrtLayout12ARecord : public BiffRecord
		{
			public: CrtLayout12ARecord();
			public: CrtLayout12ARecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 68;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_CrtLayout12A;
			protected: void SetDefaults();
			protected: FrtHeaderStruct* m_frtHeader;
			protected: unsigned int m_dwCheckSum;
			protected: unsigned short m_fLayoutTargetInner;
			protected: unsigned short m_reserved1;
			protected: short m_xTL;
			protected: short m_yTL;
			protected: short m_xBR;
			protected: short m_yBR;
			protected: unsigned short m_wXMode;
			protected: unsigned short m_wYMode;
			protected: unsigned short m_wWidthMode;
			protected: unsigned short m_wHeightMode;
			protected: double m_x;
			protected: double m_y;
			protected: double m_dx;
			protected: double m_dy;
			protected: unsigned short m_reserved2;
			public: void PostSetDefaults();
			public: virtual ~CrtLayout12ARecord();
		};
		class ColInfoRecord : public BiffRecord
		{
			public: ColInfoRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 10;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_COLINFO;
			protected: void SetDefaults();
			protected: unsigned short m_colFirst;
			protected: unsigned short m_colLast;
			protected: unsigned short m_coldx;
			protected: unsigned short m_ixfe;
			protected: unsigned short m_fHidden;
			protected: unsigned short m_fUserSet;
			protected: unsigned short m_fBestFit;
			protected: unsigned short m_fPhonetic;
			protected: unsigned short m_reserved1;
			protected: unsigned short m_iOutLevel;
			protected: unsigned short m_unused1;
			protected: unsigned short m_fCollapsed;
			protected: unsigned short m_reserved2;
			public: ColInfoRecord(unsigned short nFirstColumn, unsigned short nLastColumn, unsigned short nColumnWidth, bool bHidden);
			public: void PostBlobWrite(BlobView* pBlobView);
			public: unsigned short GetFirstColumn();
			public: unsigned short GetLastColumn();
			public: unsigned short GetColumnWidth();
			public: bool GetHidden();
		};
		class CodePage : public BiffRecord
		{
			public: CodePage();
			public: CodePage(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_CODE_PAGE;
			protected: void SetDefaults();
			protected: short m_cv;
		};
		class ChartRecord : public BiffRecord
		{
			public: ChartRecord();
			public: ChartRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 16;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_Chart;
			protected: void SetDefaults();
			protected: unsigned int m_x;
			protected: unsigned int m_y;
			protected: unsigned int m_dx;
			protected: unsigned int m_dy;
			public: unsigned short GetX();
			public: unsigned short GetY();
			public: unsigned short GetWidth();
			public: unsigned short GetHeight();
		};
		class ChartFrtInfoRecord : public BiffRecord
		{
			public: ChartFrtInfoRecord();
			public: ChartFrtInfoRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 24;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_ChartFrtInfo;
			protected: void SetDefaults();
			protected: FrtHeaderOldStruct* m_frtHeaderOld;
			protected: unsigned char m_verOriginator;
			protected: unsigned char m_verWriter;
			protected: unsigned short m_cCFRTID;
			protected: unsigned short m_hax1;
			protected: unsigned short m_hax2;
			protected: unsigned short m_hax3;
			protected: unsigned short m_hax4;
			protected: unsigned short m_hax5;
			protected: unsigned short m_hax6;
			protected: unsigned short m_hax7;
			protected: unsigned short m_hax8;
			protected: void PostSetDefaults();
			public: virtual ~ChartFrtInfoRecord();
		};
		class ChartFormatRecord : public BiffRecord
		{
			public: ChartFormatRecord();
			public: ChartFormatRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 20;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_ChartFormat;
			protected: void SetDefaults();
			protected: unsigned int m_reserved1;
			protected: unsigned int m_reserved2;
			protected: unsigned int m_reserved3;
			protected: unsigned int m_reserved4;
			protected: unsigned short m_fVaried;
			protected: unsigned short m_reserved5;
			protected: unsigned short m_icrt;
		};
		class Chart3DBarShapeRecord : public BiffRecord
		{
			public: Chart3DBarShapeRecord();
			public: Chart3DBarShapeRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_Chart3DBarShape;
			protected: void SetDefaults();
			protected: unsigned char m_riser;
			protected: unsigned char m_taper;
		};
		class CatSerRangeRecord : public BiffRecord
		{
			public: CatSerRangeRecord();
			public: CatSerRangeRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 8;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_CatSerRange;
			protected: void SetDefaults();
			protected: short m_catCross;
			protected: short m_catLabel;
			protected: short m_catMark;
			protected: unsigned short m_fBetween;
			protected: unsigned short m_fMaxCross;
			protected: unsigned short m_fReverse;
			protected: unsigned short m_reserved;
		};
		class CatLabRecord : public BiffRecord
		{
			public: CatLabRecord();
			public: CatLabRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 12;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_CatLab;
			protected: void SetDefaults();
			protected: FrtHeaderOldStruct* m_frtHeaderOld;
			protected: unsigned short m_wOffset;
			protected: unsigned short m_at;
			protected: unsigned short m_cAutoCatLabelReal;
			protected: unsigned short m_unused;
			protected: unsigned short m_reserved;
			protected: void PostSetDefaults();
			public: virtual ~CatLabRecord();
		};
		class CalcPrecision : public BiffRecord
		{
			public: CalcPrecision();
			public: CalcPrecision(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_CALC_PRECISION;
			protected: void SetDefaults();
			protected: unsigned short m_fFullPrec;
		};
		class CalcCountRecord : public BiffRecord
		{
			public: CalcCountRecord();
			public: CalcCountRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_CALCCOUNT;
			protected: void SetDefaults();
			protected: unsigned short m_nMaxNumIteration;
		};
		class BuiltInFnGroupCount : public BiffRecord
		{
			public: BuiltInFnGroupCount();
			public: BuiltInFnGroupCount(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_BUILT_IN_FN_GROUP_COUNT;
			protected: void SetDefaults();
			protected: unsigned short m_count;
		};
		class BraiRecord : public BiffRecord
		{
			public: BraiRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 6;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_BRAI;
			protected: void SetDefaults();
			protected: unsigned char m_id;
			protected: unsigned char m_rt;
			protected: unsigned short m_fUnlinkedIfmt;
			protected: unsigned short m_reserved;
			protected: unsigned short m_ifmt;
			protected: CellParsedFormulaStruct* m_formula;
			public: BraiRecord(unsigned char id, unsigned char rt, bool fUnlinkedIfmt, unsigned short ifmt, Formula* pFormula, WorkbookGlobals* pWorkbookGlobals);
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: unsigned char GetId();
			public: unsigned char GetRt();
			public: Formula* GetFormula(WorkbookGlobals* pWorkbookGlobals);
			public: virtual ~BraiRecord();
		};
		class BoundSheet8Record : public BiffRecord
		{
			public: BoundSheet8Record(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 8;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_BOUND_SHEET_8;
			protected: void SetDefaults();
			protected: unsigned int m_lbPlyPos;
			protected: unsigned char m_hsState;
			protected: unsigned char m_reserved;
			protected: unsigned char m_dt;
			protected: ShortXLUnicodeStringStruct* m_stName;
			public: BoundSheet8Record(const char* sxName);
			public: const char* GetName();
			public: void SetStreamOffset(unsigned int nStreamOffset);
			public: virtual ~BoundSheet8Record();
		};
		class BottomMarginRecord : public BiffRecord
		{
			public: BottomMarginRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 8;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_BOTTOM_MARGIN;
			protected: void SetDefaults();
			protected: double m_num;
			public: BottomMarginRecord(double num);
		};
		class BoolErrRecord : public BiffRecord
		{
			public: BoolErrRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 8;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_BOOLERR;
			protected: void SetDefaults();
			protected: CellStruct* m_cell;
			protected: unsigned char m_bBoolErr;
			protected: unsigned char m_fError;
			public: BoolErrRecord(unsigned short nX, unsigned short nY, unsigned short nXfIndex, bool bBoolean);
			public: unsigned short GetX();
			public: unsigned short GetY();
			public: unsigned short GetXfIndex();
			public: bool IsBoolean();
			public: bool GetBoolean();
			public: virtual ~BoolErrRecord();
		};
		class BookExtRecord : public BiffRecord
		{
			public: BookExtRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 20;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_BOOK_EXT;
			protected: void SetDefaults();
			protected: FrtHeaderStruct* m_frtHeader;
			protected: unsigned int m_cb;
			protected: unsigned int m_fDontAutoRecover;
			protected: unsigned int m_fHidePivotList;
			protected: unsigned int m_fFilterPrivacy;
			protected: unsigned int m_fEmbedFactoids;
			protected: unsigned int m_mdFactoidDisplay;
			protected: unsigned int m_fSavedDuringRecovery;
			protected: unsigned int m_fCreatedViaMinimalSave;
			protected: unsigned int m_fOpenedViaDataRecovery;
			protected: unsigned int m_fOpenedViaSafeLoad;
			protected: unsigned int m_reserved;
			protected: unsigned char m_grbit1;
			protected: unsigned char m_grbit2;
			public: BookExtRecord();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: virtual ~BookExtRecord();
		};
		class BookBool : public BiffRecord
		{
			public: BookBool();
			public: BookBool(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_BOOK_BOOL;
			protected: void SetDefaults();
			protected: unsigned short m_fNoSaveSup;
			protected: unsigned short m_reserved1;
			protected: unsigned short m_fHasEnvelope;
			protected: unsigned short m_fEnvelopeVisible;
			protected: unsigned short m_fEnvelopeInitDone;
			protected: unsigned short m_grUpdateLinks;
			protected: unsigned short m_unused;
			protected: unsigned short m_fHideBorderUnselLists;
			protected: unsigned short m_reserved2;
		};
		class BofRecord : public BiffRecord
		{
			public: BofRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 16;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_BOF;
			protected: void SetDefaults();
			protected: unsigned short m_vers;
			protected: unsigned short m_dt;
			protected: unsigned short m_rupBuild;
			protected: unsigned short m_rupYear;
			protected: unsigned int m_nFileHistoryFlags;
			protected: unsigned int m_nMinimumExcelVersion;
			public: enum BofType
			{
				BOF_TYPE_WORKBOOK_GLOBALS = 0x005,
				BOF_TYPE_VISUAL_BASIC_MODULE = 0x0006,
				BOF_TYPE_SHEET = 0x0010,
				BOF_TYPE_CHART = 0x0020,
				BOF_TYPE_MACRO_SHEET = 0x0040,
			};

			public: BofRecord(BofType eType);
			public: BofRecord::BofType GetBofType();
		};
		class Blank : public BiffRecord
		{
			public: Blank(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 6;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_BLANK;
			protected: void SetDefaults();
			protected: CellStruct* m_cell;
			public: Blank(unsigned short nX, unsigned short nY, unsigned short nXfIndex);
			public: unsigned short GetX();
			public: unsigned short GetY();
			public: unsigned short GetXfIndex();
			public: virtual ~Blank();
		};
		class BiffRecord_ContinueInfo
		{
			public: int m_nOffset;
			public: int m_nType;
			public: BiffRecord_ContinueInfo(int nOffset, int nType);
		};
		class BeginRecord : public BiffRecord
		{
			public: BeginRecord();
			public: BeginRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 0;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_Begin;
			protected: void SetDefaults();
		};
		class BarRecord : public BiffRecord
		{
			public: BarRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 6;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_Bar;
			protected: void SetDefaults();
			protected: short m_pcOverlap;
			protected: unsigned short m_pcGap;
			protected: unsigned short m_fTranspose;
			protected: unsigned short m_fStacked;
			protected: unsigned short m_f100;
			protected: unsigned short m_fHasShadow;
			protected: unsigned short m_reserved;
			public: BarRecord(Chart::Type eType);
			public: Chart::Type GetChartType();
		};
		class Backup : public BiffRecord
		{
			public: Backup();
			public: Backup(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_BACKUP;
			protected: void SetDefaults();
			protected: unsigned short m_fBackup;
		};
		class AxisRecord : public BiffRecord
		{
			public: AxisRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 18;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_Axis;
			protected: void SetDefaults();
			protected: unsigned short m_wType;
			protected: unsigned int m_reserved1;
			protected: unsigned int m_reserved2;
			protected: unsigned int m_reserved3;
			protected: unsigned int m_reserved4;
			public: AxisRecord(unsigned short wType);
			public: unsigned short GetType();
		};
		class AxisParentRecord : public BiffRecord
		{
			public: AxisParentRecord();
			public: AxisParentRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 18;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_AxisParent;
			protected: void SetDefaults();
			protected: unsigned short m_iax;
			protected: unsigned int m_unused1;
			protected: unsigned int m_unused2;
			protected: unsigned int m_unused3;
			protected: unsigned int m_unused4;
		};
		class AxisLineRecord : public BiffRecord
		{
			public: AxisLineRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_AxisLine;
			protected: void SetDefaults();
			protected: unsigned short m_id;
			public: AxisLineRecord(unsigned short id);
			public: unsigned short GetId();
		};
		class AxesUsedRecord : public BiffRecord
		{
			public: AxesUsedRecord();
			public: AxesUsedRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_AxesUsed;
			protected: void SetDefaults();
			protected: unsigned short m_cAxes;
		};
		class AxcExtRecord : public BiffRecord
		{
			public: AxcExtRecord();
			public: AxcExtRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 18;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_AxcExt;
			protected: void SetDefaults();
			protected: unsigned short m_catMin;
			protected: unsigned short m_catMax;
			protected: unsigned short m_catMajor;
			protected: unsigned short m_duMajor;
			protected: unsigned short m_catMinor;
			protected: unsigned short m_duMinor;
			protected: unsigned short m_duBase;
			protected: unsigned short m_catCrossDate;
			protected: unsigned short m_fAutoMin;
			protected: unsigned short m_fAutoMax;
			protected: unsigned short m_fAutoMajor;
			protected: unsigned short m_fAutoMinor;
			protected: unsigned short m_fDateAxis;
			protected: unsigned short m_fAutoBase;
			protected: unsigned short m_fAutoCross;
			protected: unsigned short m_fAutoDate;
			protected: unsigned short m_reserved;
		};
		class AreaRecord : public BiffRecord
		{
			public: AreaRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 2;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_Area;
			protected: void SetDefaults();
			protected: unsigned short m_fStacked;
			protected: unsigned short m_f100;
			protected: unsigned short m_fHasShadow;
			protected: unsigned short m_reserved;
			public: AreaRecord(Chart::Type eType);
			public: Chart::Type GetChartType();
		};
		class AreaFormatRecord : public BiffRecord
		{
			public: AreaFormatRecord(BiffHeader* pHeader, Stream* pStream);
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			protected: static const unsigned short SIZE = 16;
			protected: static const BiffRecord::Type TYPE = BiffRecord::Type::TYPE_AreaFormat;
			protected: void SetDefaults();
			protected: unsigned int m_rgbFore;
			protected: unsigned int m_rgbBack;
			protected: unsigned short m_fls;
			protected: unsigned short m_fAuto;
			protected: unsigned short m_fInvertNeg;
			protected: unsigned short m_reserved;
			protected: unsigned short m_icvFore;
			protected: unsigned short m_icvBack;
			public: AreaFormatRecord(unsigned int rgbFore, unsigned int rgbBack, unsigned short fls, bool fAuto, bool fInvertNeg, unsigned short icvFore, unsigned short icvBack);
			public: AreaFormatRecord(Fill* pFill);
			public: void ModifyFill(Fill* pFill, BiffWorkbookGlobals* pBiffWorkbookGlobals);
			public: void PackForChecksum(BlobView* pBlobView);
		};
		class XTIStruct : public BiffStruct
		{
			public: XTIStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 6;
			public: void SetDefaults();
			public: unsigned short m_iSupBook;
			public: short m_itabFirst;
			public: short m_itabLast;
		};
		class XLUnicodeStringStruct : public BiffStruct
		{
			public: XLUnicodeStringStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 3;
			public: void SetDefaults();
			public: unsigned short m_cch;
			public: unsigned char m_fHighByte;
			public: unsigned char m_reserved;
			public: InternalString* m_rgb;
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PreBlobWrite(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: int GetDynamicSize();
			public: virtual ~XLUnicodeStringStruct();
		};
		class XLUnicodeRichExtendedString_ContinueInfo
		{
			public: int m_nOffset;
			public: unsigned char m_fHighByte;
			public: XLUnicodeRichExtendedString_ContinueInfo();
		};
		class XLUnicodeRichExtendedString : public BiffStruct
		{
			public: XLUnicodeRichExtendedString();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 3;
			public: void SetDefaults();
			public: unsigned short m_cch;
			public: unsigned char m_fHighByte;
			public: unsigned char m_reserved1;
			public: unsigned char m_fExtSt;
			public: unsigned char m_fRichSt;
			public: unsigned char m_reserved2;
			public: unsigned short m_cRun;
			public: int m_cbExtRst;
			public: InternalString* m_rgb;
			public: OwnedVector<XLUnicodeRichExtendedString_ContinueInfo*>* m_pContinueInfoVector;
			public: XLUnicodeRichExtendedString(const char* szString);
			protected: void PostSetDefaults();
			public: void ContinueAwareBlobRead(BlobView* pBlobView, OwnedVector<BiffRecord_ContinueInfo*>* pContinueInfoVector);
			protected: void PostBlobRead(BlobView* pBlobView);
			public: void ContinueAwareBlobWrite(BlobView* pBlobView, OwnedVector<BiffRecord_ContinueInfo*>* pContinueInfoVector);
			protected: void PreBlobWrite(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: virtual ~XLUnicodeRichExtendedString();
		};
		class ShortXLUnicodeStringStruct : public BiffStruct
		{
			public: ShortXLUnicodeStringStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 2;
			public: void SetDefaults();
			public: unsigned char m_cch;
			public: unsigned char m_fHighByte;
			public: unsigned char m_reserved;
			public: InternalString* m_rgb;
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PreBlobWrite(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: int GetDynamicSize();
			public: virtual ~ShortXLUnicodeStringStruct();
		};
		class RwUStruct : public BiffStruct
		{
			public: RwUStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 2;
			public: void SetDefaults();
			public: unsigned short m_rw;
		};
		class RwStruct : public BiffStruct
		{
			public: RwStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 2;
			public: void SetDefaults();
			public: unsigned short m_rw;
		};
		class RkRecStruct : public BiffStruct
		{
			public: RkRecStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 6;
			public: void SetDefaults();
			public: unsigned short m_ixfe;
			public: unsigned int m_RK;
		};
		class RgceStruct : public BiffStruct
		{
			public: RgceStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 0;
			public: void SetDefaults();
			public: OwnedVector<ParsedExpressionRecord*>* m_pParsedExpressionRecordVector;
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PreBlobWrite(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: int GetSize();
			public: virtual ~RgceStruct();
		};
		class RgceLocStruct : public BiffStruct
		{
			public: RgceLocStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 4;
			public: void SetDefaults();
			public: RwUStruct* m_row;
			public: ColRelUStruct* m_column;
			public: virtual ~RgceLocStruct();
		};
		class RgceAreaStruct : public BiffStruct
		{
			public: RgceAreaStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 8;
			public: void SetDefaults();
			public: RwUStruct* m_rowFirst;
			public: RwUStruct* m_rowLast;
			public: ColRelUStruct* m_columnFirst;
			public: ColRelUStruct* m_columnLast;
			public: virtual ~RgceAreaStruct();
		};
		class Ref8Struct : public BiffStruct
		{
			public: Ref8Struct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 8;
			public: void SetDefaults();
			public: unsigned short m_rwFirst;
			public: unsigned short m_rwLast;
			public: unsigned short m_colFirst;
			public: unsigned short m_colLast;
		};
		class PtgAttrSpaceTypeStruct : public BiffStruct
		{
			public: PtgAttrSpaceTypeStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 2;
			public: void SetDefaults();
			public: unsigned char m_type;
			public: unsigned char m_cch;
		};
		class OfficeArtRecordHeaderStruct : public BiffStruct
		{
			public: OfficeArtRecordHeaderStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 8;
			public: void SetDefaults();
			public: unsigned short m_recVer;
			public: unsigned short m_recInstance;
			public: unsigned short m_recType;
			public: unsigned int m_recLen;
		};
		class OfficeArtIDCLStruct : public BiffStruct
		{
			public: OfficeArtIDCLStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 8;
			public: void SetDefaults();
			public: unsigned int m_dgid;
			public: unsigned int m_cspidCur;
		};
		class OfficeArtFRITStruct : public BiffStruct
		{
			public: OfficeArtFRITStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 4;
			public: void SetDefaults();
			public: unsigned short m_fridNew;
			public: unsigned short m_fridOld;
		};
		class OfficeArtFOPTEStruct : public BiffStruct
		{
			public: OfficeArtFOPTEStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 6;
			public: void SetDefaults();
			public: OfficeArtFOPTEOPIDStruct* m_opid;
			public: int m_op;
			public: Blob* m_pComplexData;
			protected: void PostSetDefaults();
			public: virtual ~OfficeArtFOPTEStruct();
		};
		class OfficeArtFOPTEOPIDStruct : public BiffStruct
		{
			public: OfficeArtFOPTEOPIDStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 2;
			public: void SetDefaults();
			public: unsigned short m_opid;
			public: unsigned short m_fBid;
			public: unsigned short m_fComplex;
		};
		class MSOCRStruct : public BiffStruct
		{
			public: MSOCRStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 4;
			public: void SetDefaults();
			public: unsigned char m_red;
			public: unsigned char m_green;
			public: unsigned char m_blue;
			public: unsigned char m_unused1;
			public: unsigned char m_fSchemeIndex;
			public: unsigned char m_unused2;
		};
		class MD4DigestStruct : public BiffStruct
		{
			public: MD4DigestStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 16;
			public: void SetDefaults();
			public: unsigned char m_rgbUid1_0;
			public: unsigned char m_rgbUid1_1;
			public: unsigned char m_rgbUid1_2;
			public: unsigned char m_rgbUid1_3;
			public: unsigned char m_rgbUid1_4;
			public: unsigned char m_rgbUid1_5;
			public: unsigned char m_rgbUid1_6;
			public: unsigned char m_rgbUid1_7;
			public: unsigned char m_rgbUid1_8;
			public: unsigned char m_rgbUid1_9;
			public: unsigned char m_rgbUid1_10;
			public: unsigned char m_rgbUid1_11;
			public: unsigned char m_rgbUid1_12;
			public: unsigned char m_rgbUid1_13;
			public: unsigned char m_rgbUid1_14;
			public: unsigned char m_rgbUid1_15;
		};
		class IcvFontStruct : public BiffStruct
		{
			public: IcvFontStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 2;
			public: void SetDefaults();
			public: unsigned short m_icv;
		};
		class IXFCellStruct : public BiffStruct
		{
			public: IXFCellStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 2;
			public: void SetDefaults();
			public: unsigned short m_ixfe;
		};
		class IHlinkStruct : public BiffStruct
		{
			public: IHlinkStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 24;
			public: void SetDefaults();
			public: unsigned char m_CLSID_StdHlink_0;
			public: unsigned char m_CLSID_StdHlink_1;
			public: unsigned char m_CLSID_StdHlink_2;
			public: unsigned char m_CLSID_StdHlink_3;
			public: unsigned char m_CLSID_StdHlink_4;
			public: unsigned char m_CLSID_StdHlink_5;
			public: unsigned char m_CLSID_StdHlink_6;
			public: unsigned char m_CLSID_StdHlink_7;
			public: unsigned char m_CLSID_StdHlink_8;
			public: unsigned char m_CLSID_StdHlink_9;
			public: unsigned char m_CLSID_StdHlink_10;
			public: unsigned char m_CLSID_StdHlink_11;
			public: unsigned char m_CLSID_StdHlink_12;
			public: unsigned char m_CLSID_StdHlink_13;
			public: unsigned char m_CLSID_StdHlink_14;
			public: unsigned char m_CLSID_StdHlink_15;
			public: HyperlinkObjectStruct* m_hyperlink;
			public: virtual ~IHlinkStruct();
		};
		class HyperlinkStringStruct : public BiffStruct
		{
			public: HyperlinkStringStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 4;
			public: void SetDefaults();
			public: unsigned int m_length;
			protected: InternalString* m_string;
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PreBlobWrite(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: virtual ~HyperlinkStringStruct();
		};
		class HyperlinkObjectStruct : public BiffStruct
		{
			public: HyperlinkObjectStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 8;
			public: void SetDefaults();
			public: unsigned int m_streamVersion;
			public: unsigned int m_hlstmfHasMoniker;
			public: unsigned int m_hlstmfIsAbsolute;
			public: unsigned int m_hlstmfSiteGaveDisplayName;
			public: unsigned int m_hlstmfHasLocationStr;
			public: unsigned int m_hlstmfHasDisplayName;
			public: unsigned int m_hlstmfHasGUID;
			public: unsigned int m_hlstmfHasCreationTime;
			public: unsigned int m_hlstmfHasFrameName;
			public: unsigned int m_hlstmfMonikerSavedAsStr;
			public: unsigned int m_hlstmfAbsFromGetdataRel;
			public: unsigned int m_reserved;
			protected: HyperlinkStringStruct* m_displayName;
			protected: HyperlinkStringStruct* m_targetFrameName;
			protected: HyperlinkStringStruct* m_moniker;
			public: InternalString* m_haxUrl;
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: virtual ~HyperlinkObjectStruct();
		};
		class FullColorExtStruct : public BiffStruct
		{
			public: FullColorExtStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 16;
			public: void SetDefaults();
			public: unsigned short m_xclrType;
			public: short m_nTintShade;
			public: unsigned int m_xclrValue;
			public: unsigned char m_unusedA;
			public: unsigned char m_unusedB;
			public: unsigned char m_unusedC;
			public: unsigned char m_unusedD;
			public: unsigned char m_unusedE;
			public: unsigned char m_unusedF;
			public: unsigned char m_unusedG;
			public: unsigned char m_unusedH;
		};
		class FtPioGrbitStruct : public BiffStruct
		{
			public: FtPioGrbitStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 6;
			public: void SetDefaults();
			public: unsigned short m_ft;
			public: unsigned short m_cb;
			public: unsigned short m_fAutoPict;
			public: unsigned short m_fDde;
			public: unsigned short m_fPrintCalc;
			public: unsigned short m_fIcon;
			public: unsigned short m_fCtl;
			public: unsigned short m_fPrstm;
			public: unsigned short m_unused1;
			public: unsigned short m_fCamera;
			public: unsigned short m_fDefaultSize;
			public: unsigned short m_fAutoLoad;
			public: unsigned short m_unused2;
		};
		class FtCfStruct : public BiffStruct
		{
			public: FtCfStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 6;
			public: void SetDefaults();
			public: unsigned short m_ft;
			public: unsigned short m_cb;
			public: unsigned short m_cf;
		};
		class FrtHeaderStruct : public BiffStruct
		{
			public: FrtHeaderStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 12;
			public: void SetDefaults();
			public: unsigned short m_rt;
			public: FrtFlagsStruct* m_grbitFrt;
			public: unsigned int m_reservedA;
			public: unsigned int m_reservedB;
			public: virtual ~FrtHeaderStruct();
		};
		class FrtHeaderOldStruct : public BiffStruct
		{
			public: FrtHeaderOldStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 4;
			public: void SetDefaults();
			public: unsigned short m_rt;
			public: FrtFlagsStruct* m_grbitFrt;
			public: virtual ~FrtHeaderOldStruct();
		};
		class FrtFlagsStruct : public BiffStruct
		{
			public: FrtFlagsStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 2;
			public: void SetDefaults();
			public: unsigned short m_fFrtRef;
			public: unsigned short m_fFrtAlert;
			public: unsigned short m_reserved;
		};
		class FormulaValueStruct : public BiffStruct
		{
			public: FormulaValueStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 8;
			public: void SetDefaults();
			public: unsigned char m_byte1;
			public: unsigned char m_byte2;
			public: unsigned char m_byte3;
			public: unsigned char m_byte4;
			public: unsigned char m_byte5;
			public: unsigned char m_byte6;
			public: unsigned short m_fExprO;
		};
		class ExtPropStruct : public BiffStruct
		{
			public: ExtPropStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 4;
			public: void SetDefaults();
			public: unsigned short m_extType;
			public: unsigned short m_cb;
			public: FullColorExtStruct* m_pFullColorExt;
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PreBlobWrite(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: virtual ~ExtPropStruct();
		};
		class ColStruct : public BiffStruct
		{
			public: ColStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 2;
			public: void SetDefaults();
			public: unsigned short m_col;
		};
		class ColRelUStruct : public BiffStruct
		{
			public: ColRelUStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 2;
			public: void SetDefaults();
			public: unsigned short m_col;
			public: unsigned short m_colRelative;
			public: unsigned short m_rowRelative;
		};
		class CellStruct : public BiffStruct
		{
			public: CellStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 6;
			public: void SetDefaults();
			public: RwStruct* m_rw;
			public: ColStruct* m_col;
			public: IXFCellStruct* m_ixfe;
			public: virtual ~CellStruct();
		};
		class CellParsedFormulaStruct : public BiffStruct
		{
			public: CellParsedFormulaStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 2;
			public: void SetDefaults();
			public: unsigned short m_cce;
			public: RgceStruct* m_rgce;
			public: CellParsedFormulaStruct(Formula* pFormula, WorkbookGlobals* pWorkbookGlobals);
			protected: void PostSetDefaults();
			protected: void PostBlobRead(BlobView* pBlobView);
			protected: void PreBlobWrite(BlobView* pBlobView);
			protected: void PostBlobWrite(BlobView* pBlobView);
			public: int GetSize();
			public: virtual ~CellParsedFormulaStruct();
		};
		class BuiltInStyleStruct : public BiffStruct
		{
			public: BuiltInStyleStruct();
			public: virtual void BlobRead(BlobView* pBlobView);
			public: virtual void BlobWrite(BlobView* pBlobView);
			public: static const unsigned short SIZE = 2;
			public: void SetDefaults();
			public: unsigned char m_istyBuiltIn;
			public: unsigned char m_iLevel;
		};
		class OfficeArtDimensions
		{
			public: unsigned short m_nCellX1;
			public: unsigned short m_nSubCellX1;
			public: unsigned short m_nCellY1;
			public: unsigned short m_nSubCellY1;
			public: unsigned short m_nCellX2;
			public: unsigned short m_nSubCellX2;
			public: unsigned short m_nCellY2;
			public: unsigned short m_nSubCellY2;
			public: OfficeArtDimensions();
		};
		class BiffWorksheet : public Worksheet
		{
			protected: BiffRecordContainer* m_pBiffRecordContainer;
			public: BiffWorksheet(Workbook* pWorkbook);
			public: BiffWorksheet(Workbook* pWorkbook, BiffWorkbookGlobals* pBiffWorkbookGlobals, BiffRecord* pInitialBiffRecord, Stream* pStream);
			public: static void Write(Worksheet* pWorksheet, WorkbookGlobals* pWorkbookGlobals, unsigned short nWorksheetIndex, BiffRecordContainer* pBiffRecordContainer);
			public: static OfficeArtDimensions* ComputeDimensions(Worksheet* pWorksheet, unsigned short nCellX, unsigned short nSubCellX, unsigned short nWidth, unsigned short nCellY, unsigned short nSubCellY, unsigned short nHeight);
			public: int LoopToEnd(int i, BiffRecordContainer* pBiffRecordContainer);
			public: virtual ~BiffWorksheet();
		};
		class BiffUtils
		{
			public: static double RkValueDecode(unsigned int nRkValue);
		};
		class BiffRecordContainer : public WorkbookGlobals
		{
			public: OwnedVector<BiffRecord*>* m_pBiffRecordVector;
			public: BiffRecordContainer();
			public: BiffRecordContainer(BiffRecord* pInitialBiffRecord, Stream* pStream);
			public: void AddBiffRecord(BiffRecord* pBiffRecord);
			public: unsigned int GetSize();
			public: void Write(Stream* pStream);
			public: virtual ~BiffRecordContainer();
		};
		class StreamDirectoryImplementation
		{
			public: unsigned int m_nMinimumStandardStreamSize;
			public: OwnedVector<Stream*>* m_pStreamVector;
			public: CompoundFile* m_pCompoundFile;
			public: void AppendStream(Stream* pStream);
			public: static int RedBlackTreeComparisonCallback(const void* pObjectA, const void* pObjectB);
			public: void RedBlackTreeWalk(RedBlackNode* pNode, Stream* pStorage);
			public: StreamDirectoryImplementation();
			public: virtual ~StreamDirectoryImplementation();
		};
		class StreamDirectory : public SectorChain
		{
			protected: StreamDirectoryImplementation* m_pImpl;
			public: StreamDirectory(int nSectorSize, unsigned int nMinimumStandardStreamSize, CompoundFile* pCompoundFile);
			public: int GetNumStream();
			public: Stream* GetStreamByIndex(int nStreamDirectoryId);
			public: Stream* GetStreamByName(const char* sxName);
			public: Stream* CreateStream(const char* sxName, Stream::Type eType);
			public: virtual void AppendSector(Sector* pSector);
			public: virtual void Extend(Sector* pSector);
			public: void RedBlackTreeRebuild();
			public: virtual ~StreamDirectory();
		};
		class SectorAllocationTable : public SectorChain
		{
			protected: int m_nNumFreeSectorId;
			public: SectorAllocationTable(int nSectorSize);
			public: virtual int GetNumSectorId();
			public: virtual int GetNumFreeSectorId();
			public: virtual int GetSectorId(int nIndex);
			public: virtual void SetSectorId(int nIndex, int nSectorId);
			public: int GetFreeSectorId();
			public: virtual void AppendSector(Sector* pSector);
			public: virtual void Extend(Sector* pSector);
		};
		class SectorImplementation
		{
			public: int m_nSectorId;
			public: BlobView* m_pBlobView;
			public: SectorImplementation();
			public: virtual ~SectorImplementation();
		};
		class Sector
		{
			public: static const int MINIMUM_SECTOR_SIZE = 128;
			public: static const int MINIMUM_SECTOR_SIZE_SHIFT = 7;
			protected: SectorImplementation* m_pImpl;
			public: enum SectorId
			{
				FREE_SECTOR_SECTOR_ID = -1,
				END_OF_CHAIN_SECTOR_ID = -2,
				SECTOR_ALLOCATION_TABLE_SECTOR_ID = -3,
				MASTER_SECTOR_ALLOCATION_TABLE_SECTOR_ID = -4,
			};

			public: Sector(int nSectorId, BlobView* pBlobView, int nDataSize);
			public: int GetDataSize();
			public: int GetSectorId();
			public: BlobView* GetBlobView();
			public: virtual ~Sector();
		};
		class MasterSectorAllocationTable : public SectorAllocationTable
		{
			public: static const int INITIAL_SECTOR_ID_ARRAY_SIZE = 109;
			protected: CompoundFileHeader* m_pHeader;
			public: MasterSectorAllocationTable(CompoundFileHeader* pHeader);
			public: virtual int GetNumSectorId();
			public: int GetNumInternalSectorId();
			public: virtual int GetSectorId(int nIndex);
			public: virtual void SetSectorId(int nIndex, int nSectorId);
			public: int GetInternalSectorId(int nIndex);
			public: void SetInternalSectorId(int nIndex, int nSectorId);
			public: int TranslateIndex(int nIndex);
			public: int GetSectorIdToAppend();
			public: virtual void AppendSector(Sector* pSector);
			public: virtual void Extend(Sector* pSector);
		};
		class CompoundFileHeader
		{
			public: static const int MAGIC_WORD_SIZE = 8;
			public: static const unsigned char MAGIC_WORD[CompoundFileHeader::MAGIC_WORD_SIZE];
			public: static const unsigned int UNIQUE_IDENTIFIER_SIZE = 16;
			public: static const unsigned short REVISION_NUMBER = 62;
			public: static const unsigned short VERSION_NUMBER = 0x0003;
			public: static const unsigned short BOM_LITTLE_ENDIAN = 0xFFFF;
			public: static const unsigned short BOM_BIG_ENDIAN = 0xFFFE;
			public: unsigned char m_pMagicWord[MAGIC_WORD_SIZE];
			public: unsigned char m_pUniqueIdentifier[UNIQUE_IDENTIFIER_SIZE];
			public: unsigned short m_nRevisonNumber;
			public: unsigned short m_nVersionNumber;
			public: unsigned short m_nByteOrderIdentifier;
			public: unsigned short m_nSectorSize;
			public: unsigned short m_nShortSectorSize;
			public: unsigned char m_pUnusedA[10];
			public: unsigned int m_nSectorAllocationTableSize;
			public: int m_nStreamDirectoryStreamSectorId;
			public: unsigned char m_pUnusedB[4];
			public: unsigned int m_nMinimumStandardStreamSize;
			public: int m_nShortSectorAllocationTableSectorId;
			public: unsigned int m_nShortSectorAllocationTableSize;
			public: int m_nMasterSectorAllocationTableSectorId;
			public: unsigned int m_nMasterSectorAllocationTableSize;
			public: int m_pMasterSectorAllocationTable[MasterSectorAllocationTable::INITIAL_SECTOR_ID_ARRAY_SIZE];
			public: CompoundFileHeader(unsigned int nSectorSize, unsigned int nShortSectorSize);
			public: int GetSectorSize();
			public: bool Unpack(Blob* pBlob);
			public: void Pack(Blob* pBlob);
		};
		class CompoundFile
		{
			public: static const int HEADER_SIZE = 512;
			protected: CompoundFileHeader* m_pHeader;
			protected: Blob* m_pBlob;
			protected: MasterSectorAllocationTable* m_pMasterSectorAllocationTable;
			protected: SectorAllocationTable* m_pSectorAllocationTable;
			protected: SectorAllocationTable* m_pShortSectorAllocationTable;
			protected: StreamDirectory* m_pStreamDirectory;
			protected: OwnedVector<Sector*>* m_pSectorVector;
			protected: OwnedVector<Sector*>* m_pShortSectorVector;
			public: CompoundFile(unsigned int nSectorSize = 512, unsigned int nShortSectorSize = 64, unsigned int nMinimumStandardStreamSize = 4096);
			public: virtual ~CompoundFile();
			public: bool Load(const char* sxFileName);
			public: bool Save(const char* sxFileName);
			public: CompoundFileHeader* GetHeader();
			public: StreamDirectory* GetStreamDirectory();
			public: Stream* CreateStream(const char* sxName, Stream::Type eType);
			public: int GetNumStream();
			public: Stream* GetStreamByIndex(int nIndex);
			public: Stream* GetStreamByName(const char* sxName);
			public: int GetSectorSize(bool bShortSector);
			public: int GetSectorId(int nSectorId, bool bShortSector);
			public: Sector* GetSector(int nSectorId, bool bShortSector);
			public: void FillSectorChain(SectorChain* pSectorChain, int nInitialSectorId, bool bShortSector);
			public: int GetFreeSectorId(bool bShortSector);
			public: SectorAllocationTable* GetSectorAllocationTable(bool bShortSector);
			public: MasterSectorAllocationTable* GetMasterSectorAllocationTable();
			public: void MasterSectorAllocationTableExtend();
			public: void SectorAllocationTableExtend(bool bShortSector);
			public: void SectorChainExtend(SectorChain* pSectorChain);
			public: void StreamDirectoryExtend();
		};
		class Token
		{
			public: enum Type
			{
				TYPE_FUNC_COUNT = 0x0000,
				TYPE_FUNC_IF = 0x0001,
				TYPE_FUNC_ISNA = 0x0002,
				TYPE_FUNC_ISERROR = 0x0003,
				TYPE_FUNC_SUM = 0x0004,
				TYPE_FUNC_AVERAGE = 0x0005,
				TYPE_FUNC_MIN = 0x0006,
				TYPE_FUNC_MAX = 0x0007,
				TYPE_FUNC_ROW = 0x0008,
				TYPE_FUNC_COLUMN = 0x0009,
				TYPE_FUNC_NA = 0x000A,
				TYPE_FUNC_NPV = 0x000B,
				TYPE_FUNC_STDEV = 0x000C,
				TYPE_FUNC_DOLLAR = 0x000D,
				TYPE_FUNC_FIXED = 0x000E,
				TYPE_FUNC_SIN = 0x000F,
				TYPE_FUNC_COS = 0x0010,
				TYPE_FUNC_TAN = 0x0011,
				TYPE_FUNC_ATAN = 0x0012,
				TYPE_FUNC_PI = 0x0013,
				TYPE_FUNC_SQRT = 0x0014,
				TYPE_FUNC_EXP = 0x0015,
				TYPE_FUNC_LN = 0x0016,
				TYPE_FUNC_LOG10 = 0x0017,
				TYPE_FUNC_ABS = 0x0018,
				TYPE_FUNC_INT = 0x0019,
				TYPE_FUNC_SIGN = 0x001A,
				TYPE_FUNC_ROUND = 0x001B,
				TYPE_FUNC_LOOKUP = 0x001C,
				TYPE_FUNC_INDEX = 0x001D,
				TYPE_FUNC_REPT = 0x001E,
				TYPE_FUNC_MID = 0x001F,
				TYPE_FUNC_LEN = 0x0020,
				TYPE_FUNC_VALUE = 0x0021,
				TYPE_FUNC_TRUE = 0x0022,
				TYPE_FUNC_FALSE = 0x0023,
				TYPE_FUNC_AND = 0x0024,
				TYPE_FUNC_OR = 0x0025,
				TYPE_FUNC_NOT = 0x0026,
				TYPE_FUNC_MOD = 0x0027,
				TYPE_FUNC_DCOUNT = 0x0028,
				TYPE_FUNC_DSUM = 0x0029,
				TYPE_FUNC_DAVERAGE = 0x002A,
				TYPE_FUNC_DMIN = 0x002B,
				TYPE_FUNC_DMAX = 0x002C,
				TYPE_FUNC_DSTDEV = 0x002D,
				TYPE_FUNC_VAR = 0x002E,
				TYPE_FUNC_DVAR = 0x002F,
				TYPE_FUNC_TEXT = 0x0030,
				TYPE_FUNC_LINEST = 0x0031,
				TYPE_FUNC_TREND = 0x0032,
				TYPE_FUNC_LOGEST = 0x0033,
				TYPE_FUNC_GROWTH = 0x0034,
				TYPE_FUNC_GOTO = 0x0035,
				TYPE_FUNC_HALT = 0x0036,
				TYPE_FUNC_RETURN = 0x0037,
				TYPE_FUNC_PV = 0x0038,
				TYPE_FUNC_FV = 0x0039,
				TYPE_FUNC_NPER = 0x003A,
				TYPE_FUNC_PMT = 0x003B,
				TYPE_FUNC_RATE = 0x003C,
				TYPE_FUNC_MIRR = 0x003D,
				TYPE_FUNC_IRR = 0x003E,
				TYPE_FUNC_RAND = 0x003F,
				TYPE_FUNC_MATCH = 0x0040,
				TYPE_FUNC_DATE = 0x0041,
				TYPE_FUNC_TIME = 0x0042,
				TYPE_FUNC_DAY = 0x0043,
				TYPE_FUNC_MONTH = 0x0044,
				TYPE_FUNC_YEAR = 0x0045,
				TYPE_FUNC_WEEKDAY = 0x0046,
				TYPE_FUNC_HOUR = 0x0047,
				TYPE_FUNC_MINUTE = 0x0048,
				TYPE_FUNC_SECOND = 0x0049,
				TYPE_FUNC_NOW = 0x004A,
				TYPE_FUNC_AREAS = 0x004B,
				TYPE_FUNC_ROWS = 0x004C,
				TYPE_FUNC_COLUMNS = 0x004D,
				TYPE_FUNC_OFFSET = 0x004E,
				TYPE_FUNC_ABSREF = 0x004F,
				TYPE_FUNC_RELREF = 0x0050,
				TYPE_FUNC_ARGUMENT = 0x0051,
				TYPE_FUNC_SEARCH = 0x0052,
				TYPE_FUNC_TRANSPOSE = 0x0053,
				TYPE_FUNC_ERROR = 0x0054,
				TYPE_FUNC_STEP = 0x0055,
				TYPE_FUNC_TYPE = 0x0056,
				TYPE_FUNC_ECHO = 0x0057,
				TYPE_FUNC_SET_NAME = 0x0058,
				TYPE_FUNC_CALLER = 0x0059,
				TYPE_FUNC_DEREF = 0x005A,
				TYPE_FUNC_WINDOWS = 0x005B,
				TYPE_FUNC_SERIES = 0x005C,
				TYPE_FUNC_DOCUMENTS = 0x005D,
				TYPE_FUNC_ACTIVE_CELL = 0x005E,
				TYPE_FUNC_SELECTION = 0x005F,
				TYPE_FUNC_RESULT = 0x0060,
				TYPE_FUNC_ATAN2 = 0x0061,
				TYPE_FUNC_ASIN = 0x0062,
				TYPE_FUNC_ACOS = 0x0063,
				TYPE_FUNC_CHOOSE = 0x0064,
				TYPE_FUNC_HLOOKUP = 0x0065,
				TYPE_FUNC_VLOOKUP = 0x0066,
				TYPE_FUNC_LINKS = 0x0067,
				TYPE_FUNC_INPUT = 0x0068,
				TYPE_FUNC_ISREF = 0x0069,
				TYPE_FUNC_GET_FORMULA = 0x006A,
				TYPE_FUNC_GET_NAME = 0x006B,
				TYPE_FUNC_SET_VALUE = 0x006C,
				TYPE_FUNC_LOG = 0x006D,
				TYPE_FUNC_EXEC = 0x006E,
				TYPE_FUNC_CHAR = 0x006F,
				TYPE_FUNC_LOWER = 0x0070,
				TYPE_FUNC_UPPER = 0x0071,
				TYPE_FUNC_PROPER = 0x0072,
				TYPE_FUNC_LEFT = 0x0073,
				TYPE_FUNC_RIGHT = 0x0074,
				TYPE_FUNC_EXACT = 0x0075,
				TYPE_FUNC_TRIM = 0x0076,
				TYPE_FUNC_REPLACE = 0x0077,
				TYPE_FUNC_SUBSTITUTE = 0x0078,
				TYPE_FUNC_CODE = 0x0079,
				TYPE_FUNC_NAMES = 0x007A,
				TYPE_FUNC_DIRECTORY = 0x007B,
				TYPE_FUNC_FIND = 0x007C,
				TYPE_FUNC_CELL = 0x007D,
				TYPE_FUNC_ISERR = 0x007E,
				TYPE_FUNC_ISTEXT = 0x007F,
				TYPE_FUNC_ISNUMBER = 0x0080,
				TYPE_FUNC_ISBLANK = 0x0081,
				TYPE_FUNC_T = 0x0082,
				TYPE_FUNC_N = 0x0083,
				TYPE_FUNC_FOPEN = 0x0084,
				TYPE_FUNC_FCLOSE = 0x0085,
				TYPE_FUNC_FSIZE = 0x0086,
				TYPE_FUNC_FREADLN = 0x0087,
				TYPE_FUNC_FREAD = 0x0088,
				TYPE_FUNC_FWRITELN = 0x0089,
				TYPE_FUNC_FWRITE = 0x008A,
				TYPE_FUNC_FPOS = 0x008B,
				TYPE_FUNC_DATEVALUE = 0x008C,
				TYPE_FUNC_TIMEVALUE = 0x008D,
				TYPE_FUNC_SLN = 0x008E,
				TYPE_FUNC_SYD = 0x008F,
				TYPE_FUNC_DDB = 0x0090,
				TYPE_FUNC_GET_DEF = 0x0091,
				TYPE_FUNC_REFTEXT = 0x0092,
				TYPE_FUNC_TEXTREF = 0x0093,
				TYPE_FUNC_INDIRECT = 0x0094,
				TYPE_FUNC_REGISTER = 0x0095,
				TYPE_FUNC_CALL = 0x0096,
				TYPE_FUNC_ADD_BAR = 0x0097,
				TYPE_FUNC_ADD_MENU = 0x0098,
				TYPE_FUNC_ADD_COMMAND = 0x0099,
				TYPE_FUNC_ENABLE_COMMAND = 0x009A,
				TYPE_FUNC_CHECK_COMMAND = 0x009B,
				TYPE_FUNC_RENAME_COMMAND = 0x009C,
				TYPE_FUNC_SHOW_BAR = 0x009D,
				TYPE_FUNC_DELETE_MENU = 0x009E,
				TYPE_FUNC_DELETE_COMMAND = 0x009F,
				TYPE_FUNC_GET_CHART_ITEM = 0x00A0,
				TYPE_FUNC_DIALOG_BOX = 0x00A1,
				TYPE_FUNC_CLEAN = 0x00A2,
				TYPE_FUNC_MDETERM = 0x00A3,
				TYPE_FUNC_MINVERSE = 0x00A4,
				TYPE_FUNC_MMULT = 0x00A5,
				TYPE_FUNC_FILES = 0x00A6,
				TYPE_FUNC_IPMT = 0x00A7,
				TYPE_FUNC_PPMT = 0x00A8,
				TYPE_FUNC_COUNTA = 0x00A9,
				TYPE_FUNC_CANCEL_KEY = 0x00AA,
				TYPE_FUNC_FOR = 0x00AB,
				TYPE_FUNC_WHILE = 0x00AC,
				TYPE_FUNC_BREAK = 0x00AD,
				TYPE_FUNC_NEXT = 0x00AE,
				TYPE_FUNC_INITIATE = 0x00AF,
				TYPE_FUNC_REQUEST = 0x00B0,
				TYPE_FUNC_POKE = 0x00B1,
				TYPE_FUNC_EXECUTE = 0x00B2,
				TYPE_FUNC_TERMINATE = 0x00B3,
				TYPE_FUNC_RESTART = 0x00B4,
				TYPE_FUNC_HELP = 0x00B5,
				TYPE_FUNC_GET_BAR = 0x00B6,
				TYPE_FUNC_PRODUCT = 0x00B7,
				TYPE_FUNC_FACT = 0x00B8,
				TYPE_FUNC_GET_CELL = 0x00B9,
				TYPE_FUNC_GET_WORKSPACE = 0x00BA,
				TYPE_FUNC_GET_WINDOW = 0x00BB,
				TYPE_FUNC_GET_DOCUMENT = 0x00BC,
				TYPE_FUNC_DPRODUCT = 0x00BD,
				TYPE_FUNC_ISNONTEXT = 0x00BE,
				TYPE_FUNC_GET_NOTE = 0x00BF,
				TYPE_FUNC_NOTE = 0x00C0,
				TYPE_FUNC_STDEVP = 0x00C1,
				TYPE_FUNC_VARP = 0x00C2,
				TYPE_FUNC_DSTDEVP = 0x00C3,
				TYPE_FUNC_DVARP = 0x00C4,
				TYPE_FUNC_TRUNC = 0x00C5,
				TYPE_FUNC_ISLOGICAL = 0x00C6,
				TYPE_FUNC_DCOUNTA = 0x00C7,
				TYPE_FUNC_DELETE_BAR = 0x00C8,
				TYPE_FUNC_UNREGISTER = 0x00C9,
				TYPE_FUNC_USDOLLAR = 0x00CC,
				TYPE_FUNC_FINDB = 0x00CD,
				TYPE_FUNC_SEARCHB = 0x00CE,
				TYPE_FUNC_REPLACEB = 0x00CF,
				TYPE_FUNC_LEFTB = 0x00D0,
				TYPE_FUNC_RIGHTB = 0x00D1,
				TYPE_FUNC_MIDB = 0x00D2,
				TYPE_FUNC_LENB = 0x00D3,
				TYPE_FUNC_ROUNDUP = 0x00D4,
				TYPE_FUNC_ROUNDDOWN = 0x00D5,
				TYPE_FUNC_ASC = 0x00D6,
				TYPE_FUNC_DBCS = 0x00D7,
				TYPE_FUNC_RANK = 0x00D8,
				TYPE_FUNC_ADDRESS = 0x00DB,
				TYPE_FUNC_DAYS360 = 0x00DC,
				TYPE_FUNC_TODAY = 0x00DD,
				TYPE_FUNC_VDB = 0x00DE,
				TYPE_FUNC_ELSE = 0x00DF,
				TYPE_FUNC_ELSE_IF = 0x00E0,
				TYPE_FUNC_END_IF = 0x00E1,
				TYPE_FUNC_FOR_CELL = 0x00E2,
				TYPE_FUNC_MEDIAN = 0x00E3,
				TYPE_FUNC_SUMPRODUCT = 0x00E4,
				TYPE_FUNC_SINH = 0x00E5,
				TYPE_FUNC_COSH = 0x00E6,
				TYPE_FUNC_TANH = 0x00E7,
				TYPE_FUNC_ASINH = 0x00E8,
				TYPE_FUNC_ACOSH = 0x00E9,
				TYPE_FUNC_ATANH = 0x00EA,
				TYPE_FUNC_DGET = 0x00EB,
				TYPE_FUNC_CREATE_OBJECT = 0x00EC,
				TYPE_FUNC_VOLATILE = 0x00ED,
				TYPE_FUNC_LAST_ERROR = 0x00EE,
				TYPE_FUNC_CUSTOM_UNDO = 0x00EF,
				TYPE_FUNC_CUSTOM_REPEAT = 0x00F0,
				TYPE_FUNC_FORMULA_CONVERT = 0x00F1,
				TYPE_FUNC_GET_LINK_INFO = 0x00F2,
				TYPE_FUNC_TEXT_BOX = 0x00F3,
				TYPE_FUNC_INFO = 0x00F4,
				TYPE_FUNC_GROUP = 0x00F5,
				TYPE_FUNC_GET_OBJECT = 0x00F6,
				TYPE_FUNC_DB = 0x00F7,
				TYPE_FUNC_PAUSE = 0x00F8,
				TYPE_FUNC_RESUME = 0x00FB,
				TYPE_FUNC_FREQUENCY = 0x00FC,
				TYPE_FUNC_ADD_TOOLBAR = 0x00FD,
				TYPE_FUNC_DELETE_TOOLBAR = 0x00FE,
				TYPE_FUNC_RESET_TOOLBAR = 0x0100,
				TYPE_FUNC_EVALUATE = 0x0101,
				TYPE_FUNC_GET_TOOLBAR = 0x0102,
				TYPE_FUNC_GET_TOOL = 0x0103,
				TYPE_FUNC_SPELLING_CHECK = 0x0104,
				TYPE_FUNC_ERROR_TYPE = 0x0105,
				TYPE_FUNC_APP_TITLE = 0x0106,
				TYPE_FUNC_WINDOW_TITLE = 0x0107,
				TYPE_FUNC_SAVE_TOOLBAR = 0x0108,
				TYPE_FUNC_ENABLE_TOOL = 0x0109,
				TYPE_FUNC_PRESS_TOOL = 0x010A,
				TYPE_FUNC_REGISTER_ID = 0x010B,
				TYPE_FUNC_GET_WORKBOOK = 0x010C,
				TYPE_FUNC_AVEDEV = 0x010D,
				TYPE_FUNC_BETADIST = 0x010E,
				TYPE_FUNC_GAMMALN = 0x010F,
				TYPE_FUNC_BETAINV = 0x0110,
				TYPE_FUNC_BINOMDIST = 0x0111,
				TYPE_FUNC_CHIDIST = 0x0112,
				TYPE_FUNC_CHIINV = 0x0113,
				TYPE_FUNC_COMBIN = 0x0114,
				TYPE_FUNC_CONFIDENCE = 0x0115,
				TYPE_FUNC_CRITBINOM = 0x0116,
				TYPE_FUNC_EVEN = 0x0117,
				TYPE_FUNC_EXPONDIST = 0x0118,
				TYPE_FUNC_FDIST = 0x0119,
				TYPE_FUNC_FINV = 0x011A,
				TYPE_FUNC_FISHER = 0x011B,
				TYPE_FUNC_FISHERINV = 0x011C,
				TYPE_FUNC_FLOOR = 0x011D,
				TYPE_FUNC_GAMMADIST = 0x011E,
				TYPE_FUNC_GAMMAINV = 0x011F,
				TYPE_FUNC_CEILING = 0x0120,
				TYPE_FUNC_HYPGEOMDIST = 0x0121,
				TYPE_FUNC_LOGNORMDIST = 0x0122,
				TYPE_FUNC_LOGINV = 0x0123,
				TYPE_FUNC_NEGBINOMDIST = 0x0124,
				TYPE_FUNC_NORMDIST = 0x0125,
				TYPE_FUNC_NORMSDIST = 0x0126,
				TYPE_FUNC_NORMINV = 0x0127,
				TYPE_FUNC_NORMSINV = 0x0128,
				TYPE_FUNC_STANDARDIZE = 0x0129,
				TYPE_FUNC_ODD = 0x012A,
				TYPE_FUNC_PERMUT = 0x012B,
				TYPE_FUNC_POISSON = 0x012C,
				TYPE_FUNC_TDIST = 0x012D,
				TYPE_FUNC_WEIBULL = 0x012E,
				TYPE_FUNC_SUMXMY2 = 0x012F,
				TYPE_FUNC_SUMX2MY2 = 0x0130,
				TYPE_FUNC_SUMX2PY2 = 0x0131,
				TYPE_FUNC_CHITEST = 0x0132,
				TYPE_FUNC_CORREL = 0x0133,
				TYPE_FUNC_COVAR = 0x0134,
				TYPE_FUNC_FORECAST = 0x0135,
				TYPE_FUNC_FTEST = 0x0136,
				TYPE_FUNC_INTERCEPT = 0x0137,
				TYPE_FUNC_PEARSON = 0x0138,
				TYPE_FUNC_RSQ = 0x0139,
				TYPE_FUNC_STEYX = 0x013A,
				TYPE_FUNC_SLOPE = 0x013B,
				TYPE_FUNC_TTEST = 0x013C,
				TYPE_FUNC_PROB = 0x013D,
				TYPE_FUNC_DEVSQ = 0x013E,
				TYPE_FUNC_GEOMEAN = 0x013F,
				TYPE_FUNC_HARMEAN = 0x0140,
				TYPE_FUNC_SUMSQ = 0x0141,
				TYPE_FUNC_KURT = 0x0142,
				TYPE_FUNC_SKEW = 0x0143,
				TYPE_FUNC_ZTEST = 0x0144,
				TYPE_FUNC_LARGE = 0x0145,
				TYPE_FUNC_SMALL = 0x0146,
				TYPE_FUNC_QUARTILE = 0x0147,
				TYPE_FUNC_PERCENTILE = 0x0148,
				TYPE_FUNC_PERCENTRANK = 0x0149,
				TYPE_FUNC_MODE = 0x014A,
				TYPE_FUNC_TRIMMEAN = 0x014B,
				TYPE_FUNC_TINV = 0x014C,
				TYPE_FUNC_MOVIE_COMMAND = 0x014E,
				TYPE_FUNC_GET_MOVIE = 0x014F,
				TYPE_FUNC_CONCATENATE = 0x0150,
				TYPE_FUNC_POWER = 0x0151,
				TYPE_FUNC_PIVOT_ADD_DATA = 0x0152,
				TYPE_FUNC_GET_PIVOT_TABLE = 0x0153,
				TYPE_FUNC_GET_PIVOT_FIELD = 0x0154,
				TYPE_FUNC_GET_PIVOT_ITEM = 0x0155,
				TYPE_FUNC_RADIANS = 0x0156,
				TYPE_FUNC_DEGREES = 0x0157,
				TYPE_FUNC_SUBTOTAL = 0x0158,
				TYPE_FUNC_SUMIF = 0x0159,
				TYPE_FUNC_COUNTIF = 0x015A,
				TYPE_FUNC_COUNTBLANK = 0x015B,
				TYPE_FUNC_SCENARIO_GET = 0x015C,
				TYPE_FUNC_OPTIONS_LISTS_GET = 0x015D,
				TYPE_FUNC_ISPMT = 0x015E,
				TYPE_FUNC_DATEDIF = 0x015F,
				TYPE_FUNC_DATESTRING = 0x0160,
				TYPE_FUNC_NUMBERSTRING = 0x0161,
				TYPE_FUNC_ROMAN = 0x0162,
				TYPE_FUNC_OPEN_DIALOG = 0x0163,
				TYPE_FUNC_SAVE_DIALOG = 0x0164,
				TYPE_FUNC_VIEW_GET = 0x0165,
				TYPE_FUNC_GETPIVOTDATA = 0x0166,
				TYPE_FUNC_HYPERLINK = 0x0167,
				TYPE_FUNC_PHONETIC = 0x0168,
				TYPE_FUNC_AVERAGEA = 0x0169,
				TYPE_FUNC_MAXA = 0x016A,
				TYPE_FUNC_MINA = 0x016B,
				TYPE_FUNC_STDEVPA = 0x016C,
				TYPE_FUNC_VARPA = 0x016D,
				TYPE_FUNC_STDEVA = 0x016E,
				TYPE_FUNC_VARA = 0x016F,
				TYPE_FUNC_BAHTTEXT = 0x0170,
				TYPE_FUNC_THAIDAYOFWEEK = 0x0171,
				TYPE_FUNC_THAIDIGIT = 0x0172,
				TYPE_FUNC_THAIMONTHOFYEAR = 0x0173,
				TYPE_FUNC_THAINUMSOUND = 0x0174,
				TYPE_FUNC_THAINUMSTRING = 0x0175,
				TYPE_FUNC_THAISTRINGLENGTH = 0x0176,
				TYPE_FUNC_ISTHAIDIGIT = 0x0177,
				TYPE_FUNC_ROUNDBAHTDOWN = 0x0178,
				TYPE_FUNC_ROUNDBAHTUP = 0x0179,
				TYPE_FUNC_THAIYEAR = 0x017A,
				TYPE_FUNC_RTD = 0x017B,
				TYPE_BOOL,
				TYPE_INT,
				TYPE_NUMBER,
				TYPE_SPACE,
				TYPE_MISS_ARG,
				TYPE_STRING,
				TYPE_COORDINATE,
				TYPE_COORDINATE_3D,
				TYPE_AREA,
				TYPE_AREA_3D,
				TYPE_OPERATOR,
				TYPE_PAREN,
			};

			public: enum SubType
			{
				SUB_TYPE_FUNCTION,
				SUB_TYPE_OPERATOR,
				SUB_TYPE_VARIABLE,
			};

			protected: Type m_eType;
			protected: SubType m_eSubType;
			protected: unsigned char m_nParameterCount;
			public: Token(Type eType, SubType eSubType, unsigned char nParameterCount);
			public: virtual ~Token();
			public: Token::Type GetType() const;
			public: Token::SubType GetSubType();
			public: unsigned char GetParameterCount();
			public: virtual void ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut);
			public: virtual ParsedExpressionRecord* ToParsedExpression(WorkbookGlobals* pWorkbookGlobals);
			public: virtual bool Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth);
			public: virtual void InsertColumn(unsigned short nWorksheet, unsigned short nColumn);
			public: virtual void DeleteColumn(unsigned short nWorksheet, unsigned short nColumn);
			public: virtual void InsertRow(unsigned short nWorksheet, unsigned short nRow);
			public: virtual void DeleteRow(unsigned short nWorksheet, unsigned short nRow);
			public: static const char* GetTypeName(Type eType);
		};
		class SumToken : public Token
		{
			public: SumToken(unsigned char nParameterCount);
			public: virtual void ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut);
			public: virtual ParsedExpressionRecord* ToParsedExpression(WorkbookGlobals* pWorkbookGlobals);
			public: virtual bool Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth);
		};
		class StringToken : public Token
		{
			protected: InternalString* m_sString;
			public: StringToken(const char* sxString);
			public: virtual void ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut);
			public: virtual ParsedExpressionRecord* ToParsedExpression(WorkbookGlobals* pWorkbookGlobals);
			public: virtual bool Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth);
			public: virtual ~StringToken();
		};
		class SpaceToken : public Token
		{
			public: enum SpaceType
			{
				TYPE_SPACE_BEFORE_BASE_EXPRESSION = 0x00,
				TYPE_RETURN_BEFORE_BASE_EXPRESSION = 0x01,
				TYPE_SPACE_BEFORE_OPEN = 0x02,
				TYPE_RETURN_BEFORE_OPEN = 0x03,
				TYPE_SPACE_BEFORE_CLOSE = 0x04,
				TYPE_RETURN_BEFORE_CLOSE = 0x05,
				TYPE_SPACE_BEFORE_EXPRESSION = 0x06,
			};

			protected: SpaceType m_eSpaceType;
			protected: unsigned char m_nCount;
			public: SpaceToken(SpaceType eSpaceType, unsigned char nCount);
			public: virtual void ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut);
			public: virtual ParsedExpressionRecord* ToParsedExpression(WorkbookGlobals* pWorkbookGlobals);
			public: SpaceToken::SpaceType GetSpaceType();
			public: virtual bool Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth);
		};
		class OperatorToken : public Token
		{
			protected: InternalString* m_sOperator;
			public: OperatorToken(const char* szOperator);
			public: virtual void ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut);
			public: virtual ParsedExpressionRecord* ToParsedExpression(WorkbookGlobals* pWorkbookGlobals);
			public: virtual bool Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth);
			public: virtual ~OperatorToken();
		};
		class NumToken : public Token
		{
			protected: double m_fNumber;
			public: NumToken(double fNumber);
			public: virtual void ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut);
			public: virtual ParsedExpressionRecord* ToParsedExpression(WorkbookGlobals* pWorkbookGlobals);
			public: virtual bool Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth);
		};
		class MissArgToken : public Token
		{
			public: MissArgToken();
			public: virtual void ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut);
			public: virtual ParsedExpressionRecord* ToParsedExpression(WorkbookGlobals* pWorkbookGlobals);
			public: virtual bool Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth);
		};
		class IntToken : public Token
		{
			protected: unsigned short m_nInt;
			public: IntToken(unsigned short nInt);
			public: virtual void ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut);
			public: virtual ParsedExpressionRecord* ToParsedExpression(WorkbookGlobals* pWorkbookGlobals);
			public: virtual bool Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth);
		};
		class ParseFunctionData
		{
			public: int m_nCount;
			public: ParseFunctionData();
		};
		class ParseSpaceData
		{
			public: int m_nIndex;
			public: unsigned short m_cChar;
			public: int m_nCount;
			public: ParseSpaceData();
		};
		class Formula
		{
			protected: OwnedVector<Token*>* m_pTokenVector;
			protected: Value* m_pValue;
			protected: InternalString* m_sTemp;
			public: Formula(const char* szFormula, WorksheetImplementation* pWorksheetImplementation);
			public: Formula(Vector<ParsedExpressionRecord*>* pParsedExpressionRecordVector, WorkbookGlobals* pWorkbookGlobals);
			public: Formula(OwnedVector<ParsedExpressionRecord*>* pParsedExpressionRecordVector, WorkbookGlobals* pWorkbookGlobals);
			public: unsigned short GetNumToken();
			public: const Token* GetTokenByIndex(unsigned short nIndex);
			public: const Value* Evaluate(WorksheetImplementation* pWorksheetImplementation, unsigned short nDepth);
			public: const char* ToString(WorksheetImplementation* pWorksheetImplementation);
			public: void ToRgce(RgceStruct* pRgce, WorkbookGlobals* pWorkbookGlobals);
			public: void InsertColumn(unsigned short nWorksheet, unsigned short nColumn);
			public: void DeleteColumn(unsigned short nWorksheet, unsigned short nColumn);
			public: void InsertRow(unsigned short nWorksheet, unsigned short nRow);
			public: void DeleteRow(unsigned short nWorksheet, unsigned short nRow);
			public: bool ValidateForChart(WorksheetImplementation* pWorksheetImplementation);
			public: const char* ToChartString(WorksheetImplementation* pWorksheetImplementation);
			public: bool ValidateForChartName(WorksheetImplementation* pWorksheetImplementation);
			public: const char* ToChartNameString(WorksheetImplementation* pWorksheetImplementation);
			protected: unsigned char Parse(InternalString* sFormula, WorksheetImplementation* pWorksheetImplementation);
			protected: bool ParseFunction(InternalString* sFormula, const char* szFunction, ParseFunctionData* pData, WorksheetImplementation* pWorksheetImplementation);
			protected: bool ParseSpace(InternalString* sFormula, ParseSpaceData* pData);
			protected: bool ParseString(InternalString* sFormula);
			protected: bool ParseBool(InternalString* sFormula, WorksheetImplementation* pWorksheetImplementation);
			protected: bool ParseInt(InternalString* sFormula);
			protected: bool ParseFloat(InternalString* sFormula);
			protected: void InsertOperator(InternalString* sOperator, InternalString* sTrailingSpaces);
			public: virtual ~Formula();
		};
		class CoordinateToken : public Token
		{
			protected: Coordinate* m_pCoordinate;
			public: CoordinateToken(Coordinate* pCoordinate);
			public: Coordinate* GetCoordinate();
			public: virtual void ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut);
			public: virtual ParsedExpressionRecord* ToParsedExpression(WorkbookGlobals* pWorkbookGlobals);
			public: virtual bool Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth);
			public: virtual ~CoordinateToken();
		};
		class Coordinate3dToken : public Token
		{
			protected: Coordinate3d* m_pCoordinate3d;
			public: Coordinate3dToken(Coordinate3d* pCoordinate3d);
			public: Coordinate3d* GetCoordinate3d();
			public: virtual void ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut);
			public: virtual ParsedExpressionRecord* ToParsedExpression(WorkbookGlobals* pWorkbookGlobals);
			public: virtual bool Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth);
			public: virtual void InsertColumn(unsigned short nWorksheet, unsigned short nColumn);
			public: virtual void DeleteColumn(unsigned short nWorksheet, unsigned short nColumn);
			public: virtual void InsertRow(unsigned short nWorksheet, unsigned short nRow);
			public: virtual void DeleteRow(unsigned short nWorksheet, unsigned short nRow);
			public: virtual ~Coordinate3dToken();
		};
		class BoolToken : public Token
		{
			protected: bool m_bBool;
			public: BoolToken(bool bBool, bool bFunction);
			public: virtual void ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut);
			public: virtual ParsedExpressionRecord* ToParsedExpression(WorkbookGlobals* pWorkbookGlobals);
			public: virtual bool Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth);
		};
		class AreaToken : public Token
		{
			protected: Area* m_pArea;
			public: AreaToken(Area* pArea);
			public: Area* GetArea();
			public: virtual void ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut);
			public: virtual ParsedExpressionRecord* ToParsedExpression(WorkbookGlobals* pWorkbookGlobals);
			public: virtual bool Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth);
			public: virtual ~AreaToken();
		};
		class Area3dToken : public Token
		{
			protected: Area3d* m_pArea3d;
			public: Area3dToken(Area3d* pArea3d);
			public: Area3d* GetArea3d();
			public: virtual void ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut);
			public: virtual ParsedExpressionRecord* ToParsedExpression(WorkbookGlobals* pWorkbookGlobals);
			public: virtual bool Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth);
			public: virtual void InsertColumn(unsigned short nWorksheet, unsigned short nColumn);
			public: virtual void DeleteColumn(unsigned short nWorksheet, unsigned short nColumn);
			public: virtual void InsertRow(unsigned short nWorksheet, unsigned short nRow);
			public: virtual void DeleteRow(unsigned short nWorksheet, unsigned short nRow);
			public: virtual ~Area3dToken();
		};
		class RedBlackNode
		{
			public: enum NodeColor
			{
				COLOR_RED = 0,
				COLOR_BLACK,
			};

			public: virtual RedBlackNode::NodeColor GetColor() const;
			public: virtual RedBlackNode* GetParent() const;
			public: virtual RedBlackNode* GetLeftChild() const;
			public: virtual RedBlackNode* GetRightChild() const;
			public: virtual RedBlackNode* GetChild(int nDirection) const;
			public: virtual void* GetStoredObject() const;
		};
		class RedBlackNodeImplementation : public RedBlackNode
		{
			public: NodeColor m_eColor;
			public: RedBlackNodeImplementation* m_pParent;
			public: RedBlackNodeImplementation* m_pChild[2];
			public: void* m_pObject;
			public: RedBlackNodeImplementation(void* pObject);
			public: RedBlackNodeImplementation* GetUncle() const;
			public: RedBlackNodeImplementation* GetGrandparent() const;
			public: virtual RedBlackNode::NodeColor GetColor() const;
			public: virtual RedBlackNode* GetParent() const;
			public: virtual RedBlackNode* GetLeftChild() const;
			public: virtual RedBlackNode* GetRightChild() const;
			public: virtual RedBlackNode* GetChild(int nDirection) const;
			public: virtual void* GetStoredObject() const;
			public: virtual ~RedBlackNodeImplementation();
		};
		class RedBlackTree
		{
			public: typedef int (ComparisonCallback)(const void* pObjectA, const void* pObjectB);
			protected: RedBlackTreeImplementation* m_pImpl;
			public: RedBlackTree(ComparisonCallback* pComparisonCallback);
			public: virtual ~RedBlackTree();
			public: bool AddObject(void* pObject);
			public: bool DeleteObject(void* pObject);
			public: RedBlackNode* GetRootNode();
			public: RedBlackNode* GetNode(void* pObject);
		};
		class RedBlackTreeImplementation
		{
			public: RedBlackNodeImplementation* m_pRootNode;
			public: RedBlackTree::ComparisonCallback* m_pComparisonCallback;
			public: void RecursiveDelete(RedBlackNodeImplementation* pNode);
			public: void Rotate(RedBlackNodeImplementation* pNode, int nDirection);
			public: RedBlackTreeImplementation();
			public: virtual ~RedBlackTreeImplementation();
		};
		template <class T>
		class TableElement
		{
			public: int m_nColumn;
			public: int m_nRow;
			public: T m_xObject;
			public: virtual ~TableElement()
			{
				if (m_xObject != 0)
					{
						delete m_xObject;
						m_xObject = 0;
					}
			}

			public: TableElement()
			{
				m_nColumn = 0;
				m_nRow = 0;
				m_xObject = 0;
			}

		};
		template <class T>
		class Table
		{
			protected: OwnedVector<TableElement<T>*>* m_pElementVector;
			public: Table()
			{
				m_pElementVector = 0;
				m_pElementVector = new OwnedVector<TableElement<T>*>();
			}

			public: void Set(int nColumn, int nRow, T xObject)
			{
				TableElement<T>* pElement = GetOrCreate(nColumn, nRow);
				pElement->m_xObject = xObject;
			}

			public: int GetIndex(int nColumn, int nRow)
			{
				int i = 0;
				while (true)
				{
					if (i >= m_pElementVector->GetSize())
						return i;
					TableElement<T>* pElement = m_pElementVector->Get(i);
					if (pElement->m_nRow > nRow)
						return i;
					if (pElement->m_nRow == nRow)
						if (pElement->m_nColumn >= nColumn)
							return i;
					i++;
				}
			}

			public: TableElement<T>* Get(int nColumn, int nRow)
			{
				int nIndex = GetIndex(nColumn, nRow);
				TableElement<T>* pElement = GetByIndex(nIndex);
				if (pElement == 0 || pElement->m_nColumn != nColumn || pElement->m_nRow != nRow)
					return 0;
				return pElement;
			}

			public: TableElement<T>* GetByIndex(int nIndex)
			{
				if (nIndex >= m_pElementVector->GetSize())
					return 0;
				return m_pElementVector->Get(nIndex);
			}

			public: TableElement<T>* GetOrCreate(int nColumn, int nRow)
			{
				int nIndex = GetIndex(nColumn, nRow);
				TableElement<T>* pElement = GetByIndex(nIndex);
				if (pElement == 0 || pElement->m_nColumn != nColumn || pElement->m_nRow != nRow)
				{
					TableElement<T>* pOwnedElement = new TableElement<T>();
					pOwnedElement->m_nColumn = nColumn;
					pOwnedElement->m_nRow = nRow;
					pOwnedElement->m_xObject = 0;
					pElement = pOwnedElement;
					{
						NumberDuck::Secret::TableElement<T>* __828927520 = pOwnedElement;
						pOwnedElement = 0;
						m_pElementVector->Insert(nIndex, __828927520);
					}
					if (pOwnedElement) delete pOwnedElement;
				}
				return pElement;
			}

			public: void Erase(int nIndex)
			{
				m_pElementVector->Erase(nIndex);
			}

			public: T PopBack()
			{
				TableElement<T>* pElement = m_pElementVector->PopBack();
				T xObject;
				{
					T __3920382863 = pElement->m_xObject;
					pElement->m_xObject = 0;
					xObject = __3920382863;
				}
				{
					delete pElement;
					pElement = 0;
				}
				{
					T __1841677085 = xObject;
					xObject = 0;
					{
						if (pElement) delete pElement;
						return __1841677085;
					}
				}
			}

			public: int GetSize()
			{
				return m_pElementVector->GetSize();
			}

			public: virtual ~Table()
			{
				if (m_pElementVector) delete m_pElementVector;
			}

		};
		class PngImageInfo
		{
			public: int m_nWidth;
			public: int m_nHeight;
			public: PngImageInfo();
		};
		class PngLoader
		{
			protected: PngImageInfo* m_pImageInfo;
			public: PngImageInfo* Load(Blob* pBlob);
			public: PngLoader();
			public: virtual ~PngLoader();
		};
		class JpegImageInfo
		{
			public: int m_nWidth;
			public: int m_nHeight;
			public: JpegImageInfo();
		};
		class JpegLoader
		{
			protected: JpegImageInfo* m_pImageInfo;
			public: JpegImageInfo* Load(Blob* pBlob);
			public: JpegLoader();
			public: virtual ~JpegLoader();
		};
		class XlsxWorksheet : public Worksheet
		{
			public: XlsxWorksheet(Workbook* pWorkbook);
			public: bool Parse(XlsxWorkbookGlobals* pWorkbookGlobals, XmlNode* pWorksheetNode);
		};
		class XlsxWorkbookGlobals : public WorkbookGlobals
		{
			public: static bool LoadVector(Vector<XmlNode*>* pVector, XmlNode* pStyleSheetNode, const char* szParent, const char* szChild);
			public: static XmlNode* GetElement(Vector<XmlNode*>* pVector, int nIndex);
			public: static unsigned int ParseColor(XmlNode* pColorNode);
			public: static bool ApplyFont(XmlNode* pFontNode, Style* pStyle);
			public: static bool ApplyBorderLine(XmlNode* pSideElement, Line* pLine);
			public: static bool ApplyBorder(XmlNode* pBorderElement, Style* pStyle);
			public: static bool ApplyFill(XmlNode* pFillElement, Style* pStyle);
			public: static bool ParseStyles(WorkbookGlobals* pWorkbookGlobals, XmlNode* pStyleSheetNode);
			public: static bool SubParseStyles(WorkbookGlobals* pWorkbookGlobals, XmlNode* pStyleSheetNode, Vector<XmlNode*>* pNumFmtVector, Vector<XmlNode*>* pFontVector, Vector<XmlNode*>* pFillVector, Vector<XmlNode*>* pBorderVector, Vector<XmlNode*>* pCellStyleXfVector, Vector<XmlNode*>* pCellXfVector, Vector<XmlNode*>* pCellStyleVector);
		};
		class ColumnInfo
		{
			public: unsigned short m_nWidth;
			public: bool m_bHidden;
			public: ColumnInfo();
		};
		class RowInfo
		{
			public: unsigned short m_nHeight;
			public: RowInfo();
		};
		class Coordinate
		{
			public: Coordinate();
			public: Coordinate(unsigned short nX, unsigned short nY, bool bXRelative = true, bool bYRelative = true);
			public: Coordinate* CreateClone();
			public: unsigned short m_nX;
			public: unsigned short m_nY;
			public: bool m_bXRelative;
			public: bool m_bYRelative;
		};
		class WorksheetRange
		{
			public: WorksheetRange(unsigned short nFirst, unsigned short nLast);
			public: WorksheetRange* CreateClone();
			public: unsigned short m_nFirst;
			public: unsigned short m_nLast;
		};
		class Coordinate3d
		{
			public: unsigned short m_nWorksheetFirst;
			public: unsigned short m_nWorksheetLast;
			public: Coordinate* m_pCoordinate;
			public: Coordinate3d(unsigned short nWorksheetFirst, unsigned short nWorksheetLast, Coordinate* pCoordinate);
			public: Coordinate3d* CreateClone();
			public: void ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut);
			public: virtual ~Coordinate3d();
		};
		class Area
		{
			public: Coordinate* m_pTopLeft;
			public: Coordinate* m_pBottomRight;
			public: Area(Coordinate* pTopLeft, Coordinate* pBottomRight);
			public: Area* CreateClone();
			public: virtual ~Area();
		};
		class Area3d
		{
			public: WorksheetRange* m_pWorksheetRange;
			public: Area* m_pArea;
			public: Area3d(unsigned short nWorksheetFirst, unsigned short nWorksheetLast, Area* pArea);
			public: Area3d* CreateClone();
			public: virtual ~Area3d();
		};
		class WorksheetImplementation
		{
			public: Workbook* m_pWorkbook;
			public: InternalString* m_sName;
			public: Worksheet::Orientation m_eOrientation;
			public: bool m_bShowGridlines;
			public: bool m_bPrintGridlines;
			public: Table<Cell*>* m_pCellTable;
			public: Table<ColumnInfo*>* m_pColumnInfoTable;
			public: Table<RowInfo*>* m_pRowInfoTable;
			public: unsigned short m_nDefaultRowHeight;
			public: OwnedVector<Picture*>* m_pPictureVector;
			public: OwnedVector<Chart*>* m_pChartVector;
			public: OwnedVector<MergedCell*>* m_pMergedCellVector;
			public: Worksheet* m_pWorksheet;
			public: WorksheetImplementation(Workbook* pWorkbook, Worksheet* pWorksheet);
			public: virtual ~WorksheetImplementation();
			public: static unsigned short TwipsToPixels(unsigned short nTwips);
			public: static unsigned short PixelsToTwips(unsigned short nPixels);
			public: static void CoordinateToAddress(Coordinate* pCoordinate, InternalString* sOut);
			public: static void AreaToAddress(Area* pArea, InternalString* sOut);
			public: static Coordinate* AddressToCoordinate(const char* szAddress);
			public: static Area* AddressToArea(const char* szAddress);
			public: void WorksheetRangeToAddress(unsigned short nFirst, unsigned short nLast, InternalString* sOut);
			public: void Area3dToAddress(Area3d* pArea3d, InternalString* sOut);
			public: WorksheetRange* ParseWorksheetRange(InternalString* sString);
			public: Coordinate3d* ParseCoordinate3d(InternalString* sString);
			public: Area3d* ParseArea3d(InternalString* sString);
			public: ColumnInfo* GetColumnInfo(unsigned short nColumn);
			public: ColumnInfo* GetOrCreateColumnInfo(unsigned short nColumn);
			public: RowInfo* GetRowInfo(unsigned short nRow);
			public: RowInfo* GetOrCreateRowInfo(unsigned short nRow);
			public: Workbook* GetWorkbook();
		};
		class WorkbookImplementation
		{
			public: WorkbookGlobals* m_pWorkbookGlobals;
			public: OwnedVector<Worksheet*>* m_pWorksheetVector;
			public: virtual ~WorkbookImplementation();
			public: WorkbookImplementation();
		};
		class ValueImplementation
		{
			public: Value::Type m_eType;
			public: InternalString* m_sString;
			public: double m_fFloat;
			public: bool m_bBoolean;
			public: Formula* m_pFormula;
			public: Worksheet* m_pWorksheet;
			public: Area* m_pArea;
			public: Area3d* m_pArea3d;
			public: Value* m_pValue;
			public: ValueImplementation();
			public: static Value* CreateFloatValue(double fFloat);
			public: static Value* CreateStringValue(const char* szString);
			public: static Value* CreateBooleanValue(const bool bBoolean);
			public: static Value* CreateErrorValue();
			public: static Value* CreateAreaValue(Area* pArea);
			public: static Value* CreateArea3dValue(Area3d* pArea3d);
			public: static Value* CopyValue(const Value* pValue);
			public: void Clear();
			public: void SetString(const char* szString);
			public: void SetFloat(double fFloat);
			public: void SetBoolean(bool bBoolean);
			public: void SetFormulaFromString(const char* szFormula, Worksheet* pWorksheet);
			public: void SetFormula(Formula* pFormula, Worksheet* pWorksheet);
			public: virtual ~ValueImplementation();
		};
		class StyleImplementation
		{
			public: Font* m_pFont;
			public: Style::HorizontalAlign m_eHorizontalAlign;
			public: Style::VerticalAlign m_eVerticalAlign;
			public: Color* m_pBackgroundColor;
			public: Style::FillPattern m_eFillPattern;
			public: Color* m_pFillPatternColor;
			public: Line* m_pTopBorderLine;
			public: Line* m_pRightBorderLine;
			public: Line* m_pBottomBorderLine;
			public: Line* m_pLeftBorderLine;
			public: InternalString* m_sFormat;
			public: unsigned int m_nFormatIndex;
			public: StyleImplementation();
			public: virtual ~StyleImplementation();
		};
		class SharedString
		{
			public: InternalString* m_sString;
			public: int m_nChecksum;
			public: int m_nIndex;
			public: SharedString();
			public: virtual ~SharedString();
		};
		class SharedStringContainer
		{
			protected: OwnedVector<SharedString*>* m_pSharedStringVector;
			protected: Vector<SharedString*>* m_pSharedStringSortedVector;
			public: SharedStringContainer();
			public: virtual ~SharedStringContainer();
			public: void Clear();
			public: const char* Get(int nIndex);
			public: int GetIndex(const char* sxString);
			public: int Push(const char* sxString);
			public: int GetSize();
		};
		class SeriesImplementation
		{
			public: Worksheet* m_pWorksheet;
			public: Formula* m_pNameFormula;
			public: Formula* m_pValuesFormula;
			public: Line* m_pLine;
			public: Fill* m_pFill;
			public: Marker* m_pMarker;
			public: SeriesImplementation(Worksheet* pWorksheet, Formula* pValuesFormula);
			public: void SetNameFormula(Formula* pFormula);
			public: void SetValuesFormula(Formula* pFormula);
			public: void SetClassicStyle(Chart::Type eChartType, unsigned short nIndex);
			public: virtual ~SeriesImplementation();
		};
		class PictureImplementation
		{
			public: unsigned int m_nX;
			public: unsigned int m_nY;
			public: unsigned int m_nSubX;
			public: unsigned int m_nSubY;
			public: unsigned int m_nWidth;
			public: unsigned int m_nHeight;
			public: InternalString* m_sUrl;
			public: Blob* m_pBlob;
			public: Picture::Format m_eFormat;
			public: PictureImplementation(Blob* pBlob, Picture::Format eFormat);
			public: virtual ~PictureImplementation();
		};
		class MergedCellImplementation
		{
			public: unsigned int m_nX;
			public: unsigned int m_nY;
			public: unsigned int m_nWidth;
			public: unsigned int m_nHeight;
			public: MergedCellImplementation();
		};
		class MarkerImplementation
		{
			public: Marker::Type m_eType;
			public: Color* m_pFillColor;
			public: Color* m_pBorderColor;
			public: int m_nSize;
			public: MarkerImplementation();
			public: bool Equals(const MarkerImplementation* pMarkerImplementation) const;
			public: Marker::Type GetType() const;
			public: void SetType(Marker::Type eType);
			public: Color* GetFillColor(bool bCreateIfMissing);
			public: void SetFillColor(const Color* pColor);
			public: void ClearFillColor();
			public: Color* GetBorderColor(bool bCreateIfMissing);
			public: void SetBorderColor(const Color* pColor);
			public: void ClearBorderColor();
			public: int GetSize() const;
			public: void SetSize(int nSize);
			public: virtual ~MarkerImplementation();
		};
		class LineImplementation
		{
			public: Line::Type m_eType;
			public: Color* m_pColor;
			public: LineImplementation();
			public: bool Equals(const LineImplementation* pLineImplementation) const;
			public: Line::Type GetType() const;
			public: void SetType(Line::Type eType);
			public: virtual ~LineImplementation();
		};
		class LegendImplementation
		{
			public: bool m_bHidden;
			public: Line* m_pBorderLine;
			public: Fill* m_pFill;
			public: LegendImplementation();
			public: virtual ~LegendImplementation();
		};
		class FontImplementation
		{
			public: InternalString* m_sName;
			public: int m_nSizeTwips;
			public: Color* m_pColor;
			public: bool m_bBold;
			public: bool m_bItalic;
			public: Font::Underline m_eUnderline;
			public: FontImplementation();
			public: virtual ~FontImplementation();
		};
		class FillImplementation
		{
			public: Fill::Type m_eType;
			public: Color* m_pForegroundColor;
			public: Color* m_pBackgroundColor;
			public: FillImplementation();
			public: bool Equals(const FillImplementation* pFillImplementation) const;
			public: Fill::Type GetType() const;
			public: void SetType(Fill::Type eType);
			public: virtual ~FillImplementation();
		};
		class ChartImplementation
		{
			public: Worksheet* m_pWorksheet;
			public: unsigned int m_nX;
			public: unsigned int m_nY;
			public: unsigned int m_nSubX;
			public: unsigned int m_nSubY;
			public: unsigned int m_nWidth;
			public: unsigned int m_nHeight;
			public: Chart::Type m_eType;
			public: Formula* m_pCategoriesFormula;
			public: InternalString* m_sTitle;
			public: InternalString* m_sHorizontalAxisLabel;
			public: InternalString* m_sVerticalAxisLabel;
			public: Legend* m_pLegend;
			public: Line* m_pFrameBorderLine;
			public: Fill* m_pFrameFill;
			public: Line* m_pPlotBorderLine;
			public: Fill* m_pPlotFill;
			public: Line* m_pHorizontalAxisLine;
			public: Line* m_pHorizontalGridLine;
			public: Line* m_pVerticalAxisLine;
			public: Line* m_pVerticalGridLine;
			public: OwnedVector<Series*>* m_pSeriesVector;
			public: ChartImplementation(Worksheet* pWorksheet, Chart::Type eType);
			public: Series* CreateSeries(Formula* pValuesFormula);
			public: void PurgeSeries(int nIndex);
			public: void SetCategoriesFormula(Formula* pCategoriesFormula);
			public: void SetClassicStyle();
			public: void InsertColumn(unsigned short nWorksheet, unsigned short nColumn);
			public: void DeleteColumn(unsigned short nWorksheet, unsigned short nColumn);
			public: void InsertRow(unsigned short nWorksheet, unsigned short nRow);
			public: void DeleteRow(unsigned short nWorksheet, unsigned short nRow);
			public: virtual ~ChartImplementation();
		};
		class CellImplementation
		{
			public: Worksheet* m_pWorksheet;
			public: Value* m_pValue;
			public: Style* m_pStyle;
			public: Workbook* GetWorkbook();
			public: void SetFormula(Formula* pFormula);
			public: CellImplementation();
			public: virtual ~CellImplementation();
		};
		template <class T>
		class OwnedVector
		{
			protected: Vector<T>* m_pVector;
			public: OwnedVector()
			{
				m_pVector = 0;
				m_pVector = new Vector<T>();
			}

			public: virtual ~OwnedVector()
			{
				Clear();
				if (m_pVector) delete m_pVector;
			}

			public: T PushBack(T xObject)
			{
				m_pVector->PushBack(xObject);
				return m_pVector->Get(m_pVector->GetSize() - 1);
			}

			public: int GetSize()
			{
				return m_pVector->GetSize();
			}

			public: T Get(int nIndex)
			{
				return m_pVector->Get(nIndex);
			}

			public: void Clear()
			{
				while (m_pVector->GetSize() > 0)
				{
					T pTemp = m_pVector->PopBack();
					{
						delete pTemp;
						pTemp = 0;
					}
				}
			}

			public: void Insert(int nIndex, T pObject)
			{
				m_pVector->Insert(nIndex, pObject);
			}

			public: T Remove(int nIndex)
			{
				T pTemp = m_pVector->Get(nIndex);
				m_pVector->Erase(nIndex);
				return pTemp;
			}

			public: void Erase(int nIndex)
			{
				{
					delete m_pVector->Get(nIndex);
				}
				m_pVector->Erase(nIndex);
			}

			public: T PopBack()
			{
				return m_pVector->PopBack();
			}

			public: T PopFront()
			{
				return m_pVector->PopFront();
			}

		};
	}
}



#include <vector>

namespace NumberDuck
{
	namespace Secret
	{
		template <class T>
		class Vector
		{
			public:
				Vector() {
					m_pVector = new std::vector<T>();
				}

				~Vector()
				{
					delete m_pVector;
				}

				void PushFront(T xObject)
				{
					m_pVector->insert(m_pVector->begin(), xObject);
				}

				void PushBack(T xObject)
				{
					m_pVector->push_back(xObject);
				}

				T PopBack()
				{
					T xBack = m_pVector->back();
					m_pVector->pop_back();
					return xBack;
				}

				T PopFront()
				{
					T xFront = (*m_pVector)[0];
					m_pVector->erase(m_pVector->begin());
					return xFront;
				}

				int GetSize()
				{
					return (int)m_pVector->size();
				}

				T Get(int nIndex)
				{
					return (*m_pVector)[nIndex];
				}

				void Set(int nIndex, T xObject)
				{
					(*m_pVector)[nIndex] = xObject;
				}

				void Insert(int nIndex, T xObject)
				{
					m_pVector->insert(m_pVector->begin() + nIndex, xObject);
				}

				void Clear()
				{
					m_pVector->clear();
				}

				void Erase(int nIndex)
				{
					m_pVector->erase(m_pVector->begin() + nIndex);
				}

			protected:
				std::vector<T>* m_pVector;		
		};
	}
}



namespace NumberDuck
{
	namespace Secret
	{
		class nbAssert
		{
			public: static void Assert(bool bTest, const char* sxAssert, const char* sxFile, int nLine);
			public: static void Assert(bool bTest);
		};
	}
}

#ifndef CLIFFY_ASSERT
	#define CLIFFY_ASSERT(x) NumberDuck::Secret::nbAssert::Assert(!!(x), #x, __FILE__, __LINE__)
#endif



namespace NumberDuck
{
	namespace Secret
	{
		class Console
		{
			public: static void Log(const char* sxPath);
		};
	}
}



namespace NumberDuck
{
	namespace Secret
	{
		class ExternalString
		{
			public:
				static bool Equal(const char* szA, const char* szB);
				static int GetChecksum(const char* szString);
				static long hextol(const char* szString);

				static int atoi(const char* szString);

				static double atof(const char* szString);
				static long atol(const char* szString);
		};
	}
}



#include <cstddef>
#include <string.h>	// for NULL

namespace NumberDuck
{
	class BlobView;

	namespace Secret
	{
		class InternalString
		{
			public:
				InternalString(const char* szString);
				~InternalString();

				InternalString* CreateClone();

				void Set(const char* szString);
				const char* GetExternalString() const;

				void Append(const char* szString);
				void AppendChar(unsigned short nChar);
				void AppendString(const char* szString);
				void AppendStringData(unsigned char* pData, int nLength);

				void AppendInt(int nInt);
				void AppendUnsignedInt(unsigned int nUint32);
				void AppendUint32(unsigned int nUint32);
				void AppendDouble(double fDouble);

				void PrependChar(unsigned short nChar);
				void PrependString(const char* szString);

				void SubStr(int nStart, int nLength);
				void CropFront(int nLength);

				//void CropBack(int nLength);

				int GetLength();
				unsigned short GetChar(int nIndex);

				void BlobWriteUtf8(BlobView* pBlobView, bool bZeroTerminator);
				void BlobWrite16Bit(BlobView* pBlobView, bool bZeroTerminator);

				bool IsAscii();

				bool IsEqual(const char* szCompare);
				bool StartsWith(const char* szString);
				bool EndsWith(const char* szString);

				double ParseDouble();
				unsigned int ParseHex();

				int FindChar(unsigned short nChar);

				void Replace(const char* sxFind, const char* sxReplace);

			protected:
				char* m_szBuffer;
				int m_nBufferSize;

				int m_nByteLength;
				int m_nCharLength;

				void Resize(int nSize);

				static int GetCharSize(unsigned short nChar);
				static int GetUtf8CharSize(unsigned char cLeadChar);
				static bool GetUtf8Length(const char* szString, int* pCharLength, int* pByteLength);

				static unsigned short DecodeChar(unsigned char* pUtf8Char);
				static int EncodeChar(unsigned short nChar, unsigned char* pBuffer);
		};
	}
}



#include <stdint.h>

namespace NumberDuck
{
	namespace Secret
	{
		class InternalString;
		class Utils
		{
			public:
				static double Pow(double fBase, double fExponent);
				static double ByteConvertUint64ToDouble(uint64_t nValue);
				static int32_t ByteConvertUint32ToInt32(uint32_t nValue);
				static uint32_t ByteConvertInt32ToUint32(int32_t nValue);

				static void Indent(int nTabDepth, InternalString* sOut);
		};
	}
}



/*
Original code by Lee Thomason (www.grinninglizard.com)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any
damages arising from the use of this software.

Permission is granted to anyone to use this software for any
purpose, including commercial applications, and to alter it and
redistribute it freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and
must not be misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
*/

#ifndef TINYXML2_INCLUDED
#define TINYXML2_INCLUDED

#if defined(ANDROID_NDK) || defined(__BORLANDC__) || defined(__QNXNTO__)
#   include <ctype.h>
#   include <limits.h>
#   include <stdio.h>
#   include <stdlib.h>
#   include <string.h>
#	if defined(__PS3__)
#		include <stddef.h>
#	endif
#else
#   include <cctype>
#   include <climits>
#   include <cstdio>
#   include <cstdlib>
#   include <cstring>
#endif
#include <stdint.h>

/*
	gcc:
        g++ -Wall -DTINYXML2_DEBUG tinyxml2.cpp xmltest.cpp -o gccxmltest.exe

    Formatting, Artistic Style:
        AStyle.exe --style=1tbs --indent-switches --break-closing-brackets --indent-preprocessor tinyxml2.cpp tinyxml2.h
*/

#if defined( _DEBUG ) || defined (__DEBUG__)
#   ifndef TINYXML2_DEBUG
#       define TINYXML2_DEBUG
#   endif
#endif

#ifdef _MSC_VER
#   pragma warning(push)
#   pragma warning(disable: 4251)
#endif

#ifdef _MSC_VER
#   ifdef TINYXML2_EXPORT
#       define TINYXML2_LIB __declspec(dllexport)
#   elif defined(TINYXML2_IMPORT)
#       define TINYXML2_LIB __declspec(dllimport)
#   else
#       define TINYXML2_LIB
#   endif
#elif __GNUC__ >= 4
#   define TINYXML2_LIB __attribute__((visibility("default")))
#else
#   define TINYXML2_LIB
#endif


#if !defined(TIXMLASSERT)
#if defined(TINYXML2_DEBUG)
#   if defined(_MSC_VER)
#       // "(void)0," is for suppressing C4127 warning in "assert(false)", "assert(true)" and the like
#       define TIXMLASSERT( x )           do { if ( !((void)0,(x))) { __debugbreak(); } } while(false)
#   elif defined (ANDROID_NDK)
#       include <android/log.h>
#       define TIXMLASSERT( x )           do { if ( !(x)) { __android_log_assert( "assert", "grinliz", "ASSERT in '%s' at %d.", __FILE__, __LINE__ ); } } while(false)
#   else
#       include <assert.h>
#       define TIXMLASSERT                assert
#   endif
#else
#   define TIXMLASSERT( x )               do {} while(false)
#endif
#endif

/* Versioning, past 1.0.14:
	http://semver.org/
*/
static const int TIXML2_MAJOR_VERSION = 10;
static const int TIXML2_MINOR_VERSION = 0;
static const int TIXML2_PATCH_VERSION = 0;

#define TINYXML2_MAJOR_VERSION 10
#define TINYXML2_MINOR_VERSION 0
#define TINYXML2_PATCH_VERSION 0

// A fixed element depth limit is problematic. There needs to be a
// limit to avoid a stack overflow. However, that limit varies per
// system, and the capacity of the stack. On the other hand, it's a trivial
// attack that can result from ill, malicious, or even correctly formed XML,
// so there needs to be a limit in place.
static const int TINYXML2_MAX_ELEMENT_DEPTH = 500;

namespace tinyxml2
{
class XMLDocument;
class XMLElement;
class XMLAttribute;
class XMLComment;
class XMLText;
class XMLDeclaration;
class XMLUnknown;
class XMLPrinter;

/*
	A class that wraps strings. Normally stores the start and end
	pointers into the XML file itself, and will apply normalization
	and entity translation if actually read. Can also store (and memory
	manage) a traditional char[]

    Isn't clear why TINYXML2_LIB is needed; but seems to fix #719
*/
class TINYXML2_LIB StrPair
{
public:
    enum Mode {
        NEEDS_ENTITY_PROCESSING			= 0x01,
        NEEDS_NEWLINE_NORMALIZATION		= 0x02,
        NEEDS_WHITESPACE_COLLAPSING     = 0x04,

        TEXT_ELEMENT		            = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,
        TEXT_ELEMENT_LEAVE_ENTITIES		= NEEDS_NEWLINE_NORMALIZATION,
        ATTRIBUTE_NAME		            = 0,
        ATTRIBUTE_VALUE		            = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,
        ATTRIBUTE_VALUE_LEAVE_ENTITIES  = NEEDS_NEWLINE_NORMALIZATION,
        COMMENT							= NEEDS_NEWLINE_NORMALIZATION
    };

    StrPair() : _flags( 0 ), _start( 0 ), _end( 0 ) {}
    ~StrPair();

    void Set( char* start, char* end, int flags ) {
        TIXMLASSERT( start );
        TIXMLASSERT( end );
        Reset();
        _start  = start;
        _end    = end;
        _flags  = flags | NEEDS_FLUSH;
    }

    const char* GetStr();

    bool Empty() const {
        return _start == _end;
    }

    void SetInternedStr( const char* str ) {
        Reset();
        _start = const_cast<char*>(str);
    }

    void SetStr( const char* str, int flags=0 );

    char* ParseText( char* in, const char* endTag, int strFlags, int* curLineNumPtr );
    char* ParseName( char* in );

    void TransferTo( StrPair* other );
	void Reset();

private:
    void CollapseWhitespace();

    enum {
        NEEDS_FLUSH = 0x100,
        NEEDS_DELETE = 0x200
    };

    int     _flags;
    char*   _start;
    char*   _end;

    StrPair( const StrPair& other );	// not supported
    void operator=( const StrPair& other );	// not supported, use TransferTo()
};


/*
	A dynamic array of Plain Old Data. Doesn't support constructors, etc.
	Has a small initial memory pool, so that low or no usage will not
	cause a call to new/delete
*/
template <class T, int INITIAL_SIZE>
class DynArray
{
public:
    DynArray() :
        _mem( _pool ),
        _allocated( INITIAL_SIZE ),
        _size( 0 )
    {
    }

    ~DynArray() {
        if ( _mem != _pool ) {
            delete [] _mem;
        }
    }

    void Clear() {
        _size = 0;
    }

    void Push( T t ) {
        TIXMLASSERT( _size < INT_MAX );
        EnsureCapacity( _size+1 );
        _mem[_size] = t;
        ++_size;
    }

    T* PushArr( int count ) {
        TIXMLASSERT( count >= 0 );
        TIXMLASSERT( _size <= INT_MAX - count );
        EnsureCapacity( _size+count );
        T* ret = &_mem[_size];
        _size += count;
        return ret;
    }

    T Pop() {
        TIXMLASSERT( _size > 0 );
        --_size;
        return _mem[_size];
    }

    void PopArr( int count ) {
        TIXMLASSERT( _size >= count );
        _size -= count;
    }

    bool Empty() const					{
        return _size == 0;
    }

    T& operator[](int i)				{
        TIXMLASSERT( i>= 0 && i < _size );
        return _mem[i];
    }

    const T& operator[](int i) const	{
        TIXMLASSERT( i>= 0 && i < _size );
        return _mem[i];
    }

    const T& PeekTop() const            {
        TIXMLASSERT( _size > 0 );
        return _mem[ _size - 1];
    }

    int Size() const					{
        TIXMLASSERT( _size >= 0 );
        return _size;
    }

    int Capacity() const				{
        TIXMLASSERT( _allocated >= INITIAL_SIZE );
        return _allocated;
    }

	void SwapRemove(int i) {
		TIXMLASSERT(i >= 0 && i < _size);
		TIXMLASSERT(_size > 0);
		_mem[i] = _mem[_size - 1];
		--_size;
	}

    const T* Mem() const				{
        TIXMLASSERT( _mem );
        return _mem;
    }

    T* Mem() {
        TIXMLASSERT( _mem );
        return _mem;
    }

private:
    DynArray( const DynArray& ); // not supported
    void operator=( const DynArray& ); // not supported

    void EnsureCapacity( int cap ) {
        TIXMLASSERT( cap > 0 );
        if ( cap > _allocated ) {
            TIXMLASSERT( cap <= INT_MAX / 2 );
            const int newAllocated = cap * 2;
            T* newMem = new T[static_cast<unsigned int>(newAllocated)];
            TIXMLASSERT( newAllocated >= _size );
            memcpy( newMem, _mem, sizeof(T)*static_cast<size_t>(_size) );	// warning: not using constructors, only works for PODs
            if ( _mem != _pool ) {
                delete [] _mem;
            }
            _mem = newMem;
            _allocated = newAllocated;
        }
    }

    T*  _mem;
    T   _pool[static_cast<size_t>(INITIAL_SIZE)];
    int _allocated;		// objects allocated
    int _size;			// number objects in use
};


/*
	Parent virtual class of a pool for fast allocation
	and deallocation of objects.
*/
class MemPool
{
public:
    MemPool() {}
    virtual ~MemPool() {}

    virtual int ItemSize() const = 0;
    virtual void* Alloc() = 0;
    virtual void Free( void* ) = 0;
    virtual void SetTracked() = 0;
};


/*
	Template child class to create pools of the correct type.
*/
template< int ITEM_SIZE >
class MemPoolT : public MemPool
{
public:
    MemPoolT() : _blockPtrs(), _root(0), _currentAllocs(0), _nAllocs(0), _maxAllocs(0), _nUntracked(0)	{}
    ~MemPoolT() {
        MemPoolT< ITEM_SIZE >::Clear();
    }

    void Clear() {
        // Delete the blocks.
        while( !_blockPtrs.Empty()) {
            Block* lastBlock = _blockPtrs.Pop();
            delete lastBlock;
        }
        _root = 0;
        _currentAllocs = 0;
        _nAllocs = 0;
        _maxAllocs = 0;
        _nUntracked = 0;
    }

    virtual int ItemSize() const override{
        return ITEM_SIZE;
    }
    int CurrentAllocs() const		{
        return _currentAllocs;
    }

    virtual void* Alloc() override{
        if ( !_root ) {
            // Need a new block.
            Block* block = new Block;
            _blockPtrs.Push( block );

            Item* blockItems = block->items;
            for( int i = 0; i < ITEMS_PER_BLOCK - 1; ++i ) {
                blockItems[i].next = &(blockItems[i + 1]);
            }
            blockItems[ITEMS_PER_BLOCK - 1].next = 0;
            _root = blockItems;
        }
        Item* const result = _root;
        TIXMLASSERT( result != 0 );
        _root = _root->next;

        ++_currentAllocs;
        if ( _currentAllocs > _maxAllocs ) {
            _maxAllocs = _currentAllocs;
        }
        ++_nAllocs;
        ++_nUntracked;
        return result;
    }

    virtual void Free( void* mem ) override {
        if ( !mem ) {
            return;
        }
        --_currentAllocs;
        Item* item = static_cast<Item*>( mem );
#ifdef TINYXML2_DEBUG
        memset( item, 0xfe, sizeof( *item ) );
#endif
        item->next = _root;
        _root = item;
    }
    void Trace( const char* name ) {
        printf( "Mempool %s watermark=%d [%dk] current=%d size=%d nAlloc=%d blocks=%d\n",
                name, _maxAllocs, _maxAllocs * ITEM_SIZE / 1024, _currentAllocs,
                ITEM_SIZE, _nAllocs, _blockPtrs.Size() );
    }

    void SetTracked() override {
        --_nUntracked;
    }

    int Untracked() const {
        return _nUntracked;
    }

	// This number is perf sensitive. 4k seems like a good tradeoff on my machine.
	// The test file is large, 170k.
	// Release:		VS2010 gcc(no opt)
	//		1k:		4000
	//		2k:		4000
	//		4k:		3900	21000
	//		16k:	5200
	//		32k:	4300
	//		64k:	4000	21000
    // Declared public because some compilers do not accept to use ITEMS_PER_BLOCK
    // in private part if ITEMS_PER_BLOCK is private
    enum { ITEMS_PER_BLOCK = (4 * 1024) / ITEM_SIZE };

private:
    MemPoolT( const MemPoolT& ); // not supported
    void operator=( const MemPoolT& ); // not supported

    union Item {
        Item*   next;
        char    itemData[static_cast<size_t>(ITEM_SIZE)];
    };
    struct Block {
        Item items[ITEMS_PER_BLOCK];
    };
    DynArray< Block*, 10 > _blockPtrs;
    Item* _root;

    int _currentAllocs;
    int _nAllocs;
    int _maxAllocs;
    int _nUntracked;
};



/**
	Implements the interface to the "Visitor pattern" (see the Accept() method.)
	If you call the Accept() method, it requires being passed a XMLVisitor
	class to handle callbacks. For nodes that contain other nodes (Document, Element)
	you will get called with a VisitEnter/VisitExit pair. Nodes that are always leafs
	are simply called with Visit().

	If you return 'true' from a Visit method, recursive parsing will continue. If you return
	false, <b>no children of this node or its siblings</b> will be visited.

	All flavors of Visit methods have a default implementation that returns 'true' (continue
	visiting). You need to only override methods that are interesting to you.

	Generally Accept() is called on the XMLDocument, although all nodes support visiting.

	You should never change the document from a callback.

	@sa XMLNode::Accept()
*/
class TINYXML2_LIB XMLVisitor
{
public:
    virtual ~XMLVisitor() {}

    /// Visit a document.
    virtual bool VisitEnter( const XMLDocument& /*doc*/ )			{
        return true;
    }
    /// Visit a document.
    virtual bool VisitExit( const XMLDocument& /*doc*/ )			{
        return true;
    }

    /// Visit an element.
    virtual bool VisitEnter( const XMLElement& /*element*/, const XMLAttribute* /*firstAttribute*/ )	{
        return true;
    }
    /// Visit an element.
    virtual bool VisitExit( const XMLElement& /*element*/ )			{
        return true;
    }

    /// Visit a declaration.
    virtual bool Visit( const XMLDeclaration& /*declaration*/ )		{
        return true;
    }
    /// Visit a text node.
    virtual bool Visit( const XMLText& /*text*/ )					{
        return true;
    }
    /// Visit a comment node.
    virtual bool Visit( const XMLComment& /*comment*/ )				{
        return true;
    }
    /// Visit an unknown node.
    virtual bool Visit( const XMLUnknown& /*unknown*/ )				{
        return true;
    }
};

// WARNING: must match XMLDocument::_errorNames[]
enum XMLError {
    XML_SUCCESS = 0,
    XML_NO_ATTRIBUTE,
    XML_WRONG_ATTRIBUTE_TYPE,
    XML_ERROR_FILE_NOT_FOUND,
    XML_ERROR_FILE_COULD_NOT_BE_OPENED,
    XML_ERROR_FILE_READ_ERROR,
    XML_ERROR_PARSING_ELEMENT,
    XML_ERROR_PARSING_ATTRIBUTE,
    XML_ERROR_PARSING_TEXT,
    XML_ERROR_PARSING_CDATA,
    XML_ERROR_PARSING_COMMENT,
    XML_ERROR_PARSING_DECLARATION,
    XML_ERROR_PARSING_UNKNOWN,
    XML_ERROR_EMPTY_DOCUMENT,
    XML_ERROR_MISMATCHED_ELEMENT,
    XML_ERROR_PARSING,
    XML_CAN_NOT_CONVERT_TEXT,
    XML_NO_TEXT_NODE,
	XML_ELEMENT_DEPTH_EXCEEDED,

	XML_ERROR_COUNT
};


/*
	Utility functionality.
*/
class TINYXML2_LIB XMLUtil
{
public:
    static const char* SkipWhiteSpace( const char* p, int* curLineNumPtr )	{
        TIXMLASSERT( p );

        while( IsWhiteSpace(*p) ) {
            if (curLineNumPtr && *p == '\n') {
                ++(*curLineNumPtr);
            }
            ++p;
        }
        TIXMLASSERT( p );
        return p;
    }
    static char* SkipWhiteSpace( char* const p, int* curLineNumPtr ) {
        return const_cast<char*>( SkipWhiteSpace( const_cast<const char*>(p), curLineNumPtr ) );
    }

    // Anything in the high order range of UTF-8 is assumed to not be whitespace. This isn't
    // correct, but simple, and usually works.
    static bool IsWhiteSpace( char p )					{
        return !IsUTF8Continuation(p) && isspace( static_cast<unsigned char>(p) );
    }

    inline static bool IsNameStartChar( unsigned char ch ) {
        if ( ch >= 128 ) {
            // This is a heuristic guess in attempt to not implement Unicode-aware isalpha()
            return true;
        }
        if ( isalpha( ch ) ) {
            return true;
        }
        return ch == ':' || ch == '_';
    }

    inline static bool IsNameChar( unsigned char ch ) {
        return IsNameStartChar( ch )
               || isdigit( ch )
               || ch == '.'
               || ch == '-';
    }

    inline static bool IsPrefixHex( const char* p) {
        p = SkipWhiteSpace(p, 0);
        return p && *p == '0' && ( *(p + 1) == 'x' || *(p + 1) == 'X');
    }

    inline static bool StringEqual( const char* p, const char* q, int nChar=INT_MAX )  {
        if ( p == q ) {
            return true;
        }
        TIXMLASSERT( p );
        TIXMLASSERT( q );
        TIXMLASSERT( nChar >= 0 );
        return strncmp( p, q, static_cast<size_t>(nChar) ) == 0;
    }

    inline static bool IsUTF8Continuation( const char p ) {
        return ( p & 0x80 ) != 0;
    }

    static const char* ReadBOM( const char* p, bool* hasBOM );
    // p is the starting location,
    // the UTF-8 value of the entity will be placed in value, and length filled in.
    static const char* GetCharacterRef( const char* p, char* value, int* length );
    static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );

    // converts primitive types to strings
    static void ToStr( int v, char* buffer, int bufferSize );
    static void ToStr( unsigned v, char* buffer, int bufferSize );
    static void ToStr( bool v, char* buffer, int bufferSize );
    static void ToStr( float v, char* buffer, int bufferSize );
    static void ToStr( double v, char* buffer, int bufferSize );
	static void ToStr(int64_t v, char* buffer, int bufferSize);
    static void ToStr(uint64_t v, char* buffer, int bufferSize);

    // converts strings to primitive types
    static bool	ToInt( const char* str, int* value );
    static bool ToUnsigned( const char* str, unsigned* value );
    static bool	ToBool( const char* str, bool* value );
    static bool	ToFloat( const char* str, float* value );
    static bool ToDouble( const char* str, double* value );
	static bool ToInt64(const char* str, int64_t* value);
    static bool ToUnsigned64(const char* str, uint64_t* value);
	// Changes what is serialized for a boolean value.
	// Default to "true" and "false". Shouldn't be changed
	// unless you have a special testing or compatibility need.
	// Be careful: static, global, & not thread safe.
	// Be sure to set static const memory as parameters.
	static void SetBoolSerialization(const char* writeTrue, const char* writeFalse);

private:
	static const char* writeBoolTrue;
	static const char* writeBoolFalse;
};


/** XMLNode is a base class for every object that is in the
	XML Document Object Model (DOM), except XMLAttributes.
	Nodes have siblings, a parent, and children which can
	be navigated. A node is always in a XMLDocument.
	The type of a XMLNode can be queried, and it can
	be cast to its more defined type.

	A XMLDocument allocates memory for all its Nodes.
	When the XMLDocument gets deleted, all its Nodes
	will also be deleted.

	@verbatim
	A Document can contain:	Element	(container or leaf)
							Comment (leaf)
							Unknown (leaf)
							Declaration( leaf )

	An Element can contain:	Element (container or leaf)
							Text	(leaf)
							Attributes (not on tree)
							Comment (leaf)
							Unknown (leaf)

	@endverbatim
*/
class TINYXML2_LIB XMLNode
{
    friend class XMLDocument;
    friend class XMLElement;
public:

    /// Get the XMLDocument that owns this XMLNode.
    const XMLDocument* GetDocument() const	{
        TIXMLASSERT( _document );
        return _document;
    }
    /// Get the XMLDocument that owns this XMLNode.
    XMLDocument* GetDocument()				{
        TIXMLASSERT( _document );
        return _document;
    }

    /// Safely cast to an Element, or null.
    virtual XMLElement*		ToElement()		{
        return 0;
    }
    /// Safely cast to Text, or null.
    virtual XMLText*		ToText()		{
        return 0;
    }
    /// Safely cast to a Comment, or null.
    virtual XMLComment*		ToComment()		{
        return 0;
    }
    /// Safely cast to a Document, or null.
    virtual XMLDocument*	ToDocument()	{
        return 0;
    }
    /// Safely cast to a Declaration, or null.
    virtual XMLDeclaration*	ToDeclaration()	{
        return 0;
    }
    /// Safely cast to an Unknown, or null.
    virtual XMLUnknown*		ToUnknown()		{
        return 0;
    }

    virtual const XMLElement*		ToElement() const		{
        return 0;
    }
    virtual const XMLText*			ToText() const			{
        return 0;
    }
    virtual const XMLComment*		ToComment() const		{
        return 0;
    }
    virtual const XMLDocument*		ToDocument() const		{
        return 0;
    }
    virtual const XMLDeclaration*	ToDeclaration() const	{
        return 0;
    }
    virtual const XMLUnknown*		ToUnknown() const		{
        return 0;
    }

    // ChildElementCount was originally suggested by msteiger on the sourceforge page for TinyXML and modified by KB1SPH for TinyXML-2.

    int ChildElementCount(const char *value) const;

    int ChildElementCount() const;

    /** The meaning of 'value' changes for the specific type.
    	@verbatim
    	Document:	empty (NULL is returned, not an empty string)
    	Element:	name of the element
    	Comment:	the comment text
    	Unknown:	the tag contents
    	Text:		the text string
    	@endverbatim
    */
    const char* Value() const;

    /** Set the Value of an XML node.
    	@sa Value()
    */
    void SetValue( const char* val, bool staticMem=false );

    /// Gets the line number the node is in, if the document was parsed from a file.
    int GetLineNum() const { return _parseLineNum; }

    /// Get the parent of this node on the DOM.
    const XMLNode*	Parent() const			{
        return _parent;
    }

    XMLNode* Parent()						{
        return _parent;
    }

    /// Returns true if this node has no children.
    bool NoChildren() const					{
        return !_firstChild;
    }

    /// Get the first child node, or null if none exists.
    const XMLNode*  FirstChild() const		{
        return _firstChild;
    }

    XMLNode*		FirstChild()			{
        return _firstChild;
    }

    /** Get the first child element, or optionally the first child
        element with the specified name.
    */
    const XMLElement* FirstChildElement( const char* name = 0 ) const;

    XMLElement* FirstChildElement( const char* name = 0 )	{
        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->FirstChildElement( name ));
    }

    /// Get the last child node, or null if none exists.
    const XMLNode*	LastChild() const						{
        return _lastChild;
    }

    XMLNode*		LastChild()								{
        return _lastChild;
    }

    /** Get the last child element or optionally the last child
        element with the specified name.
    */
    const XMLElement* LastChildElement( const char* name = 0 ) const;

    XMLElement* LastChildElement( const char* name = 0 )	{
        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->LastChildElement(name) );
    }

    /// Get the previous (left) sibling node of this node.
    const XMLNode*	PreviousSibling() const					{
        return _prev;
    }

    XMLNode*	PreviousSibling()							{
        return _prev;
    }

    /// Get the previous (left) sibling element of this node, with an optionally supplied name.
    const XMLElement*	PreviousSiblingElement( const char* name = 0 ) const ;

    XMLElement*	PreviousSiblingElement( const char* name = 0 ) {
        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->PreviousSiblingElement( name ) );
    }

    /// Get the next (right) sibling node of this node.
    const XMLNode*	NextSibling() const						{
        return _next;
    }

    XMLNode*	NextSibling()								{
        return _next;
    }

    /// Get the next (right) sibling element of this node, with an optionally supplied name.
    const XMLElement*	NextSiblingElement( const char* name = 0 ) const;

    XMLElement*	NextSiblingElement( const char* name = 0 )	{
        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->NextSiblingElement( name ) );
    }

    /**
    	Add a child node as the last (right) child.
		If the child node is already part of the document,
		it is moved from its old location to the new location.
		Returns the addThis argument or 0 if the node does not
		belong to the same document.
    */
    XMLNode* InsertEndChild( XMLNode* addThis );

    XMLNode* LinkEndChild( XMLNode* addThis )	{
        return InsertEndChild( addThis );
    }
    /**
    	Add a child node as the first (left) child.
		If the child node is already part of the document,
		it is moved from its old location to the new location.
		Returns the addThis argument or 0 if the node does not
		belong to the same document.
    */
    XMLNode* InsertFirstChild( XMLNode* addThis );
    /**
    	Add a node after the specified child node.
		If the child node is already part of the document,
		it is moved from its old location to the new location.
		Returns the addThis argument or 0 if the afterThis node
		is not a child of this node, or if the node does not
		belong to the same document.
    */
    XMLNode* InsertAfterChild( XMLNode* afterThis, XMLNode* addThis );

    /**
    	Delete all the children of this node.
    */
    void DeleteChildren();

    /**
    	Delete a child of this node.
    */
    void DeleteChild( XMLNode* node );

    /**
    	Make a copy of this node, but not its children.
    	You may pass in a Document pointer that will be
    	the owner of the new Node. If the 'document' is
    	null, then the node returned will be allocated
    	from the current Document. (this->GetDocument())

    	Note: if called on a XMLDocument, this will return null.
    */
    virtual XMLNode* ShallowClone( XMLDocument* document ) const = 0;

	/**
		Make a copy of this node and all its children.

		If the 'target' is null, then the nodes will
		be allocated in the current document. If 'target'
        is specified, the memory will be allocated is the
        specified XMLDocument.

		NOTE: This is probably not the correct tool to
		copy a document, since XMLDocuments can have multiple
		top level XMLNodes. You probably want to use
        XMLDocument::DeepCopy()
	*/
	XMLNode* DeepClone( XMLDocument* target ) const;

    /**
    	Test if 2 nodes are the same, but don't test children.
    	The 2 nodes do not need to be in the same Document.

    	Note: if called on a XMLDocument, this will return false.
    */
    virtual bool ShallowEqual( const XMLNode* compare ) const = 0;

    /** Accept a hierarchical visit of the nodes in the TinyXML-2 DOM. Every node in the
    	XML tree will be conditionally visited and the host will be called back
    	via the XMLVisitor interface.

    	This is essentially a SAX interface for TinyXML-2. (Note however it doesn't re-parse
    	the XML for the callbacks, so the performance of TinyXML-2 is unchanged by using this
    	interface versus any other.)

    	The interface has been based on ideas from:

    	- http://www.saxproject.org/
    	- http://c2.com/cgi/wiki?HierarchicalVisitorPattern

    	Which are both good references for "visiting".

    	An example of using Accept():
    	@verbatim
    	XMLPrinter printer;
    	tinyxmlDoc.Accept( &printer );
    	const char* xmlcstr = printer.CStr();
    	@endverbatim
    */
    virtual bool Accept( XMLVisitor* visitor ) const = 0;

	/**
		Set user data into the XMLNode. TinyXML-2 in
		no way processes or interprets user data.
		It is initially 0.
	*/
	void SetUserData(void* userData)	{ _userData = userData; }

	/**
		Get user data set into the XMLNode. TinyXML-2 in
		no way processes or interprets user data.
		It is initially 0.
	*/
	void* GetUserData() const			{ return _userData; }

protected:
    explicit XMLNode( XMLDocument* );
    virtual ~XMLNode();

    virtual char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr);

    XMLDocument*	_document;
    XMLNode*		_parent;
    mutable StrPair	_value;
    int             _parseLineNum;

    XMLNode*		_firstChild;
    XMLNode*		_lastChild;

    XMLNode*		_prev;
    XMLNode*		_next;

	void*			_userData;

private:
    MemPool*		_memPool;
    void Unlink( XMLNode* child );
    static void DeleteNode( XMLNode* node );
    void InsertChildPreamble( XMLNode* insertThis ) const;
    const XMLElement* ToElementWithName( const char* name ) const;

    XMLNode( const XMLNode& );	// not supported
    XMLNode& operator=( const XMLNode& );	// not supported
};


/** XML text.

	Note that a text node can have child element nodes, for example:
	@verbatim
	<root>This is <b>bold</b></root>
	@endverbatim

	A text node can have 2 ways to output the next. "normal" output
	and CDATA. It will default to the mode it was parsed from the XML file and
	you generally want to leave it alone, but you can change the output mode with
	SetCData() and query it with CData().
*/
class TINYXML2_LIB XMLText : public XMLNode
{
    friend class XMLDocument;
public:
    virtual bool Accept( XMLVisitor* visitor ) const override;

    virtual XMLText* ToText() override		{
        return this;
    }
    virtual const XMLText* ToText() const override {
        return this;
    }

    /// Declare whether this should be CDATA or standard text.
    void SetCData( bool isCData )			{
        _isCData = isCData;
    }
    /// Returns true if this is a CDATA text element.
    bool CData() const						{
        return _isCData;
    }

    virtual XMLNode* ShallowClone( XMLDocument* document ) const override;
    virtual bool ShallowEqual( const XMLNode* compare ) const override;

protected:
    explicit XMLText( XMLDocument* doc )	: XMLNode( doc ), _isCData( false )	{}
    virtual ~XMLText()												{}

    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr ) override;

private:
    bool _isCData;

    XMLText( const XMLText& );	// not supported
    XMLText& operator=( const XMLText& );	// not supported
};


/** An XML Comment. */
class TINYXML2_LIB XMLComment : public XMLNode
{
    friend class XMLDocument;
public:
    virtual XMLComment*	ToComment() override		{
        return this;
    }
    virtual const XMLComment* ToComment() const override {
        return this;
    }

    virtual bool Accept( XMLVisitor* visitor ) const override;

    virtual XMLNode* ShallowClone( XMLDocument* document ) const override;
    virtual bool ShallowEqual( const XMLNode* compare ) const override;

protected:
    explicit XMLComment( XMLDocument* doc );
    virtual ~XMLComment();

    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr) override;

private:
    XMLComment( const XMLComment& );	// not supported
    XMLComment& operator=( const XMLComment& );	// not supported
};


/** In correct XML the declaration is the first entry in the file.
	@verbatim
		<?xml version="1.0" standalone="yes"?>
	@endverbatim

	TinyXML-2 will happily read or write files without a declaration,
	however.

	The text of the declaration isn't interpreted. It is parsed
	and written as a string.
*/
class TINYXML2_LIB XMLDeclaration : public XMLNode
{
    friend class XMLDocument;
public:
    virtual XMLDeclaration*	ToDeclaration() override		{
        return this;
    }
    virtual const XMLDeclaration* ToDeclaration() const override {
        return this;
    }

    virtual bool Accept( XMLVisitor* visitor ) const override;

    virtual XMLNode* ShallowClone( XMLDocument* document ) const override;
    virtual bool ShallowEqual( const XMLNode* compare ) const override;

protected:
    explicit XMLDeclaration( XMLDocument* doc );
    virtual ~XMLDeclaration();

    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr ) override;

private:
    XMLDeclaration( const XMLDeclaration& );	// not supported
    XMLDeclaration& operator=( const XMLDeclaration& );	// not supported
};


/** Any tag that TinyXML-2 doesn't recognize is saved as an
	unknown. It is a tag of text, but should not be modified.
	It will be written back to the XML, unchanged, when the file
	is saved.

	DTD tags get thrown into XMLUnknowns.
*/
class TINYXML2_LIB XMLUnknown : public XMLNode
{
    friend class XMLDocument;
public:
    virtual XMLUnknown*	ToUnknown() override		{
        return this;
    }
    virtual const XMLUnknown* ToUnknown() const override {
        return this;
    }

    virtual bool Accept( XMLVisitor* visitor ) const override;

    virtual XMLNode* ShallowClone( XMLDocument* document ) const override;
    virtual bool ShallowEqual( const XMLNode* compare ) const override;

protected:
    explicit XMLUnknown( XMLDocument* doc );
    virtual ~XMLUnknown();

    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr ) override;

private:
    XMLUnknown( const XMLUnknown& );	// not supported
    XMLUnknown& operator=( const XMLUnknown& );	// not supported
};



/** An attribute is a name-value pair. Elements have an arbitrary
	number of attributes, each with a unique name.

	@note The attributes are not XMLNodes. You may only query the
	Next() attribute in a list.
*/
class TINYXML2_LIB XMLAttribute
{
    friend class XMLElement;
public:
    /// The name of the attribute.
    const char* Name() const;

    /// The value of the attribute.
    const char* Value() const;

    /// Gets the line number the attribute is in, if the document was parsed from a file.
    int GetLineNum() const { return _parseLineNum; }

    /// The next attribute in the list.
    const XMLAttribute* Next() const {
        return _next;
    }

    /** IntValue interprets the attribute as an integer, and returns the value.
        If the value isn't an integer, 0 will be returned. There is no error checking;
    	use QueryIntValue() if you need error checking.
    */
	int	IntValue() const {
		int i = 0;
		QueryIntValue(&i);
		return i;
	}

	int64_t Int64Value() const {
		int64_t i = 0;
		QueryInt64Value(&i);
		return i;
	}

    uint64_t Unsigned64Value() const {
        uint64_t i = 0;
        QueryUnsigned64Value(&i);
        return i;
    }

    /// Query as an unsigned integer. See IntValue()
    unsigned UnsignedValue() const			{
        unsigned i=0;
        QueryUnsignedValue( &i );
        return i;
    }
    /// Query as a boolean. See IntValue()
    bool	 BoolValue() const				{
        bool b=false;
        QueryBoolValue( &b );
        return b;
    }
    /// Query as a double. See IntValue()
    double 	 DoubleValue() const			{
        double d=0;
        QueryDoubleValue( &d );
        return d;
    }
    /// Query as a float. See IntValue()
    float	 FloatValue() const				{
        float f=0;
        QueryFloatValue( &f );
        return f;
    }

    /** QueryIntValue interprets the attribute as an integer, and returns the value
    	in the provided parameter. The function will return XML_SUCCESS on success,
    	and XML_WRONG_ATTRIBUTE_TYPE if the conversion is not successful.
    */
    XMLError QueryIntValue( int* value ) const;
    /// See QueryIntValue
    XMLError QueryUnsignedValue( unsigned int* value ) const;
	/// See QueryIntValue
	XMLError QueryInt64Value(int64_t* value) const;
    /// See QueryIntValue
    XMLError QueryUnsigned64Value(uint64_t* value) const;
	/// See QueryIntValue
    XMLError QueryBoolValue( bool* value ) const;
    /// See QueryIntValue
    XMLError QueryDoubleValue( double* value ) const;
    /// See QueryIntValue
    XMLError QueryFloatValue( float* value ) const;

    /// Set the attribute to a string value.
    void SetAttribute( const char* value );
    /// Set the attribute to value.
    void SetAttribute( int value );
    /// Set the attribute to value.
    void SetAttribute( unsigned value );
	/// Set the attribute to value.
	void SetAttribute(int64_t value);
    /// Set the attribute to value.
    void SetAttribute(uint64_t value);
    /// Set the attribute to value.
    void SetAttribute( bool value );
    /// Set the attribute to value.
    void SetAttribute( double value );
    /// Set the attribute to value.
    void SetAttribute( float value );

private:
    enum { BUF_SIZE = 200 };

    XMLAttribute() : _name(), _value(),_parseLineNum( 0 ), _next( 0 ), _memPool( 0 ) {}
    virtual ~XMLAttribute()	{}

    XMLAttribute( const XMLAttribute& );	// not supported
    void operator=( const XMLAttribute& );	// not supported
    void SetName( const char* name );

    char* ParseDeep( char* p, bool processEntities, int* curLineNumPtr );

    mutable StrPair _name;
    mutable StrPair _value;
    int             _parseLineNum;
    XMLAttribute*   _next;
    MemPool*        _memPool;
};


/** The element is a container class. It has a value, the element name,
	and can contain other elements, text, comments, and unknowns.
	Elements also contain an arbitrary number of attributes.
*/
class TINYXML2_LIB XMLElement : public XMLNode
{
    friend class XMLDocument;
public:
    /// Get the name of an element (which is the Value() of the node.)
    const char* Name() const		{
        return Value();
    }
    /// Set the name of the element.
    void SetName( const char* str, bool staticMem=false )	{
        SetValue( str, staticMem );
    }

    virtual XMLElement* ToElement() override	{
        return this;
    }
    virtual const XMLElement* ToElement() const override {
        return this;
    }
    virtual bool Accept( XMLVisitor* visitor ) const override;

    /** Given an attribute name, Attribute() returns the value
    	for the attribute of that name, or null if none
    	exists. For example:

    	@verbatim
    	const char* value = ele->Attribute( "foo" );
    	@endverbatim

    	The 'value' parameter is normally null. However, if specified,
    	the attribute will only be returned if the 'name' and 'value'
    	match. This allow you to write code:

    	@verbatim
    	if ( ele->Attribute( "foo", "bar" ) ) callFooIsBar();
    	@endverbatim

    	rather than:
    	@verbatim
    	if ( ele->Attribute( "foo" ) ) {
    		if ( strcmp( ele->Attribute( "foo" ), "bar" ) == 0 ) callFooIsBar();
    	}
    	@endverbatim
    */
    const char* Attribute( const char* name, const char* value=0 ) const;

    /** Given an attribute name, IntAttribute() returns the value
    	of the attribute interpreted as an integer. The default
        value will be returned if the attribute isn't present,
        or if there is an error. (For a method with error
    	checking, see QueryIntAttribute()).
    */
	int IntAttribute(const char* name, int defaultValue = 0) const;
    /// See IntAttribute()
	unsigned UnsignedAttribute(const char* name, unsigned defaultValue = 0) const;
	/// See IntAttribute()
	int64_t Int64Attribute(const char* name, int64_t defaultValue = 0) const;
    /// See IntAttribute()
    uint64_t Unsigned64Attribute(const char* name, uint64_t defaultValue = 0) const;
	/// See IntAttribute()
	bool BoolAttribute(const char* name, bool defaultValue = false) const;
    /// See IntAttribute()
	double DoubleAttribute(const char* name, double defaultValue = 0) const;
    /// See IntAttribute()
	float FloatAttribute(const char* name, float defaultValue = 0) const;

    /** Given an attribute name, QueryIntAttribute() returns
    	XML_SUCCESS, XML_WRONG_ATTRIBUTE_TYPE if the conversion
    	can't be performed, or XML_NO_ATTRIBUTE if the attribute
    	doesn't exist. If successful, the result of the conversion
    	will be written to 'value'. If not successful, nothing will
    	be written to 'value'. This allows you to provide default
    	value:

    	@verbatim
    	int value = 10;
    	QueryIntAttribute( "foo", &value );		// if "foo" isn't found, value will still be 10
    	@endverbatim
    */
    XMLError QueryIntAttribute( const char* name, int* value ) const				{
        const XMLAttribute* a = FindAttribute( name );
        if ( !a ) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryIntValue( value );
    }

	/// See QueryIntAttribute()
    XMLError QueryUnsignedAttribute( const char* name, unsigned int* value ) const	{
        const XMLAttribute* a = FindAttribute( name );
        if ( !a ) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryUnsignedValue( value );
    }

	/// See QueryIntAttribute()
	XMLError QueryInt64Attribute(const char* name, int64_t* value) const {
		const XMLAttribute* a = FindAttribute(name);
		if (!a) {
			return XML_NO_ATTRIBUTE;
		}
		return a->QueryInt64Value(value);
	}

    /// See QueryIntAttribute()
    XMLError QueryUnsigned64Attribute(const char* name, uint64_t* value) const {
        const XMLAttribute* a = FindAttribute(name);
        if(!a) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryUnsigned64Value(value);
    }

	/// See QueryIntAttribute()
    XMLError QueryBoolAttribute( const char* name, bool* value ) const				{
        const XMLAttribute* a = FindAttribute( name );
        if ( !a ) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryBoolValue( value );
    }
    /// See QueryIntAttribute()
    XMLError QueryDoubleAttribute( const char* name, double* value ) const			{
        const XMLAttribute* a = FindAttribute( name );
        if ( !a ) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryDoubleValue( value );
    }
    /// See QueryIntAttribute()
    XMLError QueryFloatAttribute( const char* name, float* value ) const			{
        const XMLAttribute* a = FindAttribute( name );
        if ( !a ) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryFloatValue( value );
    }

	/// See QueryIntAttribute()
	XMLError QueryStringAttribute(const char* name, const char** value) const {
		const XMLAttribute* a = FindAttribute(name);
		if (!a) {
			return XML_NO_ATTRIBUTE;
		}
		*value = a->Value();
		return XML_SUCCESS;
	}



    /** Given an attribute name, QueryAttribute() returns
    	XML_SUCCESS, XML_WRONG_ATTRIBUTE_TYPE if the conversion
    	can't be performed, or XML_NO_ATTRIBUTE if the attribute
    	doesn't exist. It is overloaded for the primitive types,
		and is a generally more convenient replacement of
		QueryIntAttribute() and related functions.

		If successful, the result of the conversion
    	will be written to 'value'. If not successful, nothing will
    	be written to 'value'. This allows you to provide default
    	value:

    	@verbatim
    	int value = 10;
    	QueryAttribute( "foo", &value );		// if "foo" isn't found, value will still be 10
    	@endverbatim
    */
	XMLError QueryAttribute( const char* name, int* value ) const {
		return QueryIntAttribute( name, value );
	}

	XMLError QueryAttribute( const char* name, unsigned int* value ) const {
		return QueryUnsignedAttribute( name, value );
	}

	XMLError QueryAttribute(const char* name, int64_t* value) const {
		return QueryInt64Attribute(name, value);
	}

    XMLError QueryAttribute(const char* name, uint64_t* value) const {
        return QueryUnsigned64Attribute(name, value);
    }

    XMLError QueryAttribute( const char* name, bool* value ) const {
		return QueryBoolAttribute( name, value );
	}

	XMLError QueryAttribute( const char* name, double* value ) const {
		return QueryDoubleAttribute( name, value );
	}

	XMLError QueryAttribute( const char* name, float* value ) const {
		return QueryFloatAttribute( name, value );
	}

	XMLError QueryAttribute(const char* name, const char** value) const {
		return QueryStringAttribute(name, value);
	}

	/// Sets the named attribute to value.
    void SetAttribute( const char* name, const char* value )	{
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }
    /// Sets the named attribute to value.
    void SetAttribute( const char* name, int value )			{
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }
    /// Sets the named attribute to value.
    void SetAttribute( const char* name, unsigned value )		{
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }

	/// Sets the named attribute to value.
	void SetAttribute(const char* name, int64_t value) {
		XMLAttribute* a = FindOrCreateAttribute(name);
		a->SetAttribute(value);
	}

    /// Sets the named attribute to value.
    void SetAttribute(const char* name, uint64_t value) {
        XMLAttribute* a = FindOrCreateAttribute(name);
        a->SetAttribute(value);
    }

    /// Sets the named attribute to value.
    void SetAttribute( const char* name, bool value )			{
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }
    /// Sets the named attribute to value.
    void SetAttribute( const char* name, double value )		{
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }
    /// Sets the named attribute to value.
    void SetAttribute( const char* name, float value )		{
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }

    /**
    	Delete an attribute.
    */
    void DeleteAttribute( const char* name );

    /// Return the first attribute in the list.
    const XMLAttribute* FirstAttribute() const {
        return _rootAttribute;
    }
    /// Query a specific attribute in the list.
    const XMLAttribute* FindAttribute( const char* name ) const;

    /** Convenience function for easy access to the text inside an element. Although easy
    	and concise, GetText() is limited compared to getting the XMLText child
    	and accessing it directly.

    	If the first child of 'this' is a XMLText, the GetText()
    	returns the character string of the Text node, else null is returned.

    	This is a convenient method for getting the text of simple contained text:
    	@verbatim
    	<foo>This is text</foo>
    		const char* str = fooElement->GetText();
    	@endverbatim

    	'str' will be a pointer to "This is text".

    	Note that this function can be misleading. If the element foo was created from
    	this XML:
    	@verbatim
    		<foo><b>This is text</b></foo>
    	@endverbatim

    	then the value of str would be null. The first child node isn't a text node, it is
    	another element. From this XML:
    	@verbatim
    		<foo>This is <b>text</b></foo>
    	@endverbatim
    	GetText() will return "This is ".
    */
    const char* GetText() const;

    /** Convenience function for easy access to the text inside an element. Although easy
    	and concise, SetText() is limited compared to creating an XMLText child
    	and mutating it directly.

    	If the first child of 'this' is a XMLText, SetText() sets its value to
		the given string, otherwise it will create a first child that is an XMLText.

    	This is a convenient method for setting the text of simple contained text:
    	@verbatim
    	<foo>This is text</foo>
    		fooElement->SetText( "Hullaballoo!" );
     	<foo>Hullaballoo!</foo>
		@endverbatim

    	Note that this function can be misleading. If the element foo was created from
    	this XML:
    	@verbatim
    		<foo><b>This is text</b></foo>
    	@endverbatim

    	then it will not change "This is text", but rather prefix it with a text element:
    	@verbatim
    		<foo>Hullaballoo!<b>This is text</b></foo>
    	@endverbatim

		For this XML:
    	@verbatim
    		<foo />
    	@endverbatim
    	SetText() will generate
    	@verbatim
    		<foo>Hullaballoo!</foo>
    	@endverbatim
    */
	void SetText( const char* inText );
    /// Convenience method for setting text inside an element. See SetText() for important limitations.
    void SetText( int value );
    /// Convenience method for setting text inside an element. See SetText() for important limitations.
    void SetText( unsigned value );
	/// Convenience method for setting text inside an element. See SetText() for important limitations.
	void SetText(int64_t value);
    /// Convenience method for setting text inside an element. See SetText() for important limitations.
    void SetText(uint64_t value);
	/// Convenience method for setting text inside an element. See SetText() for important limitations.
    void SetText( bool value );
    /// Convenience method for setting text inside an element. See SetText() for important limitations.
    void SetText( double value );
    /// Convenience method for setting text inside an element. See SetText() for important limitations.
    void SetText( float value );

    /**
    	Convenience method to query the value of a child text node. This is probably best
    	shown by example. Given you have a document is this form:
    	@verbatim
    		<point>
    			<x>1</x>
    			<y>1.4</y>
    		</point>
    	@endverbatim

    	The QueryIntText() and similar functions provide a safe and easier way to get to the
    	"value" of x and y.

    	@verbatim
    		int x = 0;
    		float y = 0;	// types of x and y are contrived for example
    		const XMLElement* xElement = pointElement->FirstChildElement( "x" );
    		const XMLElement* yElement = pointElement->FirstChildElement( "y" );
    		xElement->QueryIntText( &x );
    		yElement->QueryFloatText( &y );
    	@endverbatim

    	@returns XML_SUCCESS (0) on success, XML_CAN_NOT_CONVERT_TEXT if the text cannot be converted
    			 to the requested type, and XML_NO_TEXT_NODE if there is no child text to query.

    */
    XMLError QueryIntText( int* ival ) const;
    /// See QueryIntText()
    XMLError QueryUnsignedText( unsigned* uval ) const;
	/// See QueryIntText()
	XMLError QueryInt64Text(int64_t* uval) const;
	/// See QueryIntText()
	XMLError QueryUnsigned64Text(uint64_t* uval) const;
	/// See QueryIntText()
    XMLError QueryBoolText( bool* bval ) const;
    /// See QueryIntText()
    XMLError QueryDoubleText( double* dval ) const;
    /// See QueryIntText()
    XMLError QueryFloatText( float* fval ) const;

	int IntText(int defaultValue = 0) const;

	/// See QueryIntText()
	unsigned UnsignedText(unsigned defaultValue = 0) const;
	/// See QueryIntText()
	int64_t Int64Text(int64_t defaultValue = 0) const;
    /// See QueryIntText()
    uint64_t Unsigned64Text(uint64_t defaultValue = 0) const;
	/// See QueryIntText()
	bool BoolText(bool defaultValue = false) const;
	/// See QueryIntText()
	double DoubleText(double defaultValue = 0) const;
	/// See QueryIntText()
    float FloatText(float defaultValue = 0) const;

    /**
        Convenience method to create a new XMLElement and add it as last (right)
        child of this node. Returns the created and inserted element.
    */
    XMLElement* InsertNewChildElement(const char* name);
    /// See InsertNewChildElement()
    XMLComment* InsertNewComment(const char* comment);
    /// See InsertNewChildElement()
    XMLText* InsertNewText(const char* text);
    /// See InsertNewChildElement()
    XMLDeclaration* InsertNewDeclaration(const char* text);
    /// See InsertNewChildElement()
    XMLUnknown* InsertNewUnknown(const char* text);


    // internal:
    enum ElementClosingType {
        OPEN,		// <foo>
        CLOSED,		// <foo/>
        CLOSING		// </foo>
    };
    ElementClosingType ClosingType() const {
        return _closingType;
    }
    virtual XMLNode* ShallowClone( XMLDocument* document ) const override;
    virtual bool ShallowEqual( const XMLNode* compare ) const override;

protected:
    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr ) override;

private:
    XMLElement( XMLDocument* doc );
    virtual ~XMLElement();
    XMLElement( const XMLElement& );	// not supported
    void operator=( const XMLElement& );	// not supported

    XMLAttribute* FindOrCreateAttribute( const char* name );
    char* ParseAttributes( char* p, int* curLineNumPtr );
    static void DeleteAttribute( XMLAttribute* attribute );
    XMLAttribute* CreateAttribute();

    enum { BUF_SIZE = 200 };
    ElementClosingType _closingType;
    // The attribute list is ordered; there is no 'lastAttribute'
    // because the list needs to be scanned for dupes before adding
    // a new attribute.
    XMLAttribute* _rootAttribute;
};


enum Whitespace {
    PRESERVE_WHITESPACE,
    COLLAPSE_WHITESPACE,
    PEDANTIC_WHITESPACE
};


/** A Document binds together all the functionality.
	It can be saved, loaded, and printed to the screen.
	All Nodes are connected and allocated to a Document.
	If the Document is deleted, all its Nodes are also deleted.
*/
class TINYXML2_LIB XMLDocument : public XMLNode
{
    friend class XMLElement;
    // Gives access to SetError and Push/PopDepth, but over-access for everything else.
    // Wishing C++ had "internal" scope.
    friend class XMLNode;
    friend class XMLText;
    friend class XMLComment;
    friend class XMLDeclaration;
    friend class XMLUnknown;
public:
    /// constructor
    XMLDocument( bool processEntities = true, Whitespace whitespaceMode = PRESERVE_WHITESPACE );
    ~XMLDocument();

    virtual XMLDocument* ToDocument() override		{
        TIXMLASSERT( this == _document );
        return this;
    }
    virtual const XMLDocument* ToDocument() const override {
        TIXMLASSERT( this == _document );
        return this;
    }

    /**
    	Parse an XML file from a character string.
    	Returns XML_SUCCESS (0) on success, or
    	an errorID.

    	You may optionally pass in the 'nBytes', which is
    	the number of bytes which will be parsed. If not
    	specified, TinyXML-2 will assume 'xml' points to a
    	null terminated string.
    */
    XMLError Parse( const char* xml, size_t nBytes=static_cast<size_t>(-1) );

    /**
    	Load an XML file from disk.
    	Returns XML_SUCCESS (0) on success, or
    	an errorID.
    */
    XMLError LoadFile( const char* filename );

    /**
    	Load an XML file from disk. You are responsible
    	for providing and closing the FILE*.

        NOTE: The file should be opened as binary ("rb")
        not text in order for TinyXML-2 to correctly
        do newline normalization.

    	Returns XML_SUCCESS (0) on success, or
    	an errorID.
    */
    XMLError LoadFile( FILE* );

    /**
    	Save the XML file to disk.
    	Returns XML_SUCCESS (0) on success, or
    	an errorID.
    */
    XMLError SaveFile( const char* filename, bool compact = false );

    /**
    	Save the XML file to disk. You are responsible
    	for providing and closing the FILE*.

    	Returns XML_SUCCESS (0) on success, or
    	an errorID.
    */
    XMLError SaveFile( FILE* fp, bool compact = false );

    bool ProcessEntities() const		{
        return _processEntities;
    }
    Whitespace WhitespaceMode() const	{
        return _whitespaceMode;
    }

    /**
    	Returns true if this document has a leading Byte Order Mark of UTF8.
    */
    bool HasBOM() const {
        return _writeBOM;
    }
    /** Sets whether to write the BOM when writing the file.
    */
    void SetBOM( bool useBOM ) {
        _writeBOM = useBOM;
    }

    /** Return the root element of DOM. Equivalent to FirstChildElement().
        To get the first node, use FirstChild().
    */
    XMLElement* RootElement()				{
        return FirstChildElement();
    }
    const XMLElement* RootElement() const	{
        return FirstChildElement();
    }

    /** Print the Document. If the Printer is not provided, it will
        print to stdout. If you provide Printer, this can print to a file:
    	@verbatim
    	XMLPrinter printer( fp );
    	doc.Print( &printer );
    	@endverbatim

    	Or you can use a printer to print to memory:
    	@verbatim
    	XMLPrinter printer;
    	doc.Print( &printer );
    	// printer.CStr() has a const char* to the XML
    	@endverbatim
    */
    void Print( XMLPrinter* streamer=0 ) const;
    virtual bool Accept( XMLVisitor* visitor ) const override;

    /**
    	Create a new Element associated with
    	this Document. The memory for the Element
    	is managed by the Document.
    */
    XMLElement* NewElement( const char* name );
    /**
    	Create a new Comment associated with
    	this Document. The memory for the Comment
    	is managed by the Document.
    */
    XMLComment* NewComment( const char* comment );
    /**
    	Create a new Text associated with
    	this Document. The memory for the Text
    	is managed by the Document.
    */
    XMLText* NewText( const char* text );
    /**
    	Create a new Declaration associated with
    	this Document. The memory for the object
    	is managed by the Document.

    	If the 'text' param is null, the standard
    	declaration is used.:
    	@verbatim
    		<?xml version="1.0" encoding="UTF-8"?>
    	@endverbatim
    */
    XMLDeclaration* NewDeclaration( const char* text=0 );
    /**
    	Create a new Unknown associated with
    	this Document. The memory for the object
    	is managed by the Document.
    */
    XMLUnknown* NewUnknown( const char* text );

    /**
    	Delete a node associated with this document.
    	It will be unlinked from the DOM.
    */
    void DeleteNode( XMLNode* node );

    /// Clears the error flags.
    void ClearError();

    /// Return true if there was an error parsing the document.
    bool Error() const {
        return _errorID != XML_SUCCESS;
    }
    /// Return the errorID.
    XMLError  ErrorID() const {
        return _errorID;
    }
	const char* ErrorName() const;
    static const char* ErrorIDToName(XMLError errorID);

    /** Returns a "long form" error description. A hopefully helpful
        diagnostic with location, line number, and/or additional info.
    */
	const char* ErrorStr() const;

    /// A (trivial) utility function that prints the ErrorStr() to stdout.
    void PrintError() const;

    /// Return the line where the error occurred, or zero if unknown.
    int ErrorLineNum() const
    {
        return _errorLineNum;
    }

    /// Clear the document, resetting it to the initial state.
    void Clear();

	/**
		Copies this document to a target document.
		The target will be completely cleared before the copy.
		If you want to copy a sub-tree, see XMLNode::DeepClone().

		NOTE: that the 'target' must be non-null.
	*/
	void DeepCopy(XMLDocument* target) const;

	// internal
    char* Identify( char* p, XMLNode** node, bool first );

	// internal
	void MarkInUse(const XMLNode* const);

    virtual XMLNode* ShallowClone( XMLDocument* /*document*/ ) const override{
        return 0;
    }
    virtual bool ShallowEqual( const XMLNode* /*compare*/ ) const override{
        return false;
    }

private:
    XMLDocument( const XMLDocument& );	// not supported
    void operator=( const XMLDocument& );	// not supported

    bool			_writeBOM;
    bool			_processEntities;
    XMLError		_errorID;
    Whitespace		_whitespaceMode;
    mutable StrPair	_errorStr;
    int             _errorLineNum;
    char*			_charBuffer;
    int				_parseCurLineNum;
	int				_parsingDepth;
	// Memory tracking does add some overhead.
	// However, the code assumes that you don't
	// have a bunch of unlinked nodes around.
	// Therefore it takes less memory to track
	// in the document vs. a linked list in the XMLNode,
	// and the performance is the same.
	DynArray<XMLNode*, 10> _unlinked;

    MemPoolT< sizeof(XMLElement) >	 _elementPool;
    MemPoolT< sizeof(XMLAttribute) > _attributePool;
    MemPoolT< sizeof(XMLText) >		 _textPool;
    MemPoolT< sizeof(XMLComment) >	 _commentPool;

	static const char* _errorNames[XML_ERROR_COUNT];

    void Parse();

    void SetError( XMLError error, int lineNum, const char* format, ... );

	// Something of an obvious security hole, once it was discovered.
	// Either an ill-formed XML or an excessively deep one can overflow
	// the stack. Track stack depth, and error out if needed.
	class DepthTracker {
	public:
		explicit DepthTracker(XMLDocument * document) {
			this->_document = document;
			document->PushDepth();
		}
		~DepthTracker() {
			_document->PopDepth();
		}
	private:
		XMLDocument * _document;
	};
	void PushDepth();
	void PopDepth();

    template<class NodeType, int PoolElementSize>
    NodeType* CreateUnlinkedNode( MemPoolT<PoolElementSize>& pool );
};

template<class NodeType, int PoolElementSize>
inline NodeType* XMLDocument::CreateUnlinkedNode( MemPoolT<PoolElementSize>& pool )
{
    TIXMLASSERT( sizeof( NodeType ) == PoolElementSize );
    TIXMLASSERT( sizeof( NodeType ) == pool.ItemSize() );
    NodeType* returnNode = new (pool.Alloc()) NodeType( this );
    TIXMLASSERT( returnNode );
    returnNode->_memPool = &pool;

	_unlinked.Push(returnNode);
    return returnNode;
}

/**
	A XMLHandle is a class that wraps a node pointer with null checks; this is
	an incredibly useful thing. Note that XMLHandle is not part of the TinyXML-2
	DOM structure. It is a separate utility class.

	Take an example:
	@verbatim
	<Document>
		<Element attributeA = "valueA">
			<Child attributeB = "value1" />
			<Child attributeB = "value2" />
		</Element>
	</Document>
	@endverbatim

	Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very
	easy to write a *lot* of code that looks like:

	@verbatim
	XMLElement* root = document.FirstChildElement( "Document" );
	if ( root )
	{
		XMLElement* element = root->FirstChildElement( "Element" );
		if ( element )
		{
			XMLElement* child = element->FirstChildElement( "Child" );
			if ( child )
			{
				XMLElement* child2 = child->NextSiblingElement( "Child" );
				if ( child2 )
				{
					// Finally do something useful.
	@endverbatim

	And that doesn't even cover "else" cases. XMLHandle addresses the verbosity
	of such code. A XMLHandle checks for null pointers so it is perfectly safe
	and correct to use:

	@verbatim
	XMLHandle docHandle( &document );
	XMLElement* child2 = docHandle.FirstChildElement( "Document" ).FirstChildElement( "Element" ).FirstChildElement().NextSiblingElement();
	if ( child2 )
	{
		// do something useful
	@endverbatim

	Which is MUCH more concise and useful.

	It is also safe to copy handles - internally they are nothing more than node pointers.
	@verbatim
	XMLHandle handleCopy = handle;
	@endverbatim

	See also XMLConstHandle, which is the same as XMLHandle, but operates on const objects.
*/
class TINYXML2_LIB XMLHandle
{
public:
    /// Create a handle from any node (at any depth of the tree.) This can be a null pointer.
    explicit XMLHandle( XMLNode* node ) : _node( node ) {
    }
    /// Create a handle from a node.
    explicit XMLHandle( XMLNode& node ) : _node( &node ) {
    }
    /// Copy constructor
    XMLHandle( const XMLHandle& ref ) : _node( ref._node ) {
    }
    /// Assignment
    XMLHandle& operator=( const XMLHandle& ref )							{
        _node = ref._node;
        return *this;
    }

    /// Get the first child of this handle.
    XMLHandle FirstChild() 													{
        return XMLHandle( _node ? _node->FirstChild() : 0 );
    }
    /// Get the first child element of this handle.
    XMLHandle FirstChildElement( const char* name = 0 )						{
        return XMLHandle( _node ? _node->FirstChildElement( name ) : 0 );
    }
    /// Get the last child of this handle.
    XMLHandle LastChild()													{
        return XMLHandle( _node ? _node->LastChild() : 0 );
    }
    /// Get the last child element of this handle.
    XMLHandle LastChildElement( const char* name = 0 )						{
        return XMLHandle( _node ? _node->LastChildElement( name ) : 0 );
    }
    /// Get the previous sibling of this handle.
    XMLHandle PreviousSibling()												{
        return XMLHandle( _node ? _node->PreviousSibling() : 0 );
    }
    /// Get the previous sibling element of this handle.
    XMLHandle PreviousSiblingElement( const char* name = 0 )				{
        return XMLHandle( _node ? _node->PreviousSiblingElement( name ) : 0 );
    }
    /// Get the next sibling of this handle.
    XMLHandle NextSibling()													{
        return XMLHandle( _node ? _node->NextSibling() : 0 );
    }
    /// Get the next sibling element of this handle.
    XMLHandle NextSiblingElement( const char* name = 0 )					{
        return XMLHandle( _node ? _node->NextSiblingElement( name ) : 0 );
    }

    /// Safe cast to XMLNode. This can return null.
    XMLNode* ToNode()							{
        return _node;
    }
    /// Safe cast to XMLElement. This can return null.
    XMLElement* ToElement() 					{
        return ( _node ? _node->ToElement() : 0 );
    }
    /// Safe cast to XMLText. This can return null.
    XMLText* ToText() 							{
        return ( _node ? _node->ToText() : 0 );
    }
    /// Safe cast to XMLUnknown. This can return null.
    XMLUnknown* ToUnknown() 					{
        return ( _node ? _node->ToUnknown() : 0 );
    }
    /// Safe cast to XMLDeclaration. This can return null.
    XMLDeclaration* ToDeclaration() 			{
        return ( _node ? _node->ToDeclaration() : 0 );
    }

private:
    XMLNode* _node;
};


/**
	A variant of the XMLHandle class for working with const XMLNodes and Documents. It is the
	same in all regards, except for the 'const' qualifiers. See XMLHandle for API.
*/
class TINYXML2_LIB XMLConstHandle
{
public:
    explicit XMLConstHandle( const XMLNode* node ) : _node( node ) {
    }
    explicit XMLConstHandle( const XMLNode& node ) : _node( &node ) {
    }
    XMLConstHandle( const XMLConstHandle& ref ) : _node( ref._node ) {
    }

    XMLConstHandle& operator=( const XMLConstHandle& ref )							{
        _node = ref._node;
        return *this;
    }

    const XMLConstHandle FirstChild() const											{
        return XMLConstHandle( _node ? _node->FirstChild() : 0 );
    }
    const XMLConstHandle FirstChildElement( const char* name = 0 ) const				{
        return XMLConstHandle( _node ? _node->FirstChildElement( name ) : 0 );
    }
    const XMLConstHandle LastChild()	const										{
        return XMLConstHandle( _node ? _node->LastChild() : 0 );
    }
    const XMLConstHandle LastChildElement( const char* name = 0 ) const				{
        return XMLConstHandle( _node ? _node->LastChildElement( name ) : 0 );
    }
    const XMLConstHandle PreviousSibling() const									{
        return XMLConstHandle( _node ? _node->PreviousSibling() : 0 );
    }
    const XMLConstHandle PreviousSiblingElement( const char* name = 0 ) const		{
        return XMLConstHandle( _node ? _node->PreviousSiblingElement( name ) : 0 );
    }
    const XMLConstHandle NextSibling() const										{
        return XMLConstHandle( _node ? _node->NextSibling() : 0 );
    }
    const XMLConstHandle NextSiblingElement( const char* name = 0 ) const			{
        return XMLConstHandle( _node ? _node->NextSiblingElement( name ) : 0 );
    }


    const XMLNode* ToNode() const				{
        return _node;
    }
    const XMLElement* ToElement() const			{
        return ( _node ? _node->ToElement() : 0 );
    }
    const XMLText* ToText() const				{
        return ( _node ? _node->ToText() : 0 );
    }
    const XMLUnknown* ToUnknown() const			{
        return ( _node ? _node->ToUnknown() : 0 );
    }
    const XMLDeclaration* ToDeclaration() const	{
        return ( _node ? _node->ToDeclaration() : 0 );
    }

private:
    const XMLNode* _node;
};


/**
	Printing functionality. The XMLPrinter gives you more
	options than the XMLDocument::Print() method.

	It can:
	-# Print to memory.
	-# Print to a file you provide.
	-# Print XML without a XMLDocument.

	Print to Memory

	@verbatim
	XMLPrinter printer;
	doc.Print( &printer );
	SomeFunction( printer.CStr() );
	@endverbatim

	Print to a File

	You provide the file pointer.
	@verbatim
	XMLPrinter printer( fp );
	doc.Print( &printer );
	@endverbatim

	Print without a XMLDocument

	When loading, an XML parser is very useful. However, sometimes
	when saving, it just gets in the way. The code is often set up
	for streaming, and constructing the DOM is just overhead.

	The Printer supports the streaming case. The following code
	prints out a trivially simple XML file without ever creating
	an XML document.

	@verbatim
	XMLPrinter printer( fp );
	printer.OpenElement( "foo" );
	printer.PushAttribute( "foo", "bar" );
	printer.CloseElement();
	@endverbatim
*/
class TINYXML2_LIB XMLPrinter : public XMLVisitor
{
public:
    /** Construct the printer. If the FILE* is specified,
    	this will print to the FILE. Else it will print
    	to memory, and the result is available in CStr().
    	If 'compact' is set to true, then output is created
    	with only required whitespace and newlines.
    */
    XMLPrinter( FILE* file=0, bool compact = false, int depth = 0 );
    virtual ~XMLPrinter()	{}

    /** If streaming, write the BOM and declaration. */
    void PushHeader( bool writeBOM, bool writeDeclaration );
    /** If streaming, start writing an element.
        The element must be closed with CloseElement()
    */
    void OpenElement( const char* name, bool compactMode=false );
    /// If streaming, add an attribute to an open element.
    void PushAttribute( const char* name, const char* value );
    void PushAttribute( const char* name, int value );
    void PushAttribute( const char* name, unsigned value );
	void PushAttribute( const char* name, int64_t value );
	void PushAttribute( const char* name, uint64_t value );
	void PushAttribute( const char* name, bool value );
    void PushAttribute( const char* name, double value );
    /// If streaming, close the Element.
    virtual void CloseElement( bool compactMode=false );

    /// Add a text node.
    void PushText( const char* text, bool cdata=false );
    /// Add a text node from an integer.
    void PushText( int value );
    /// Add a text node from an unsigned.
    void PushText( unsigned value );
	/// Add a text node from a signed 64bit integer.
	void PushText( int64_t value );
	/// Add a text node from an unsigned 64bit integer.
	void PushText( uint64_t value );
	/// Add a text node from a bool.
    void PushText( bool value );
    /// Add a text node from a float.
    void PushText( float value );
    /// Add a text node from a double.
    void PushText( double value );

    /// Add a comment
    void PushComment( const char* comment );

    void PushDeclaration( const char* value );
    void PushUnknown( const char* value );

    virtual bool VisitEnter( const XMLDocument& /*doc*/ ) override;
    virtual bool VisitExit( const XMLDocument& /*doc*/ ) override	{
        return true;
    }

    virtual bool VisitEnter( const XMLElement& element, const XMLAttribute* attribute ) override;
    virtual bool VisitExit( const XMLElement& element ) override;

    virtual bool Visit( const XMLText& text ) override;
    virtual bool Visit( const XMLComment& comment ) override;
    virtual bool Visit( const XMLDeclaration& declaration ) override;
    virtual bool Visit( const XMLUnknown& unknown ) override;

    /**
    	If in print to memory mode, return a pointer to
    	the XML file in memory.
    */
    const char* CStr() const {
        return _buffer.Mem();
    }
    /**
    	If in print to memory mode, return the size
    	of the XML file in memory. (Note the size returned
    	includes the terminating null.)
    */
    int CStrSize() const {
        return _buffer.Size();
    }
    /**
    	If in print to memory mode, reset the buffer to the
    	beginning.
    */
    void ClearBuffer( bool resetToFirstElement = true ) {
        _buffer.Clear();
        _buffer.Push(0);
		_firstElement = resetToFirstElement;
    }

protected:
	virtual bool CompactMode( const XMLElement& )	{ return _compactMode; }

	/** Prints out the space before an element. You may override to change
	    the space and tabs used. A PrintSpace() override should call Print().
	*/
    virtual void PrintSpace( int depth );
    virtual void Print( const char* format, ... );
    virtual void Write( const char* data, size_t size );
    virtual void Putc( char ch );

    inline void Write(const char* data) { Write(data, strlen(data)); }

    void SealElementIfJustOpened();
    bool _elementJustOpened;
    DynArray< const char*, 10 > _stack;

private:
    /**
       Prepares to write a new node. This includes sealing an element that was
       just opened, and writing any whitespace necessary if not in compact mode.
     */
    void PrepareForNewNode( bool compactMode );
    void PrintString( const char*, bool restrictedEntitySet );	// prints out, after detecting entities.

    bool _firstElement;
    FILE* _fp;
    int _depth;
    int _textDepth;
    bool _processEntities;
	bool _compactMode;

    enum {
        ENTITY_RANGE = 64,
        BUF_SIZE = 200
    };
    bool _entityFlag[ENTITY_RANGE];
    bool _restrictedEntityFlag[ENTITY_RANGE];

    DynArray< char, 20 > _buffer;

    // Prohibit cloning, intentionally not implemented
    XMLPrinter( const XMLPrinter& );
    XMLPrinter& operator=( const XMLPrinter& );
};


}	// tinyxml2

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#endif // TINYXML2_INCLUDED




#ifndef CLANG_PARSE
	
#endif

namespace NumberDuck
{
	class Blob;
	class BlobView;

	namespace Secret
	{
		template <class T>
		class Vector;

		class XmlNode
		{
			public:
				XmlNode* GetFirstChildElement(const char* szName);
				XmlNode* GetNextSiblingElement(const char* szName);
				const char* GetValue();
				const char* GetText();
				const char* GetAttribute(const char* szName);

			protected:
				#ifndef CLANG_PARSE
					XmlNode(tinyxml2::XMLNode* pNode, XmlNode* pParent);
					virtual ~XmlNode();

					tinyxml2::XMLNode* m_pNode;
					XmlNode* m_pParent;
					Vector<XmlNode*>* m_pChildNodeVector;
				#endif
		};

		class XmlFile : public XmlNode
		{
			public:
				XmlFile();
				~XmlFile();

				bool Load(BlobView* pBlobView);

			protected:
				#ifndef CLANG_PARSE
					void Cleanup();

					tinyxml2::XMLDocument* m_pDocument;
				#endif
		};
	}
}


#ifndef MINIZ_EXPORT
#define MINIZ_EXPORT
#endif
/* miniz.c 3.0.0 - public domain deflate/inflate, zlib-subset, ZIP reading/writing/appending, PNG writing
   See "unlicense" statement at the end of this file.
   Rich Geldreich <richgel99@gmail.com>, last updated Oct. 13, 2013
   Implements RFC 1950: http://www.ietf.org/rfc/rfc1950.txt and RFC 1951: http://www.ietf.org/rfc/rfc1951.txt

   Most API's defined in miniz.c are optional. For example, to disable the archive related functions just define
   MINIZ_NO_ARCHIVE_APIS, or to get rid of all stdio usage define MINIZ_NO_STDIO (see the list below for more macros).

   * Low-level Deflate/Inflate implementation notes:

     Compression: Use the "tdefl" API's. The compressor supports raw, static, and dynamic blocks, lazy or
     greedy parsing, match length filtering, RLE-only, and Huffman-only streams. It performs and compresses
     approximately as well as zlib.

     Decompression: Use the "tinfl" API's. The entire decompressor is implemented as a single function
     coroutine: see tinfl_decompress(). It supports decompression into a 32KB (or larger power of 2) wrapping buffer, or into a memory
     block large enough to hold the entire file.

     The low-level tdefl/tinfl API's do not make any use of dynamic memory allocation.

   * zlib-style API notes:

     miniz.c implements a fairly large subset of zlib. There's enough functionality present for it to be a drop-in
     zlib replacement in many apps:
        The z_stream struct, optional memory allocation callbacks
        deflateInit/deflateInit2/deflate/deflateReset/deflateEnd/deflateBound
        inflateInit/inflateInit2/inflate/inflateReset/inflateEnd
        compress, compress2, compressBound, uncompress
        CRC-32, Adler-32 - Using modern, minimal code size, CPU cache friendly routines.
        Supports raw deflate streams or standard zlib streams with adler-32 checking.

     Limitations:
      The callback API's are not implemented yet. No support for gzip headers or zlib static dictionaries.
      I've tried to closely emulate zlib's various flavors of stream flushing and return status codes, but
      there are no guarantees that miniz.c pulls this off perfectly.

   * PNG writing: See the tdefl_write_image_to_png_file_in_memory() function, originally written by
     Alex Evans. Supports 1-4 bytes/pixel images.

   * ZIP archive API notes:

     The ZIP archive API's where designed with simplicity and efficiency in mind, with just enough abstraction to
     get the job done with minimal fuss. There are simple API's to retrieve file information, read files from
     existing archives, create new archives, append new files to existing archives, or clone archive data from
     one archive to another. It supports archives located in memory or the heap, on disk (using stdio.h),
     or you can specify custom file read/write callbacks.

     - Archive reading: Just call this function to read a single file from a disk archive:

      void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name,
        size_t *pSize, mz_uint zip_flags);

     For more complex cases, use the "mz_zip_reader" functions. Upon opening an archive, the entire central
     directory is located and read as-is into memory, and subsequent file access only occurs when reading individual files.

     - Archives file scanning: The simple way is to use this function to scan a loaded archive for a specific file:

     int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);

     The locate operation can optionally check file comments too, which (as one example) can be used to identify
     multiple versions of the same file in an archive. This function uses a simple linear search through the central
     directory, so it's not very fast.

     Alternately, you can iterate through all the files in an archive (using mz_zip_reader_get_num_files()) and
     retrieve detailed info on each file by calling mz_zip_reader_file_stat().

     - Archive creation: Use the "mz_zip_writer" functions. The ZIP writer immediately writes compressed file data
     to disk and builds an exact image of the central directory in memory. The central directory image is written
     all at once at the end of the archive file when the archive is finalized.

     The archive writer can optionally align each file's local header and file data to any power of 2 alignment,
     which can be useful when the archive will be read from optical media. Also, the writer supports placing
     arbitrary data blobs at the very beginning of ZIP archives. Archives written using either feature are still
     readable by any ZIP tool.

     - Archive appending: The simple way to add a single file to an archive is to call this function:

      mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name,
        const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);

     The archive will be created if it doesn't already exist, otherwise it'll be appended to.
     Note the appending is done in-place and is not an atomic operation, so if something goes wrong
     during the operation it's possible the archive could be left without a central directory (although the local
     file headers and file data will be fine, so the archive will be recoverable).

     For more complex archive modification scenarios:
     1. The safest way is to use a mz_zip_reader to read the existing archive, cloning only those bits you want to
     preserve into a new archive using using the mz_zip_writer_add_from_zip_reader() function (which compiles the
     compressed file data as-is). When you're done, delete the old archive and rename the newly written archive, and
     you're done. This is safe but requires a bunch of temporary disk space or heap memory.

     2. Or, you can convert an mz_zip_reader in-place to an mz_zip_writer using mz_zip_writer_init_from_reader(),
     append new files as needed, then finalize the archive which will write an updated central directory to the
     original archive. (This is basically what mz_zip_add_mem_to_archive_file_in_place() does.) There's a
     possibility that the archive's central directory could be lost with this method if anything goes wrong, though.

     - ZIP archive support limitations:
     No spanning support. Extraction functions can only handle unencrypted, stored or deflated files.
     Requires streams capable of seeking.

   * This is a header file library, like stb_image.c. To get only a header file, either cut and paste the
     below header, or create miniz.h, #define MINIZ_HEADER_FILE_ONLY, and then include miniz.c from it.

   * Important: For best perf. be sure to customize the below macros for your target platform:
     #define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1
     #define MINIZ_LITTLE_ENDIAN 1
     #define MINIZ_HAS_64BIT_REGISTERS 1

   * On platforms using glibc, Be sure to "#define _LARGEFILE64_SOURCE 1" before including miniz.c to ensure miniz
     uses the 64-bit variants: fopen64(), stat64(), etc. Otherwise you won't be able to process large files
     (i.e. 32-bit stat() fails for me on files > 0x7FFFFFFF bytes).
*/




/* Defines to completely disable specific portions of miniz.c: 
   If all macros here are defined the only functionality remaining will be CRC-32 and adler-32. */

/* Define MINIZ_NO_STDIO to disable all usage and any functions which rely on stdio for file I/O. */
/*#define MINIZ_NO_STDIO */

/* If MINIZ_NO_TIME is specified then the ZIP archive functions will not be able to get the current time, or */
/* get/set file times, and the C run-time funcs that get/set times won't be called. */
/* The current downside is the times written to your archives will be from 1979. */
/*#define MINIZ_NO_TIME */

/* Define MINIZ_NO_DEFLATE_APIS to disable all compression API's. */
/*#define MINIZ_NO_DEFLATE_APIS */

/* Define MINIZ_NO_INFLATE_APIS to disable all decompression API's. */
/*#define MINIZ_NO_INFLATE_APIS */

/* Define MINIZ_NO_ARCHIVE_APIS to disable all ZIP archive API's. */
/*#define MINIZ_NO_ARCHIVE_APIS */

/* Define MINIZ_NO_ARCHIVE_WRITING_APIS to disable all writing related ZIP archive API's. */
/*#define MINIZ_NO_ARCHIVE_WRITING_APIS */

/* Define MINIZ_NO_ZLIB_APIS to remove all ZLIB-style compression/decompression API's. */
/*#define MINIZ_NO_ZLIB_APIS */

/* Define MINIZ_NO_ZLIB_COMPATIBLE_NAME to disable zlib names, to prevent conflicts against stock zlib. */
/*#define MINIZ_NO_ZLIB_COMPATIBLE_NAMES */

/* Define MINIZ_NO_MALLOC to disable all calls to malloc, free, and realloc. 
   Note if MINIZ_NO_MALLOC is defined then the user must always provide custom user alloc/free/realloc
   callbacks to the zlib and archive API's, and a few stand-alone helper API's which don't provide custom user
   functions (such as tdefl_compress_mem_to_heap() and tinfl_decompress_mem_to_heap()) won't work. */
/*#define MINIZ_NO_MALLOC */

#ifdef MINIZ_NO_INFLATE_APIS
#define MINIZ_NO_ARCHIVE_APIS
#endif

#ifdef MINIZ_NO_DEFLATE_APIS
#define MINIZ_NO_ARCHIVE_WRITING_APIS
#endif

#if defined(__TINYC__) && (defined(__linux) || defined(__linux__))
/* TODO: Work around "error: include file 'sys\utime.h' when compiling with tcc on Linux */
#define MINIZ_NO_TIME
#endif

#include <stddef.h>

#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_ARCHIVE_APIS)
#include <time.h>
#endif

#if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) || defined(__i386) || defined(__i486__) || defined(__i486) || defined(i386) || defined(__ia64__) || defined(__x86_64__)
/* MINIZ_X86_OR_X64_CPU is only used to help set the below macros. */
#define MINIZ_X86_OR_X64_CPU 1
#else
#define MINIZ_X86_OR_X64_CPU 0
#endif

/* Set MINIZ_LITTLE_ENDIAN only if not set */
#if !defined(MINIZ_LITTLE_ENDIAN)
#if defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__)

#if (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
/* Set MINIZ_LITTLE_ENDIAN to 1 if the processor is little endian. */
#define MINIZ_LITTLE_ENDIAN 1
#else
#define MINIZ_LITTLE_ENDIAN 0
#endif

#else

#if MINIZ_X86_OR_X64_CPU
#define MINIZ_LITTLE_ENDIAN 1
#else
#define MINIZ_LITTLE_ENDIAN 0
#endif

#endif
#endif

/* Using unaligned loads and stores causes errors when using UBSan */
#if defined(__has_feature)
#if __has_feature(undefined_behavior_sanitizer)
#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 0
#endif
#endif

/* Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES only if not set */
#if !defined(MINIZ_USE_UNALIGNED_LOADS_AND_STORES)
#if MINIZ_X86_OR_X64_CPU
/* Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES to 1 on CPU's that permit efficient integer loads and stores from unaligned addresses. */
#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 0
#define MINIZ_UNALIGNED_USE_MEMCPY
#else
#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 0
#endif
#endif

#if defined(_M_X64) || defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__) || defined(__ia64__) || defined(__x86_64__)
/* Set MINIZ_HAS_64BIT_REGISTERS to 1 if operations on 64-bit integers are reasonably fast (and don't involve compiler generated calls to helper functions). */
#define MINIZ_HAS_64BIT_REGISTERS 1
#else
#define MINIZ_HAS_64BIT_REGISTERS 0
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* ------------------- zlib-style API Definitions. */

/* For more compatibility with zlib, miniz.c uses unsigned long for some parameters/struct members. Beware: mz_ulong can be either 32 or 64-bits! */
typedef unsigned long mz_ulong;

/* mz_free() internally uses the MZ_FREE() macro (which by default calls free() unless you've modified the MZ_MALLOC macro) to release a block allocated from the heap. */
MINIZ_EXPORT void mz_free(void *p);

#define MZ_ADLER32_INIT (1)
/* mz_adler32() returns the initial adler-32 value to use when called with ptr==NULL. */
MINIZ_EXPORT mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len);

#define MZ_CRC32_INIT (0)
/* mz_crc32() returns the initial CRC-32 value to use when called with ptr==NULL. */
MINIZ_EXPORT mz_ulong mz_crc32(mz_ulong crc, const unsigned char *ptr, size_t buf_len);

/* Compression strategies. */
enum
{
    MZ_DEFAULT_STRATEGY = 0,
    MZ_FILTERED = 1,
    MZ_HUFFMAN_ONLY = 2,
    MZ_RLE = 3,
    MZ_FIXED = 4
};

/* Method */
#define MZ_DEFLATED 8

/* Heap allocation callbacks.
Note that mz_alloc_func parameter types purposely differ from zlib's: items/size is size_t, not unsigned long. */
typedef void *(*mz_alloc_func)(void *opaque, size_t items, size_t size);
typedef void (*mz_free_func)(void *opaque, void *address);
typedef void *(*mz_realloc_func)(void *opaque, void *address, size_t items, size_t size);

/* Compression levels: 0-9 are the standard zlib-style levels, 10 is best possible compression (not zlib compatible, and may be very slow), MZ_DEFAULT_COMPRESSION=MZ_DEFAULT_LEVEL. */
enum
{
    MZ_NO_COMPRESSION = 0,
    MZ_BEST_SPEED = 1,
    MZ_BEST_COMPRESSION = 9,
    MZ_UBER_COMPRESSION = 10,
    MZ_DEFAULT_LEVEL = 6,
    MZ_DEFAULT_COMPRESSION = -1
};

#define MZ_VERSION "11.0.2"
#define MZ_VERNUM 0xB002
#define MZ_VER_MAJOR 11
#define MZ_VER_MINOR 2
#define MZ_VER_REVISION 0
#define MZ_VER_SUBREVISION 0

#ifndef MINIZ_NO_ZLIB_APIS

/* Flush values. For typical usage you only need MZ_NO_FLUSH and MZ_FINISH. The other values are for advanced use (refer to the zlib docs). */
enum
{
    MZ_NO_FLUSH = 0,
    MZ_PARTIAL_FLUSH = 1,
    MZ_SYNC_FLUSH = 2,
    MZ_FULL_FLUSH = 3,
    MZ_FINISH = 4,
    MZ_BLOCK = 5
};

/* Return status codes. MZ_PARAM_ERROR is non-standard. */
enum
{
    MZ_OK = 0,
    MZ_STREAM_END = 1,
    MZ_NEED_DICT = 2,
    MZ_ERRNO = -1,
    MZ_STREAM_ERROR = -2,
    MZ_DATA_ERROR = -3,
    MZ_MEM_ERROR = -4,
    MZ_BUF_ERROR = -5,
    MZ_VERSION_ERROR = -6,
    MZ_PARAM_ERROR = -10000
};

/* Window bits */
#define MZ_DEFAULT_WINDOW_BITS 15

struct mz_internal_state;

/* Compression/decompression stream struct. */
typedef struct mz_stream_s
{
    const unsigned char *next_in; /* pointer to next byte to read */
    unsigned int avail_in;        /* number of bytes available at next_in */
    mz_ulong total_in;            /* total number of bytes consumed so far */

    unsigned char *next_out; /* pointer to next byte to write */
    unsigned int avail_out;  /* number of bytes that can be written to next_out */
    mz_ulong total_out;      /* total number of bytes produced so far */

    char *msg;                       /* error msg (unused) */
    struct mz_internal_state *state; /* internal state, allocated by zalloc/zfree */

    mz_alloc_func zalloc; /* optional heap allocation function (defaults to malloc) */
    mz_free_func zfree;   /* optional heap free function (defaults to free) */
    void *opaque;         /* heap alloc function user pointer */

    int data_type;     /* data_type (unused) */
    mz_ulong adler;    /* adler32 of the source or uncompressed data */
    mz_ulong reserved; /* not used */
} mz_stream;

typedef mz_stream *mz_streamp;

/* Returns the version string of miniz.c. */
MINIZ_EXPORT const char *mz_version(void);

#ifndef MINIZ_NO_DEFLATE_APIS

/* mz_deflateInit() initializes a compressor with default options: */
/* Parameters: */
/*  pStream must point to an initialized mz_stream struct. */
/*  level must be between [MZ_NO_COMPRESSION, MZ_BEST_COMPRESSION]. */
/*  level 1 enables a specially optimized compression function that's been optimized purely for performance, not ratio. */
/*  (This special func. is currently only enabled when MINIZ_USE_UNALIGNED_LOADS_AND_STORES and MINIZ_LITTLE_ENDIAN are defined.) */
/* Return values: */
/*  MZ_OK on success. */
/*  MZ_STREAM_ERROR if the stream is bogus. */
/*  MZ_PARAM_ERROR if the input parameters are bogus. */
/*  MZ_MEM_ERROR on out of memory. */
MINIZ_EXPORT int mz_deflateInit(mz_streamp pStream, int level);

/* mz_deflateInit2() is like mz_deflate(), except with more control: */
/* Additional parameters: */
/*   method must be MZ_DEFLATED */
/*   window_bits must be MZ_DEFAULT_WINDOW_BITS (to wrap the deflate stream with zlib header/adler-32 footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate/no header or footer) */
/*   mem_level must be between [1, 9] (it's checked but ignored by miniz.c) */
MINIZ_EXPORT int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy);

/* Quickly resets a compressor without having to reallocate anything. Same as calling mz_deflateEnd() followed by mz_deflateInit()/mz_deflateInit2(). */
MINIZ_EXPORT int mz_deflateReset(mz_streamp pStream);

/* mz_deflate() compresses the input to output, consuming as much of the input and producing as much output as possible. */
/* Parameters: */
/*   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members. */
/*   flush may be MZ_NO_FLUSH, MZ_PARTIAL_FLUSH/MZ_SYNC_FLUSH, MZ_FULL_FLUSH, or MZ_FINISH. */
/* Return values: */
/*   MZ_OK on success (when flushing, or if more input is needed but not available, and/or there's more output to be written but the output buffer is full). */
/*   MZ_STREAM_END if all input has been consumed and all output bytes have been written. Don't call mz_deflate() on the stream anymore. */
/*   MZ_STREAM_ERROR if the stream is bogus. */
/*   MZ_PARAM_ERROR if one of the parameters is invalid. */
/*   MZ_BUF_ERROR if no forward progress is possible because the input and/or output buffers are empty. (Fill up the input buffer or free up some output space and try again.) */
MINIZ_EXPORT int mz_deflate(mz_streamp pStream, int flush);

/* mz_deflateEnd() deinitializes a compressor: */
/* Return values: */
/*  MZ_OK on success. */
/*  MZ_STREAM_ERROR if the stream is bogus. */
MINIZ_EXPORT int mz_deflateEnd(mz_streamp pStream);

/* mz_deflateBound() returns a (very) conservative upper bound on the amount of data that could be generated by deflate(), assuming flush is set to only MZ_NO_FLUSH or MZ_FINISH. */
MINIZ_EXPORT mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len);

/* Single-call compression functions mz_compress() and mz_compress2(): */
/* Returns MZ_OK on success, or one of the error codes from mz_deflate() on failure. */
MINIZ_EXPORT int mz_compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len);
MINIZ_EXPORT int mz_compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, int level);

/* mz_compressBound() returns a (very) conservative upper bound on the amount of data that could be generated by calling mz_compress(). */
MINIZ_EXPORT mz_ulong mz_compressBound(mz_ulong source_len);

#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/

#ifndef MINIZ_NO_INFLATE_APIS

/* Initializes a decompressor. */
MINIZ_EXPORT int mz_inflateInit(mz_streamp pStream);

/* mz_inflateInit2() is like mz_inflateInit() with an additional option that controls the window size and whether or not the stream has been wrapped with a zlib header/footer: */
/* window_bits must be MZ_DEFAULT_WINDOW_BITS (to parse zlib header/footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate). */
MINIZ_EXPORT int mz_inflateInit2(mz_streamp pStream, int window_bits);

/* Quickly resets a compressor without having to reallocate anything. Same as calling mz_inflateEnd() followed by mz_inflateInit()/mz_inflateInit2(). */
MINIZ_EXPORT int mz_inflateReset(mz_streamp pStream);

/* Decompresses the input stream to the output, consuming only as much of the input as needed, and writing as much to the output as possible. */
/* Parameters: */
/*   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members. */
/*   flush may be MZ_NO_FLUSH, MZ_SYNC_FLUSH, or MZ_FINISH. */
/*   On the first call, if flush is MZ_FINISH it's assumed the input and output buffers are both sized large enough to decompress the entire stream in a single call (this is slightly faster). */
/*   MZ_FINISH implies that there are no more source bytes available beside what's already in the input buffer, and that the output buffer is large enough to hold the rest of the decompressed data. */
/* Return values: */
/*   MZ_OK on success. Either more input is needed but not available, and/or there's more output to be written but the output buffer is full. */
/*   MZ_STREAM_END if all needed input has been consumed and all output bytes have been written. For zlib streams, the adler-32 of the decompressed data has also been verified. */
/*   MZ_STREAM_ERROR if the stream is bogus. */
/*   MZ_DATA_ERROR if the deflate stream is invalid. */
/*   MZ_PARAM_ERROR if one of the parameters is invalid. */
/*   MZ_BUF_ERROR if no forward progress is possible because the input buffer is empty but the inflater needs more input to continue, or if the output buffer is not large enough. Call mz_inflate() again */
/*   with more input data, or with more room in the output buffer (except when using single call decompression, described above). */
MINIZ_EXPORT int mz_inflate(mz_streamp pStream, int flush);

/* Deinitializes a decompressor. */
MINIZ_EXPORT int mz_inflateEnd(mz_streamp pStream);

/* Single-call decompression. */
/* Returns MZ_OK on success, or one of the error codes from mz_inflate() on failure. */
MINIZ_EXPORT int mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len);
MINIZ_EXPORT int mz_uncompress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong *pSource_len);
#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/

/* Returns a string description of the specified error code, or NULL if the error code is invalid. */
MINIZ_EXPORT const char *mz_error(int err);

/* Redefine zlib-compatible names to miniz equivalents, so miniz.c can be used as a drop-in replacement for the subset of zlib that miniz.c supports. */
/* Define MINIZ_NO_ZLIB_COMPATIBLE_NAMES to disable zlib-compatibility if you use zlib in the same project. */
#ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES
typedef unsigned char Byte;
typedef unsigned int uInt;
typedef mz_ulong uLong;
typedef Byte Bytef;
typedef uInt uIntf;
typedef char charf;
typedef int intf;
typedef void *voidpf;
typedef uLong uLongf;
typedef void *voidp;
typedef void *const voidpc;
#define Z_NULL 0
#define Z_NO_FLUSH MZ_NO_FLUSH
#define Z_PARTIAL_FLUSH MZ_PARTIAL_FLUSH
#define Z_SYNC_FLUSH MZ_SYNC_FLUSH
#define Z_FULL_FLUSH MZ_FULL_FLUSH
#define Z_FINISH MZ_FINISH
#define Z_BLOCK MZ_BLOCK
#define Z_OK MZ_OK
#define Z_STREAM_END MZ_STREAM_END
#define Z_NEED_DICT MZ_NEED_DICT
#define Z_ERRNO MZ_ERRNO
#define Z_STREAM_ERROR MZ_STREAM_ERROR
#define Z_DATA_ERROR MZ_DATA_ERROR
#define Z_MEM_ERROR MZ_MEM_ERROR
#define Z_BUF_ERROR MZ_BUF_ERROR
#define Z_VERSION_ERROR MZ_VERSION_ERROR
#define Z_PARAM_ERROR MZ_PARAM_ERROR
#define Z_NO_COMPRESSION MZ_NO_COMPRESSION
#define Z_BEST_SPEED MZ_BEST_SPEED
#define Z_BEST_COMPRESSION MZ_BEST_COMPRESSION
#define Z_DEFAULT_COMPRESSION MZ_DEFAULT_COMPRESSION
#define Z_DEFAULT_STRATEGY MZ_DEFAULT_STRATEGY
#define Z_FILTERED MZ_FILTERED
#define Z_HUFFMAN_ONLY MZ_HUFFMAN_ONLY
#define Z_RLE MZ_RLE
#define Z_FIXED MZ_FIXED
#define Z_DEFLATED MZ_DEFLATED
#define Z_DEFAULT_WINDOW_BITS MZ_DEFAULT_WINDOW_BITS
#define alloc_func mz_alloc_func
#define free_func mz_free_func
#define internal_state mz_internal_state
#define z_stream mz_stream

#ifndef MINIZ_NO_DEFLATE_APIS
#define deflateInit mz_deflateInit
#define deflateInit2 mz_deflateInit2
#define deflateReset mz_deflateReset
#define deflate mz_deflate
#define deflateEnd mz_deflateEnd
#define deflateBound mz_deflateBound
#define compress mz_compress
#define compress2 mz_compress2
#define compressBound mz_compressBound
#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/

#ifndef MINIZ_NO_INFLATE_APIS
#define inflateInit mz_inflateInit
#define inflateInit2 mz_inflateInit2
#define inflateReset mz_inflateReset
#define inflate mz_inflate
#define inflateEnd mz_inflateEnd
#define uncompress mz_uncompress
#define uncompress2 mz_uncompress2
#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/

#define crc32 mz_crc32
#define adler32 mz_adler32
#define MAX_WBITS 15
#define MAX_MEM_LEVEL 9
#define zError mz_error
#define ZLIB_VERSION MZ_VERSION
#define ZLIB_VERNUM MZ_VERNUM
#define ZLIB_VER_MAJOR MZ_VER_MAJOR
#define ZLIB_VER_MINOR MZ_VER_MINOR
#define ZLIB_VER_REVISION MZ_VER_REVISION
#define ZLIB_VER_SUBREVISION MZ_VER_SUBREVISION
#define zlibVersion mz_version
#define zlib_version mz_version()
#endif /* #ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES */

#endif /* MINIZ_NO_ZLIB_APIS */

#ifdef __cplusplus
}
#endif






#include <assert.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>



/* ------------------- Types and macros */
typedef unsigned char mz_uint8;
typedef signed short mz_int16;
typedef unsigned short mz_uint16;
typedef unsigned int mz_uint32;
typedef unsigned int mz_uint;
typedef int64_t mz_int64;
typedef uint64_t mz_uint64;
typedef int mz_bool;

#define MZ_FALSE (0)
#define MZ_TRUE (1)

/* Works around MSVC's spammy "warning C4127: conditional expression is constant" message. */
#ifdef _MSC_VER
#define MZ_MACRO_END while (0, 0)
#else
#define MZ_MACRO_END while (0)
#endif

#ifdef MINIZ_NO_STDIO
#define MZ_FILE void *
#else
#include <stdio.h>
#define MZ_FILE FILE
#endif /* #ifdef MINIZ_NO_STDIO */

#ifdef MINIZ_NO_TIME
typedef struct mz_dummy_time_t_tag
{
    mz_uint32 m_dummy1;
    mz_uint32 m_dummy2;
} mz_dummy_time_t;
#define MZ_TIME_T mz_dummy_time_t
#else
#define MZ_TIME_T time_t
#endif

#define MZ_ASSERT(x) assert(x)

#ifdef MINIZ_NO_MALLOC
#define MZ_MALLOC(x) NULL
#define MZ_FREE(x) (void)x, ((void)0)
#define MZ_REALLOC(p, x) NULL
#else
#define MZ_MALLOC(x) malloc(x)
#define MZ_FREE(x) free(x)
#define MZ_REALLOC(p, x) realloc(p, x)
#endif

#define MZ_MAX(a, b) (((a) > (b)) ? (a) : (b))
#define MZ_MIN(a, b) (((a) < (b)) ? (a) : (b))
#define MZ_CLEAR_OBJ(obj) memset(&(obj), 0, sizeof(obj))
#define MZ_CLEAR_ARR(obj) memset((obj), 0, sizeof(obj))
#define MZ_CLEAR_PTR(obj) memset((obj), 0, sizeof(*obj))

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
#define MZ_READ_LE16(p) *((const mz_uint16 *)(p))
#define MZ_READ_LE32(p) *((const mz_uint32 *)(p))
#else
#define MZ_READ_LE16(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U))
#define MZ_READ_LE32(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U) | ((mz_uint32)(((const mz_uint8 *)(p))[2]) << 16U) | ((mz_uint32)(((const mz_uint8 *)(p))[3]) << 24U))
#endif

#define MZ_READ_LE64(p) (((mz_uint64)MZ_READ_LE32(p)) | (((mz_uint64)MZ_READ_LE32((const mz_uint8 *)(p) + sizeof(mz_uint32))) << 32U))

#ifdef _MSC_VER
#define MZ_FORCEINLINE __forceinline
#elif defined(__GNUC__)
#define MZ_FORCEINLINE __inline__ __attribute__((__always_inline__))
#else
#define MZ_FORCEINLINE inline
#endif

#ifdef __cplusplus
extern "C" {
#endif

extern MINIZ_EXPORT void *miniz_def_alloc_func(void *opaque, size_t items, size_t size);
extern MINIZ_EXPORT void miniz_def_free_func(void *opaque, void *address);
extern MINIZ_EXPORT void *miniz_def_realloc_func(void *opaque, void *address, size_t items, size_t size);

#define MZ_UINT16_MAX (0xFFFFU)
#define MZ_UINT32_MAX (0xFFFFFFFFU)

#ifdef __cplusplus
}
#endif
 


#ifndef MINIZ_NO_DEFLATE_APIS

#ifdef __cplusplus
extern "C" {
#endif
/* ------------------- Low-level Compression API Definitions */

/* Set TDEFL_LESS_MEMORY to 1 to use less memory (compression will be slightly slower, and raw/dynamic blocks will be output more frequently). */
#define TDEFL_LESS_MEMORY 0

/* tdefl_init() compression flags logically OR'd together (low 12 bits contain the max. number of probes per dictionary search): */
/* TDEFL_DEFAULT_MAX_PROBES: The compressor defaults to 128 dictionary probes per dictionary search. 0=Huffman only, 1=Huffman+LZ (fastest/crap compression), 4095=Huffman+LZ (slowest/best compression). */
enum
{
    TDEFL_HUFFMAN_ONLY = 0,
    TDEFL_DEFAULT_MAX_PROBES = 128,
    TDEFL_MAX_PROBES_MASK = 0xFFF
};

/* TDEFL_WRITE_ZLIB_HEADER: If set, the compressor outputs a zlib header before the deflate data, and the Adler-32 of the source data at the end. Otherwise, you'll get raw deflate data. */
/* TDEFL_COMPUTE_ADLER32: Always compute the adler-32 of the input data (even when not writing zlib headers). */
/* TDEFL_GREEDY_PARSING_FLAG: Set to use faster greedy parsing, instead of more efficient lazy parsing. */
/* TDEFL_NONDETERMINISTIC_PARSING_FLAG: Enable to decrease the compressor's initialization time to the minimum, but the output may vary from run to run given the same input (depending on the contents of memory). */
/* TDEFL_RLE_MATCHES: Only look for RLE matches (matches with a distance of 1) */
/* TDEFL_FILTER_MATCHES: Discards matches <= 5 chars if enabled. */
/* TDEFL_FORCE_ALL_STATIC_BLOCKS: Disable usage of optimized Huffman tables. */
/* TDEFL_FORCE_ALL_RAW_BLOCKS: Only use raw (uncompressed) deflate blocks. */
/* The low 12 bits are reserved to control the max # of hash probes per dictionary lookup (see TDEFL_MAX_PROBES_MASK). */
enum
{
    TDEFL_WRITE_ZLIB_HEADER = 0x01000,
    TDEFL_COMPUTE_ADLER32 = 0x02000,
    TDEFL_GREEDY_PARSING_FLAG = 0x04000,
    TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,
    TDEFL_RLE_MATCHES = 0x10000,
    TDEFL_FILTER_MATCHES = 0x20000,
    TDEFL_FORCE_ALL_STATIC_BLOCKS = 0x40000,
    TDEFL_FORCE_ALL_RAW_BLOCKS = 0x80000
};

/* High level compression functions: */
/* tdefl_compress_mem_to_heap() compresses a block in memory to a heap block allocated via malloc(). */
/* On entry: */
/*  pSrc_buf, src_buf_len: Pointer and size of source block to compress. */
/*  flags: The max match finder probes (default is 128) logically OR'd against the above flags. Higher probes are slower but improve compression. */
/* On return: */
/*  Function returns a pointer to the compressed data, or NULL on failure. */
/*  *pOut_len will be set to the compressed data's size, which could be larger than src_buf_len on uncompressible data. */
/*  The caller must free() the returned block when it's no longer needed. */
MINIZ_EXPORT void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);

/* tdefl_compress_mem_to_mem() compresses a block in memory to another block in memory. */
/* Returns 0 on failure. */
MINIZ_EXPORT size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);

/* Compresses an image to a compressed PNG file in memory. */
/* On entry: */
/*  pImage, w, h, and num_chans describe the image to compress. num_chans may be 1, 2, 3, or 4. */
/*  The image pitch in bytes per scanline will be w*num_chans. The leftmost pixel on the top scanline is stored first in memory. */
/*  level may range from [0,10], use MZ_NO_COMPRESSION, MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc. or a decent default is MZ_DEFAULT_LEVEL */
/*  If flip is true, the image will be flipped on the Y axis (useful for OpenGL apps). */
/* On return: */
/*  Function returns a pointer to the compressed data, or NULL on failure. */
/*  *pLen_out will be set to the size of the PNG image file. */
/*  The caller must mz_free() the returned heap block (which will typically be larger than *pLen_out) when it's no longer needed. */
MINIZ_EXPORT void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip);
MINIZ_EXPORT void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h, int num_chans, size_t *pLen_out);

/* Output stream interface. The compressor uses this interface to write compressed data. It'll typically be called TDEFL_OUT_BUF_SIZE at a time. */
typedef mz_bool (*tdefl_put_buf_func_ptr)(const void *pBuf, int len, void *pUser);

/* tdefl_compress_mem_to_output() compresses a block to an output stream. The above helpers use this function internally. */
MINIZ_EXPORT mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

enum
{
    TDEFL_MAX_HUFF_TABLES = 3,
    TDEFL_MAX_HUFF_SYMBOLS_0 = 288,
    TDEFL_MAX_HUFF_SYMBOLS_1 = 32,
    TDEFL_MAX_HUFF_SYMBOLS_2 = 19,
    TDEFL_LZ_DICT_SIZE = 32768,
    TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1,
    TDEFL_MIN_MATCH_LEN = 3,
    TDEFL_MAX_MATCH_LEN = 258
};

/* TDEFL_OUT_BUF_SIZE MUST be large enough to hold a single entire compressed output block (using static/fixed Huffman codes). */
#if TDEFL_LESS_MEMORY
enum
{
    TDEFL_LZ_CODE_BUF_SIZE = 24 * 1024,
    TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
    TDEFL_MAX_HUFF_SYMBOLS = 288,
    TDEFL_LZ_HASH_BITS = 12,
    TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
    TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
    TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
};
#else
enum
{
    TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024,
    TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
    TDEFL_MAX_HUFF_SYMBOLS = 288,
    TDEFL_LZ_HASH_BITS = 15,
    TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
    TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
    TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
};
#endif

/* The low-level tdefl functions below may be used directly if the above helper functions aren't flexible enough. The low-level functions don't make any heap allocations, unlike the above helper functions. */
typedef enum {
    TDEFL_STATUS_BAD_PARAM = -2,
    TDEFL_STATUS_PUT_BUF_FAILED = -1,
    TDEFL_STATUS_OKAY = 0,
    TDEFL_STATUS_DONE = 1
} tdefl_status;

/* Must map to MZ_NO_FLUSH, MZ_SYNC_FLUSH, etc. enums */
typedef enum {
    TDEFL_NO_FLUSH = 0,
    TDEFL_SYNC_FLUSH = 2,
    TDEFL_FULL_FLUSH = 3,
    TDEFL_FINISH = 4
} tdefl_flush;

/* tdefl's compression state structure. */
typedef struct
{
    tdefl_put_buf_func_ptr m_pPut_buf_func;
    void *m_pPut_buf_user;
    mz_uint m_flags, m_max_probes[2];
    int m_greedy_parsing;
    mz_uint m_adler32, m_lookahead_pos, m_lookahead_size, m_dict_size;
    mz_uint8 *m_pLZ_code_buf, *m_pLZ_flags, *m_pOutput_buf, *m_pOutput_buf_end;
    mz_uint m_num_flags_left, m_total_lz_bytes, m_lz_code_buf_dict_pos, m_bits_in, m_bit_buffer;
    mz_uint m_saved_match_dist, m_saved_match_len, m_saved_lit, m_output_flush_ofs, m_output_flush_remaining, m_finished, m_block_index, m_wants_to_finish;
    tdefl_status m_prev_return_status;
    const void *m_pIn_buf;
    void *m_pOut_buf;
    size_t *m_pIn_buf_size, *m_pOut_buf_size;
    tdefl_flush m_flush;
    const mz_uint8 *m_pSrc;
    size_t m_src_buf_left, m_out_buf_ofs;
    mz_uint8 m_dict[TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN - 1];
    mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
    mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
    mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
    mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE];
    mz_uint16 m_next[TDEFL_LZ_DICT_SIZE];
    mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE];
    mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE];
} tdefl_compressor;

/* Initializes the compressor. */
/* There is no corresponding deinit() function because the tdefl API's do not dynamically allocate memory. */
/* pBut_buf_func: If NULL, output data will be supplied to the specified callback. In this case, the user should call the tdefl_compress_buffer() API for compression. */
/* If pBut_buf_func is NULL the user should always call the tdefl_compress() API. */
/* flags: See the above enums (TDEFL_HUFFMAN_ONLY, TDEFL_WRITE_ZLIB_HEADER, etc.) */
MINIZ_EXPORT tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

/* Compresses a block of data, consuming as much of the specified input buffer as possible, and writing as much compressed data to the specified output buffer as possible. */
MINIZ_EXPORT tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pIn_buf_size, void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush);

/* tdefl_compress_buffer() is only usable when the tdefl_init() is called with a non-NULL tdefl_put_buf_func_ptr. */
/* tdefl_compress_buffer() always consumes the entire input buffer. */
MINIZ_EXPORT tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush);

MINIZ_EXPORT tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d);
MINIZ_EXPORT mz_uint32 tdefl_get_adler32(tdefl_compressor *d);

/* Create tdefl_compress() flags given zlib-style compression parameters. */
/* level may range from [0,10] (where 10 is absolute max compression, but may be much slower on some files) */
/* window_bits may be -15 (raw deflate) or 15 (zlib) */
/* strategy may be either MZ_DEFAULT_STRATEGY, MZ_FILTERED, MZ_HUFFMAN_ONLY, MZ_RLE, or MZ_FIXED */
MINIZ_EXPORT mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy);

#ifndef MINIZ_NO_MALLOC
/* Allocate the tdefl_compressor structure in C so that */
/* non-C language bindings to tdefl_ API don't need to worry about */
/* structure size and allocation mechanism. */
MINIZ_EXPORT tdefl_compressor *tdefl_compressor_alloc(void);
MINIZ_EXPORT void tdefl_compressor_free(tdefl_compressor *pComp);
#endif

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/
 

/* ------------------- Low-level Decompression API Definitions */

#ifndef MINIZ_NO_INFLATE_APIS

#ifdef __cplusplus
extern "C" {
#endif
/* Decompression flags used by tinfl_decompress(). */
/* TINFL_FLAG_PARSE_ZLIB_HEADER: If set, the input has a valid zlib header and ends with an adler32 checksum (it's a valid zlib stream). Otherwise, the input is a raw deflate stream. */
/* TINFL_FLAG_HAS_MORE_INPUT: If set, there are more input bytes available beyond the end of the supplied input buffer. If clear, the input buffer contains all remaining input. */
/* TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF: If set, the output buffer is large enough to hold the entire decompressed stream. If clear, the output buffer is at least the size of the dictionary (typically 32KB). */
/* TINFL_FLAG_COMPUTE_ADLER32: Force adler-32 checksum computation of the decompressed bytes. */
enum
{
    TINFL_FLAG_PARSE_ZLIB_HEADER = 1,
    TINFL_FLAG_HAS_MORE_INPUT = 2,
    TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,
    TINFL_FLAG_COMPUTE_ADLER32 = 8
};

/* High level decompression functions: */
/* tinfl_decompress_mem_to_heap() decompresses a block in memory to a heap block allocated via malloc(). */
/* On entry: */
/*  pSrc_buf, src_buf_len: Pointer and size of the Deflate or zlib source data to decompress. */
/* On return: */
/*  Function returns a pointer to the decompressed data, or NULL on failure. */
/*  *pOut_len will be set to the decompressed data's size, which could be larger than src_buf_len on uncompressible data. */
/*  The caller must call mz_free() on the returned block when it's no longer needed. */
MINIZ_EXPORT void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);

/* tinfl_decompress_mem_to_mem() decompresses a block in memory to another block in memory. */
/* Returns TINFL_DECOMPRESS_MEM_TO_MEM_FAILED on failure, or the number of bytes written on success. */
#define TINFL_DECOMPRESS_MEM_TO_MEM_FAILED ((size_t)(-1))
MINIZ_EXPORT size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);

/* tinfl_decompress_mem_to_callback() decompresses a block in memory to an internal 32KB buffer, and a user provided callback function will be called to flush the buffer. */
/* Returns 1 on success or 0 on failure. */
typedef int (*tinfl_put_buf_func_ptr)(const void *pBuf, int len, void *pUser);
MINIZ_EXPORT int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

struct tinfl_decompressor_tag;
typedef struct tinfl_decompressor_tag tinfl_decompressor;

#ifndef MINIZ_NO_MALLOC
/* Allocate the tinfl_decompressor structure in C so that */
/* non-C language bindings to tinfl_ API don't need to worry about */
/* structure size and allocation mechanism. */
MINIZ_EXPORT tinfl_decompressor *tinfl_decompressor_alloc(void);
MINIZ_EXPORT void tinfl_decompressor_free(tinfl_decompressor *pDecomp);
#endif

/* Max size of LZ dictionary. */
#define TINFL_LZ_DICT_SIZE 32768

/* Return status. */
typedef enum {
    /* This flags indicates the inflator needs 1 or more input bytes to make forward progress, but the caller is indicating that no more are available. The compressed data */
    /* is probably corrupted. If you call the inflator again with more bytes it'll try to continue processing the input but this is a BAD sign (either the data is corrupted or you called it incorrectly). */
    /* If you call it again with no input you'll just get TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS again. */
    TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS = -4,

    /* This flag indicates that one or more of the input parameters was obviously bogus. (You can try calling it again, but if you get this error the calling code is wrong.) */
    TINFL_STATUS_BAD_PARAM = -3,

    /* This flags indicate the inflator is finished but the adler32 check of the uncompressed data didn't match. If you call it again it'll return TINFL_STATUS_DONE. */
    TINFL_STATUS_ADLER32_MISMATCH = -2,

    /* This flags indicate the inflator has somehow failed (bad code, corrupted input, etc.). If you call it again without resetting via tinfl_init() it it'll just keep on returning the same status failure code. */
    TINFL_STATUS_FAILED = -1,

    /* Any status code less than TINFL_STATUS_DONE must indicate a failure. */

    /* This flag indicates the inflator has returned every byte of uncompressed data that it can, has consumed every byte that it needed, has successfully reached the end of the deflate stream, and */
    /* if zlib headers and adler32 checking enabled that it has successfully checked the uncompressed data's adler32. If you call it again you'll just get TINFL_STATUS_DONE over and over again. */
    TINFL_STATUS_DONE = 0,

    /* This flag indicates the inflator MUST have more input data (even 1 byte) before it can make any more forward progress, or you need to clear the TINFL_FLAG_HAS_MORE_INPUT */
    /* flag on the next call if you don't have any more source data. If the source data was somehow corrupted it's also possible (but unlikely) for the inflator to keep on demanding input to */
    /* proceed, so be sure to properly set the TINFL_FLAG_HAS_MORE_INPUT flag. */
    TINFL_STATUS_NEEDS_MORE_INPUT = 1,

    /* This flag indicates the inflator definitely has 1 or more bytes of uncompressed data available, but it cannot write this data into the output buffer. */
    /* Note if the source compressed data was corrupted it's possible for the inflator to return a lot of uncompressed data to the caller. I've been assuming you know how much uncompressed data to expect */
    /* (either exact or worst case) and will stop calling the inflator and fail after receiving too much. In pure streaming scenarios where you have no idea how many bytes to expect this may not be possible */
    /* so I may need to add some code to address this. */
    TINFL_STATUS_HAS_MORE_OUTPUT = 2
} tinfl_status;

/* Initializes the decompressor to its initial state. */
#define tinfl_init(r)     \
    do                    \
    {                     \
        (r)->m_state = 0; \
    }                     \
    MZ_MACRO_END
#define tinfl_get_adler32(r) (r)->m_check_adler32

/* Main low-level decompressor coroutine function. This is the only function actually needed for decompression. All the other functions are just high-level helpers for improved usability. */
/* This is a universal API, i.e. it can be used as a building block to build any desired higher level decompression API. In the limit case, it can be called once per every byte input or output. */
MINIZ_EXPORT tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags);

/* Internal/private bits follow. */
enum
{
    TINFL_MAX_HUFF_TABLES = 3,
    TINFL_MAX_HUFF_SYMBOLS_0 = 288,
    TINFL_MAX_HUFF_SYMBOLS_1 = 32,
    TINFL_MAX_HUFF_SYMBOLS_2 = 19,
    TINFL_FAST_LOOKUP_BITS = 10,
    TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS
};

#if MINIZ_HAS_64BIT_REGISTERS
#define TINFL_USE_64BIT_BITBUF 1
#else
#define TINFL_USE_64BIT_BITBUF 0
#endif

#if TINFL_USE_64BIT_BITBUF
typedef mz_uint64 tinfl_bit_buf_t;
#define TINFL_BITBUF_SIZE (64)
#else
typedef mz_uint32 tinfl_bit_buf_t;
#define TINFL_BITBUF_SIZE (32)
#endif

struct tinfl_decompressor_tag
{
    mz_uint32 m_state, m_num_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];
    tinfl_bit_buf_t m_bit_buf;
    size_t m_dist_from_out_buf_start;
    mz_int16 m_look_up[TINFL_MAX_HUFF_TABLES][TINFL_FAST_LOOKUP_SIZE];
    mz_int16 m_tree_0[TINFL_MAX_HUFF_SYMBOLS_0 * 2];
    mz_int16 m_tree_1[TINFL_MAX_HUFF_SYMBOLS_1 * 2];
    mz_int16 m_tree_2[TINFL_MAX_HUFF_SYMBOLS_2 * 2];
    mz_uint8 m_code_size_0[TINFL_MAX_HUFF_SYMBOLS_0];
    mz_uint8 m_code_size_1[TINFL_MAX_HUFF_SYMBOLS_1];
    mz_uint8 m_code_size_2[TINFL_MAX_HUFF_SYMBOLS_2];
    mz_uint8 m_raw_header[4], m_len_codes[TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 137];
};

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/
 



/* ------------------- ZIP archive reading/writing */

#ifndef MINIZ_NO_ARCHIVE_APIS

#ifdef __cplusplus
extern "C" {
#endif

enum
{
    /* Note: These enums can be reduced as needed to save memory or stack space - they are pretty conservative. */
    MZ_ZIP_MAX_IO_BUF_SIZE = 64 * 1024,
    MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE = 512,
    MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE = 512
};

typedef struct
{
    /* Central directory file index. */
    mz_uint32 m_file_index;

    /* Byte offset of this entry in the archive's central directory. Note we currently only support up to UINT_MAX or less bytes in the central dir. */
    mz_uint64 m_central_dir_ofs;

    /* These fields are copied directly from the zip's central dir. */
    mz_uint16 m_version_made_by;
    mz_uint16 m_version_needed;
    mz_uint16 m_bit_flag;
    mz_uint16 m_method;

    /* CRC-32 of uncompressed data. */
    mz_uint32 m_crc32;

    /* File's compressed size. */
    mz_uint64 m_comp_size;

    /* File's uncompressed size. Note, I've seen some old archives where directory entries had 512 bytes for their uncompressed sizes, but when you try to unpack them you actually get 0 bytes. */
    mz_uint64 m_uncomp_size;

    /* Zip internal and external file attributes. */
    mz_uint16 m_internal_attr;
    mz_uint32 m_external_attr;

    /* Entry's local header file offset in bytes. */
    mz_uint64 m_local_header_ofs;

    /* Size of comment in bytes. */
    mz_uint32 m_comment_size;

    /* MZ_TRUE if the entry appears to be a directory. */
    mz_bool m_is_directory;

    /* MZ_TRUE if the entry uses encryption/strong encryption (which miniz_zip doesn't support) */
    mz_bool m_is_encrypted;

    /* MZ_TRUE if the file is not encrypted, a patch file, and if it uses a compression method we support. */
    mz_bool m_is_supported;

    /* Filename. If string ends in '/' it's a subdirectory entry. */
    /* Guaranteed to be zero terminated, may be truncated to fit. */
    char m_filename[MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE];

    /* Comment field. */
    /* Guaranteed to be zero terminated, may be truncated to fit. */
    char m_comment[MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE];

#ifdef MINIZ_NO_TIME
    MZ_TIME_T m_padding;
#else
    MZ_TIME_T m_time;
#endif
} mz_zip_archive_file_stat;

typedef size_t (*mz_file_read_func)(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n);
typedef size_t (*mz_file_write_func)(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n);
typedef mz_bool (*mz_file_needs_keepalive)(void *pOpaque);

struct mz_zip_internal_state_tag;
typedef struct mz_zip_internal_state_tag mz_zip_internal_state;

typedef enum {
    MZ_ZIP_MODE_INVALID = 0,
    MZ_ZIP_MODE_READING = 1,
    MZ_ZIP_MODE_WRITING = 2,
    MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED = 3
} mz_zip_mode;

typedef enum {
    MZ_ZIP_FLAG_CASE_SENSITIVE = 0x0100,
    MZ_ZIP_FLAG_IGNORE_PATH = 0x0200,
    MZ_ZIP_FLAG_COMPRESSED_DATA = 0x0400,
    MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY = 0x0800,
    MZ_ZIP_FLAG_VALIDATE_LOCATE_FILE_FLAG = 0x1000, /* if enabled, mz_zip_reader_locate_file() will be called on each file as its validated to ensure the func finds the file in the central dir (intended for testing) */
    MZ_ZIP_FLAG_VALIDATE_HEADERS_ONLY = 0x2000,     /* validate the local headers, but don't decompress the entire file and check the crc32 */
    MZ_ZIP_FLAG_WRITE_ZIP64 = 0x4000,               /* always use the zip64 file format, instead of the original zip file format with automatic switch to zip64. Use as flags parameter with mz_zip_writer_init*_v2 */
    MZ_ZIP_FLAG_WRITE_ALLOW_READING = 0x8000,
    MZ_ZIP_FLAG_ASCII_FILENAME = 0x10000,
    /*After adding a compressed file, seek back
    to local file header and set the correct sizes*/
    MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE = 0x20000
} mz_zip_flags;

typedef enum {
    MZ_ZIP_TYPE_INVALID = 0,
    MZ_ZIP_TYPE_USER,
    MZ_ZIP_TYPE_MEMORY,
    MZ_ZIP_TYPE_HEAP,
    MZ_ZIP_TYPE_FILE,
    MZ_ZIP_TYPE_CFILE,
    MZ_ZIP_TOTAL_TYPES
} mz_zip_type;

/* miniz error codes. Be sure to update mz_zip_get_error_string() if you add or modify this enum. */
typedef enum {
    MZ_ZIP_NO_ERROR = 0,
    MZ_ZIP_UNDEFINED_ERROR,
    MZ_ZIP_TOO_MANY_FILES,
    MZ_ZIP_FILE_TOO_LARGE,
    MZ_ZIP_UNSUPPORTED_METHOD,
    MZ_ZIP_UNSUPPORTED_ENCRYPTION,
    MZ_ZIP_UNSUPPORTED_FEATURE,
    MZ_ZIP_FAILED_FINDING_CENTRAL_DIR,
    MZ_ZIP_NOT_AN_ARCHIVE,
    MZ_ZIP_INVALID_HEADER_OR_CORRUPTED,
    MZ_ZIP_UNSUPPORTED_MULTIDISK,
    MZ_ZIP_DECOMPRESSION_FAILED,
    MZ_ZIP_COMPRESSION_FAILED,
    MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE,
    MZ_ZIP_CRC_CHECK_FAILED,
    MZ_ZIP_UNSUPPORTED_CDIR_SIZE,
    MZ_ZIP_ALLOC_FAILED,
    MZ_ZIP_FILE_OPEN_FAILED,
    MZ_ZIP_FILE_CREATE_FAILED,
    MZ_ZIP_FILE_WRITE_FAILED,
    MZ_ZIP_FILE_READ_FAILED,
    MZ_ZIP_FILE_CLOSE_FAILED,
    MZ_ZIP_FILE_SEEK_FAILED,
    MZ_ZIP_FILE_STAT_FAILED,
    MZ_ZIP_INVALID_PARAMETER,
    MZ_ZIP_INVALID_FILENAME,
    MZ_ZIP_BUF_TOO_SMALL,
    MZ_ZIP_INTERNAL_ERROR,
    MZ_ZIP_FILE_NOT_FOUND,
    MZ_ZIP_ARCHIVE_TOO_LARGE,
    MZ_ZIP_VALIDATION_FAILED,
    MZ_ZIP_WRITE_CALLBACK_FAILED,
    MZ_ZIP_TOTAL_ERRORS
} mz_zip_error;

typedef struct
{
    mz_uint64 m_archive_size;
    mz_uint64 m_central_directory_file_ofs;

    /* We only support up to UINT32_MAX files in zip64 mode. */
    mz_uint32 m_total_files;
    mz_zip_mode m_zip_mode;
    mz_zip_type m_zip_type;
    mz_zip_error m_last_error;

    mz_uint64 m_file_offset_alignment;

    mz_alloc_func m_pAlloc;
    mz_free_func m_pFree;
    mz_realloc_func m_pRealloc;
    void *m_pAlloc_opaque;

    mz_file_read_func m_pRead;
    mz_file_write_func m_pWrite;
    mz_file_needs_keepalive m_pNeeds_keepalive;
    void *m_pIO_opaque;

    mz_zip_internal_state *m_pState;

} mz_zip_archive;

typedef struct
{
    mz_zip_archive *pZip;
    mz_uint flags;

    int status;

    mz_uint64 read_buf_size, read_buf_ofs, read_buf_avail, comp_remaining, out_buf_ofs, cur_file_ofs;
    mz_zip_archive_file_stat file_stat;
    void *pRead_buf;
    void *pWrite_buf;

    size_t out_blk_remain;

    tinfl_decompressor inflator;

#ifdef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
    mz_uint padding;
#else
    mz_uint file_crc32;
#endif

} mz_zip_reader_extract_iter_state;

/* -------- ZIP reading */

/* Inits a ZIP archive reader. */
/* These functions read and validate the archive's central directory. */
MINIZ_EXPORT mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint flags);

MINIZ_EXPORT mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint flags);

#ifndef MINIZ_NO_STDIO
/* Read a archive from a disk file. */
/* file_start_ofs is the file offset where the archive actually begins, or 0. */
/* actual_archive_size is the true total size of the archive, which may be smaller than the file's actual size on disk. If zero the entire file is treated as the archive. */
MINIZ_EXPORT mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags);
MINIZ_EXPORT mz_bool mz_zip_reader_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags, mz_uint64 file_start_ofs, mz_uint64 archive_size);

/* Read an archive from an already opened FILE, beginning at the current file position. */
/* The archive is assumed to be archive_size bytes long. If archive_size is 0, then the entire rest of the file is assumed to contain the archive. */
/* The FILE will NOT be closed when mz_zip_reader_end() is called. */
MINIZ_EXPORT mz_bool mz_zip_reader_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint64 archive_size, mz_uint flags);
#endif

/* Ends archive reading, freeing all allocations, and closing the input archive file if mz_zip_reader_init_file() was used. */
MINIZ_EXPORT mz_bool mz_zip_reader_end(mz_zip_archive *pZip);

/* -------- ZIP reading or writing */

/* Clears a mz_zip_archive struct to all zeros. */
/* Important: This must be done before passing the struct to any mz_zip functions. */
MINIZ_EXPORT void mz_zip_zero_struct(mz_zip_archive *pZip);

MINIZ_EXPORT mz_zip_mode mz_zip_get_mode(mz_zip_archive *pZip);
MINIZ_EXPORT mz_zip_type mz_zip_get_type(mz_zip_archive *pZip);

/* Returns the total number of files in the archive. */
MINIZ_EXPORT mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip);

MINIZ_EXPORT mz_uint64 mz_zip_get_archive_size(mz_zip_archive *pZip);
MINIZ_EXPORT mz_uint64 mz_zip_get_archive_file_start_offset(mz_zip_archive *pZip);
MINIZ_EXPORT MZ_FILE *mz_zip_get_cfile(mz_zip_archive *pZip);

/* Reads n bytes of raw archive data, starting at file offset file_ofs, to pBuf. */
MINIZ_EXPORT size_t mz_zip_read_archive_data(mz_zip_archive *pZip, mz_uint64 file_ofs, void *pBuf, size_t n);

/* All mz_zip funcs set the m_last_error field in the mz_zip_archive struct. These functions retrieve/manipulate this field. */
/* Note that the m_last_error functionality is not thread safe. */
MINIZ_EXPORT mz_zip_error mz_zip_set_last_error(mz_zip_archive *pZip, mz_zip_error err_num);
MINIZ_EXPORT mz_zip_error mz_zip_peek_last_error(mz_zip_archive *pZip);
MINIZ_EXPORT mz_zip_error mz_zip_clear_last_error(mz_zip_archive *pZip);
MINIZ_EXPORT mz_zip_error mz_zip_get_last_error(mz_zip_archive *pZip);
MINIZ_EXPORT const char *mz_zip_get_error_string(mz_zip_error mz_err);

/* MZ_TRUE if the archive file entry is a directory entry. */
MINIZ_EXPORT mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index);

/* MZ_TRUE if the file is encrypted/strong encrypted. */
MINIZ_EXPORT mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index);

/* MZ_TRUE if the compression method is supported, and the file is not encrypted, and the file is not a compressed patch file. */
MINIZ_EXPORT mz_bool mz_zip_reader_is_file_supported(mz_zip_archive *pZip, mz_uint file_index);

/* Retrieves the filename of an archive file entry. */
/* Returns the number of bytes written to pFilename, or if filename_buf_size is 0 this function returns the number of bytes needed to fully store the filename. */
MINIZ_EXPORT mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size);

/* Attempts to locates a file in the archive's central directory. */
/* Valid flags: MZ_ZIP_FLAG_CASE_SENSITIVE, MZ_ZIP_FLAG_IGNORE_PATH */
/* Returns -1 if the file cannot be found. */
MINIZ_EXPORT int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_reader_locate_file_v2(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags, mz_uint32 *file_index);

/* Returns detailed information about an archive file entry. */
MINIZ_EXPORT mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat);

/* MZ_TRUE if the file is in zip64 format. */
/* A file is considered zip64 if it contained a zip64 end of central directory marker, or if it contained any zip64 extended file information fields in the central directory. */
MINIZ_EXPORT mz_bool mz_zip_is_zip64(mz_zip_archive *pZip);

/* Returns the total central directory size in bytes. */
/* The current max supported size is <= MZ_UINT32_MAX. */
MINIZ_EXPORT size_t mz_zip_get_central_dir_size(mz_zip_archive *pZip);

/* Extracts a archive file to a memory buffer using no memory allocation. */
/* There must be at least enough room on the stack to store the inflator's state (~34KB or so). */
MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);

/* Extracts a archive file to a memory buffer. */
MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags);

/* Extracts a archive file to a dynamically allocated heap buffer. */
/* The memory will be allocated via the mz_zip_archive's alloc/realloc functions. */
/* Returns NULL and sets the last error on failure. */
MINIZ_EXPORT void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags);
MINIZ_EXPORT void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags);

/* Extracts a archive file using a callback function to output the file's data. */
MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);

/* Extract a file iteratively */
MINIZ_EXPORT mz_zip_reader_extract_iter_state* mz_zip_reader_extract_iter_new(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags);
MINIZ_EXPORT mz_zip_reader_extract_iter_state* mz_zip_reader_extract_file_iter_new(mz_zip_archive *pZip, const char *pFilename, mz_uint flags);
MINIZ_EXPORT size_t mz_zip_reader_extract_iter_read(mz_zip_reader_extract_iter_state* pState, void* pvBuf, size_t buf_size);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_iter_free(mz_zip_reader_extract_iter_state* pState);

#ifndef MINIZ_NO_STDIO
/* Extracts a archive file to a disk file and sets its last accessed and modified times. */
/* This function only extracts files, not archive directory records. */
MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags);

/* Extracts a archive file starting at the current position in the destination FILE stream. */
MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_cfile(mz_zip_archive *pZip, mz_uint file_index, MZ_FILE *File, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_cfile(mz_zip_archive *pZip, const char *pArchive_filename, MZ_FILE *pFile, mz_uint flags);
#endif

#if 0
/* TODO */
	typedef void *mz_zip_streaming_extract_state_ptr;
	mz_zip_streaming_extract_state_ptr mz_zip_streaming_extract_begin(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags);
	mz_uint64 mz_zip_streaming_extract_get_size(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState);
	mz_uint64 mz_zip_streaming_extract_get_cur_ofs(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState);
	mz_bool mz_zip_streaming_extract_seek(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState, mz_uint64 new_ofs);
	size_t mz_zip_streaming_extract_read(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState, void *pBuf, size_t buf_size);
	mz_bool mz_zip_streaming_extract_end(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState);
#endif

/* This function compares the archive's local headers, the optional local zip64 extended information block, and the optional descriptor following the compressed data vs. the data in the central directory. */
/* It also validates that each file can be successfully uncompressed unless the MZ_ZIP_FLAG_VALIDATE_HEADERS_ONLY is specified. */
MINIZ_EXPORT mz_bool mz_zip_validate_file(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags);

/* Validates an entire archive by calling mz_zip_validate_file() on each file. */
MINIZ_EXPORT mz_bool mz_zip_validate_archive(mz_zip_archive *pZip, mz_uint flags);

/* Misc utils/helpers, valid for ZIP reading or writing */
MINIZ_EXPORT mz_bool mz_zip_validate_mem_archive(const void *pMem, size_t size, mz_uint flags, mz_zip_error *pErr);
#ifndef MINIZ_NO_STDIO
MINIZ_EXPORT mz_bool mz_zip_validate_file_archive(const char *pFilename, mz_uint flags, mz_zip_error *pErr);
#endif

/* Universal end function - calls either mz_zip_reader_end() or mz_zip_writer_end(). */
MINIZ_EXPORT mz_bool mz_zip_end(mz_zip_archive *pZip);

/* -------- ZIP writing */

#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

/* Inits a ZIP archive writer. */
/*Set pZip->m_pWrite (and pZip->m_pIO_opaque) before calling mz_zip_writer_init or mz_zip_writer_init_v2*/
/*The output is streamable, i.e. file_ofs in mz_file_write_func always increases only by n*/
MINIZ_EXPORT mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size);
MINIZ_EXPORT mz_bool mz_zip_writer_init_v2(mz_zip_archive *pZip, mz_uint64 existing_size, mz_uint flags);

MINIZ_EXPORT mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size);
MINIZ_EXPORT mz_bool mz_zip_writer_init_heap_v2(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size, mz_uint flags);

#ifndef MINIZ_NO_STDIO
MINIZ_EXPORT mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning);
MINIZ_EXPORT mz_bool mz_zip_writer_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_writer_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint flags);
#endif

/* Converts a ZIP archive reader object into a writer object, to allow efficient in-place file appends to occur on an existing archive. */
/* For archives opened using mz_zip_reader_init_file, pFilename must be the archive's filename so it can be reopened for writing. If the file can't be reopened, mz_zip_reader_end() will be called. */
/* For archives opened using mz_zip_reader_init_mem, the memory block must be growable using the realloc callback (which defaults to realloc unless you've overridden it). */
/* Finally, for archives opened using mz_zip_reader_init, the mz_zip_archive's user provided m_pWrite function cannot be NULL. */
/* Note: In-place archive modification is not recommended unless you know what you're doing, because if execution stops or something goes wrong before */
/* the archive is finalized the file's central directory will be hosed. */
MINIZ_EXPORT mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename);
MINIZ_EXPORT mz_bool mz_zip_writer_init_from_reader_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags);

/* Adds the contents of a memory buffer to an archive. These functions record the current local time into the archive. */
/* To add a directory entry, call this method with an archive name ending in a forwardslash with an empty buffer. */
/* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */
MINIZ_EXPORT mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags);

/* Like mz_zip_writer_add_mem(), except you can specify a file comment field, and optionally supply the function with already compressed data. */
/* uncomp_size/uncomp_crc32 are only used if the MZ_ZIP_FLAG_COMPRESSED_DATA flag is specified. */
MINIZ_EXPORT mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
                                              mz_uint64 uncomp_size, mz_uint32 uncomp_crc32);

MINIZ_EXPORT mz_bool mz_zip_writer_add_mem_ex_v2(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
                                                 mz_uint64 uncomp_size, mz_uint32 uncomp_crc32, MZ_TIME_T *last_modified, const char *user_extra_data_local, mz_uint user_extra_data_local_len,
                                                 const char *user_extra_data_central, mz_uint user_extra_data_central_len);

/* Adds the contents of a file to an archive. This function also records the disk file's modified time into the archive. */
/* File data is supplied via a read callback function. User mz_zip_writer_add_(c)file to add a file directly.*/
MINIZ_EXPORT mz_bool mz_zip_writer_add_read_buf_callback(mz_zip_archive *pZip, const char *pArchive_name, mz_file_read_func read_callback, void* callback_opaque, mz_uint64 max_size,
	const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, const char *user_extra_data_local, mz_uint user_extra_data_local_len,
	const char *user_extra_data_central, mz_uint user_extra_data_central_len);


#ifndef MINIZ_NO_STDIO
/* Adds the contents of a disk file to an archive. This function also records the disk file's modified time into the archive. */
/* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */
MINIZ_EXPORT mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);

/* Like mz_zip_writer_add_file(), except the file data is read from the specified FILE stream. */
MINIZ_EXPORT mz_bool mz_zip_writer_add_cfile(mz_zip_archive *pZip, const char *pArchive_name, MZ_FILE *pSrc_file, mz_uint64 max_size,
                                const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, const char *user_extra_data_local, mz_uint user_extra_data_local_len,
                                const char *user_extra_data_central, mz_uint user_extra_data_central_len);
#endif

/* Adds a file to an archive by fully cloning the data from another archive. */
/* This function fully clones the source file's compressed data (no recompression), along with its full filename, extra data (it may add or modify the zip64 local header extra data field), and the optional descriptor following the compressed data. */
MINIZ_EXPORT mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint src_file_index);

/* Finalizes the archive by writing the central directory records followed by the end of central directory record. */
/* After an archive is finalized, the only valid call on the mz_zip_archive struct is mz_zip_writer_end(). */
/* An archive must be manually finalized by calling this function for it to be valid. */
MINIZ_EXPORT mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip);

/* Finalizes a heap archive, returning a pointer to the heap block and its size. */
/* The heap block will be allocated using the mz_zip_archive's alloc/realloc callbacks. */
MINIZ_EXPORT mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **ppBuf, size_t *pSize);

/* Ends archive writing, freeing all allocations, and closing the output file if mz_zip_writer_init_file() was used. */
/* Note for the archive to be valid, it *must* have been finalized before ending (this function will not do it for you). */
MINIZ_EXPORT mz_bool mz_zip_writer_end(mz_zip_archive *pZip);

/* -------- Misc. high-level helper functions: */

/* mz_zip_add_mem_to_archive_file_in_place() efficiently (but not atomically) appends a memory blob to a ZIP archive. */
/* Note this is NOT a fully safe operation. If it crashes or dies in some way your archive can be left in a screwed up state (without a central directory). */
/* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */
/* TODO: Perhaps add an option to leave the existing central dir in place in case the add dies? We could then truncate the file (so the old central dir would be at the end) if something goes wrong. */
MINIZ_EXPORT mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);
MINIZ_EXPORT mz_bool mz_zip_add_mem_to_archive_file_in_place_v2(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_zip_error *pErr);

#ifndef MINIZ_NO_STDIO
/* Reads a single file from an archive into a heap block. */
/* If pComment is not NULL, only the file with the specified comment will be extracted. */
/* Returns NULL on failure. */
MINIZ_EXPORT void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint flags);
MINIZ_EXPORT void *mz_zip_extract_archive_file_to_heap_v2(const char *pZip_filename, const char *pArchive_name, const char *pComment, size_t *pSize, mz_uint flags, mz_zip_error *pErr);
#endif

#endif /* #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS */

#ifdef __cplusplus
}
#endif

#endif /* MINIZ_NO_ARCHIVE_APIS */




#ifndef CLANG_PARSE
	
#endif

namespace NumberDuck
{
	class Blob;
	class BlobView;
	namespace Secret
	{
		class InternalString;

		class ZipFileInfo
		{
			public:
				const char* GetFileName();
				int GetSize();

			//unsigned int GetCrc32();

			protected:
				#ifndef CLANG_PARSE
					friend class Zip;
					ZipFileInfo();
					~ZipFileInfo();

					mz_zip_archive_file_stat* m_pFileStat;
				#endif
		};

		class Zip
		{
			public:
				Zip();
				~Zip();

				bool LoadBlobView(BlobView* pBlobView);
				bool LoadFile(const char* szFileName);

				int GetNumFile();
				ZipFileInfo* GetFileInfo(int nIndex);

				bool ExtractFileByIndex(int nIndex, BlobView* pOutBlobView);
				bool ExtractFileByName(const char* szFileName, BlobView* pOutBlobView);

				bool ExtractFileByIndexToString(int nIndex, InternalString* sOut);

			private:
				#ifndef CLANG_PARSE
					void CleanupArchive();
					void Cleanup();

					Blob* m_pBlob;
					mz_zip_archive* m_pArchive;
					ZipFileInfo* m_pTempFileInfo;
				#endif
		};
	}
}


#include "NumberDuck.hpp"

namespace NumberDuck
{
	class Workbook;
	class Worksheet;
	class Cell;
	class Picture;
	class Chart;
	class MergedCell;
	class Blob;
	class BlobView;
}
namespace NumberDuck
{
	Value::Value()
	{
		m_pImpl = 0;
		m_pImpl = new Secret::ValueImplementation();
		m_pImpl->m_eType = Type::TYPE_EMPTY;
	}

	bool Value::Equals(const Value* pValue) const
	{
		if (pValue == this)
			return true;
		if (m_pImpl->m_eType == pValue->m_pImpl->m_eType)
		{
			switch (m_pImpl->m_eType)
			{
				case Type::TYPE_EMPTY:
				{
					return true;
				}

				case Type::TYPE_STRING:
				{
					return Secret::ExternalString::Equal(m_pImpl->m_sString->GetExternalString(), pValue->m_pImpl->m_sString->GetExternalString());
				}

				case Type::TYPE_FLOAT:
				{
					double fDiff = m_pImpl->m_fFloat - pValue->m_pImpl->m_fFloat;
					return fDiff < 0.00001 && fDiff > -0.00001;
				}

				case Type::TYPE_BOOLEAN:
				{
					return m_pImpl->m_bBoolean == pValue->m_pImpl->m_bBoolean;
				}

				case Type::TYPE_FORMULA:
				{
					return Secret::ExternalString::Equal(GetFormula(), pValue->GetFormula());
				}

				case Type::TYPE_ERROR:
				{
					return true;
				}

			}
			Secret::nbAssert::Assert(false);
		}
		return false;
	}

	Value::Type Value::GetType() const
	{
		return m_pImpl->m_eType;
	}

	const char* Value::GetString() const
	{
		if (m_pImpl->m_eType == Type::TYPE_STRING)
			return m_pImpl->m_sString->GetExternalString();
		return "";
	}

	double Value::GetFloat() const
	{
		if (m_pImpl->m_eType == Type::TYPE_FLOAT)
			return m_pImpl->m_fFloat;
		return 0.0f;
	}

	bool Value::GetBoolean() const
	{
		if (m_pImpl->m_eType == Type::TYPE_BOOLEAN)
			return m_pImpl->m_bBoolean;
		return false;
	}

	const char* Value::GetFormula() const
	{
		if (m_pImpl->m_eType == Type::TYPE_FORMULA)
		{
			m_pImpl->m_sString->Set(m_pImpl->m_pFormula->ToString(m_pImpl->m_pWorksheet->m_pImpl));
			return m_pImpl->m_sString->GetExternalString();
		}
		return "=";
	}

	const Value* Value::EvaulateFormula() const
	{
		if (m_pImpl->m_eType == Type::TYPE_FORMULA)
			return m_pImpl->m_pFormula->Evaluate(m_pImpl->m_pWorksheet->m_pImpl, 0);
		if (m_pImpl->m_pValue != 0)
			{
				delete m_pImpl->m_pValue;
			}
		m_pImpl->m_pValue = Secret::ValueImplementation::CreateErrorValue();
		return m_pImpl->m_pValue;
	}

	Value::~Value()
	{
		if (m_pImpl) delete m_pImpl;
	}

	Cell::Cell(Worksheet* pWorksheet)
	{
		m_pImpl = 0;
		m_pImpl = new Secret::CellImplementation();
		m_pImpl->m_pValue = new Value();
		m_pImpl->m_pWorksheet = pWorksheet;
		Clear();
	}

	bool Cell::Equals(const Cell* pCell) const
	{
		return m_pImpl->m_pValue->Equals(pCell->m_pImpl->m_pValue) && m_pImpl->m_pStyle == pCell->m_pImpl->m_pStyle;
	}

	const Value* Cell::GetValue()
	{
		return m_pImpl->m_pValue;
	}

	Value::Type Cell::GetType()
	{
		return m_pImpl->m_pValue->GetType();
	}

	void Cell::Clear()
	{
		m_pImpl->m_pValue->m_pImpl->Clear();
		m_pImpl->m_pStyle = m_pImpl->m_pWorksheet->m_pImpl->m_pWorkbook->GetDefaultStyle();
	}

	void Cell::SetString(const char* szString)
	{
		m_pImpl->m_pValue->m_pImpl->SetString(szString);
	}

	const char* Cell::GetString()
	{
		return m_pImpl->m_pValue->GetString();
	}

	void Cell::SetFloat(double fFloat)
	{
		m_pImpl->m_pValue->m_pImpl->SetFloat(fFloat);
	}

	double Cell::GetFloat()
	{
		return m_pImpl->m_pValue->GetFloat();
	}

	void Cell::SetBoolean(bool bBoolean)
	{
		m_pImpl->m_pValue->m_pImpl->SetBoolean(bBoolean);
	}

	bool Cell::GetBoolean()
	{
		return m_pImpl->m_pValue->GetBoolean();
	}

	void Cell::SetFormula(const char* szFormula)
	{
		m_pImpl->m_pValue->m_pImpl->SetFormulaFromString(szFormula, m_pImpl->m_pWorksheet);
	}

	const char* Cell::GetFormula()
	{
		return m_pImpl->m_pValue->GetFormula();
	}

	const Value* Cell::EvaulateFormula() const
	{
		return m_pImpl->m_pValue->EvaulateFormula();
	}

	bool Cell::SetStyle(Style* pStyle)
	{
		Workbook* pWorkbook = m_pImpl->GetWorkbook();
		unsigned short i;
		for (i = 0; i < pWorkbook->GetNumStyle(); i++)
			if (pWorkbook->GetStyleByIndex(i) == pStyle)
				break;
		if (i == pWorkbook->GetNumStyle())
			return false;
		m_pImpl->m_pStyle = pStyle;
		return true;
	}

	Style* Cell::GetStyle()
	{
		return m_pImpl->m_pStyle;
	}

	Cell::~Cell()
	{
		if (m_pImpl) delete m_pImpl;
	}

	Style::Style()
	{
		m_pImplementation = 0;
		m_pImplementation = new Secret::StyleImplementation();
	}

	Font* Style::GetFont()
	{
		return m_pImplementation->m_pFont;
	}

	Style::HorizontalAlign Style::GetHorizontalAlign()
	{
		return m_pImplementation->m_eHorizontalAlign;
	}

	void Style::SetHorizontalAlign(Style::HorizontalAlign eHorizontalAlign)
	{
		if (eHorizontalAlign < HorizontalAlign::HORIZONTAL_ALIGN_GENERAL || eHorizontalAlign > HorizontalAlign::HORIZONTAL_ALIGN_DISTRIBUTED)
			eHorizontalAlign = HorizontalAlign::HORIZONTAL_ALIGN_GENERAL;
		m_pImplementation->m_eHorizontalAlign = eHorizontalAlign;
	}

	Style::VerticalAlign Style::GetVerticalAlign()
	{
		return m_pImplementation->m_eVerticalAlign;
	}

	void Style::SetVerticalAlign(Style::VerticalAlign eVerticalAlign)
	{
		if (eVerticalAlign < VerticalAlign::VERTICAL_ALIGN_TOP || eVerticalAlign > VerticalAlign::VERTICAL_ALIGN_DISTRIBUTED)
			eVerticalAlign = VerticalAlign::VERTICAL_ALIGN_BOTTOM;
		m_pImplementation->m_eVerticalAlign = eVerticalAlign;
	}

	Color* Style::GetBackgroundColor(bool bCreateIfMissing)
	{
		if (m_pImplementation->m_pBackgroundColor == 0 && bCreateIfMissing)
			m_pImplementation->m_pBackgroundColor = new Color(0xFF, 0xFF, 0xFF);
		return m_pImplementation->m_pBackgroundColor;
	}

	void Style::ClearBackgroundColor()
	{
		{
			delete m_pImplementation->m_pBackgroundColor;
		}
		m_pImplementation->m_pBackgroundColor = 0;
	}

	Style::FillPattern Style::GetFillPattern()
	{
		return m_pImplementation->m_eFillPattern;
	}

	void Style::SetFillPattern(Style::FillPattern eFillPattern)
	{
		if (eFillPattern < FillPattern::FILL_PATTERN_NONE || eFillPattern >= FillPattern::NUM_FILL_PATTERN)
			eFillPattern = FillPattern::FILL_PATTERN_NONE;
		m_pImplementation->m_eFillPattern = eFillPattern;
	}

	Color* Style::GetFillPatternColor(bool bCreateIfMissing)
	{
		if (m_pImplementation->m_pFillPatternColor == 0 && bCreateIfMissing)
			m_pImplementation->m_pFillPatternColor = new Color(0, 0, 0);
		return m_pImplementation->m_pFillPatternColor;
	}

	void Style::ClearFillPatternColor()
	{
		{
			delete m_pImplementation->m_pFillPatternColor;
		}
		m_pImplementation->m_pFillPatternColor = 0;
	}

	Line* Style::GetTopBorderLine()
	{
		return m_pImplementation->m_pTopBorderLine;
	}

	Line* Style::GetRightBorderLine()
	{
		return m_pImplementation->m_pRightBorderLine;
	}

	Line* Style::GetBottomBorderLine()
	{
		return m_pImplementation->m_pBottomBorderLine;
	}

	Line* Style::GetLeftBorderLine()
	{
		return m_pImplementation->m_pLeftBorderLine;
	}

	const char* Style::GetFormat()
	{
		return m_pImplementation->m_sFormat->GetExternalString();
	}

	void Style::SetFormat(const char* szFormat)
	{
		if (szFormat != 0)
		{
			{
				delete m_pImplementation->m_sFormat;
			}
			m_pImplementation->m_sFormat = new Secret::InternalString(szFormat);
		}
	}

	Style::~Style()
	{
		if (m_pImplementation) delete m_pImplementation;
	}

	Line::Line()
	{
		m_pImpl = 0;
		m_pImpl = new Secret::LineImplementation();
	}

	bool Line::Equals(const Line* pLine) const
	{
		if (pLine == 0)
			return false;
		return m_pImpl->Equals(pLine->m_pImpl);
	}

	Line::Type Line::GetType() const
	{
		return m_pImpl->GetType();
	}

	void Line::SetType(Type eType)
	{
		m_pImpl->SetType(eType);
	}

	Color* Line::GetColor()
	{
		return m_pImpl->m_pColor;
	}

	Line::~Line()
	{
		if (m_pImpl) delete m_pImpl;
	}

	Marker::Marker()
	{
		m_pImpl = 0;
		m_pImpl = new Secret::MarkerImplementation();
	}

	bool Marker::Equals(const Marker* pMarker) const
	{
		if (pMarker == 0)
			return false;
		return m_pImpl->Equals(pMarker->m_pImpl);
	}

	Marker::Type Marker::GetType() const
	{
		return m_pImpl->GetType();
	}

	void Marker::SetType(Marker::Type eType)
	{
		m_pImpl->SetType(eType);
	}

	Color* Marker::GetFillColor(bool bCreateIfMissing)
	{
		return m_pImpl->GetFillColor(bCreateIfMissing);
	}

	void Marker::SetFillColor(const Color* pColor)
	{
		m_pImpl->SetFillColor(pColor);
	}

	void Marker::ClearFillColor()
	{
		m_pImpl->ClearFillColor();
	}

	Color* Marker::GetBorderColor(bool bCreateIfMissing)
	{
		return m_pImpl->GetBorderColor(bCreateIfMissing);
	}

	void Marker::SetBorderColor(const Color* pColor)
	{
		m_pImpl->SetBorderColor(pColor);
	}

	void Marker::ClearBorderColor()
	{
		m_pImpl->ClearBorderColor();
	}

	int Marker::GetSize() const
	{
		return m_pImpl->GetSize();
	}

	void Marker::SetSize(int nSize)
	{
		m_pImpl->SetSize(nSize);
	}

	Marker::~Marker()
	{
		if (m_pImpl) delete m_pImpl;
	}

	Fill::Fill()
	{
		m_pImpl = 0;
		m_pImpl = new Secret::FillImplementation();
	}

	bool Fill::Equals(const Fill* pFill) const
	{
		if (pFill == 0)
			return false;
		return m_pImpl->Equals(pFill->m_pImpl);
	}

	Fill::Type Fill::GetType() const
	{
		return m_pImpl->GetType();
	}

	void Fill::SetType(Type eType)
	{
		m_pImpl->SetType(eType);
	}

	Color* Fill::GetForegroundColor()
	{
		return m_pImpl->m_pForegroundColor;
	}

	Color* Fill::GetBackgroundColor()
	{
		return m_pImpl->m_pBackgroundColor;
	}

	Fill::~Fill()
	{
		if (m_pImpl) delete m_pImpl;
	}

	Font::Font()
	{
		m_pImpl = 0;
		m_pImpl = new Secret::FontImplementation();
	}

	void Font::SetName(const char* szName)
	{
		m_pImpl->m_sName->Set(szName);
	}

	const char* Font::GetName()
	{
		return m_pImpl->m_sName->GetExternalString();
	}

	void Font::SetSize(unsigned char nSize)
	{
		if (nSize < 10)
			nSize = 10;
		else if (nSize > 96)
			nSize = 96;
		m_pImpl->m_nSizeTwips = nSize * 15;
	}

	unsigned char Font::GetSize()
	{
		return (unsigned char)(m_pImpl->m_nSizeTwips / 15);
	}

	Color* Font::GetColor(bool bCreateIfMissing)
	{
		if (m_pImpl->m_pColor == 0 && bCreateIfMissing)
			m_pImpl->m_pColor = new Color(0, 0, 0);
		return m_pImpl->m_pColor;
	}

	void Font::ClearColor()
	{
		{
			delete m_pImpl->m_pColor;
		}
		m_pImpl->m_pColor = 0;
	}

	bool Font::GetBold()
	{
		return m_pImpl->m_bBold;
	}

	void Font::SetBold(bool bBold)
	{
		m_pImpl->m_bBold = bBold;
	}

	bool Font::GetItalic()
	{
		return m_pImpl->m_bItalic;
	}

	void Font::SetItalic(bool bItalic)
	{
		m_pImpl->m_bItalic = bItalic;
	}

	Font::Underline Font::GetUnderline()
	{
		return m_pImpl->m_eUnderline;
	}

	void Font::SetUnderline(Font::Underline eUnderline)
	{
		if (eUnderline < Font::Underline::UNDERLINE_NONE || eUnderline >= Font::Underline::NUM_UNDERLINE)
			eUnderline = Font::Underline::UNDERLINE_NONE;
		m_pImpl->m_eUnderline = eUnderline;
	}

	Font::~Font()
	{
		if (m_pImpl) delete m_pImpl;
	}

	Chart::Chart(Worksheet* pWorksheet, Type eType)
	{
		m_pImpl = 0;
		m_pImpl = new Secret::ChartImplementation(pWorksheet, eType);
	}

	unsigned int Chart::GetX()
	{
		return m_pImpl->m_nX;
	}

	bool Chart::SetX(unsigned int nX)
	{
		m_pImpl->m_nX = nX;
		return true;
	}

	unsigned int Chart::GetY()
	{
		return m_pImpl->m_nY;
	}

	bool Chart::SetY(unsigned int nY)
	{
		m_pImpl->m_nY = nY;
		return true;
	}

	unsigned int Chart::GetSubX()
	{
		return m_pImpl->m_nSubX;
	}

	void Chart::SetSubX(unsigned int nSubX)
	{
		m_pImpl->m_nSubX = nSubX;
	}

	unsigned int Chart::GetSubY()
	{
		return m_pImpl->m_nSubY;
	}

	void Chart::SetSubY(unsigned int nSubY)
	{
		m_pImpl->m_nSubY = nSubY;
	}

	unsigned int Chart::GetWidth()
	{
		return m_pImpl->m_nWidth;
	}

	void Chart::SetWidth(unsigned int nWidth)
	{
		m_pImpl->m_nWidth = nWidth;
	}

	unsigned int Chart::GetHeight()
	{
		return m_pImpl->m_nHeight;
	}

	void Chart::SetHeight(unsigned int nHeight)
	{
		m_pImpl->m_nHeight = nHeight;
	}

	Chart::Type Chart::GetType()
	{
		return m_pImpl->m_eType;
	}

	void Chart::SetType(Type eType)
	{
		if (eType >= Type::TYPE_COLUMN && eType < Type::NUM_TYPE)
			m_pImpl->m_eType = eType;
	}

	unsigned int Chart::GetNumSeries()
	{
		return (unsigned int)(m_pImpl->m_pSeriesVector->GetSize());
	}

	Series* Chart::GetSeriesByIndex(unsigned int nIndex)
	{
		if (nIndex >= GetNumSeries())
			return 0;
		return m_pImpl->m_pSeriesVector->Get((int)(nIndex));
	}

	Series* Chart::CreateSeries(const char* szValues)
	{
		Secret::Formula* pFormula = new Secret::Formula(szValues, m_pImpl->m_pWorksheet->m_pImpl);
		if (pFormula->ValidateForChart(m_pImpl->m_pWorksheet->m_pImpl))
		{
			NumberDuck::Secret::Formula* __879619620 = pFormula;
			pFormula = 0;
			{
				if (pFormula) delete pFormula;
				return m_pImpl->CreateSeries(__879619620);
			}
		}
		{
			delete pFormula;
			pFormula = 0;
		}
		{
			if (pFormula) delete pFormula;
			return 0;
		}
	}

	void Chart::PurgeSeries(unsigned int nIndex)
	{
		m_pImpl->PurgeSeries((int)(nIndex));
	}

	const char* Chart::GetCategories()
	{
		if (m_pImpl->m_pCategoriesFormula != 0)
			return m_pImpl->m_pCategoriesFormula->ToChartString(m_pImpl->m_pWorksheet->m_pImpl);
		return "=";
	}

	bool Chart::SetCategories(const char* szCategories)
	{
		Secret::Formula* pFormula = new Secret::Formula(szCategories, m_pImpl->m_pWorksheet->m_pImpl);
		if (pFormula->ValidateForChart(m_pImpl->m_pWorksheet->m_pImpl))
		{
			{
				delete m_pImpl->m_pCategoriesFormula;
			}
			{
				NumberDuck::Secret::Formula* __879619620 = pFormula;
				pFormula = 0;
				m_pImpl->m_pCategoriesFormula = __879619620;
			}
			{
				if (pFormula) delete pFormula;
				return true;
			}
		}
		{
			if (pFormula) delete pFormula;
			return false;
		}
	}

	const char* Chart::GetTitle()
	{
		return m_pImpl->m_sTitle->GetExternalString();
	}

	void Chart::SetTitle(const char* szTitle)
	{
		m_pImpl->m_sTitle->Set(szTitle);
	}

	const char* Chart::GetHorizontalAxisLabel()
	{
		return m_pImpl->m_sHorizontalAxisLabel->GetExternalString();
	}

	void Chart::SetHorizontalAxisLabel(const char* szHorizontalAxisLabel)
	{
		m_pImpl->m_sHorizontalAxisLabel->Set(szHorizontalAxisLabel);
	}

	const char* Chart::GetVerticalAxisLabel()
	{
		return m_pImpl->m_sVerticalAxisLabel->GetExternalString();
	}

	void Chart::SetVerticalAxisLabel(const char* szVerticalAxisLabel)
	{
		m_pImpl->m_sVerticalAxisLabel->Set(szVerticalAxisLabel);
	}

	Legend* Chart::GetLegend()
	{
		return m_pImpl->m_pLegend;
	}

	Line* Chart::GetFrameBorderLine()
	{
		return m_pImpl->m_pFrameBorderLine;
	}

	Fill* Chart::GetFrameFill()
	{
		return m_pImpl->m_pFrameFill;
	}

	Line* Chart::GetPlotBorderLine()
	{
		return m_pImpl->m_pPlotBorderLine;
	}

	Fill* Chart::GetPlotFill()
	{
		return m_pImpl->m_pPlotFill;
	}

	Line* Chart::GetHorizontalAxisLine()
	{
		return m_pImpl->m_pHorizontalAxisLine;
	}

	Line* Chart::GetHorizontalGridLine()
	{
		return m_pImpl->m_pHorizontalGridLine;
	}

	Line* Chart::GetVerticalAxisLine()
	{
		return m_pImpl->m_pVerticalAxisLine;
	}

	Line* Chart::GetVerticalGridLine()
	{
		return m_pImpl->m_pVerticalGridLine;
	}

	Chart::~Chart()
	{
		if (m_pImpl) delete m_pImpl;
	}

	Picture::Picture(Blob* pBlob, Picture::Format eFormat)
	{
		m_pImplementation = 0;
		m_pImplementation = new Secret::PictureImplementation(pBlob, eFormat);
	}

	unsigned int Picture::GetX()
	{
		return m_pImplementation->m_nX;
	}

	bool Picture::SetX(unsigned int nX)
	{
		m_pImplementation->m_nX = nX;
		return true;
	}

	unsigned int Picture::GetY()
	{
		return m_pImplementation->m_nY;
	}

	bool Picture::SetY(unsigned int nY)
	{
		m_pImplementation->m_nY = nY;
		return true;
	}

	unsigned int Picture::GetSubX()
	{
		return m_pImplementation->m_nSubX;
	}

	void Picture::SetSubX(unsigned int nSubX)
	{
		m_pImplementation->m_nSubX = nSubX;
	}

	unsigned int Picture::GetSubY()
	{
		return m_pImplementation->m_nSubY;
	}

	void Picture::SetSubY(unsigned int nSubY)
	{
		m_pImplementation->m_nSubY = nSubY;
	}

	unsigned int Picture::GetWidth()
	{
		return m_pImplementation->m_nWidth;
	}

	void Picture::SetWidth(unsigned int nWidth)
	{
		m_pImplementation->m_nWidth = nWidth;
	}

	unsigned int Picture::GetHeight()
	{
		return m_pImplementation->m_nHeight;
	}

	void Picture::SetHeight(unsigned int nHeight)
	{
		m_pImplementation->m_nHeight = nHeight;
	}

	const char* Picture::GetUrl()
	{
		return m_pImplementation->m_sUrl->GetExternalString();
	}

	void Picture::SetUrl(const char* szUrl)
	{
		m_pImplementation->m_sUrl->Set(szUrl);
	}

	Blob* Picture::GetBlob()
	{
		return m_pImplementation->m_pBlob;
	}

	Picture::Format Picture::GetFormat()
	{
		return m_pImplementation->m_eFormat;
	}

	Picture::~Picture()
	{
		if (m_pImplementation) delete m_pImplementation;
	}

	Worksheet::Worksheet(Workbook* pWorkbook)
	{
		m_pImpl = 0;
		m_pImpl = new Secret::WorksheetImplementation(pWorkbook, this);
	}

	Worksheet::~Worksheet()
	{
		{
			delete m_pImpl;
			m_pImpl = 0;
		}
		if (m_pImpl) delete m_pImpl;
	}

	const char* Worksheet::GetName()
	{
		return m_pImpl->m_sName->GetExternalString();
	}

	bool Worksheet::SetName(const char* szName)
	{
		for (unsigned short i = 0; i < m_pImpl->m_pWorkbook->GetNumWorksheet(); i++)
		{
			Worksheet* pWorksheet = m_pImpl->m_pWorkbook->GetWorksheetByIndex(i);
			if (pWorksheet != this && Secret::ExternalString::Equal(pWorksheet->GetName(), szName))
				return false;
		}
		m_pImpl->m_sName->Set(szName);
		return true;
	}

	Worksheet::Orientation Worksheet::GetOrientation()
	{
		return m_pImpl->m_eOrientation;
	}

	void Worksheet::SetOrientation(Worksheet::Orientation eOrientation)
	{
		m_pImpl->m_eOrientation = eOrientation;
	}

	bool Worksheet::GetPrintGridlines()
	{
		return m_pImpl->m_bPrintGridlines;
	}

	void Worksheet::SetPrintGridlines(bool bPrintGridlines)
	{
		m_pImpl->m_bPrintGridlines = bPrintGridlines;
	}

	bool Worksheet::GetShowGridlines()
	{
		return m_pImpl->m_bShowGridlines;
	}

	void Worksheet::SetShowGridlines(bool bShowGridlines)
	{
		m_pImpl->m_bShowGridlines = bShowGridlines;
	}

	unsigned short Worksheet::GetColumnWidth(unsigned short nColumn)
	{
		Secret::ColumnInfo* pColumnInfo = m_pImpl->GetColumnInfo(nColumn);
		if (pColumnInfo != 0)
			return pColumnInfo->m_nWidth;
		return DEFAULT_COLUMN_WIDTH;
	}

	void Worksheet::SetColumnWidth(unsigned short nColumn, unsigned short nWidth)
	{
		if (nColumn > MAX_COLUMN)
			return;
		Secret::ColumnInfo* pColumnInfo = m_pImpl->GetOrCreateColumnInfo(nColumn);
		pColumnInfo->m_nWidth = nWidth;
	}

	bool Worksheet::GetColumnHidden(unsigned short nColumn)
	{
		Secret::ColumnInfo* pColumnInfo = m_pImpl->GetColumnInfo(nColumn);
		if (pColumnInfo != 0)
			return pColumnInfo->m_bHidden;
		return false;
	}

	void Worksheet::SetColumnHidden(unsigned short nColumn, bool bHidden)
	{
		if (nColumn > MAX_COLUMN)
			return;
		Secret::ColumnInfo* pColumnInfo = m_pImpl->GetOrCreateColumnInfo(nColumn);
		pColumnInfo->m_bHidden = bHidden;
	}

	void Worksheet::InsertColumn(unsigned short nColumn)
	{
		if (nColumn > MAX_COLUMN)
			return;
		if (m_pImpl->m_pColumnInfoTable->GetSize() > 0)
		{
			int i = m_pImpl->m_pColumnInfoTable->GetSize() - 1;
			while (true)
			{
				Secret::TableElement<Secret::ColumnInfo*>* pElement = m_pImpl->m_pColumnInfoTable->GetByIndex(i);
				if (pElement->m_nColumn == MAX_COLUMN)
				{
					m_pImpl->m_pColumnInfoTable->Erase(i);
				}
				else if (pElement->m_nColumn >= nColumn)
				{
					{
						NumberDuck::Secret::ColumnInfo* __3920382863 = pElement->m_xObject;
						pElement->m_xObject = 0;
						m_pImpl->m_pColumnInfoTable->Set(pElement->m_nColumn + 1, pElement->m_nRow, __3920382863);
					}
					m_pImpl->m_pColumnInfoTable->Erase(i);
				}
				if (i == 0)
					break;
				i--;
			}
		}
		if (m_pImpl->m_pCellTable->GetSize() > 0)
		{
			int i = m_pImpl->m_pCellTable->GetSize() - 1;
			while (true)
			{
				Secret::TableElement<Cell*>* pElement = m_pImpl->m_pCellTable->GetByIndex(i);
				if (pElement->m_nColumn == MAX_COLUMN)
				{
					m_pImpl->m_pCellTable->Erase(i);
				}
				else if (pElement->m_nColumn >= nColumn)
				{
					{
						NumberDuck::Cell* __3920382863 = pElement->m_xObject;
						pElement->m_xObject = 0;
						m_pImpl->m_pCellTable->Set(pElement->m_nColumn + 1, pElement->m_nRow, __3920382863);
					}
					m_pImpl->m_pCellTable->Erase(i);
				}
				if (i == 0)
					break;
				i--;
			}
		}
		for (int i = 0; i < m_pImpl->m_pPictureVector->GetSize(); )
		{
			Picture* pPicture = m_pImpl->m_pPictureVector->Get(i);
			if (pPicture->GetX() == MAX_COLUMN)
			{
				PurgePicture((unsigned short)(i));
				continue;
			}
			if (pPicture->GetX() >= nColumn)
				pPicture->SetX(pPicture->GetX() + 1);
			i++;
		}
		unsigned short nWorksheetIndex = 0;
		for (unsigned short i = 0; i < m_pImpl->m_pWorkbook->GetNumWorksheet(); i++)
		{
			if (this == m_pImpl->m_pWorkbook->GetWorksheetByIndex(i))
			{
				nWorksheetIndex = i;
				break;
			}
		}
		for (int i = 0; i < m_pImpl->m_pChartVector->GetSize(); )
		{
			Chart* pChart = m_pImpl->m_pChartVector->Get(i);
			if (pChart->GetX() == MAX_COLUMN)
			{
				PurgeChart((unsigned short)(i));
				continue;
			}
			if (pChart->GetX() >= nColumn)
				pChart->SetX(pChart->GetX() + 1);
			pChart->m_pImpl->InsertColumn(nWorksheetIndex, nColumn);
			i++;
		}
		for (int i = 0; i < m_pImpl->m_pMergedCellVector->GetSize(); )
		{
			MergedCell* pMergedCell = m_pImpl->m_pMergedCellVector->Get(i);
			if (pMergedCell->GetX() == MAX_COLUMN)
			{
				PurgeMergedCell((unsigned short)(i));
				continue;
			}
			if (pMergedCell->GetX() >= nColumn)
			{
				pMergedCell->SetX(pMergedCell->GetX() + 1);
				pMergedCell->SetWidth(pMergedCell->GetWidth());
			}
			else if (pMergedCell->GetX() + pMergedCell->GetWidth() >= nColumn)
				pMergedCell->SetWidth(pMergedCell->GetWidth() + 1);
			i++;
		}
	}

	void Worksheet::DeleteColumn(unsigned short nColumn)
	{
		if (nColumn > MAX_COLUMN)
			return;
		{
			int i = 0;
			while (i < m_pImpl->m_pColumnInfoTable->GetSize())
			{
				Secret::TableElement<Secret::ColumnInfo*>* pElement = m_pImpl->m_pColumnInfoTable->GetByIndex(i);
				if (pElement->m_nColumn == nColumn)
				{
					m_pImpl->m_pColumnInfoTable->Erase(i);
				}
				else if (pElement->m_nColumn > nColumn)
				{
					int nTempColumn = pElement->m_nColumn - 1;
					int nTempRow = pElement->m_nRow;
					Secret::ColumnInfo* pColumnInfo = 0;
					{
						NumberDuck::Secret::ColumnInfo* __3920382863 = pElement->m_xObject;
						pElement->m_xObject = 0;
						pColumnInfo = __3920382863;
					}
					m_pImpl->m_pColumnInfoTable->Erase(i++);
					{
						NumberDuck::Secret::ColumnInfo* __1173438266 = pColumnInfo;
						pColumnInfo = 0;
						m_pImpl->m_pColumnInfoTable->Set(nTempColumn, nTempRow, __1173438266);
					}
					if (pColumnInfo) delete pColumnInfo;
				}
				else
				{
					i++;
				}
			}
		}
		{
			int i = 0;
			while (i < m_pImpl->m_pCellTable->GetSize())
			{
				Secret::TableElement<Cell*>* pElement = m_pImpl->m_pCellTable->GetByIndex(i);
				if (pElement->m_nColumn == nColumn)
				{
					m_pImpl->m_pCellTable->Erase(i);
				}
				else if (pElement->m_nColumn > nColumn)
				{
					int nTempColumn = pElement->m_nColumn - 1;
					int nTempRow = pElement->m_nRow;
					Cell* pCell = 0;
					{
						NumberDuck::Cell* __3920382863 = pElement->m_xObject;
						pElement->m_xObject = 0;
						pCell = __3920382863;
					}
					m_pImpl->m_pCellTable->Erase(i++);
					{
						NumberDuck::Cell* __2223188566 = pCell;
						pCell = 0;
						m_pImpl->m_pCellTable->Set(nTempColumn, nTempRow, __2223188566);
					}
					if (pCell) delete pCell;
				}
				else
				{
					i++;
				}
			}
		}
		for (int i = 0; i < m_pImpl->m_pPictureVector->GetSize(); )
		{
			Picture* pPicture = m_pImpl->m_pPictureVector->Get(i);
			if (pPicture->GetX() == nColumn)
			{
				PurgePicture((unsigned short)(i));
				continue;
			}
			if (pPicture->GetX() > nColumn)
				pPicture->SetX(pPicture->GetX() - 1);
			i++;
		}
		unsigned short nWorksheetIndex = 0;
		for (unsigned short i = 0; i < m_pImpl->m_pWorkbook->GetNumWorksheet(); i++)
		{
			if (this == m_pImpl->m_pWorkbook->GetWorksheetByIndex(i))
			{
				nWorksheetIndex = i;
				break;
			}
		}
		for (int i = 0; i < m_pImpl->m_pChartVector->GetSize(); )
		{
			Chart* pChart = m_pImpl->m_pChartVector->Get(i);
			if (pChart->GetX() == nColumn)
			{
				PurgeChart((unsigned short)(i));
				continue;
			}
			if (pChart->GetX() > nColumn)
				pChart->SetX(pChart->GetX() - 1);
			pChart->m_pImpl->DeleteColumn(nWorksheetIndex, nColumn);
			i++;
		}
		for (int i = 0; i < m_pImpl->m_pMergedCellVector->GetSize(); )
		{
			MergedCell* pMergedCell = m_pImpl->m_pMergedCellVector->Get(i);
			if (pMergedCell->GetX() == nColumn)
			{
				PurgeMergedCell((unsigned short)(i));
				continue;
			}
			else if (pMergedCell->GetX() > nColumn)
				pMergedCell->SetX(pMergedCell->GetX() - 1);
			else if (pMergedCell->GetX() + pMergedCell->GetWidth() > nColumn)
				pMergedCell->SetWidth(pMergedCell->GetWidth() - 1);
			i++;
		}
	}

	unsigned short Worksheet::GetRowHeight(unsigned short nRow)
	{
		Secret::RowInfo* pRowInfo = m_pImpl->GetRowInfo(nRow);
		if (pRowInfo != 0)
			return pRowInfo->m_nHeight;
		return DEFAULT_ROW_HEIGHT;
	}

	void Worksheet::SetRowHeight(unsigned short nRow, unsigned short nHeight)
	{
		if (nRow > MAX_ROW)
			return;
		Secret::RowInfo* pRowInfo = m_pImpl->GetOrCreateRowInfo(nRow);
		pRowInfo->m_nHeight = nHeight;
	}

	void Worksheet::InsertRow(unsigned short nRow)
	{
		if (nRow > MAX_ROW)
			return;
		if (m_pImpl->m_pRowInfoTable->GetSize() > 0)
		{
			int i = m_pImpl->m_pRowInfoTable->GetSize() - 1;
			while (true)
			{
				Secret::TableElement<Secret::RowInfo*>* pElement = m_pImpl->m_pRowInfoTable->GetByIndex(i);
				if (pElement->m_nRow == MAX_ROW)
				{
					m_pImpl->m_pRowInfoTable->Erase(i);
				}
				else if (pElement->m_nRow >= nRow)
				{
					{
						NumberDuck::Secret::RowInfo* __3920382863 = pElement->m_xObject;
						pElement->m_xObject = 0;
						m_pImpl->m_pRowInfoTable->Set(pElement->m_nColumn, pElement->m_nRow + 1, __3920382863);
					}
					m_pImpl->m_pRowInfoTable->Erase(i);
				}
				if (i == 0)
					break;
				i--;
			}
		}
		if (m_pImpl->m_pCellTable->GetSize() > 0)
		{
			int i = m_pImpl->m_pCellTable->GetSize() - 1;
			while (true)
			{
				Secret::TableElement<Cell*>* pElement = m_pImpl->m_pCellTable->GetByIndex(i);
				if (pElement->m_nRow == MAX_ROW)
				{
					m_pImpl->m_pCellTable->Erase(i);
				}
				else if (pElement->m_nRow >= nRow)
				{
					{
						NumberDuck::Cell* __3920382863 = pElement->m_xObject;
						pElement->m_xObject = 0;
						m_pImpl->m_pCellTable->Set(pElement->m_nColumn, pElement->m_nRow + 1, __3920382863);
					}
					m_pImpl->m_pCellTable->Erase(i);
				}
				if (i == 0)
					break;
				i--;
			}
		}
		for (int i = 0; i < m_pImpl->m_pPictureVector->GetSize(); )
		{
			Picture* pPicture = m_pImpl->m_pPictureVector->Get(i);
			if (pPicture->GetY() == MAX_ROW)
			{
				PurgePicture((unsigned short)(i));
				continue;
			}
			if (pPicture->GetY() >= nRow)
				pPicture->SetY(pPicture->GetY() + 1);
			i++;
		}
		unsigned short nWorksheetIndex = 0;
		for (unsigned short i = 0; i < m_pImpl->m_pWorkbook->GetNumWorksheet(); i++)
		{
			if (this == m_pImpl->m_pWorkbook->GetWorksheetByIndex(i))
			{
				nWorksheetIndex = i;
				break;
			}
		}
		for (int i = 0; i < m_pImpl->m_pChartVector->GetSize(); )
		{
			Chart* pChart = m_pImpl->m_pChartVector->Get(i);
			if (pChart->GetY() == MAX_ROW)
			{
				PurgeChart((unsigned short)(i));
				continue;
			}
			if (pChart->GetY() >= nRow)
				pChart->SetY(pChart->GetY() + 1);
			pChart->m_pImpl->InsertRow(nWorksheetIndex, nRow);
			i++;
		}
		for (int i = 0; i < m_pImpl->m_pMergedCellVector->GetSize(); )
		{
			MergedCell* pMergedCell = m_pImpl->m_pMergedCellVector->Get(i);
			if (pMergedCell->GetY() == MAX_ROW)
			{
				PurgeMergedCell((unsigned short)(i));
				continue;
			}
			if (pMergedCell->GetY() >= nRow)
			{
				pMergedCell->SetY(pMergedCell->GetY() + 1);
				pMergedCell->SetHeight(pMergedCell->GetHeight());
			}
			else if (pMergedCell->GetY() + pMergedCell->GetHeight() >= nRow)
				pMergedCell->SetHeight(pMergedCell->GetHeight() + 1);
			i++;
		}
	}

	void Worksheet::DeleteRow(unsigned short nRow)
	{
		if (nRow > MAX_ROW)
			return;
		{
			int i = 0;
			while (i < m_pImpl->m_pRowInfoTable->GetSize())
			{
				Secret::TableElement<Secret::RowInfo*>* pElement = m_pImpl->m_pRowInfoTable->GetByIndex(i);
				if (pElement->m_nRow == nRow)
				{
					m_pImpl->m_pRowInfoTable->Erase(i);
				}
				else if (pElement->m_nRow > nRow)
				{
					int nTempColumn = pElement->m_nColumn;
					int nTempRow = pElement->m_nRow - 1;
					Secret::RowInfo* pRowInfo = 0;
					{
						NumberDuck::Secret::RowInfo* __3920382863 = pElement->m_xObject;
						pElement->m_xObject = 0;
						pRowInfo = __3920382863;
					}
					m_pImpl->m_pRowInfoTable->Erase(i++);
					{
						NumberDuck::Secret::RowInfo* __3798332131 = pRowInfo;
						pRowInfo = 0;
						m_pImpl->m_pRowInfoTable->Set(nTempColumn, nTempRow, __3798332131);
					}
					if (pRowInfo) delete pRowInfo;
				}
				else
				{
					i++;
				}
			}
		}
		{
			int i = 0;
			while (i < m_pImpl->m_pCellTable->GetSize())
			{
				Secret::TableElement<Cell*>* pElement = m_pImpl->m_pCellTable->GetByIndex(i);
				if (pElement->m_nRow == nRow)
				{
					m_pImpl->m_pCellTable->Erase(i);
				}
				else if (pElement->m_nRow > nRow)
				{
					int nTempColumn = pElement->m_nColumn;
					int nTempRow = pElement->m_nRow - 1;
					Cell* pCell = 0;
					{
						NumberDuck::Cell* __3920382863 = pElement->m_xObject;
						pElement->m_xObject = 0;
						pCell = __3920382863;
					}
					m_pImpl->m_pCellTable->Erase(i++);
					{
						NumberDuck::Cell* __2223188566 = pCell;
						pCell = 0;
						m_pImpl->m_pCellTable->Set(nTempColumn, nTempRow, __2223188566);
					}
					if (pCell) delete pCell;
				}
				else
				{
					i++;
				}
			}
		}
		for (int i = 0; i < m_pImpl->m_pPictureVector->GetSize(); )
		{
			Picture* pPicture = m_pImpl->m_pPictureVector->Get(i);
			if (pPicture->GetY() == nRow)
			{
				PurgePicture((unsigned short)(i));
				continue;
			}
			if (pPicture->GetY() > nRow)
				pPicture->SetY(pPicture->GetY() - 1);
			i++;
		}
		unsigned short nWorksheetIndex = 0;
		for (unsigned short i = 0; i < m_pImpl->m_pWorkbook->GetNumWorksheet(); i++)
		{
			if (this == m_pImpl->m_pWorkbook->GetWorksheetByIndex(i))
			{
				nWorksheetIndex = i;
				break;
			}
		}
		for (int i = 0; i < m_pImpl->m_pChartVector->GetSize(); )
		{
			Chart* pChart = m_pImpl->m_pChartVector->Get(i);
			if (pChart->GetY() == nRow)
			{
				PurgeChart((unsigned short)(i));
				continue;
			}
			if (pChart->GetY() > nRow)
				pChart->SetY(pChart->GetY() - 1);
			pChart->m_pImpl->DeleteRow(nWorksheetIndex, nRow);
			i++;
		}
		for (int i = 0; i < m_pImpl->m_pMergedCellVector->GetSize(); )
		{
			MergedCell* pMergedCell = m_pImpl->m_pMergedCellVector->Get(i);
			if (pMergedCell->GetY() == nRow)
			{
				PurgeMergedCell((unsigned short)(i));
				continue;
			}
			else if (pMergedCell->GetY() > nRow)
				pMergedCell->SetY(pMergedCell->GetY() - 1);
			else if (pMergedCell->GetY() + pMergedCell->GetHeight() > nRow)
				pMergedCell->SetHeight(pMergedCell->GetHeight() - 1);
			i++;
		}
	}

	Cell* Worksheet::GetCell(unsigned short nX, unsigned short nY)
	{
		if (nX > MAX_COLUMN || nY > MAX_ROW)
			return 0;
		Secret::TableElement<Cell*>* pElement = m_pImpl->m_pCellTable->GetOrCreate(nX, nY);
		if (pElement->m_xObject != 0)
			return pElement->m_xObject;
		pElement->m_xObject = new Cell(this);
		return pElement->m_xObject;
	}

	Cell* Worksheet::GetCellByRC(unsigned short nRow, unsigned short nColumn)
	{
		if (nRow == 0 || nColumn == 0)
			return 0;
		return GetCell((unsigned short)(nColumn - 1), (unsigned short)(nRow - 1));
	}

	Cell* Worksheet::GetCellByAddress(const char* szAddress)
	{
		Secret::Coordinate* pCoordinate = Secret::WorksheetImplementation::AddressToCoordinate(szAddress);
		if (pCoordinate == 0)
		{
			if (pCoordinate) delete pCoordinate;
			return 0;
		}
		Cell* pCell = GetCell(pCoordinate->m_nX, pCoordinate->m_nY);
		{
			delete pCoordinate;
			pCoordinate = 0;
		}
		{
			if (pCoordinate) delete pCoordinate;
			return pCell;
		}
	}

	int Worksheet::GetNumPicture()
	{
		return m_pImpl->m_pPictureVector->GetSize();
	}

	Picture* Worksheet::GetPictureByIndex(int nIndex)
	{
		if (nIndex >= GetNumPicture())
			return 0;
		return m_pImpl->m_pPictureVector->Get(nIndex);
	}

	Picture* Worksheet::CreatePicture(const char* szFileName)
	{
		Picture* pPicture = 0;
		Blob* pBlob = new Blob(false);
		if (pBlob->Load(szFileName))
		{
			if (pPicture == 0)
			{
				Secret::JpegLoader* pJpegLoader = new Secret::JpegLoader();
				Secret::JpegImageInfo* pImageInfo = pJpegLoader->Load(pBlob);
				if (pImageInfo != 0)
				{
					Picture* pOwnedPicture = new Picture(pBlob, Picture::Format::JPEG);
					pOwnedPicture->SetWidth((unsigned int)(pImageInfo->m_nWidth));
					pOwnedPicture->SetHeight((unsigned int)(pImageInfo->m_nHeight));
					pPicture = pOwnedPicture;
					{
						NumberDuck::Picture* __1257297764 = pOwnedPicture;
						pOwnedPicture = 0;
						m_pImpl->m_pPictureVector->PushBack(__1257297764);
					}
					if (pOwnedPicture) delete pOwnedPicture;
				}
				{
					delete pJpegLoader;
					pJpegLoader = 0;
				}
				if (pJpegLoader) delete pJpegLoader;
			}
			if (pPicture == 0)
			{
				Secret::PngLoader* pPngLoader = new Secret::PngLoader();
				Secret::PngImageInfo* pImageInfo = pPngLoader->Load(pBlob);
				if (pImageInfo != 0)
				{
					Picture* pOwnedPicture = new Picture(pBlob, Picture::Format::PNG);
					pOwnedPicture->SetWidth((unsigned int)(pImageInfo->m_nWidth));
					pOwnedPicture->SetHeight((unsigned int)(pImageInfo->m_nHeight));
					pPicture = pOwnedPicture;
					{
						NumberDuck::Picture* __1257297764 = pOwnedPicture;
						pOwnedPicture = 0;
						m_pImpl->m_pPictureVector->PushBack(__1257297764);
					}
					if (pOwnedPicture) delete pOwnedPicture;
				}
				{
					delete pPngLoader;
					pPngLoader = 0;
				}
				if (pPngLoader) delete pPngLoader;
			}
		}
		{
			delete pBlob;
			pBlob = 0;
		}
		{
			if (pBlob) delete pBlob;
			return pPicture;
		}
	}

	void Worksheet::PurgePicture(int nIndex)
	{
		Picture* pPicture = GetPictureByIndex(nIndex);
		if (pPicture != 0)
			m_pImpl->m_pPictureVector->Erase(nIndex);
	}

	int Worksheet::GetNumChart()
	{
		return m_pImpl->m_pChartVector->GetSize();
	}

	Chart* Worksheet::GetChartByIndex(int nIndex)
	{
		if (nIndex >= GetNumChart())
			return 0;
		return m_pImpl->m_pChartVector->Get(nIndex);
	}

	Chart* Worksheet::CreateChart(Chart::Type eType)
	{
		Chart* pOwnedChart = new Chart(this, eType);
		Chart* pChart = pOwnedChart;
		{
			NumberDuck::Chart* __1362309574 = pOwnedChart;
			pOwnedChart = 0;
			m_pImpl->m_pChartVector->PushBack(__1362309574);
		}
		{
			if (pOwnedChart) delete pOwnedChart;
			return pChart;
		}
	}

	void Worksheet::PurgeChart(int nIndex)
	{
		Chart* pChart = GetChartByIndex(nIndex);
		if (pChart != 0)
			m_pImpl->m_pChartVector->Erase(nIndex);
	}

	int Worksheet::GetNumMergedCell()
	{
		return m_pImpl->m_pMergedCellVector->GetSize();
	}

	MergedCell* Worksheet::GetMergedCellByIndex(int nIndex)
	{
		if (nIndex >= GetNumMergedCell())
			return 0;
		return m_pImpl->m_pMergedCellVector->Get(nIndex);
	}

	MergedCell* Worksheet::CreateMergedCell(unsigned short nX, unsigned short nY, unsigned short nWidth, unsigned short nHeight)
	{
		MergedCell* pOwnedMergedCell = new MergedCell(nX, nY, nWidth, nHeight);
		MergedCell* pMergedCell = pOwnedMergedCell;
		{
			NumberDuck::MergedCell* __3844553686 = pOwnedMergedCell;
			pOwnedMergedCell = 0;
			m_pImpl->m_pMergedCellVector->PushBack(__3844553686);
		}
		{
			if (pOwnedMergedCell) delete pOwnedMergedCell;
			return pMergedCell;
		}
	}

	void Worksheet::PurgeMergedCell(int nIndex)
	{
		MergedCell* pMergedCell = GetMergedCellByIndex(nIndex);
		if (pMergedCell != 0)
			m_pImpl->m_pMergedCellVector->Erase(nIndex);
	}

	void MD4::Process(BlobView* pBlobView)
	{
		int nIncomingSize = pBlobView->GetSize() - pBlobView->GetOffset();
		Reset();
		while (pBlobView->GetOffset() + BLOCK_SIZE <= pBlobView->GetSize())
		{
			ProcessChunk(pBlobView);
		}
		int nRemainingBlockSize = nIncomingSize % BLOCK_SIZE;
		int nPaddingSize = (BLOCK_SIZE - 8) - nRemainingBlockSize;
		if (nPaddingSize <= 0)
			nPaddingSize += BLOCK_SIZE;
		Blob* pFinalBlob = new Blob(true);
		BlobView* pFinalBlobView = pFinalBlob->GetBlobView();
		pFinalBlobView->Pack(pBlobView, pBlobView->GetSize() - pBlobView->GetOffset());
		pFinalBlobView->PackUint8(0x80);
		for (int i = 0; i < nPaddingSize - 1; i++)
			pFinalBlobView->PackUint8(0);
		for (int i = 0; i < 4; i++)
			pFinalBlobView->PackUint8((unsigned char)((nIncomingSize * 8) >> (8 * i)));
		pFinalBlobView->PackUint32(0);
		pFinalBlobView->SetOffset(0);
		while (pFinalBlobView->GetOffset() < pFinalBlobView->GetSize())
		{
			ProcessChunk(pFinalBlobView);
		}
		if (pFinalBlob) delete pFinalBlob;
	}

	void MD4::BlobWrite(BlobView* pBlobView)
	{
		for (int i = 0; i < 4; i++)
			for (int j = 0; j < 4; j++)
				pBlobView->PackUint8((unsigned char)(m_nBuffer[i] >> (8 * j)));
	}

	void MD4::Reset()
	{
		m_nBuffer[0] = 0x67452301;
		m_nBuffer[1] = 0xEFCDAB89;
		m_nBuffer[2] = 0x98BADCFE;
		m_nBuffer[3] = 0x10325476;
	}

	void MD4::ProcessChunk(BlobView* pBlobView)
	{
		int i;
		unsigned int A = m_nBuffer[0];
		unsigned int B = m_nBuffer[1];
		unsigned int C = m_nBuffer[2];
		unsigned int D = m_nBuffer[3];
		unsigned int m_nChunk[BLOCK_SIZE >> 2];
		Secret::nbAssert::Assert(pBlobView->GetOffset() + BLOCK_SIZE <= pBlobView->GetSize());
		for (i = 0; i < 16; i++)
		{
			unsigned int c0 = pBlobView->UnpackUint8();
			unsigned int c1 = pBlobView->UnpackUint8();
			unsigned int c2 = pBlobView->UnpackUint8();
			unsigned int c3 = pBlobView->UnpackUint8();
			m_nChunk[i] = c0 | (c1 << 8) | (c2 << 16) | (c3 << 24);
		}
		A = FF(A, B, C, D, m_nChunk[0], 3);
		D = FF(D, A, B, C, m_nChunk[1], 7);
		C = FF(C, D, A, B, m_nChunk[2], 11);
		B = FF(B, C, D, A, m_nChunk[3], 19);
		A = FF(A, B, C, D, m_nChunk[4], 3);
		D = FF(D, A, B, C, m_nChunk[5], 7);
		C = FF(C, D, A, B, m_nChunk[6], 11);
		B = FF(B, C, D, A, m_nChunk[7], 19);
		A = FF(A, B, C, D, m_nChunk[8], 3);
		D = FF(D, A, B, C, m_nChunk[9], 7);
		C = FF(C, D, A, B, m_nChunk[10], 11);
		B = FF(B, C, D, A, m_nChunk[11], 19);
		A = FF(A, B, C, D, m_nChunk[12], 3);
		D = FF(D, A, B, C, m_nChunk[13], 7);
		C = FF(C, D, A, B, m_nChunk[14], 11);
		B = FF(B, C, D, A, m_nChunk[15], 19);
		A = GG(A, B, C, D, m_nChunk[0], 3);
		D = GG(D, A, B, C, m_nChunk[4], 5);
		C = GG(C, D, A, B, m_nChunk[8], 9);
		B = GG(B, C, D, A, m_nChunk[12], 13);
		A = GG(A, B, C, D, m_nChunk[1], 3);
		D = GG(D, A, B, C, m_nChunk[5], 5);
		C = GG(C, D, A, B, m_nChunk[9], 9);
		B = GG(B, C, D, A, m_nChunk[13], 13);
		A = GG(A, B, C, D, m_nChunk[2], 3);
		D = GG(D, A, B, C, m_nChunk[6], 5);
		C = GG(C, D, A, B, m_nChunk[10], 9);
		B = GG(B, C, D, A, m_nChunk[14], 13);
		A = GG(A, B, C, D, m_nChunk[3], 3);
		D = GG(D, A, B, C, m_nChunk[7], 5);
		C = GG(C, D, A, B, m_nChunk[11], 9);
		B = GG(B, C, D, A, m_nChunk[15], 13);
		A = HH(A, B, C, D, m_nChunk[0], 3);
		D = HH(D, A, B, C, m_nChunk[8], 9);
		C = HH(C, D, A, B, m_nChunk[4], 11);
		B = HH(B, C, D, A, m_nChunk[12], 15);
		A = HH(A, B, C, D, m_nChunk[2], 3);
		D = HH(D, A, B, C, m_nChunk[10], 9);
		C = HH(C, D, A, B, m_nChunk[6], 11);
		B = HH(B, C, D, A, m_nChunk[14], 15);
		A = HH(A, B, C, D, m_nChunk[1], 3);
		D = HH(D, A, B, C, m_nChunk[9], 9);
		C = HH(C, D, A, B, m_nChunk[5], 11);
		B = HH(B, C, D, A, m_nChunk[13], 15);
		A = HH(A, B, C, D, m_nChunk[3], 3);
		D = HH(D, A, B, C, m_nChunk[11], 9);
		C = HH(C, D, A, B, m_nChunk[7], 11);
		B = HH(B, C, D, A, m_nChunk[15], 15);
		m_nBuffer[0] += A;
		m_nBuffer[1] += B;
		m_nBuffer[2] += C;
		m_nBuffer[3] += D;
	}

	unsigned int MD4::FF(unsigned int a, unsigned int b, unsigned int c, unsigned int d, unsigned int x, int s)
	{
		unsigned int t = a + ((b & c) | (~b & d)) + x;
		return t << s | t >> (32 - s);
	}

	unsigned int MD4::GG(unsigned int a, unsigned int b, unsigned int c, unsigned int d, unsigned int x, int s)
	{
		unsigned int t = a + ((b & (c | d)) | (c & d)) + x + 0x5A827999;
		return t << s | t >> (32 - s);
	}

	unsigned int MD4::HH(unsigned int a, unsigned int b, unsigned int c, unsigned int d, unsigned int x, int s)
	{
		unsigned int t = a + (b ^ c ^ d) + x + 0x6ED9EBA1;
		return t << s | t >> (32 - s);
	}

	MD4::MD4()
	{
	}

	Workbook::Workbook(License eLicense)
	{
		m_pImpl = 0;
		m_pImpl = new Secret::WorkbookImplementation();
		m_pImpl->m_pWorkbookGlobals = 0;
		m_pImpl->m_pWorksheetVector = new Secret::OwnedVector<Worksheet*>();
		Clear();
	}

	void Workbook::Clear()
	{
		m_pImpl->m_pWorksheetVector->Clear();
		if (m_pImpl->m_pWorkbookGlobals != 0)
			{
				delete m_pImpl->m_pWorkbookGlobals;
			}
		m_pImpl->m_pWorkbookGlobals = new Secret::WorkbookGlobals();
		CreateWorksheet();
	}

	bool Workbook::Load(const char* szFileName)
	{
		m_pImpl->m_pWorksheetVector->Clear();
		if (m_pImpl->m_pWorkbookGlobals != 0)
		{
			{
				delete m_pImpl->m_pWorkbookGlobals;
			}
			m_pImpl->m_pWorkbookGlobals = 0;
		}
		bool bLoaded = false;
		Secret::CompoundFile* pCompoundFile = new Secret::CompoundFile();
		if (pCompoundFile->Load(szFileName))
		{
			Secret::Stream* pStream = pCompoundFile->GetStreamByName("Workbook");
			if (pStream != 0)
			{
				pStream->SetOffset(0);
				while (pStream->GetOffset() < pStream->GetStreamSize())
				{
					Secret::BiffRecord* pBiffRecord = Secret::BiffRecord::CreateBiffRecord(pStream);
					if (pBiffRecord->GetType() == Secret::BiffRecord::Type::TYPE_BOF)
					{
						Secret::BofRecord* pBofRecord = (Secret::BofRecord*)(pBiffRecord);
						switch (pBofRecord->GetBofType())
						{
							case Secret::BofRecord::BofType::BOF_TYPE_WORKBOOK_GLOBALS:
							{
								{
									NumberDuck::Secret::BiffRecord* __3036547922 = pBiffRecord;
									pBiffRecord = 0;
									m_pImpl->m_pWorkbookGlobals = new Secret::BiffWorkbookGlobals(__3036547922, pStream);
								}
								continue;
							}

							case Secret::BofRecord::BofType::BOF_TYPE_SHEET:
							{
								Worksheet* pWorksheet = 0;
								{
									NumberDuck::Secret::BiffRecord* __3036547922 = pBiffRecord;
									pBiffRecord = 0;
									pWorksheet = new Secret::BiffWorksheet(this, (Secret::BiffWorkbookGlobals*)(m_pImpl->m_pWorkbookGlobals), __3036547922, pStream);
								}
								{
									NumberDuck::Worksheet* __3928651719 = pWorksheet;
									pWorksheet = 0;
									m_pImpl->m_pWorksheetVector->PushBack(__3928651719);
								}
								{
									if (pWorksheet) delete pWorksheet;
									continue;
								}
							}

							default:
							{
								Secret::nbAssert::Assert(false);
								break;
							}

						}
					}
					Secret::nbAssert::Assert(false);
					if (pBiffRecord) delete pBiffRecord;
				}
				bLoaded = true;
			}
		}
		{
			delete pCompoundFile;
			pCompoundFile = 0;
		}
		if (!bLoaded)
		{
			Secret::InternalString* sFileName = new Secret::InternalString("");
			Secret::Zip* pZip = new Secret::Zip();
			bool bContinue = pZip->LoadFile(szFileName);
			if (bContinue)
			{
				Secret::OwnedVector<Secret::InternalString*>* sNameVector = new Secret::OwnedVector<Secret::InternalString*>();
				{
					Blob* pXmlBlob = new Blob(true);
					BlobView* pXmlBlobView = pXmlBlob->GetBlobView();
					if (pZip->ExtractFileByName("[Content_Types].xml", pXmlBlobView))
					{
						Secret::XmlFile* pXmlFile = new Secret::XmlFile();
						pXmlBlobView->SetOffset(0);
						if (pXmlFile->Load(pXmlBlobView))
						{
						}
						{
							delete pXmlFile;
							pXmlFile = 0;
						}
						if (pXmlFile) delete pXmlFile;
					}
					{
						delete pXmlBlob;
						pXmlBlob = 0;
					}
					if (pXmlBlob) delete pXmlBlob;
				}
				m_pImpl->m_pWorkbookGlobals = new Secret::XlsxWorkbookGlobals();
				if (bContinue)
				{
					Secret::XmlFile* pXmlFile = new Secret::XmlFile();
					Blob* pXmlBlob = new Blob(true);
					BlobView* pXmlBlobView = pXmlBlob->GetBlobView();
					Secret::XmlNode* pWorkbookNode = 0;
					Secret::XmlNode* pSheetsNode = 0;
					Secret::XmlNode* pSheetNode = 0;
					bContinue = bContinue && pZip->ExtractFileByName("xl/workbook.xml", pXmlBlobView);
					if (bContinue)
					{
						pXmlBlobView->SetOffset(0);
						if (!pXmlFile->Load(pXmlBlobView))
							bContinue = false;
					}
					if (bContinue)
					{
						pWorkbookNode = pXmlFile->GetFirstChildElement("workbook");
						if (pWorkbookNode == 0)
							bContinue = false;
					}
					if (bContinue)
					{
						pSheetsNode = pWorkbookNode->GetFirstChildElement("sheets");
						if (pSheetsNode == 0)
							bContinue = false;
					}
					if (bContinue)
					{
						pSheetNode = pSheetsNode->GetFirstChildElement("sheet");
						while (pSheetNode != 0)
						{
							const char* szName = pSheetNode->GetAttribute("name");
							if (szName == 0)
							{
								bContinue = false;
								break;
							}
							sNameVector->PushBack(new Secret::InternalString(szName));
							pSheetNode = pSheetNode->GetNextSiblingElement("sheet");
						}
					}
					{
						delete pXmlBlob;
						pXmlBlob = 0;
					}
					{
						delete pXmlFile;
						pXmlFile = 0;
					}
					if (pXmlFile) delete pXmlFile;
					if (pXmlBlob) delete pXmlBlob;
				}
				if (bContinue)
				{
					Secret::XmlFile* pXmlFile = new Secret::XmlFile();
					Blob* pXmlBlob = new Blob(true);
					BlobView* pXmlBlobView = pXmlBlob->GetBlobView();
					Secret::XmlNode* pSstNode = 0;
					Secret::XmlNode* pSiNode = 0;
					bContinue = bContinue && pZip->ExtractFileByName("xl/sharedStrings.xml", pXmlBlobView);
					if (bContinue)
					{
						pXmlBlobView->SetOffset(0);
						if (!pXmlFile->Load(pXmlBlobView))
							bContinue = false;
					}
					if (bContinue)
					{
						pSstNode = pXmlFile->GetFirstChildElement("sst");
						if (pSstNode == 0)
							bContinue = false;
					}
					if (bContinue)
					{
						pSiNode = pSstNode->GetFirstChildElement("si");
						if (pSiNode == 0)
							bContinue = false;
					}
					while (bContinue && pSiNode != 0)
					{
						Secret::XmlNode* pTNode = 0;
						pTNode = pSiNode->GetFirstChildElement("t");
						if (pTNode == 0)
						{
							bContinue = false;
							break;
						}
						const char* szTemp = pTNode->GetText();
						m_pImpl->m_pWorkbookGlobals->PushSharedString(szTemp);
						pSiNode = pSiNode->GetNextSiblingElement("si");
					}
					{
						delete pXmlBlob;
						pXmlBlob = 0;
					}
					{
						delete pXmlFile;
						pXmlFile = 0;
					}
					if (pXmlFile) delete pXmlFile;
					if (pXmlBlob) delete pXmlBlob;
				}
				if (bContinue)
				{
					Secret::XmlFile* pXmlFile = new Secret::XmlFile();
					Blob* pXmlBlob = new Blob(true);
					BlobView* pXmlBlobView = pXmlBlob->GetBlobView();
					Secret::XmlNode* pStyleSheetNode = 0;
					bContinue = bContinue && pZip->ExtractFileByName("xl/styles.xml", pXmlBlobView);
					if (bContinue)
					{
						pXmlBlobView->SetOffset(0);
						if (!pXmlFile->Load(pXmlBlobView))
							bContinue = false;
					}
					if (bContinue)
					{
						pStyleSheetNode = pXmlFile->GetFirstChildElement("styleSheet");
						if (pStyleSheetNode == 0)
							bContinue = false;
					}
					bContinue = bContinue && Secret::XlsxWorkbookGlobals::ParseStyles(m_pImpl->m_pWorkbookGlobals, pStyleSheetNode);
					{
						delete pXmlBlob;
						pXmlBlob = 0;
					}
					{
						delete pXmlFile;
						pXmlFile = 0;
					}
					if (pXmlFile) delete pXmlFile;
					if (pXmlBlob) delete pXmlBlob;
				}
				if (bContinue)
				{
					int nWorksheetIndex = 0;
					int nNumFail = 0;
					while (bContinue)
					{
						sFileName->Set("xl/worksheets/sheet");
						sFileName->AppendInt(nWorksheetIndex);
						sFileName->AppendString(".xml");
						Secret::XmlFile* pXmlFile = new Secret::XmlFile();
						Blob* pXmlBlob = new Blob(true);
						BlobView* pXmlBlobView = pXmlBlob->GetBlobView();
						if (!pZip->ExtractFileByName(sFileName->GetExternalString(), pXmlBlobView))
						{
							nNumFail++;
							if (nNumFail > 5)
							{
								{
									delete pXmlBlob;
									pXmlBlob = 0;
								}
								{
									delete pXmlFile;
									pXmlFile = 0;
								}
								{
									if (pXmlFile) delete pXmlFile;
									if (pXmlBlob) delete pXmlBlob;
									break;
								}
							}
						}
						else
						{
							Secret::XmlNode* pWorksheetNode = 0;
							pXmlBlobView->SetOffset(0);
							if (!pXmlFile->Load(pXmlBlobView))
							{
								{
									delete pXmlBlob;
									pXmlBlob = 0;
								}
								{
									delete pXmlFile;
									pXmlFile = 0;
								}
								bContinue = false;
								{
									if (pXmlFile) delete pXmlFile;
									if (pXmlBlob) delete pXmlBlob;
									break;
								}
							}
							pWorksheetNode = pXmlFile->GetFirstChildElement("worksheet");
							Secret::XlsxWorksheet* pWorksheet = new Secret::XlsxWorksheet(this);
							pWorksheet->SetName(sNameVector->Get(m_pImpl->m_pWorksheetVector->GetSize())->GetExternalString());
							if (!pWorksheet->Parse((Secret::XlsxWorkbookGlobals*)(m_pImpl->m_pWorkbookGlobals), pWorksheetNode))
							{
								{
									delete pWorksheet;
									pWorksheet = 0;
								}
								{
									delete pXmlBlob;
									pXmlBlob = 0;
								}
								{
									delete pXmlFile;
									pXmlFile = 0;
								}
								bContinue = false;
								{
									if (pWorksheet) delete pWorksheet;
									if (pXmlFile) delete pXmlFile;
									if (pXmlBlob) delete pXmlBlob;
									break;
								}
							}
							{
								NumberDuck::Secret::XlsxWorksheet* __3928651719 = pWorksheet;
								pWorksheet = 0;
								m_pImpl->m_pWorksheetVector->PushBack(__3928651719);
							}
							if (pWorksheet) delete pWorksheet;
						}
						nWorksheetIndex++;
						{
							delete pXmlBlob;
							pXmlBlob = 0;
						}
						{
							delete pXmlFile;
							pXmlFile = 0;
						}
						if (pXmlFile) delete pXmlFile;
						if (pXmlBlob) delete pXmlBlob;
					}
				}
				bLoaded = bContinue;
				sNameVector->Clear();
				{
					delete sNameVector;
					sNameVector = 0;
				}
				if (sNameVector) delete sNameVector;
			}
			{
				delete pZip;
				pZip = 0;
			}
			{
				delete sFileName;
				sFileName = 0;
			}
			if (sFileName) delete sFileName;
			if (pZip) delete pZip;
		}
		if (bLoaded)
		{
			if (pCompoundFile) delete pCompoundFile;
			return true;
		}
		Clear();
		{
			if (pCompoundFile) delete pCompoundFile;
			return false;
		}
	}

	bool Workbook::Save(const char* szFileName, FileType eFileType)
	{
		m_pImpl->m_pWorkbookGlobals->Clear();
		if (eFileType == FileType::XLS)
		{
			Secret::Vector<Secret::BiffRecordContainer*>* pWorksheetBiffRecordContainerVector = new Secret::Vector<Secret::BiffRecordContainer*>();
			for (int i = 0; i < m_pImpl->m_pWorksheetVector->GetSize(); i++)
			{
				Worksheet* pWorksheet = m_pImpl->m_pWorksheetVector->Get(i);
				Secret::BiffRecordContainer* pBiffRecordContainer = new Secret::BiffRecordContainer();
				Secret::BiffWorksheet::Write(pWorksheet, m_pImpl->m_pWorkbookGlobals, (unsigned short)(i), pBiffRecordContainer);
				m_pImpl->m_pWorkbookGlobals->PushBiffWorksheetStreamSize(pBiffRecordContainer->GetSize());
				pWorksheetBiffRecordContainerVector->PushBack(pBiffRecordContainer);
				pBiffRecordContainer = 0;
				if (pBiffRecordContainer) delete pBiffRecordContainer;
			}
			Secret::CompoundFile* pCompoundFile = new Secret::CompoundFile();
			Secret::Stream* pStream = pCompoundFile->CreateStream("Workbook", Secret::Stream::Type::TYPE_USER_STREAM);
			Secret::BiffWorkbookGlobals::Write(m_pImpl->m_pWorkbookGlobals, m_pImpl->m_pWorksheetVector, pStream);
			for (int i = 0; i < pWorksheetBiffRecordContainerVector->GetSize(); i++)
			{
				Secret::BiffRecordContainer* pBiffRecordContainer = pWorksheetBiffRecordContainerVector->Get(i);
				pBiffRecordContainer->Write(pStream);
				{
					delete pBiffRecordContainer;
					pBiffRecordContainer = 0;
				}
			}
			{
				delete pWorksheetBiffRecordContainerVector;
				pWorksheetBiffRecordContainerVector = 0;
			}
			bool bResult = pCompoundFile->Save(szFileName);
			{
				delete pCompoundFile;
				pCompoundFile = 0;
			}
			{
				if (pWorksheetBiffRecordContainerVector) delete pWorksheetBiffRecordContainerVector;
				if (pCompoundFile) delete pCompoundFile;
				return bResult;
			}
		}
		else
		{
			return false;
		}
	}

	unsigned int Workbook::GetNumWorksheet()
	{
		return (unsigned int)(m_pImpl->m_pWorksheetVector->GetSize());
	}

	Worksheet* Workbook::GetWorksheetByIndex(unsigned int nIndex)
	{
		if (nIndex >= GetNumWorksheet())
			return 0;
		return m_pImpl->m_pWorksheetVector->Get((int)(nIndex));
	}

	Worksheet* Workbook::CreateWorksheet()
	{
		Worksheet* pWorksheet = new Secret::BiffWorksheet(this);
		int i = 0;
		Secret::InternalString* sName = new Secret::InternalString("");
		while (true)
		{
			sName->Set("Sheet");
			sName->AppendInt(++i);
			if (pWorksheet->SetName(sName->GetExternalString()))
				break;
		}
		{
			delete sName;
			sName = 0;
		}
		Worksheet* pTempWorksheet = pWorksheet;
		{
			NumberDuck::Worksheet* __3928651719 = pWorksheet;
			pWorksheet = 0;
			m_pImpl->m_pWorksheetVector->PushBack(__3928651719);
		}
		{
			if (pWorksheet) delete pWorksheet;
			if (sName) delete sName;
			return pTempWorksheet;
		}
	}

	void Workbook::PurgeWorksheet(unsigned int nIndex)
	{
		Worksheet* pWorksheet = GetWorksheetByIndex(nIndex);
		if (pWorksheet != 0)
		{
			m_pImpl->m_pWorksheetVector->Erase((int)(nIndex));
		}
		if (GetNumWorksheet() == 0)
			CreateWorksheet();
	}

	unsigned int Workbook::GetNumStyle()
	{
		return m_pImpl->m_pWorkbookGlobals->GetNumStyle();
	}

	Style* Workbook::GetStyleByIndex(unsigned int nIndex)
	{
		return m_pImpl->m_pWorkbookGlobals->GetStyleByIndex((unsigned short)(nIndex));
	}

	Style* Workbook::GetDefaultStyle()
	{
		return GetStyleByIndex(0);
	}

	Style* Workbook::CreateStyle()
	{
		return m_pImpl->m_pWorkbookGlobals->CreateStyle();
	}

	Workbook::~Workbook()
	{
		if (m_pImpl) delete m_pImpl;
	}

	Series::Series(Worksheet* pWorksheet, Secret::Formula* pValuesFormula)
	{
		m_pImpl = 0;
		m_pImpl = new Secret::SeriesImplementation(pWorksheet, pValuesFormula);
	}

	const char* Series::GetName()
	{
		if (m_pImpl->m_pNameFormula != 0)
			return m_pImpl->m_pNameFormula->ToChartNameString(m_pImpl->m_pWorksheet->m_pImpl);
		return "=";
	}

	bool Series::SetName(const char* szName)
	{
		Secret::Formula* pFormula = new Secret::Formula(szName, m_pImpl->m_pWorksheet->m_pImpl);
		if (pFormula->ValidateForChartName(m_pImpl->m_pWorksheet->m_pImpl))
		{
			{
				delete m_pImpl->m_pNameFormula;
			}
			{
				NumberDuck::Secret::Formula* __879619620 = pFormula;
				pFormula = 0;
				m_pImpl->m_pNameFormula = __879619620;
			}
			{
				if (pFormula) delete pFormula;
				return true;
			}
		}
		{
			delete pFormula;
			pFormula = 0;
		}
		{
			if (pFormula) delete pFormula;
			return false;
		}
	}

	const char* Series::GetValues()
	{
		if (m_pImpl->m_pValuesFormula != 0)
			return m_pImpl->m_pValuesFormula->ToChartString(m_pImpl->m_pWorksheet->m_pImpl);
		return "=";
	}

	bool Series::SetValues(const char* szValues)
	{
		Secret::Formula* pFormula = new Secret::Formula(szValues, m_pImpl->m_pWorksheet->m_pImpl);
		if (pFormula->ValidateForChart(m_pImpl->m_pWorksheet->m_pImpl))
		{
			{
				delete m_pImpl->m_pValuesFormula;
			}
			{
				NumberDuck::Secret::Formula* __879619620 = pFormula;
				pFormula = 0;
				m_pImpl->m_pValuesFormula = __879619620;
			}
			{
				if (pFormula) delete pFormula;
				return true;
			}
		}
		{
			delete pFormula;
			pFormula = 0;
		}
		{
			if (pFormula) delete pFormula;
			return false;
		}
	}

	Line* Series::GetLine()
	{
		return m_pImpl->m_pLine;
	}

	Fill* Series::GetFill()
	{
		return m_pImpl->m_pFill;
	}

	Marker* Series::GetMarker()
	{
		return m_pImpl->m_pMarker;
	}

	Series::~Series()
	{
		if (m_pImpl) delete m_pImpl;
	}

	MergedCell::MergedCell(unsigned int nX, unsigned int nY, unsigned int nWidth, unsigned int nHeight)
	{
		m_pImpl = 0;
		m_pImpl = new Secret::MergedCellImplementation();
		SetX(nX);
		SetY(nY);
		SetWidth(nWidth);
		SetHeight(nHeight);
	}

	unsigned int MergedCell::GetX() const
	{
		return m_pImpl->m_nX;
	}

	void MergedCell::SetX(unsigned int nX)
	{
		if (nX > 0xFF)
			nX = 0xFF;
		m_pImpl->m_nX = nX;
	}

	unsigned int MergedCell::GetY() const
	{
		return m_pImpl->m_nY;
	}

	void MergedCell::SetY(unsigned int nY)
	{
		if (nY > 0xFFFF)
			nY = 0xFFFF;
		m_pImpl->m_nY = nY;
	}

	unsigned int MergedCell::GetWidth() const
	{
		return m_pImpl->m_nWidth;
	}

	void MergedCell::SetWidth(unsigned int nWidth)
	{
		if (nWidth == 0)
			nWidth = 1;
		if (m_pImpl->m_nX + nWidth > 0xFF + 1)
			nWidth = 0xFF - m_pImpl->m_nX + 1;
		m_pImpl->m_nWidth = nWidth;
	}

	unsigned int MergedCell::GetHeight() const
	{
		return m_pImpl->m_nHeight;
	}

	void MergedCell::SetHeight(unsigned int nHeight)
	{
		if (nHeight == 0)
			nHeight = 1;
		if (m_pImpl->m_nY + nHeight > 0xFFFF + 1)
			nHeight = 0xFFFF - m_pImpl->m_nY + 1;
		m_pImpl->m_nHeight = nHeight;
	}

	MergedCell::~MergedCell()
	{
		if (m_pImpl) delete m_pImpl;
	}

	Legend::Legend()
	{
		m_pImpl = 0;
		m_pImpl = new Secret::LegendImplementation();
	}

	bool Legend::GetHidden() const
	{
		return m_pImpl->m_bHidden;
	}

	void Legend::SetHidden(bool bHidden)
	{
		m_pImpl->m_bHidden = bHidden;
	}

	Line* Legend::GetBorderLine()
	{
		return m_pImpl->m_pBorderLine;
	}

	Fill* Legend::GetFill()
	{
		return m_pImpl->m_pFill;
	}

	Legend::~Legend()
	{
		if (m_pImpl) delete m_pImpl;
	}

	Color::Color(unsigned char nRed, unsigned char nGreen, unsigned char nBlue)
	{
		m_nRed = 0;
		m_nGreen = 0;
		m_nBlue = 0;
		m_nRed = nRed;
		m_nGreen = nGreen;
		m_nBlue = nBlue;
	}

	bool Color::Equals(const Color* pColor) const
	{
		if (pColor == 0)
			return false;
		return m_nRed == pColor->m_nRed && m_nGreen == pColor->m_nGreen && m_nBlue == pColor->m_nBlue;
	}

	unsigned char Color::GetRed() const
	{
		return m_nRed;
	}

	unsigned char Color::GetGreen() const
	{
		return m_nGreen;
	}

	unsigned char Color::GetBlue() const
	{
		return m_nBlue;
	}

	void Color::Set(unsigned char nRed, unsigned char nGreen, unsigned char nBlue)
	{
		m_nRed = nRed;
		m_nGreen = nGreen;
		m_nBlue = nBlue;
	}

	void Color::SetRed(unsigned char nRed)
	{
		m_nRed = nRed;
	}

	void Color::SetGreen(unsigned char nGreen)
	{
		m_nGreen = nGreen;
	}

	void Color::SetBlue(unsigned char nBlue)
	{
		m_nBlue = nBlue;
	}

	void Color::SetFromColor(const Color* pColor)
	{
		m_nRed = pColor->m_nRed;
		m_nGreen = pColor->m_nGreen;
		m_nBlue = pColor->m_nBlue;
	}

	void Color::SetFromRgba(unsigned int nRgba)
	{
		m_nRed = (unsigned char)(nRgba & 0xFF);
		m_nGreen = (unsigned char)((nRgba >> 8) & 0xFF);
		m_nBlue = (unsigned char)((nRgba >> 16) & 0xFF);
	}

	unsigned int Color::GetRgba() const
	{
		return ((unsigned int)(m_nRed) << 0) | ((unsigned int)(m_nGreen) << 8) | ((unsigned int)(m_nBlue) << 16) | ((unsigned int)(0xFF) << 24);
	}

}



#if defined(CLANG_PARSE)

#elif defined(_MSC_VER)
	#include <stdio.h>
	#include <Windows.h>
#elif defined(CMAKE_PLATFORM_ANDROID)
	#include <android/log.h>
	#include <assert.h>
	#include <stdio.h>
#else
	#include <assert.h>
	#include <stdio.h>
#endif

namespace NumberDuck
{
	namespace  Secret
	{
		void nbAssert::Assert(bool bTest, const char* sxAssert, const char* sxFile, int nLine)
		{
			if (!bTest)
			{
				#if defined(CLANG_PARSE)
				#elif defined(_MSC_VER)
					printf("Assert: %s (%d) : %s\n", sxFile, nLine, sxAssert);
					DebugBreak();
				#elif defined(CMAKE_PLATFORM_ANDROID)
					//__android_log_print(ANDROID_LOG_DEBUG, "LOG_TAG", "test");
					__android_log_print(ANDROID_LOG_DEBUG, "LOG_TAG", "Assert: %s (%d) : %s\n", sxFile, nLine, sxAssert);
					assert(0);
				#else
					printf("Assert: %s (%d) : %s\n", sxFile, nLine, sxAssert);
					assert(0);
				#endif
			}
		}

		void nbAssert::Assert(bool bTest)
		{
			if (!bTest)
			{
				#if defined(CLANG_PARSE)
				#elif defined(_MSC_VER)
					//printf("Assert: %s (%d) : %s\n", szFile, nLine, szAssert);
					DebugBreak();
				#elif defined(CMAKE_PLATFORM_ANDROID)
					//__android_log_print(ANDROID_LOG_DEBUG, "LOG_TAG", "Assert: %s (%d) : %s\n", szFile, nLine, szAssert);
					assert(0);
				#else
					//printf("Assert: %s (%d) : %s\n", szFile, nLine, szAssert);
					assert(0);
				#endif
			}
		}
	}
}





#ifdef _WIN32
	#include <string>

	#include <Windows.h>
#endif

#include <cstdlib>

#include <stdio.h>
#include <string.h>

namespace NumberDuck
{
	Blob::Blob(bool bAutoResize)
	{
		m_nBufferSize = DEFAULT_SIZE;
		m_pBuffer = (unsigned char*)malloc(m_nBufferSize);
		memset(m_pBuffer, 0, m_nBufferSize);
		m_nSize = 0;
		m_bAutoResize = bAutoResize;

		m_pBlobView = new BlobView(this, 0, 0);
	}

	Blob::~Blob()
	{
		free(m_pBuffer);
		delete m_pBlobView;
	}

	bool Blob::Load(const char* szFileName)
	{
		#ifdef _WIN32
			int size_needed = MultiByteToWideChar(CP_UTF8, 0, szFileName, (int)strlen(szFileName), NULL, 0);
			std::wstring wsFileName(size_needed, 0);
			MultiByteToWideChar(CP_UTF8, 0, szFileName, (int)strlen(szFileName), &wsFileName[0], size_needed);
			FILE* pFile = _wfopen(wsFileName.c_str(), L"rb");
		#else
			FILE* pFile = fopen(szFileName, "rb");
		#endif

		if (pFile != NULL)
		{
			fseek(pFile, 0, SEEK_END );
			unsigned int nFileSize = ftell(pFile);
			rewind(pFile);

			if (nFileSize > 0)
			{
				free(m_pBuffer);

				m_nBufferSize = nFileSize;
				m_pBuffer = (unsigned char*)malloc(m_nBufferSize);
				m_nSize = 0;

				if (fread(m_pBuffer, m_nBufferSize, 1, pFile) == 1)
				{
					m_nSize = m_nBufferSize;
					fclose(pFile);
					m_pBlobView->SetEnd(m_nSize);
					return true;
				}
			}

			fclose(pFile);
		}
		return false;
	}

	bool Blob::Save(const char* szFileName)
	{
		#ifdef _WIN32
			int size_needed = MultiByteToWideChar(CP_UTF8, 0, szFileName, (int)strlen(szFileName), NULL, 0);
			std::wstring wsFileName(size_needed, 0);
			MultiByteToWideChar(CP_UTF8, 0, szFileName, (int)strlen(szFileName), &wsFileName[0], size_needed);
			FILE* pFile = _wfopen(wsFileName.c_str(), L"wb");
		#else
			FILE* pFile = fopen(szFileName, "wb");
		#endif

		if (pFile != NULL)
		{
			fwrite(m_pBuffer, 1, m_nSize, pFile);
			fclose(pFile);
			return true;
		}
		return false;
	}

	void Blob::Resize(int nSize, bool bAutoResize)
	{
		unsigned char* pOldBuffer = m_pBuffer;

		if (bAutoResize)
			CLIFFY_ASSERT(m_bAutoResize);

		if (nSize > m_nSize)
		{
			while (nSize > m_nBufferSize)
			{
				// if we are over 100mb, just use the target size, otherwise we'll blow out the RAMs
				if (nSize > 1024 * 1024 * 100)
					m_nBufferSize = nSize;
				else
					m_nBufferSize <<= 1;
			}

			m_pBuffer = (unsigned char*)malloc(m_nBufferSize);
			memcpy(m_pBuffer, pOldBuffer, m_nSize);
			memset(m_pBuffer + m_nSize, 0, m_nBufferSize - m_nSize);
			free(pOldBuffer);
		}
		m_nSize = nSize;

		m_pBlobView->SetEnd(nSize);
	}

	int Blob::GetSize()
	{
		return m_nSize;
	}

	unsigned char* Blob::GetData()
	{
		return m_pBuffer;
	}

	unsigned int Blob::GetMsoCrc32()
	{
		// https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-oshared/324014d1-39aa-4038-bbf4-f3781732f767
		// https://github.com/chakannom/algorithm/blob/master/MsoCRC32Compute/MsoCRC32Compute/MsoCRC32Compute.cpp
		unsigned int nCache[256];
		{
			unsigned int i;
			for (i = 0; i < 256; i++)
			{
				unsigned int nBit;
				unsigned int nValue = i << 24;
				for (nBit = 0; nBit < 8; nBit++)
				{
					if (nValue & (0x1 << 31))
						nValue = (nValue << 1) ^ 0xAF;
					else
						nValue = nValue << 1;
				}

				nCache[i] = nValue & 0xFFFF;
			}
		}

		unsigned int nCrcValue = 0;
		{
			int i;
			for (i = 0; i < m_nSize; i++)
			{
				unsigned int nIndex = nCrcValue;
				nIndex = nIndex >> 24;
				nIndex = nIndex ^ m_pBuffer[i];
				nCrcValue = nCrcValue << 8;
				nCrcValue = nCrcValue ^ nCache[nIndex];
				//printf("%x %lX \n", m_pBuffer[i], nCrcValue);
			}
		}

		return nCrcValue;
	}

	void Blob::PackData(unsigned char* pData, int nOffset, int nSize)
	{
		CLIFFY_ASSERT(nOffset + nSize <= m_nSize);
		memcpy(m_pBuffer + nOffset, pData, nSize);
	}

	void Blob::UnpackData(unsigned char* pData, int nOffset, int nSize)
	{
		CLIFFY_ASSERT(nOffset + nSize <= m_nSize);
		memcpy(pData, m_pBuffer + nOffset, nSize);
	}

	BlobView* Blob::GetBlobView()
	{
		return m_pBlobView;
	}

	bool Blob::Equal(Blob* pOther)
	{
		if (m_nSize != pOther->m_nSize)
			return false;
		return memcmp(m_pBuffer, pOther->m_pBuffer, m_nSize) == 0;
	}

	// Blob View
	BlobView::BlobView(Blob* pBlob, int nStart, int nEnd)
	{
		CLIFFY_ASSERT(nStart >= 0);
		CLIFFY_ASSERT(nStart <= nEnd);
		CLIFFY_ASSERT(nEnd <= pBlob->GetSize());

		m_pBlob = pBlob;
		m_nStart = nStart;
		m_nEnd = nEnd;
		m_nOffset = 0;
	}

	BlobView::~BlobView()
	{
	}

	#define WIDTH  (8 * sizeof(unsigned char))
	#define TOPBIT (1 << (WIDTH - 1))
	#define POLYNOMIAL 0xD8		/* 11011 followed by 0's */

	unsigned char BlobView::GetChecksum()
	{
		unsigned char remainder = 0;
		unsigned int nEnd = m_nEnd;
		if (nEnd == 0)
			nEnd = m_pBlob->m_nSize;

		for (unsigned int byte = m_nStart; byte < nEnd; byte++)
		{
			remainder ^= (m_pBlob->m_pBuffer[byte] << (WIDTH - 8));
			for (unsigned int bit = 8; bit > 0; --bit)
			{
				if (remainder & TOPBIT)
				{
					remainder = (remainder << 1) ^ POLYNOMIAL;
				}
				else
				{
					remainder = (remainder << 1);
				}
			}
		}
		return (remainder);
	}

	// todo: this is probably wrong on different endians and stuff?
	// casting values weirdly with 64bit ints...
	// maybe we should shift and & 0xFF etc
	void BlobView::PackUint8(unsigned char n)
	{
		PackData(&n, 1);
	}

	void BlobView::PackUint16(unsigned short n)
	{
		PackData((unsigned char*)&n, 2);
	}

	void BlobView::PackUint32(unsigned int n)
	{
		PackData((unsigned char*)&n, 4);
	}

	void BlobView::PackInt8(signed char n)
	{
		PackData((unsigned char*)&n, 1);
	}

	void BlobView::PackInt16(signed short n)
	{
		PackData((unsigned char*)&n, 2);
	}

	void BlobView::PackInt32(signed int n)
	{
		PackData((unsigned char*)&n, 4);
	}

	void BlobView::PackDouble(double n)
	{
		PackData((unsigned char*)&n, 8);
	}

	unsigned char BlobView::UnpackUint8()
	{
		unsigned char n = 0;
		UnpackData(&n, 1);
		return n;
	}

	unsigned short BlobView::UnpackUint16()
	{
		unsigned short n = 0;
		UnpackData((unsigned char*)&n, 2);
		return n;
	}

	unsigned int BlobView::UnpackUint32()
	{
		unsigned int n;
		UnpackData((unsigned char*)&n, 4);
		return n;
	}

	signed char BlobView::UnpackInt8()
	{
		signed char n = 0;
		UnpackData((unsigned char*)&n, 1);
		return n;
	}

	signed short BlobView::UnpackInt16()
	{
		signed short n = 0;
		UnpackData((unsigned char*)&n, 2);
		return n;
	}

	signed int BlobView::UnpackInt32()
	{
		signed int n = 0;
		UnpackData((unsigned char*)&n, 4);
		return n;
	}

	double BlobView::UnpackDouble()
	{
		double n = 0;
		UnpackData((unsigned char*)&n, 8);
		return n;
	}

	signed int BlobView::UnpackInt32At(int nOffset)
	{
		signed int n = 0;
		UnpackDataAt(nOffset, (unsigned char*)&n, 4);
		return n;
	}

	int BlobView::GetStart()
	{
		return m_nStart;
	}

	int BlobView::GetEnd()
	{
		return m_nEnd;
	}

	void BlobView::SetEnd(int nEnd)
	{
		if (nEnd > 0)
		{
			CLIFFY_ASSERT(nEnd > m_nOffset);
			CLIFFY_ASSERT(nEnd >= m_nStart);
		}

		m_nEnd = nEnd;
	}

	int BlobView::GetSize()
	{
		int nEnd = m_nEnd;
		if (nEnd == 0)
			nEnd = m_pBlob->m_nSize;
		return nEnd - m_nStart;
	}

	int BlobView::GetOffset()
	{
		return m_nOffset;
	}

	void BlobView::SetOffset(int nOffset)
	{
		// todo: cap?
		m_nOffset = nOffset;
	}

	void BlobView::Pack(BlobView* pBlobView, int nSize)
	{
		PackAt(m_nOffset, pBlobView, nSize);
		m_nOffset += nSize;
	}

	void BlobView::PackAt(int nOffset, BlobView* pBlobView, int nSize)
	{
		unsigned char* pData = new unsigned char[nSize];
		pBlobView->UnpackData(pData, nSize);
		PackDataAt(nOffset, pData, nSize);
		delete [] pData;
	}

	void BlobView::Unpack(BlobView* pBlobView, int nSize)
	{
		UnpackAt(m_nOffset, pBlobView, nSize);
		m_nOffset += nSize;
	}

	void BlobView::UnpackAt(int nOffset, BlobView* pBlobView, int nSize)
	{
		unsigned char* pData = new unsigned char[nSize];
		UnpackDataAt(nOffset, pData, nSize);

		pBlobView->PackData(pData, nSize);
		delete [] pData;
	}

	void BlobView::PackData(unsigned char* pData, int nSize)
	{
		PackDataAt(m_nOffset, pData, nSize);
		m_nOffset += nSize;
	}

	void BlobView::UnpackData(unsigned char* pData, int nSize)
	{
		UnpackDataAt(m_nOffset, pData, nSize);
		m_nOffset += nSize;
	}

	// Single Blob View

	Blob* BlobView::GetBlob()
	{
		return m_pBlob;
	}

	void BlobView::PackDataAt(int nOffset, unsigned char* pData, int nSize)
	{
		int nBlobOffset = m_nStart + nOffset;
		if (this == m_pBlob->GetBlobView())
		{
			if (nBlobOffset + nSize > m_pBlob->GetSize())
				m_pBlob->Resize(nBlobOffset + nSize, true);
		}
		else
		{
			CLIFFY_ASSERT(nBlobOffset + nSize <= m_nEnd);
		}
		m_pBlob->PackData(pData, nBlobOffset, nSize);
	}

	void BlobView::UnpackDataAt(int nOffset, unsigned char* pData, int nSize)
	{
		int nBlobOffset = m_nStart + nOffset;
		int nEnd = m_nEnd;
		if (nEnd == 0)
			nEnd = m_pBlob->GetSize();
		CLIFFY_ASSERT(nBlobOffset + nSize <= nEnd);
		m_pBlob->UnpackData(pData, nBlobOffset, nSize);
	}
}



#include <stdio.h>

namespace NumberDuck
{
	namespace Secret
	{
		void Console::Log(const char* sxLog)
		{
			printf("%s\n", sxLog);
			fflush(stdout);
		}
	}
}



#include <stdio.h>
#include <stdlib.h>
#include <cstring>

namespace NumberDuck
{
	namespace Secret
	{
		bool ExternalString::Equal(const char* szA, const char* szB)
		{
			return strcmp(szA, szB) == 0;
		}

		// a bad checksum
		int ExternalString::GetChecksum(const char* szString)
		{
			int nResult = 0xABC123;
			const char* p = szString;
			while (*p)
				nResult = (nResult ^ *(p++)) << 1;
			return nResult;
		}

		long ExternalString::hextol(const char* szString)
		{
			return ::strtol(szString, NULL, 16);
		}

		int ExternalString::atoi(const char* szString)
		{
			return ::atoi(szString);
		}

		double ExternalString::atof(const char* szString)
		{
			return ::atof(szString);
		}

		long ExternalString::atol(const char* szString)
		{
			return ::atol(szString);
		}
	}
}





#include <stdio.h>
#include <stdlib.h>

namespace NumberDuck
{
	namespace Secret
	{
		InternalString::InternalString(const char* szString)
		{
			m_szBuffer = NULL;
			m_nBufferSize = 0;
			m_nByteLength = 0;
			m_nCharLength = 0;
			Set(szString);
		}

		InternalString::~InternalString()
		{
			if (m_szBuffer)
				delete [] m_szBuffer;
		}

		InternalString* InternalString::CreateClone()
		{
			return new InternalString(m_szBuffer);
		}

		void InternalString::Set(const char* szString)
		{
			GetUtf8Length(szString, &m_nCharLength, &m_nByteLength);
			Resize(m_nByteLength);
			memcpy(m_szBuffer, szString, m_nByteLength);
			m_szBuffer[m_nByteLength] = 0;
		}

		const char* InternalString::GetExternalString() const
		{
			return m_szBuffer;
		}

		void InternalString::Append(const char* szString)
		{
			AppendString(szString);
		}

		void InternalString::AppendChar(unsigned short nChar)
		{
			if (nChar <= 0x7F)
			{
				m_szBuffer[m_nByteLength] = (unsigned char)nChar;
				m_nCharLength++;
				m_nByteLength++;
				Resize(m_nByteLength);
				m_szBuffer[m_nByteLength] = 0;
				return;
			}

			if (nChar <= 0x7FF)
			{
				Resize(m_nByteLength + 2);
				m_nCharLength++;
				m_szBuffer[m_nByteLength++] = 0xC0 | ((nChar >> 6) & 0xFF);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 0) & 0x3F);
				m_szBuffer[m_nByteLength] = 0;
				return;
			}

			if (nChar <= 0xFFFF)
			{
				Resize(m_nByteLength + 3);
				m_nCharLength++;
				m_szBuffer[m_nByteLength++] = 0xE0 | ((nChar >> 12) & 0xFF);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 6) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 0) & 0x3F);
				m_szBuffer[m_nByteLength] = 0;
				return;
			}

			/*if (nChar <= 0x1FFFFF)
			   {
				Resize(m_nByteLength+4);
				m_nCharLength++;
				m_szBuffer[m_nByteLength++] = 0xF0 | ((nChar >> 18) & 0xFF);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 12) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 6) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 0) & 0x3F);
				m_szBuffer[m_nByteLength] = 0;
				return;
			   }

			   if (nChar <= 0x3FFFFFF)
			   {
				Resize(m_nByteLength+5);
				m_nCharLength++;
				m_szBuffer[m_nByteLength++] = 0xF8 | ((nChar >> 24) & 0xFF);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 18) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 12) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 6) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 0) & 0x3F);
				m_szBuffer[m_nByteLength] = 0;
				return;
			   }

			   if (nChar <= 0x7FFFFFFF)
			   {
				Resize(m_nByteLength+6);
				m_nCharLength++;
				m_szBuffer[m_nByteLength++] = 0xFC | ((nChar >> 30) & 0xFF);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 24) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 18) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 12) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 6) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 0) & 0x3F);
				m_szBuffer[m_nByteLength] = 0;
				return;
			   }*/

			CLIFFY_ASSERT(false);
		}

		void InternalString::AppendString(const char* szString)
		{
			int nCharLength = 0;
			int nByteLength = 0;
			GetUtf8Length(szString, &nCharLength, &nByteLength);
			Resize(m_nByteLength + nByteLength);
			memcpy(m_szBuffer + m_nByteLength, szString, nByteLength);
			m_nCharLength += nCharLength;
			m_nByteLength += nByteLength;
			m_szBuffer[m_nByteLength] = 0;
		}

		void InternalString::AppendInt(int nInt)
		{
			if (nInt == -0)
				nInt = 0;

			char szTemp[1024];
			sprintf(szTemp, "%d", nInt);
			AppendString(szTemp);
		}

		void InternalString::AppendUnsignedInt(unsigned int nUint32)
		{
			AppendUint32(nUint32);
		}

		void InternalString::AppendUint32(unsigned int nUint32)
		{
			char szTemp[1024];
			sprintf(szTemp, "%u", nUint32);
			AppendString(szTemp);
		}

		void InternalString::AppendDouble(double fDouble)
		{
			char szTemp[1024];
			sprintf(szTemp, "%G", fDouble);
			if (strcmp(szTemp, "-0") == 0)
				AppendString("0");
			else
				AppendString(szTemp);
		}

		void InternalString::PrependChar(unsigned short nChar)
		{
			int nCharSize = GetCharSize(nChar);
			Resize(m_nByteLength + nCharSize);

			memmove(m_szBuffer + nCharSize, m_szBuffer, m_nByteLength);

			EncodeChar(nChar, (unsigned char*)m_szBuffer);

			m_nCharLength++;
			m_nByteLength += nCharSize;
			m_szBuffer[m_nByteLength] = 0;
		}

		void InternalString::PrependString(const char* szString)
		{
			int nCharLength = 0;
			int nByteLength = 0;
			GetUtf8Length(szString, &nCharLength, &nByteLength);
			Resize(m_nByteLength + nByteLength);
			memmove(m_szBuffer + nByteLength, m_szBuffer, m_nByteLength);
			memcpy(m_szBuffer, szString, nByteLength);

			m_nCharLength += nCharLength;
			m_nByteLength += nByteLength;
			m_szBuffer[m_nByteLength] = 0;
		}

		void InternalString::AppendStringData(unsigned char* pData, int nLength)
		{
			// not utf8
			int nNewLength = m_nCharLength + nLength;
			Resize(nNewLength);

			memcpy(m_szBuffer + m_nCharLength, pData, nLength);

			m_nCharLength = nNewLength;
			m_nByteLength = m_nCharLength;
			m_szBuffer[m_nByteLength] = 0;
		}

		void InternalString::SubStr(int nStart, int nLength)
		{
			CLIFFY_ASSERT(nStart >= 0);
			CLIFFY_ASSERT(nLength >= 0);
			CLIFFY_ASSERT(nStart + nLength <= m_nCharLength);

			if (IsAscii())
			{
				memmove(m_szBuffer, m_szBuffer+nStart, nLength);
				m_szBuffer[nLength] = 0;
				m_nCharLength = nLength;
				m_nByteLength = nLength;
				return;
			}

			int i;
			unsigned char* p = (unsigned char*)m_szBuffer;
			for (i = 0; i < nStart; i++)
				p += GetUtf8CharSize((*p));

			char* szTemp = new char[m_nBufferSize];

			unsigned char* pOut = (unsigned char*)szTemp;
			for (i = 0; i < nLength; i++)
			{
				unsigned short nChar = DecodeChar(p);
				int nCharSize = EncodeChar(nChar, pOut);

				p += nCharSize;
				pOut += nCharSize;
			}
			(*pOut) = 0;

			m_nCharLength = nLength;
			m_nByteLength = (int)(pOut - (unsigned char*)szTemp);

			delete m_szBuffer;
			m_szBuffer = szTemp;
		}

		/*void InternalString :: CropBack(int nLength)
		   {
			CLIFFY_ASSERT(nLength <= m_nCharLength);
			SubStr(0, m_nCharLength - nLength);
		   }*/

		void InternalString::CropFront(int nLength)
		{
			CLIFFY_ASSERT(nLength >= 0);
			CLIFFY_ASSERT(nLength <= m_nCharLength);

			int i;
			unsigned char* p = (unsigned char*)m_szBuffer;
			for (i = 0; i < nLength; i++)
				p += GetUtf8CharSize((*p));

			m_nByteLength -= (int)(p - (unsigned char*)m_szBuffer);
			m_nCharLength -= nLength;

			memmove(m_szBuffer, p, m_nByteLength);
			m_szBuffer[m_nByteLength] = 0;
		}

		int InternalString::GetLength()
		{
			return m_nCharLength;
		}

		unsigned short InternalString::GetChar(int nIndex)
		{
			CLIFFY_ASSERT(nIndex >= 0);
			CLIFFY_ASSERT(nIndex < m_nCharLength);

			int i;
			unsigned char* p = (unsigned char*)m_szBuffer;
			for (i = 0; i < nIndex; i++)
				p += GetUtf8CharSize((*p));
			return DecodeChar(p);
		}

		void InternalString::BlobWriteUtf8(BlobView* pBlobView, bool bZeroTerminator)
		{
			unsigned char* p = (unsigned char*)m_szBuffer;
			pBlobView->PackData(p, m_nByteLength);
			if (bZeroTerminator)
				pBlobView->PackUint8(0);
		}

		void InternalString::BlobWrite16Bit(BlobView* pBlobView, bool bZeroTerminator)
		{
			int i;
			unsigned char* p = (unsigned char*)m_szBuffer;
			for (i = 0; i < m_nCharLength; i++)
			{
				pBlobView->PackUint16(DecodeChar(p));
				p += GetUtf8CharSize(p[0]);
			}
			if (bZeroTerminator)
				pBlobView->PackUint16(0);
		}

		bool InternalString::IsAscii()
		{
			return m_nCharLength == m_nByteLength;
		}

		bool InternalString::IsEqual(const char* szCompare)
		{
			return strcmp(m_szBuffer, szCompare) == 0;
		}

		bool InternalString::StartsWith(const char* szString)
		{
			int nCharLength;
			int nByteLength;
			GetUtf8Length(szString, &nCharLength, &nByteLength);

			if (nByteLength <= m_nByteLength)
				if (memcmp(szString, m_szBuffer, nByteLength) == 0)
					return true;
			return false;
		}

		bool InternalString::EndsWith(const char* szString)
		{
			int nCharLength;
			int nByteLength;
			GetUtf8Length(szString, &nCharLength, &nByteLength);

			if (nByteLength <= m_nByteLength)
				if (memcmp(szString, m_szBuffer + m_nByteLength - nByteLength, nByteLength) == 0)
					return true;
			return false;
		}

		double InternalString::ParseDouble()
		{
			double fTemp = 0.0f;
			sscanf(m_szBuffer, "%lf", &fTemp);
			return fTemp;
		}

		unsigned int InternalString::ParseHex()
		{
			unsigned int nTemp;
			sscanf(m_szBuffer, "%x", &nTemp);
			return nTemp;
		}

		int InternalString::FindChar(unsigned short nChar)
		{
			int nIndex = 0;
			unsigned char* p = (unsigned char*)m_szBuffer;
			while (nIndex < m_nCharLength)
			{
				unsigned short nTestChar = DecodeChar(p);
				if (nTestChar == nChar)
					return nIndex;
				p += GetUtf8CharSize((*p));
				nIndex++;
			}
			return -1;
		}

		// probably broken...
		void InternalString::Replace(const char* sxFind, const char* sxReplace)
		{
			InternalString* sFind = new InternalString(sxFind);
			InternalString* sReplace = new InternalString(sxReplace);
			int nByteLengthDelta = sReplace->m_nByteLength - sFind->m_nByteLength;
			int nCharLengthDelta = sReplace->m_nCharLength - sFind->m_nCharLength;

			int nOffset = 0;
			while (true)
			{
				if (nOffset + sFind->m_nByteLength > m_nByteLength)
				{
					delete sFind;
					delete sReplace;
					return;
				}

				unsigned char c = m_szBuffer[nOffset];
				if (c == 0)
					break;

				if (memcmp(m_szBuffer + nOffset, sFind->m_szBuffer, sFind->m_nByteLength) == 0)
				{
					if (nByteLengthDelta > 0)
						Resize(m_nByteLength + nByteLengthDelta);

					int nFrom = nOffset + sFind->m_nByteLength;
					int nTo = nFrom + nByteLengthDelta;
					int nRemain = m_nByteLength - nFrom + 1;
					if (nRemain < 1)
						nRemain = 1;
					memmove(m_szBuffer+nTo, m_szBuffer+nFrom, nRemain);
					memcpy(m_szBuffer + nOffset, sReplace->m_szBuffer, sReplace->m_nByteLength);

					m_nByteLength += nByteLengthDelta;
					nCharLengthDelta += nCharLengthDelta;

					nOffset = nTo;
					continue;
				}

				nOffset += GetUtf8CharSize(c);
			}

			delete sFind;
			delete sReplace;
		}

		void InternalString::Resize(int nSize)
		{
			CLIFFY_ASSERT(nSize < 1024 * 1024 * 100);
			nSize++;
			if (m_nBufferSize < nSize)
			{
				nSize *= 2;
				char* szTemp = new char[nSize];
				if (m_szBuffer)
				{
					memcpy(szTemp, m_szBuffer, m_nBufferSize);
					delete [] 
					m_szBuffer;
				}
				m_szBuffer = szTemp;
				m_nBufferSize = nSize;
			}
		}

		int InternalString::GetCharSize(unsigned short nChar)
		{
			if (nChar <= 0x7F)
				return 1;
			if (nChar <= 0x7FF)
				return 2;
			if (nChar <= 0xFFFF)
				return 3;

			/*if (nChar <= 0x1FFFFF)
			   {
				Resize(m_nByteLength+4);
				m_nCharLength++;
				m_szBuffer[m_nByteLength++] = 0xF0 | ((nChar >> 18) & 0xFF);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 12) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 6) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 0) & 0x3F);
				m_szBuffer[m_nByteLength] = 0;
				return;
			   }

			   if (nChar <= 0x3FFFFFF)
			   {
				Resize(m_nByteLength+5);
				m_nCharLength++;
				m_szBuffer[m_nByteLength++] = 0xF8 | ((nChar >> 24) & 0xFF);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 18) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 12) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 6) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 0) & 0x3F);
				m_szBuffer[m_nByteLength] = 0;
				return;
			   }

			   if (nChar <= 0x7FFFFFFF)
			   {
				Resize(m_nByteLength+6);
				m_nCharLength++;
				m_szBuffer[m_nByteLength++] = 0xFC | ((nChar >> 30) & 0xFF);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 24) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 18) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 12) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 6) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 0) & 0x3F);
				m_szBuffer[m_nByteLength] = 0;
				return;
			   }*/

			CLIFFY_ASSERT(false);
			return 0;
		}

		int InternalString::GetUtf8CharSize(unsigned char cLeadChar)
		{
			if (cLeadChar < 128)
				return 1;
			if (cLeadChar < 234)
				return 2;
			if (cLeadChar < 240)
				return 3;
			return 4;
		}

		bool InternalString::GetUtf8Length(const char* szString, int* pCharLength, int* pByteLength)
		{
			const char* p = szString;
			(*pCharLength) = 0;
			(*pByteLength) = 0;

			while (true)
			{
				unsigned char c = p[(*pByteLength)];

				if (c == 0)
					break;

				int nCharSize = GetUtf8CharSize(c);
				(*pCharLength)++;
				(*pByteLength) += nCharSize;
			}

			return true;
		}

		unsigned short InternalString::DecodeChar(unsigned char* pUtf8Char)
		{
			if (pUtf8Char[0] <= 0x7F)
				return pUtf8Char[0];

			if ((pUtf8Char[0] & 0xE0) == 0xC0)	// 110xxxxx
			{
				if ((pUtf8Char[1] & 0xC0) != 0x80)	// 10xxxxxx
					return 0;
				return (((unsigned short)(pUtf8Char[0] & 0x1F)) << 6) + (pUtf8Char[1] & 0x3F);
			}

			if ((pUtf8Char[0] & 0xF0) == 0xE0)	// 1110xxxx
			{
				if ((pUtf8Char[1] & 0xC0) != 0x80)	// 10xxxxxx
					return 0;
				if ((pUtf8Char[2] & 0xC0) != 0x80)	// 10xxxxxx
					return 0;

				// untested
				return (((unsigned short)(pUtf8Char[0] & 0x1F)) << 12) + (((unsigned short)(pUtf8Char[1] & 0x3F)) << 6) + (pUtf8Char[2] & 0x3F);
			}

			//printf("%04X - %s\n", pUtf8Char[0], pUtf8Char);
			CLIFFY_ASSERT(false);

			return 0;
		}

		int InternalString::EncodeChar(unsigned short nChar, unsigned char* pBuffer)
		{
			if (nChar <= 0x7F)
			{
				pBuffer[0] = (unsigned char)nChar;
				return 1;
			}

			if (nChar <= 0x7FF)
			{
				pBuffer[0] = 0xC0 | ((nChar >> 6) & 0xFF);
				pBuffer[1] = 0x80 | ((nChar >> 0) & 0x3F);
				return 2;
			}

			if (nChar <= 0xFFFF)
			{
				pBuffer[0] = 0xE0 | ((nChar >> 12) & 0xFF);
				pBuffer[1] = 0x80 | ((nChar >> 6) & 0x3F);
				pBuffer[2] = 0x80 | ((nChar >> 0) & 0x3F);
				return 3;
			}

			/*if (nChar <= 0x1FFFFF)
			   {
				Resize(m_nByteLength+4);
				m_nCharLength++;
				m_szBuffer[m_nByteLength++] = 0xF0 | ((nChar >> 18) & 0xFF);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 12) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 6) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 0) & 0x3F);
				m_szBuffer[m_nByteLength] = 0;
				return;
			   }

			   if (nChar <= 0x3FFFFFF)
			   {
				Resize(m_nByteLength+5);
				m_nCharLength++;
				m_szBuffer[m_nByteLength++] = 0xF8 | ((nChar >> 24) & 0xFF);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 18) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 12) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 6) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 0) & 0x3F);
				m_szBuffer[m_nByteLength] = 0;
				return;
			   }

			   if (nChar <= 0x7FFFFFFF)
			   {
				Resize(m_nByteLength+6);
				m_nCharLength++;
				m_szBuffer[m_nByteLength++] = 0xFC | ((nChar >> 30) & 0xFF);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 24) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 18) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 12) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 6) & 0x3F);
				m_szBuffer[m_nByteLength++] = 0x80 | ((nChar >> 0) & 0x3F);
				m_szBuffer[m_nByteLength] = 0;
				return;
			   }*/

			CLIFFY_ASSERT(false);
			return 0;
		}
	}
}




#include <math.h>

namespace NumberDuck
{
	namespace Secret
	{
		double Utils::Pow(double fBase, double fExponent)
		{
			return pow(fBase, fExponent);
		}

		double Utils::ByteConvertUint64ToDouble(uint64_t nValue)
		{
			return *(double*)(&nValue);
		}

		int32_t Utils::ByteConvertUint32ToInt32(uint32_t nValue)
		{
			return *(int32_t*)(&nValue);
		}

		uint32_t Utils::ByteConvertInt32ToUint32(int32_t nValue)
		{
			return *(uint32_t*)(&nValue);
		}

		void Utils::Indent(int nTabDepth, InternalString* sOut)
		{
			int i;
			for (i = 0; i < nTabDepth; i++)
				sOut->AppendChar('\t');
		}
	}
}

/*
Original code by Lee Thomason (www.grinninglizard.com)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any
damages arising from the use of this software.

Permission is granted to anyone to use this software for any
purpose, including commercial applications, and to alter it and
redistribute it freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and
must not be misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
*/



#include <new>		// yes, this one new style header, is in the Android SDK.
#if defined(ANDROID_NDK) || defined(__BORLANDC__) || defined(__QNXNTO__)
#   include <stddef.h>
#   include <stdarg.h>
#else
#   include <cstddef>
#   include <cstdarg>
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1400 ) && (!defined WINCE)
	// Microsoft Visual Studio, version 2005 and higher. Not WinCE.
	/*int _snprintf_s(
	   char *buffer,
	   size_t sizeOfBuffer,
	   size_t count,
	   const char *format [,
		  argument] ...
	);*/
	static inline int TIXML_SNPRINTF( char* buffer, size_t size, const char* format, ... )
	{
		va_list va;
		va_start( va, format );
		const int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );
		va_end( va );
		return result;
	}

	static inline int TIXML_VSNPRINTF( char* buffer, size_t size, const char* format, va_list va )
	{
		const int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );
		return result;
	}

	#define TIXML_VSCPRINTF	_vscprintf
	#define TIXML_SSCANF	sscanf_s
#elif defined _MSC_VER
	// Microsoft Visual Studio 2003 and earlier or WinCE
	#define TIXML_SNPRINTF	_snprintf
	#define TIXML_VSNPRINTF _vsnprintf
	#define TIXML_SSCANF	sscanf
	#if (_MSC_VER < 1400 ) && (!defined WINCE)
		// Microsoft Visual Studio 2003 and not WinCE.
		#define TIXML_VSCPRINTF   _vscprintf // VS2003's C runtime has this, but VC6 C runtime or WinCE SDK doesn't have.
	#else
		// Microsoft Visual Studio 2003 and earlier or WinCE.
		static inline int TIXML_VSCPRINTF( const char* format, va_list va )
		{
			int len = 512;
			for (;;) {
				len = len*2;
				char* str = new char[len]();
				const int required = _vsnprintf(str, len, format, va);
				delete[] str;
				if ( required != -1 ) {
					TIXMLASSERT( required >= 0 );
					len = required;
					break;
				}
			}
			TIXMLASSERT( len >= 0 );
			return len;
		}
	#endif
#else
	// GCC version 3 and higher
	//#warning( "Using sn* functions." )
	#define TIXML_SNPRINTF	snprintf
	#define TIXML_VSNPRINTF	vsnprintf
	static inline int TIXML_VSCPRINTF( const char* format, va_list va )
	{
		int len = vsnprintf( 0, 0, format, va );
		TIXMLASSERT( len >= 0 );
		return len;
	}
	#define TIXML_SSCANF   sscanf
#endif

#if defined(_WIN64)
	#define TIXML_FSEEK _fseeki64
	#define TIXML_FTELL _ftelli64
#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__DragonFly__) || defined(__CYGWIN__)
	#define TIXML_FSEEK fseeko
	#define TIXML_FTELL ftello
#elif defined(__ANDROID__) 
    #if __ANDROID_API__ > 24
        #define TIXML_FSEEK fseeko64
        #define TIXML_FTELL ftello64
    #else
        #define TIXML_FSEEK fseeko
        #define TIXML_FTELL ftello
    #endif
#else
	#define TIXML_FSEEK fseek
	#define TIXML_FTELL ftell
#endif


static const char LINE_FEED				= static_cast<char>(0x0a);			// all line endings are normalized to LF
static const char LF = LINE_FEED;
static const char CARRIAGE_RETURN		= static_cast<char>(0x0d);			// CR gets filtered out
static const char CR = CARRIAGE_RETURN;
static const char SINGLE_QUOTE			= '\'';
static const char DOUBLE_QUOTE			= '\"';

// Bunch of unicode info at:
//		http://www.unicode.org/faq/utf_bom.html
//	ef bb bf (Microsoft "lead bytes") - designates UTF-8

static const unsigned char TIXML_UTF_LEAD_0 = 0xefU;
static const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;
static const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;

namespace tinyxml2
{

struct Entity {
    const char* pattern;
    int length;
    char value;
};

static const int NUM_ENTITIES = 5;
static const Entity entities[NUM_ENTITIES] = {
    { "quot", 4,	DOUBLE_QUOTE },
    { "amp", 3,		'&'  },
    { "apos", 4,	SINGLE_QUOTE },
    { "lt",	2, 		'<'	 },
    { "gt",	2,		'>'	 }
};


StrPair::~StrPair()
{
    Reset();
}


void StrPair::TransferTo( StrPair* other )
{
    if ( this == other ) {
        return;
    }
    // This in effect implements the assignment operator by "moving"
    // ownership (as in auto_ptr).

    TIXMLASSERT( other != 0 );
    TIXMLASSERT( other->_flags == 0 );
    TIXMLASSERT( other->_start == 0 );
    TIXMLASSERT( other->_end == 0 );

    other->Reset();

    other->_flags = _flags;
    other->_start = _start;
    other->_end = _end;

    _flags = 0;
    _start = 0;
    _end = 0;
}


void StrPair::Reset()
{
    if ( _flags & NEEDS_DELETE ) {
        delete [] _start;
    }
    _flags = 0;
    _start = 0;
    _end = 0;
}


void StrPair::SetStr( const char* str, int flags )
{
    TIXMLASSERT( str );
    Reset();
    size_t len = strlen( str );
    TIXMLASSERT( _start == 0 );
    _start = new char[ len+1 ];
    memcpy( _start, str, len+1 );
    _end = _start + len;
    _flags = flags | NEEDS_DELETE;
}


char* StrPair::ParseText( char* p, const char* endTag, int strFlags, int* curLineNumPtr )
{
    TIXMLASSERT( p );
    TIXMLASSERT( endTag && *endTag );
	TIXMLASSERT(curLineNumPtr);

    char* start = p;
    const char  endChar = *endTag;
    size_t length = strlen( endTag );

    // Inner loop of text parsing.
    while ( *p ) {
        if ( *p == endChar && strncmp( p, endTag, length ) == 0 ) {
            Set( start, p, strFlags );
            return p + length;
        } else if (*p == '\n') {
            ++(*curLineNumPtr);
        }
        ++p;
        TIXMLASSERT( p );
    }
    return 0;
}


char* StrPair::ParseName( char* p )
{
    if ( !p || !(*p) ) {
        return 0;
    }
    if ( !XMLUtil::IsNameStartChar( (unsigned char) *p ) ) {
        return 0;
    }

    char* const start = p;
    ++p;
    while ( *p && XMLUtil::IsNameChar( (unsigned char) *p ) ) {
        ++p;
    }

    Set( start, p, 0 );
    return p;
}


void StrPair::CollapseWhitespace()
{
    // Adjusting _start would cause undefined behavior on delete[]
    TIXMLASSERT( ( _flags & NEEDS_DELETE ) == 0 );
    // Trim leading space.
    _start = XMLUtil::SkipWhiteSpace( _start, 0 );

    if ( *_start ) {
        const char* p = _start;	// the read pointer
        char* q = _start;	// the write pointer

        while( *p ) {
            if ( XMLUtil::IsWhiteSpace( *p )) {
                p = XMLUtil::SkipWhiteSpace( p, 0 );
                if ( *p == 0 ) {
                    break;    // don't write to q; this trims the trailing space.
                }
                *q = ' ';
                ++q;
            }
            *q = *p;
            ++q;
            ++p;
        }
        *q = 0;
    }
}


const char* StrPair::GetStr()
{
    TIXMLASSERT( _start );
    TIXMLASSERT( _end );
    if ( _flags & NEEDS_FLUSH ) {
        *_end = 0;
        _flags ^= NEEDS_FLUSH;

        if ( _flags ) {
            const char* p = _start;	// the read pointer
            char* q = _start;	// the write pointer

            while( p < _end ) {
                if ( (_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == CR ) {
                    // CR-LF pair becomes LF
                    // CR alone becomes LF
                    // LF-CR becomes LF
                    if ( *(p+1) == LF ) {
                        p += 2;
                    }
                    else {
                        ++p;
                    }
                    *q = LF;
                    ++q;
                }
                else if ( (_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == LF ) {
                    if ( *(p+1) == CR ) {
                        p += 2;
                    }
                    else {
                        ++p;
                    }
                    *q = LF;
                    ++q;
                }
                else if ( (_flags & NEEDS_ENTITY_PROCESSING) && *p == '&' ) {
                    // Entities handled by tinyXML2:
                    // - special entities in the entity table [in/out]
                    // - numeric character reference [in]
                    //   &#20013; or &#x4e2d;

                    if ( *(p+1) == '#' ) {
                        const int buflen = 10;
                        char buf[buflen] = { 0 };
                        int len = 0;
                        const char* adjusted = const_cast<char*>( XMLUtil::GetCharacterRef( p, buf, &len ) );
                        if ( adjusted == 0 ) {
                            *q = *p;
                            ++p;
                            ++q;
                        }
                        else {
                            TIXMLASSERT( 0 <= len && len <= buflen );
                            TIXMLASSERT( q + len <= adjusted );
                            p = adjusted;
                            memcpy( q, buf, len );
                            q += len;
                        }
                    }
                    else {
                        bool entityFound = false;
                        for( int i = 0; i < NUM_ENTITIES; ++i ) {
                            const Entity& entity = entities[i];
                            if ( strncmp( p + 1, entity.pattern, entity.length ) == 0
                                    && *( p + entity.length + 1 ) == ';' ) {
                                // Found an entity - convert.
                                *q = entity.value;
                                ++q;
                                p += entity.length + 2;
                                entityFound = true;
                                break;
                            }
                        }
                        if ( !entityFound ) {
                            // fixme: treat as error?
                            ++p;
                            ++q;
                        }
                    }
                }
                else {
                    *q = *p;
                    ++p;
                    ++q;
                }
            }
            *q = 0;
        }
        // The loop below has plenty going on, and this
        // is a less useful mode. Break it out.
        if ( _flags & NEEDS_WHITESPACE_COLLAPSING ) {
            CollapseWhitespace();
        }
        _flags = (_flags & NEEDS_DELETE);
    }
    TIXMLASSERT( _start );
    return _start;
}




// --------- XMLUtil ----------- //

const char* XMLUtil::writeBoolTrue  = "true";
const char* XMLUtil::writeBoolFalse = "false";

void XMLUtil::SetBoolSerialization(const char* writeTrue, const char* writeFalse)
{
	static const char* defTrue  = "true";
	static const char* defFalse = "false";

	writeBoolTrue = (writeTrue) ? writeTrue : defTrue;
	writeBoolFalse = (writeFalse) ? writeFalse : defFalse;
}


const char* XMLUtil::ReadBOM( const char* p, bool* bom )
{
    TIXMLASSERT( p );
    TIXMLASSERT( bom );
    *bom = false;
    const unsigned char* pu = reinterpret_cast<const unsigned char*>(p);
    // Check for BOM:
    if (    *(pu+0) == TIXML_UTF_LEAD_0
            && *(pu+1) == TIXML_UTF_LEAD_1
            && *(pu+2) == TIXML_UTF_LEAD_2 ) {
        *bom = true;
        p += 3;
    }
    TIXMLASSERT( p );
    return p;
}


void XMLUtil::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )
{
    const unsigned long BYTE_MASK = 0xBF;
    const unsigned long BYTE_MARK = 0x80;
    const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };

    if (input < 0x80) {
        *length = 1;
    }
    else if ( input < 0x800 ) {
        *length = 2;
    }
    else if ( input < 0x10000 ) {
        *length = 3;
    }
    else if ( input < 0x200000 ) {
        *length = 4;
    }
    else {
        *length = 0;    // This code won't convert this correctly anyway.
        return;
    }

    output += *length;

    // Scary scary fall throughs are annotated with carefully designed comments
    // to suppress compiler warnings such as -Wimplicit-fallthrough in gcc
    switch (*length) {
        case 4:
            --output;
            *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
            input >>= 6;
            //fall through
        case 3:
            --output;
            *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
            input >>= 6;
            //fall through
        case 2:
            --output;
            *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
            input >>= 6;
            //fall through
        case 1:
            --output;
            *output = static_cast<char>(input | FIRST_BYTE_MARK[*length]);
            break;
        default:
            TIXMLASSERT( false );
    }
}


const char* XMLUtil::GetCharacterRef( const char* p, char* value, int* length )
{
    // Presume an entity, and pull it out.
    *length = 0;

    if ( *(p+1) == '#' && *(p+2) ) {
        unsigned long ucs = 0;
        TIXMLASSERT( sizeof( ucs ) >= 4 );
        ptrdiff_t delta = 0;
        unsigned mult = 1;
        static const char SEMICOLON = ';';

        if ( *(p+2) == 'x' ) {
            // Hexadecimal.
            const char* q = p+3;
            if ( !(*q) ) {
                return 0;
            }

            q = strchr( q, SEMICOLON );

            if ( !q ) {
                return 0;
            }
            TIXMLASSERT( *q == SEMICOLON );

            delta = q-p;
            --q;

            while ( *q != 'x' ) {
                unsigned int digit = 0;

                if ( *q >= '0' && *q <= '9' ) {
                    digit = *q - '0';
                }
                else if ( *q >= 'a' && *q <= 'f' ) {
                    digit = *q - 'a' + 10;
                }
                else if ( *q >= 'A' && *q <= 'F' ) {
                    digit = *q - 'A' + 10;
                }
                else {
                    return 0;
                }
                TIXMLASSERT( digit < 16 );
                TIXMLASSERT( digit == 0 || mult <= UINT_MAX / digit );
                const unsigned int digitScaled = mult * digit;
                TIXMLASSERT( ucs <= ULONG_MAX - digitScaled );
                ucs += digitScaled;
                TIXMLASSERT( mult <= UINT_MAX / 16 );
                mult *= 16;
                --q;
            }
        }
        else {
            // Decimal.
            const char* q = p+2;
            if ( !(*q) ) {
                return 0;
            }

            q = strchr( q, SEMICOLON );

            if ( !q ) {
                return 0;
            }
            TIXMLASSERT( *q == SEMICOLON );

            delta = q-p;
            --q;

            while ( *q != '#' ) {
                if ( *q >= '0' && *q <= '9' ) {
                    const unsigned int digit = *q - '0';
                    TIXMLASSERT( digit < 10 );
                    TIXMLASSERT( digit == 0 || mult <= UINT_MAX / digit );
                    const unsigned int digitScaled = mult * digit;
                    TIXMLASSERT( ucs <= ULONG_MAX - digitScaled );
                    ucs += digitScaled;
                }
                else {
                    return 0;
                }
                TIXMLASSERT( mult <= UINT_MAX / 10 );
                mult *= 10;
                --q;
            }
        }
        // convert the UCS to UTF-8
        ConvertUTF32ToUTF8( ucs, value, length );
        return p + delta + 1;
    }
    return p+1;
}


void XMLUtil::ToStr( int v, char* buffer, int bufferSize )
{
    TIXML_SNPRINTF( buffer, bufferSize, "%d", v );
}


void XMLUtil::ToStr( unsigned v, char* buffer, int bufferSize )
{
    TIXML_SNPRINTF( buffer, bufferSize, "%u", v );
}


void XMLUtil::ToStr( bool v, char* buffer, int bufferSize )
{
    TIXML_SNPRINTF( buffer, bufferSize, "%s", v ? writeBoolTrue : writeBoolFalse);
}

/*
	ToStr() of a number is a very tricky topic.
	https://github.com/leethomason/tinyxml2/issues/106
*/
void XMLUtil::ToStr( float v, char* buffer, int bufferSize )
{
    TIXML_SNPRINTF( buffer, bufferSize, "%.8g", v );
}


void XMLUtil::ToStr( double v, char* buffer, int bufferSize )
{
    TIXML_SNPRINTF( buffer, bufferSize, "%.17g", v );
}


void XMLUtil::ToStr( int64_t v, char* buffer, int bufferSize )
{
	// horrible syntax trick to make the compiler happy about %lld
	TIXML_SNPRINTF(buffer, bufferSize, "%lld", static_cast<long long>(v));
}

void XMLUtil::ToStr( uint64_t v, char* buffer, int bufferSize )
{
    // horrible syntax trick to make the compiler happy about %llu
    TIXML_SNPRINTF(buffer, bufferSize, "%llu", (long long)v);
}

bool XMLUtil::ToInt(const char* str, int* value)
{
    if (IsPrefixHex(str)) {
        unsigned v;
        if (TIXML_SSCANF(str, "%x", &v) == 1) {
            *value = static_cast<int>(v);
            return true;
        }
    }
    else {
        if (TIXML_SSCANF(str, "%d", value) == 1) {
            return true;
        }
    }
    return false;
}

bool XMLUtil::ToUnsigned(const char* str, unsigned* value)
{
    if (TIXML_SSCANF(str, IsPrefixHex(str) ? "%x" : "%u", value) == 1) {
        return true;
    }
    return false;
}

bool XMLUtil::ToBool( const char* str, bool* value )
{
    int ival = 0;
    if ( ToInt( str, &ival )) {
        *value = (ival==0) ? false : true;
        return true;
    }
    static const char* TRUE_VALS[] = { "true", "True", "TRUE", 0 };
    static const char* FALSE_VALS[] = { "false", "False", "FALSE", 0 };

    for (int i = 0; TRUE_VALS[i]; ++i) {
        if (StringEqual(str, TRUE_VALS[i])) {
            *value = true;
            return true;
        }
    }
    for (int i = 0; FALSE_VALS[i]; ++i) {
        if (StringEqual(str, FALSE_VALS[i])) {
            *value = false;
            return true;
        }
    }
    return false;
}


bool XMLUtil::ToFloat( const char* str, float* value )
{
    if ( TIXML_SSCANF( str, "%f", value ) == 1 ) {
        return true;
    }
    return false;
}


bool XMLUtil::ToDouble( const char* str, double* value )
{
    if ( TIXML_SSCANF( str, "%lf", value ) == 1 ) {
        return true;
    }
    return false;
}


bool XMLUtil::ToInt64(const char* str, int64_t* value)
{
    if (IsPrefixHex(str)) {
        unsigned long long v = 0;	// horrible syntax trick to make the compiler happy about %llx
        if (TIXML_SSCANF(str, "%llx", &v) == 1) {
            *value = static_cast<int64_t>(v);
            return true;
        }
    }
    else {
        long long v = 0;	// horrible syntax trick to make the compiler happy about %lld
        if (TIXML_SSCANF(str, "%lld", &v) == 1) {
            *value = static_cast<int64_t>(v);
            return true;
        }
    }
	return false;
}


bool XMLUtil::ToUnsigned64(const char* str, uint64_t* value) {
    unsigned long long v = 0;	// horrible syntax trick to make the compiler happy about %llu
    if(TIXML_SSCANF(str, IsPrefixHex(str) ? "%llx" : "%llu", &v) == 1) {
        *value = (uint64_t)v;
        return true;
    }
    return false;
}


char* XMLDocument::Identify( char* p, XMLNode** node, bool first )
{
    TIXMLASSERT( node );
    TIXMLASSERT( p );
    char* const start = p;
    int const startLine = _parseCurLineNum;
    p = XMLUtil::SkipWhiteSpace( p, &_parseCurLineNum );
    if( !*p ) {
        *node = 0;
        TIXMLASSERT( p );
        return p;
    }

    // These strings define the matching patterns:
    static const char* xmlHeader		= { "<?" };
    static const char* commentHeader	= { "<!--" };
    static const char* cdataHeader		= { "<![CDATA[" };
    static const char* dtdHeader		= { "<!" };
    static const char* elementHeader	= { "<" };	// and a header for everything else; check last.

    static const int xmlHeaderLen		= 2;
    static const int commentHeaderLen	= 4;
    static const int cdataHeaderLen		= 9;
    static const int dtdHeaderLen		= 2;
    static const int elementHeaderLen	= 1;

    TIXMLASSERT( sizeof( XMLComment ) == sizeof( XMLUnknown ) );		// use same memory pool
    TIXMLASSERT( sizeof( XMLComment ) == sizeof( XMLDeclaration ) );	// use same memory pool
    XMLNode* returnNode = 0;
    if ( XMLUtil::StringEqual( p, xmlHeader, xmlHeaderLen ) ) {
        returnNode = CreateUnlinkedNode<XMLDeclaration>( _commentPool );
        returnNode->_parseLineNum = _parseCurLineNum;
        p += xmlHeaderLen;
    }
    else if ( XMLUtil::StringEqual( p, commentHeader, commentHeaderLen ) ) {
        returnNode = CreateUnlinkedNode<XMLComment>( _commentPool );
        returnNode->_parseLineNum = _parseCurLineNum;
        p += commentHeaderLen;
    }
    else if ( XMLUtil::StringEqual( p, cdataHeader, cdataHeaderLen ) ) {
        XMLText* text = CreateUnlinkedNode<XMLText>( _textPool );
        returnNode = text;
        returnNode->_parseLineNum = _parseCurLineNum;
        p += cdataHeaderLen;
        text->SetCData( true );
    }
    else if ( XMLUtil::StringEqual( p, dtdHeader, dtdHeaderLen ) ) {
        returnNode = CreateUnlinkedNode<XMLUnknown>( _commentPool );
        returnNode->_parseLineNum = _parseCurLineNum;
        p += dtdHeaderLen;
    }
    else if ( XMLUtil::StringEqual( p, elementHeader, elementHeaderLen ) ) {

        // Preserve whitespace pedantically before closing tag, when it's immediately after opening tag
        if (WhitespaceMode() == PEDANTIC_WHITESPACE && first && p != start && *(p + elementHeaderLen) == '/') {
            returnNode = CreateUnlinkedNode<XMLText>(_textPool);
            returnNode->_parseLineNum = startLine;
            p = start;	// Back it up, all the text counts.
            _parseCurLineNum = startLine;
        }
        else {
            returnNode = CreateUnlinkedNode<XMLElement>(_elementPool);
            returnNode->_parseLineNum = _parseCurLineNum;
            p += elementHeaderLen;
        }
    }
    else {
        returnNode = CreateUnlinkedNode<XMLText>( _textPool );
        returnNode->_parseLineNum = _parseCurLineNum; // Report line of first non-whitespace character
        p = start;	// Back it up, all the text counts.
        _parseCurLineNum = startLine;
    }

    TIXMLASSERT( returnNode );
    TIXMLASSERT( p );
    *node = returnNode;
    return p;
}


bool XMLDocument::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    if ( visitor->VisitEnter( *this ) ) {
        for ( const XMLNode* node=FirstChild(); node; node=node->NextSibling() ) {
            if ( !node->Accept( visitor ) ) {
                break;
            }
        }
    }
    return visitor->VisitExit( *this );
}


// --------- XMLNode ----------- //

XMLNode::XMLNode( XMLDocument* doc ) :
    _document( doc ),
    _parent( 0 ),
    _value(),
    _parseLineNum( 0 ),
    _firstChild( 0 ), _lastChild( 0 ),
    _prev( 0 ), _next( 0 ),
	_userData( 0 ),
    _memPool( 0 )
{
}


XMLNode::~XMLNode()
{
    DeleteChildren();
    if ( _parent ) {
        _parent->Unlink( this );
    }
}

// ChildElementCount was originally suggested by msteiger on the sourceforge page for TinyXML and modified by KB1SPH for TinyXML-2.

int XMLNode::ChildElementCount(const char *value) const {
	int count = 0;

	const XMLElement *e = FirstChildElement(value);

	while (e) {
		e = e->NextSiblingElement(value);
		count++;
	}

	return count;
}

int XMLNode::ChildElementCount() const {
	int count = 0;

	const XMLElement *e = FirstChildElement();

	while (e) {
		e = e->NextSiblingElement();
		count++;
	}

	return count;
}

const char* XMLNode::Value() const
{
    // Edge case: XMLDocuments don't have a Value. Return null.
    if ( this->ToDocument() )
        return 0;
    return _value.GetStr();
}

void XMLNode::SetValue( const char* str, bool staticMem )
{
    if ( staticMem ) {
        _value.SetInternedStr( str );
    }
    else {
        _value.SetStr( str );
    }
}

XMLNode* XMLNode::DeepClone(XMLDocument* target) const
{
	XMLNode* clone = this->ShallowClone(target);
	if (!clone) return 0;

	for (const XMLNode* child = this->FirstChild(); child; child = child->NextSibling()) {
		XMLNode* childClone = child->DeepClone(target);
		TIXMLASSERT(childClone);
		clone->InsertEndChild(childClone);
	}
	return clone;
}

void XMLNode::DeleteChildren()
{
    while( _firstChild ) {
        TIXMLASSERT( _lastChild );
        DeleteChild( _firstChild );
    }
    _firstChild = _lastChild = 0;
}


void XMLNode::Unlink( XMLNode* child )
{
    TIXMLASSERT( child );
    TIXMLASSERT( child->_document == _document );
    TIXMLASSERT( child->_parent == this );
    if ( child == _firstChild ) {
        _firstChild = _firstChild->_next;
    }
    if ( child == _lastChild ) {
        _lastChild = _lastChild->_prev;
    }

    if ( child->_prev ) {
        child->_prev->_next = child->_next;
    }
    if ( child->_next ) {
        child->_next->_prev = child->_prev;
    }
	child->_next = 0;
	child->_prev = 0;
	child->_parent = 0;
}


void XMLNode::DeleteChild( XMLNode* node )
{
    TIXMLASSERT( node );
    TIXMLASSERT( node->_document == _document );
    TIXMLASSERT( node->_parent == this );
    Unlink( node );
	TIXMLASSERT(node->_prev == 0);
	TIXMLASSERT(node->_next == 0);
	TIXMLASSERT(node->_parent == 0);
    DeleteNode( node );
}


XMLNode* XMLNode::InsertEndChild( XMLNode* addThis )
{
    TIXMLASSERT( addThis );
    if ( addThis->_document != _document ) {
        TIXMLASSERT( false );
        return 0;
    }
    InsertChildPreamble( addThis );

    if ( _lastChild ) {
        TIXMLASSERT( _firstChild );
        TIXMLASSERT( _lastChild->_next == 0 );
        _lastChild->_next = addThis;
        addThis->_prev = _lastChild;
        _lastChild = addThis;

        addThis->_next = 0;
    }
    else {
        TIXMLASSERT( _firstChild == 0 );
        _firstChild = _lastChild = addThis;

        addThis->_prev = 0;
        addThis->_next = 0;
    }
    addThis->_parent = this;
    return addThis;
}


XMLNode* XMLNode::InsertFirstChild( XMLNode* addThis )
{
    TIXMLASSERT( addThis );
    if ( addThis->_document != _document ) {
        TIXMLASSERT( false );
        return 0;
    }
    InsertChildPreamble( addThis );

    if ( _firstChild ) {
        TIXMLASSERT( _lastChild );
        TIXMLASSERT( _firstChild->_prev == 0 );

        _firstChild->_prev = addThis;
        addThis->_next = _firstChild;
        _firstChild = addThis;

        addThis->_prev = 0;
    }
    else {
        TIXMLASSERT( _lastChild == 0 );
        _firstChild = _lastChild = addThis;

        addThis->_prev = 0;
        addThis->_next = 0;
    }
    addThis->_parent = this;
    return addThis;
}


XMLNode* XMLNode::InsertAfterChild( XMLNode* afterThis, XMLNode* addThis )
{
    TIXMLASSERT( addThis );
    if ( addThis->_document != _document ) {
        TIXMLASSERT( false );
        return 0;
    }

    TIXMLASSERT( afterThis );

    if ( afterThis->_parent != this ) {
        TIXMLASSERT( false );
        return 0;
    }
    if ( afterThis == addThis ) {
        // Current state: BeforeThis -> AddThis -> OneAfterAddThis
        // Now AddThis must disappear from it's location and then
        // reappear between BeforeThis and OneAfterAddThis.
        // So just leave it where it is.
        return addThis;
    }

    if ( afterThis->_next == 0 ) {
        // The last node or the only node.
        return InsertEndChild( addThis );
    }
    InsertChildPreamble( addThis );
    addThis->_prev = afterThis;
    addThis->_next = afterThis->_next;
    afterThis->_next->_prev = addThis;
    afterThis->_next = addThis;
    addThis->_parent = this;
    return addThis;
}




const XMLElement* XMLNode::FirstChildElement( const char* name ) const
{
    for( const XMLNode* node = _firstChild; node; node = node->_next ) {
        const XMLElement* element = node->ToElementWithName( name );
        if ( element ) {
            return element;
        }
    }
    return 0;
}


const XMLElement* XMLNode::LastChildElement( const char* name ) const
{
    for( const XMLNode* node = _lastChild; node; node = node->_prev ) {
        const XMLElement* element = node->ToElementWithName( name );
        if ( element ) {
            return element;
        }
    }
    return 0;
}


const XMLElement* XMLNode::NextSiblingElement( const char* name ) const
{
    for( const XMLNode* node = _next; node; node = node->_next ) {
        const XMLElement* element = node->ToElementWithName( name );
        if ( element ) {
            return element;
        }
    }
    return 0;
}


const XMLElement* XMLNode::PreviousSiblingElement( const char* name ) const
{
    for( const XMLNode* node = _prev; node; node = node->_prev ) {
        const XMLElement* element = node->ToElementWithName( name );
        if ( element ) {
            return element;
        }
    }
    return 0;
}


char* XMLNode::ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr )
{
    // This is a recursive method, but thinking about it "at the current level"
    // it is a pretty simple flat list:
    //		<foo/>
    //		<!-- comment -->
    //
    // With a special case:
    //		<foo>
    //		</foo>
    //		<!-- comment -->
    //
    // Where the closing element (/foo) *must* be the next thing after the opening
    // element, and the names must match. BUT the tricky bit is that the closing
    // element will be read by the child.
    //
    // 'endTag' is the end tag for this node, it is returned by a call to a child.
    // 'parentEnd' is the end tag for the parent, which is filled in and returned.

	XMLDocument::DepthTracker tracker(_document);
	if (_document->Error())
		return 0;

	bool first = true;
	while( p && *p ) {
        XMLNode* node = 0;

        p = _document->Identify( p, &node, first );
        TIXMLASSERT( p );
        if ( node == 0 ) {
            break;
        }
        first = false;

       const int initialLineNum = node->_parseLineNum;

        StrPair endTag;
        p = node->ParseDeep( p, &endTag, curLineNumPtr );
        if ( !p ) {
            _document->DeleteNode( node );
            if ( !_document->Error() ) {
                _document->SetError( XML_ERROR_PARSING, initialLineNum, 0);
            }
            break;
        }

        const XMLDeclaration* const decl = node->ToDeclaration();
        if ( decl ) {
            // Declarations are only allowed at document level
            //
            // Multiple declarations are allowed but all declarations
            // must occur before anything else. 
            //
            // Optimized due to a security test case. If the first node is 
            // a declaration, and the last node is a declaration, then only 
            // declarations have so far been added.
            bool wellLocated = false;

            if (ToDocument()) {
                if (FirstChild()) {
                    wellLocated =
                        FirstChild() &&
                        FirstChild()->ToDeclaration() &&
                        LastChild() &&
                        LastChild()->ToDeclaration();
                }
                else {
                    wellLocated = true;
                }
            }
            if ( !wellLocated ) {
                _document->SetError( XML_ERROR_PARSING_DECLARATION, initialLineNum, "XMLDeclaration value=%s", decl->Value());
                _document->DeleteNode( node );
                break;
            }
        }

        XMLElement* ele = node->ToElement();
        if ( ele ) {
            // We read the end tag. Return it to the parent.
            if ( ele->ClosingType() == XMLElement::CLOSING ) {
                if ( parentEndTag ) {
                    ele->_value.TransferTo( parentEndTag );
                }
                node->_memPool->SetTracked();   // created and then immediately deleted.
                DeleteNode( node );
                return p;
            }

            // Handle an end tag returned to this level.
            // And handle a bunch of annoying errors.
            bool mismatch = false;
            if ( endTag.Empty() ) {
                if ( ele->ClosingType() == XMLElement::OPEN ) {
                    mismatch = true;
                }
            }
            else {
                if ( ele->ClosingType() != XMLElement::OPEN ) {
                    mismatch = true;
                }
                else if ( !XMLUtil::StringEqual( endTag.GetStr(), ele->Name() ) ) {
                    mismatch = true;
                }
            }
            if ( mismatch ) {
                _document->SetError( XML_ERROR_MISMATCHED_ELEMENT, initialLineNum, "XMLElement name=%s", ele->Name());
                _document->DeleteNode( node );
                break;
            }
        }
        InsertEndChild( node );
    }
    return 0;
}

/*static*/ void XMLNode::DeleteNode( XMLNode* node )
{
    if ( node == 0 ) {
        return;
    }
	TIXMLASSERT(node->_document);
	if (!node->ToDocument()) {
		node->_document->MarkInUse(node);
	}

    MemPool* pool = node->_memPool;
    node->~XMLNode();
    pool->Free( node );
}

void XMLNode::InsertChildPreamble( XMLNode* insertThis ) const
{
    TIXMLASSERT( insertThis );
    TIXMLASSERT( insertThis->_document == _document );

	if (insertThis->_parent) {
        insertThis->_parent->Unlink( insertThis );
	}
	else {
		insertThis->_document->MarkInUse(insertThis);
        insertThis->_memPool->SetTracked();
	}
}

const XMLElement* XMLNode::ToElementWithName( const char* name ) const
{
    const XMLElement* element = this->ToElement();
    if ( element == 0 ) {
        return 0;
    }
    if ( name == 0 ) {
        return element;
    }
    if ( XMLUtil::StringEqual( element->Name(), name ) ) {
       return element;
    }
    return 0;
}

// --------- XMLText ---------- //
char* XMLText::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
{
    if ( this->CData() ) {
        p = _value.ParseText( p, "]]>", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
        if ( !p ) {
            _document->SetError( XML_ERROR_PARSING_CDATA, _parseLineNum, 0 );
        }
        return p;
    }
    else {
        int flags = _document->ProcessEntities() ? StrPair::TEXT_ELEMENT : StrPair::TEXT_ELEMENT_LEAVE_ENTITIES;
        if ( _document->WhitespaceMode() == COLLAPSE_WHITESPACE ) {
            flags |= StrPair::NEEDS_WHITESPACE_COLLAPSING;
        }

        p = _value.ParseText( p, "<", flags, curLineNumPtr );
        if ( p && *p ) {
            return p-1;
        }
        if ( !p ) {
            _document->SetError( XML_ERROR_PARSING_TEXT, _parseLineNum, 0 );
        }
    }
    return 0;
}


XMLNode* XMLText::ShallowClone( XMLDocument* doc ) const
{
    if ( !doc ) {
        doc = _document;
    }
    XMLText* text = doc->NewText( Value() );	// fixme: this will always allocate memory. Intern?
    text->SetCData( this->CData() );
    return text;
}


bool XMLText::ShallowEqual( const XMLNode* compare ) const
{
    TIXMLASSERT( compare );
    const XMLText* text = compare->ToText();
    return ( text && XMLUtil::StringEqual( text->Value(), Value() ) );
}


bool XMLText::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    return visitor->Visit( *this );
}


// --------- XMLComment ---------- //

XMLComment::XMLComment( XMLDocument* doc ) : XMLNode( doc )
{
}


XMLComment::~XMLComment()
{
}


char* XMLComment::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
{
    // Comment parses as text.
    p = _value.ParseText( p, "-->", StrPair::COMMENT, curLineNumPtr );
    if ( p == 0 ) {
        _document->SetError( XML_ERROR_PARSING_COMMENT, _parseLineNum, 0 );
    }
    return p;
}


XMLNode* XMLComment::ShallowClone( XMLDocument* doc ) const
{
    if ( !doc ) {
        doc = _document;
    }
    XMLComment* comment = doc->NewComment( Value() );	// fixme: this will always allocate memory. Intern?
    return comment;
}


bool XMLComment::ShallowEqual( const XMLNode* compare ) const
{
    TIXMLASSERT( compare );
    const XMLComment* comment = compare->ToComment();
    return ( comment && XMLUtil::StringEqual( comment->Value(), Value() ));
}


bool XMLComment::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    return visitor->Visit( *this );
}


// --------- XMLDeclaration ---------- //

XMLDeclaration::XMLDeclaration( XMLDocument* doc ) : XMLNode( doc )
{
}


XMLDeclaration::~XMLDeclaration()
{
    //printf( "~XMLDeclaration\n" );
}


char* XMLDeclaration::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
{
    // Declaration parses as text.
    p = _value.ParseText( p, "?>", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
    if ( p == 0 ) {
        _document->SetError( XML_ERROR_PARSING_DECLARATION, _parseLineNum, 0 );
    }
    return p;
}


XMLNode* XMLDeclaration::ShallowClone( XMLDocument* doc ) const
{
    if ( !doc ) {
        doc = _document;
    }
    XMLDeclaration* dec = doc->NewDeclaration( Value() );	// fixme: this will always allocate memory. Intern?
    return dec;
}


bool XMLDeclaration::ShallowEqual( const XMLNode* compare ) const
{
    TIXMLASSERT( compare );
    const XMLDeclaration* declaration = compare->ToDeclaration();
    return ( declaration && XMLUtil::StringEqual( declaration->Value(), Value() ));
}



bool XMLDeclaration::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    return visitor->Visit( *this );
}

// --------- XMLUnknown ---------- //

XMLUnknown::XMLUnknown( XMLDocument* doc ) : XMLNode( doc )
{
}


XMLUnknown::~XMLUnknown()
{
}


char* XMLUnknown::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
{
    // Unknown parses as text.
    p = _value.ParseText( p, ">", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
    if ( !p ) {
        _document->SetError( XML_ERROR_PARSING_UNKNOWN, _parseLineNum, 0 );
    }
    return p;
}


XMLNode* XMLUnknown::ShallowClone( XMLDocument* doc ) const
{
    if ( !doc ) {
        doc = _document;
    }
    XMLUnknown* text = doc->NewUnknown( Value() );	// fixme: this will always allocate memory. Intern?
    return text;
}


bool XMLUnknown::ShallowEqual( const XMLNode* compare ) const
{
    TIXMLASSERT( compare );
    const XMLUnknown* unknown = compare->ToUnknown();
    return ( unknown && XMLUtil::StringEqual( unknown->Value(), Value() ));
}


bool XMLUnknown::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    return visitor->Visit( *this );
}

// --------- XMLAttribute ---------- //

const char* XMLAttribute::Name() const
{
    return _name.GetStr();
}

const char* XMLAttribute::Value() const
{
    return _value.GetStr();
}

char* XMLAttribute::ParseDeep( char* p, bool processEntities, int* curLineNumPtr )
{
    // Parse using the name rules: bug fix, was using ParseText before
    p = _name.ParseName( p );
    if ( !p || !*p ) {
        return 0;
    }

    // Skip white space before =
    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
    if ( *p != '=' ) {
        return 0;
    }

    ++p;	// move up to opening quote
    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
    if ( *p != '\"' && *p != '\'' ) {
        return 0;
    }

    const char endTag[2] = { *p, 0 };
    ++p;	// move past opening quote

    p = _value.ParseText( p, endTag, processEntities ? StrPair::ATTRIBUTE_VALUE : StrPair::ATTRIBUTE_VALUE_LEAVE_ENTITIES, curLineNumPtr );
    return p;
}


void XMLAttribute::SetName( const char* n )
{
    _name.SetStr( n );
}


XMLError XMLAttribute::QueryIntValue( int* value ) const
{
    if ( XMLUtil::ToInt( Value(), value )) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}


XMLError XMLAttribute::QueryUnsignedValue( unsigned int* value ) const
{
    if ( XMLUtil::ToUnsigned( Value(), value )) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}


XMLError XMLAttribute::QueryInt64Value(int64_t* value) const
{
	if (XMLUtil::ToInt64(Value(), value)) {
		return XML_SUCCESS;
	}
	return XML_WRONG_ATTRIBUTE_TYPE;
}


XMLError XMLAttribute::QueryUnsigned64Value(uint64_t* value) const
{
    if(XMLUtil::ToUnsigned64(Value(), value)) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}


XMLError XMLAttribute::QueryBoolValue( bool* value ) const
{
    if ( XMLUtil::ToBool( Value(), value )) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}


XMLError XMLAttribute::QueryFloatValue( float* value ) const
{
    if ( XMLUtil::ToFloat( Value(), value )) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}


XMLError XMLAttribute::QueryDoubleValue( double* value ) const
{
    if ( XMLUtil::ToDouble( Value(), value )) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}


void XMLAttribute::SetAttribute( const char* v )
{
    _value.SetStr( v );
}


void XMLAttribute::SetAttribute( int v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    _value.SetStr( buf );
}


void XMLAttribute::SetAttribute( unsigned v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    _value.SetStr( buf );
}


void XMLAttribute::SetAttribute(int64_t v)
{
	char buf[BUF_SIZE];
	XMLUtil::ToStr(v, buf, BUF_SIZE);
	_value.SetStr(buf);
}

void XMLAttribute::SetAttribute(uint64_t v)
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr(v, buf, BUF_SIZE);
    _value.SetStr(buf);
}


void XMLAttribute::SetAttribute( bool v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    _value.SetStr( buf );
}

void XMLAttribute::SetAttribute( double v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    _value.SetStr( buf );
}

void XMLAttribute::SetAttribute( float v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    _value.SetStr( buf );
}


// --------- XMLElement ---------- //
XMLElement::XMLElement( XMLDocument* doc ) : XMLNode( doc ),
    _closingType( OPEN ),
    _rootAttribute( 0 )
{
}


XMLElement::~XMLElement()
{
    while( _rootAttribute ) {
        XMLAttribute* next = _rootAttribute->_next;
        DeleteAttribute( _rootAttribute );
        _rootAttribute = next;
    }
}


const XMLAttribute* XMLElement::FindAttribute( const char* name ) const
{
    for( XMLAttribute* a = _rootAttribute; a; a = a->_next ) {
        if ( XMLUtil::StringEqual( a->Name(), name ) ) {
            return a;
        }
    }
    return 0;
}


const char* XMLElement::Attribute( const char* name, const char* value ) const
{
    const XMLAttribute* a = FindAttribute( name );
    if ( !a ) {
        return 0;
    }
    if ( !value || XMLUtil::StringEqual( a->Value(), value )) {
        return a->Value();
    }
    return 0;
}

int XMLElement::IntAttribute(const char* name, int defaultValue) const
{
	int i = defaultValue;
	QueryIntAttribute(name, &i);
	return i;
}

unsigned XMLElement::UnsignedAttribute(const char* name, unsigned defaultValue) const
{
	unsigned i = defaultValue;
	QueryUnsignedAttribute(name, &i);
	return i;
}

int64_t XMLElement::Int64Attribute(const char* name, int64_t defaultValue) const
{
	int64_t i = defaultValue;
	QueryInt64Attribute(name, &i);
	return i;
}

uint64_t XMLElement::Unsigned64Attribute(const char* name, uint64_t defaultValue) const
{
	uint64_t i = defaultValue;
	QueryUnsigned64Attribute(name, &i);
	return i;
}

bool XMLElement::BoolAttribute(const char* name, bool defaultValue) const
{
	bool b = defaultValue;
	QueryBoolAttribute(name, &b);
	return b;
}

double XMLElement::DoubleAttribute(const char* name, double defaultValue) const
{
	double d = defaultValue;
	QueryDoubleAttribute(name, &d);
	return d;
}

float XMLElement::FloatAttribute(const char* name, float defaultValue) const
{
	float f = defaultValue;
	QueryFloatAttribute(name, &f);
	return f;
}

const char* XMLElement::GetText() const
{
    /* skip comment node */
    const XMLNode* node = FirstChild();
    while (node) {
        if (node->ToComment()) {
            node = node->NextSibling();
            continue;
        }
        break;
    }

    if ( node && node->ToText() ) {
        return node->Value();
    }
    return 0;
}


void	XMLElement::SetText( const char* inText )
{
	if ( FirstChild() && FirstChild()->ToText() )
		FirstChild()->SetValue( inText );
	else {
		XMLText*	theText = GetDocument()->NewText( inText );
		InsertFirstChild( theText );
	}
}


void XMLElement::SetText( int v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    SetText( buf );
}


void XMLElement::SetText( unsigned v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    SetText( buf );
}


void XMLElement::SetText(int64_t v)
{
	char buf[BUF_SIZE];
	XMLUtil::ToStr(v, buf, BUF_SIZE);
	SetText(buf);
}

void XMLElement::SetText(uint64_t v) {
    char buf[BUF_SIZE];
    XMLUtil::ToStr(v, buf, BUF_SIZE);
    SetText(buf);
}


void XMLElement::SetText( bool v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    SetText( buf );
}


void XMLElement::SetText( float v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    SetText( buf );
}


void XMLElement::SetText( double v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    SetText( buf );
}


XMLError XMLElement::QueryIntText( int* ival ) const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        const char* t = FirstChild()->Value();
        if ( XMLUtil::ToInt( t, ival ) ) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}


XMLError XMLElement::QueryUnsignedText( unsigned* uval ) const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        const char* t = FirstChild()->Value();
        if ( XMLUtil::ToUnsigned( t, uval ) ) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}


XMLError XMLElement::QueryInt64Text(int64_t* ival) const
{
	if (FirstChild() && FirstChild()->ToText()) {
		const char* t = FirstChild()->Value();
		if (XMLUtil::ToInt64(t, ival)) {
			return XML_SUCCESS;
		}
		return XML_CAN_NOT_CONVERT_TEXT;
	}
	return XML_NO_TEXT_NODE;
}


XMLError XMLElement::QueryUnsigned64Text(uint64_t* uval) const
{
    if(FirstChild() && FirstChild()->ToText()) {
        const char* t = FirstChild()->Value();
        if(XMLUtil::ToUnsigned64(t, uval)) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}


XMLError XMLElement::QueryBoolText( bool* bval ) const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        const char* t = FirstChild()->Value();
        if ( XMLUtil::ToBool( t, bval ) ) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}


XMLError XMLElement::QueryDoubleText( double* dval ) const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        const char* t = FirstChild()->Value();
        if ( XMLUtil::ToDouble( t, dval ) ) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}


XMLError XMLElement::QueryFloatText( float* fval ) const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        const char* t = FirstChild()->Value();
        if ( XMLUtil::ToFloat( t, fval ) ) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}

int XMLElement::IntText(int defaultValue) const
{
	int i = defaultValue;
	QueryIntText(&i);
	return i;
}

unsigned XMLElement::UnsignedText(unsigned defaultValue) const
{
	unsigned i = defaultValue;
	QueryUnsignedText(&i);
	return i;
}

int64_t XMLElement::Int64Text(int64_t defaultValue) const
{
	int64_t i = defaultValue;
	QueryInt64Text(&i);
	return i;
}

uint64_t XMLElement::Unsigned64Text(uint64_t defaultValue) const
{
	uint64_t i = defaultValue;
	QueryUnsigned64Text(&i);
	return i;
}

bool XMLElement::BoolText(bool defaultValue) const
{
	bool b = defaultValue;
	QueryBoolText(&b);
	return b;
}

double XMLElement::DoubleText(double defaultValue) const
{
	double d = defaultValue;
	QueryDoubleText(&d);
	return d;
}

float XMLElement::FloatText(float defaultValue) const
{
	float f = defaultValue;
	QueryFloatText(&f);
	return f;
}


XMLAttribute* XMLElement::FindOrCreateAttribute( const char* name )
{
    XMLAttribute* last = 0;
    XMLAttribute* attrib = 0;
    for( attrib = _rootAttribute;
            attrib;
            last = attrib, attrib = attrib->_next ) {
        if ( XMLUtil::StringEqual( attrib->Name(), name ) ) {
            break;
        }
    }
    if ( !attrib ) {
        attrib = CreateAttribute();
        TIXMLASSERT( attrib );
        if ( last ) {
            TIXMLASSERT( last->_next == 0 );
            last->_next = attrib;
        }
        else {
            TIXMLASSERT( _rootAttribute == 0 );
            _rootAttribute = attrib;
        }
        attrib->SetName( name );
    }
    return attrib;
}


void XMLElement::DeleteAttribute( const char* name )
{
    XMLAttribute* prev = 0;
    for( XMLAttribute* a=_rootAttribute; a; a=a->_next ) {
        if ( XMLUtil::StringEqual( name, a->Name() ) ) {
            if ( prev ) {
                prev->_next = a->_next;
            }
            else {
                _rootAttribute = a->_next;
            }
            DeleteAttribute( a );
            break;
        }
        prev = a;
    }
}


char* XMLElement::ParseAttributes( char* p, int* curLineNumPtr )
{
    XMLAttribute* prevAttribute = 0;

    // Read the attributes.
    while( p ) {
        p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
        if ( !(*p) ) {
            _document->SetError( XML_ERROR_PARSING_ELEMENT, _parseLineNum, "XMLElement name=%s", Name() );
            return 0;
        }

        // attribute.
        if (XMLUtil::IsNameStartChar( (unsigned char) *p ) ) {
            XMLAttribute* attrib = CreateAttribute();
            TIXMLASSERT( attrib );
            attrib->_parseLineNum = _document->_parseCurLineNum;

            const int attrLineNum = attrib->_parseLineNum;

            p = attrib->ParseDeep( p, _document->ProcessEntities(), curLineNumPtr );
            if ( !p || Attribute( attrib->Name() ) ) {
                DeleteAttribute( attrib );
                _document->SetError( XML_ERROR_PARSING_ATTRIBUTE, attrLineNum, "XMLElement name=%s", Name() );
                return 0;
            }
            // There is a minor bug here: if the attribute in the source xml
            // document is duplicated, it will not be detected and the
            // attribute will be doubly added. However, tracking the 'prevAttribute'
            // avoids re-scanning the attribute list. Preferring performance for
            // now, may reconsider in the future.
            if ( prevAttribute ) {
                TIXMLASSERT( prevAttribute->_next == 0 );
                prevAttribute->_next = attrib;
            }
            else {
                TIXMLASSERT( _rootAttribute == 0 );
                _rootAttribute = attrib;
            }
            prevAttribute = attrib;
        }
        // end of the tag
        else if ( *p == '>' ) {
            ++p;
            break;
        }
        // end of the tag
        else if ( *p == '/' && *(p+1) == '>' ) {
            _closingType = CLOSED;
            return p+2;	// done; sealed element.
        }
        else {
            _document->SetError( XML_ERROR_PARSING_ELEMENT, _parseLineNum, 0 );
            return 0;
        }
    }
    return p;
}

void XMLElement::DeleteAttribute( XMLAttribute* attribute )
{
    if ( attribute == 0 ) {
        return;
    }
    MemPool* pool = attribute->_memPool;
    attribute->~XMLAttribute();
    pool->Free( attribute );
}

XMLAttribute* XMLElement::CreateAttribute()
{
    TIXMLASSERT( sizeof( XMLAttribute ) == _document->_attributePool.ItemSize() );
    XMLAttribute* attrib = new (_document->_attributePool.Alloc() ) XMLAttribute();
    TIXMLASSERT( attrib );
    attrib->_memPool = &_document->_attributePool;
    attrib->_memPool->SetTracked();
    return attrib;
}


XMLElement* XMLElement::InsertNewChildElement(const char* name)
{
    XMLElement* node = _document->NewElement(name);
    return InsertEndChild(node) ? node : 0;
}

XMLComment* XMLElement::InsertNewComment(const char* comment)
{
    XMLComment* node = _document->NewComment(comment);
    return InsertEndChild(node) ? node : 0;
}

XMLText* XMLElement::InsertNewText(const char* text)
{
    XMLText* node = _document->NewText(text);
    return InsertEndChild(node) ? node : 0;
}

XMLDeclaration* XMLElement::InsertNewDeclaration(const char* text)
{
    XMLDeclaration* node = _document->NewDeclaration(text);
    return InsertEndChild(node) ? node : 0;
}

XMLUnknown* XMLElement::InsertNewUnknown(const char* text)
{
    XMLUnknown* node = _document->NewUnknown(text);
    return InsertEndChild(node) ? node : 0;
}



//
//	<ele></ele>
//	<ele>foo<b>bar</b></ele>
//
char* XMLElement::ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr )
{
    // Read the element name.
    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );

    // The closing element is the </element> form. It is
    // parsed just like a regular element then deleted from
    // the DOM.
    if ( *p == '/' ) {
        _closingType = CLOSING;
        ++p;
    }

    p = _value.ParseName( p );
    if ( _value.Empty() ) {
        return 0;
    }

    p = ParseAttributes( p, curLineNumPtr );
    if ( !p || !*p || _closingType != OPEN ) {
        return p;
    }

    p = XMLNode::ParseDeep( p, parentEndTag, curLineNumPtr );
    return p;
}



XMLNode* XMLElement::ShallowClone( XMLDocument* doc ) const
{
    if ( !doc ) {
        doc = _document;
    }
    XMLElement* element = doc->NewElement( Value() );					// fixme: this will always allocate memory. Intern?
    for( const XMLAttribute* a=FirstAttribute(); a; a=a->Next() ) {
        element->SetAttribute( a->Name(), a->Value() );					// fixme: this will always allocate memory. Intern?
    }
    return element;
}


bool XMLElement::ShallowEqual( const XMLNode* compare ) const
{
    TIXMLASSERT( compare );
    const XMLElement* other = compare->ToElement();
    if ( other && XMLUtil::StringEqual( other->Name(), Name() )) {

        const XMLAttribute* a=FirstAttribute();
        const XMLAttribute* b=other->FirstAttribute();

        while ( a && b ) {
            if ( !XMLUtil::StringEqual( a->Value(), b->Value() ) ) {
                return false;
            }
            a = a->Next();
            b = b->Next();
        }
        if ( a || b ) {
            // different count
            return false;
        }
        return true;
    }
    return false;
}


bool XMLElement::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    if ( visitor->VisitEnter( *this, _rootAttribute ) ) {
        for ( const XMLNode* node=FirstChild(); node; node=node->NextSibling() ) {
            if ( !node->Accept( visitor ) ) {
                break;
            }
        }
    }
    return visitor->VisitExit( *this );
}


// --------- XMLDocument ----------- //

// Warning: List must match 'enum XMLError'
const char* XMLDocument::_errorNames[XML_ERROR_COUNT] = {
    "XML_SUCCESS",
    "XML_NO_ATTRIBUTE",
    "XML_WRONG_ATTRIBUTE_TYPE",
    "XML_ERROR_FILE_NOT_FOUND",
    "XML_ERROR_FILE_COULD_NOT_BE_OPENED",
    "XML_ERROR_FILE_READ_ERROR",
    "XML_ERROR_PARSING_ELEMENT",
    "XML_ERROR_PARSING_ATTRIBUTE",
    "XML_ERROR_PARSING_TEXT",
    "XML_ERROR_PARSING_CDATA",
    "XML_ERROR_PARSING_COMMENT",
    "XML_ERROR_PARSING_DECLARATION",
    "XML_ERROR_PARSING_UNKNOWN",
    "XML_ERROR_EMPTY_DOCUMENT",
    "XML_ERROR_MISMATCHED_ELEMENT",
    "XML_ERROR_PARSING",
    "XML_CAN_NOT_CONVERT_TEXT",
    "XML_NO_TEXT_NODE",
	"XML_ELEMENT_DEPTH_EXCEEDED"
};


XMLDocument::XMLDocument( bool processEntities, Whitespace whitespaceMode ) :
    XMLNode( 0 ),
    _writeBOM( false ),
    _processEntities( processEntities ),
    _errorID(XML_SUCCESS),
    _whitespaceMode( whitespaceMode ),
    _errorStr(),
    _errorLineNum( 0 ),
    _charBuffer( 0 ),
    _parseCurLineNum( 0 ),
	_parsingDepth(0),
    _unlinked(),
    _elementPool(),
    _attributePool(),
    _textPool(),
    _commentPool()
{
    // avoid VC++ C4355 warning about 'this' in initializer list (C4355 is off by default in VS2012+)
    _document = this;
}


XMLDocument::~XMLDocument()
{
    Clear();
}


void XMLDocument::MarkInUse(const XMLNode* const node)
{
	TIXMLASSERT(node);
	TIXMLASSERT(node->_parent == 0);

	for (int i = 0; i < _unlinked.Size(); ++i) {
		if (node == _unlinked[i]) {
			_unlinked.SwapRemove(i);
			break;
		}
	}
}

void XMLDocument::Clear()
{
    DeleteChildren();
	while( _unlinked.Size()) {
		DeleteNode(_unlinked[0]);	// Will remove from _unlinked as part of delete.
	}

#ifdef TINYXML2_DEBUG
    const bool hadError = Error();
#endif
    ClearError();

    delete [] _charBuffer;
    _charBuffer = 0;
	_parsingDepth = 0;

#if 0
    _textPool.Trace( "text" );
    _elementPool.Trace( "element" );
    _commentPool.Trace( "comment" );
    _attributePool.Trace( "attribute" );
#endif

#ifdef TINYXML2_DEBUG
    if ( !hadError ) {
        TIXMLASSERT( _elementPool.CurrentAllocs()   == _elementPool.Untracked() );
        TIXMLASSERT( _attributePool.CurrentAllocs() == _attributePool.Untracked() );
        TIXMLASSERT( _textPool.CurrentAllocs()      == _textPool.Untracked() );
        TIXMLASSERT( _commentPool.CurrentAllocs()   == _commentPool.Untracked() );
    }
#endif
}


void XMLDocument::DeepCopy(XMLDocument* target) const
{
	TIXMLASSERT(target);
    if (target == this) {
        return; // technically success - a no-op.
    }

	target->Clear();
	for (const XMLNode* node = this->FirstChild(); node; node = node->NextSibling()) {
		target->InsertEndChild(node->DeepClone(target));
	}
}

XMLElement* XMLDocument::NewElement( const char* name )
{
    XMLElement* ele = CreateUnlinkedNode<XMLElement>( _elementPool );
    ele->SetName( name );
    return ele;
}


XMLComment* XMLDocument::NewComment( const char* str )
{
    XMLComment* comment = CreateUnlinkedNode<XMLComment>( _commentPool );
    comment->SetValue( str );
    return comment;
}


XMLText* XMLDocument::NewText( const char* str )
{
    XMLText* text = CreateUnlinkedNode<XMLText>( _textPool );
    text->SetValue( str );
    return text;
}


XMLDeclaration* XMLDocument::NewDeclaration( const char* str )
{
    XMLDeclaration* dec = CreateUnlinkedNode<XMLDeclaration>( _commentPool );
    dec->SetValue( str ? str : "xml version=\"1.0\" encoding=\"UTF-8\"" );
    return dec;
}


XMLUnknown* XMLDocument::NewUnknown( const char* str )
{
    XMLUnknown* unk = CreateUnlinkedNode<XMLUnknown>( _commentPool );
    unk->SetValue( str );
    return unk;
}

static FILE* callfopen( const char* filepath, const char* mode )
{
    TIXMLASSERT( filepath );
    TIXMLASSERT( mode );
#if defined(_MSC_VER) && (_MSC_VER >= 1400 ) && (!defined WINCE)
    FILE* fp = 0;
    const errno_t err = fopen_s( &fp, filepath, mode );
    if ( err ) {
        return 0;
    }
#else
    FILE* fp = fopen( filepath, mode );
#endif
    return fp;
}

void XMLDocument::DeleteNode( XMLNode* node )	{
    TIXMLASSERT( node );
    TIXMLASSERT(node->_document == this );
    if (node->_parent) {
        node->_parent->DeleteChild( node );
    }
    else {
        // Isn't in the tree.
        // Use the parent delete.
        // Also, we need to mark it tracked: we 'know'
        // it was never used.
        node->_memPool->SetTracked();
        // Call the static XMLNode version:
        XMLNode::DeleteNode(node);
    }
}


XMLError XMLDocument::LoadFile( const char* filename )
{
    if ( !filename ) {
        TIXMLASSERT( false );
        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=<null>" );
        return _errorID;
    }

    Clear();
    FILE* fp = callfopen( filename, "rb" );
    if ( !fp ) {
        SetError( XML_ERROR_FILE_NOT_FOUND, 0, "filename=%s", filename );
        return _errorID;
    }
    LoadFile( fp );
    fclose( fp );
    return _errorID;
}

XMLError XMLDocument::LoadFile( FILE* fp )
{
    Clear();

    TIXML_FSEEK( fp, 0, SEEK_SET );
    if ( fgetc( fp ) == EOF && ferror( fp ) != 0 ) {
        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
        return _errorID;
    }

    TIXML_FSEEK( fp, 0, SEEK_END );

    unsigned long long filelength;
    {
        const long long fileLengthSigned = TIXML_FTELL( fp );
        TIXML_FSEEK( fp, 0, SEEK_SET );
        if ( fileLengthSigned == -1L ) {
            SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
            return _errorID;
        }
        TIXMLASSERT( fileLengthSigned >= 0 );
        filelength = static_cast<unsigned long long>(fileLengthSigned);
    }

    const size_t maxSizeT = static_cast<size_t>(-1);
    // We'll do the comparison as an unsigned long long, because that's guaranteed to be at
    // least 8 bytes, even on a 32-bit platform.
    if ( filelength >= static_cast<unsigned long long>(maxSizeT) ) {
        // Cannot handle files which won't fit in buffer together with null terminator
        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
        return _errorID;
    }

    if ( filelength == 0 ) {
        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );
        return _errorID;
    }

    const size_t size = static_cast<size_t>(filelength);
    TIXMLASSERT( _charBuffer == 0 );
    _charBuffer = new char[size+1];
    const size_t read = fread( _charBuffer, 1, size, fp );
    if ( read != size ) {
        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
        return _errorID;
    }

    _charBuffer[size] = 0;

    Parse();
    return _errorID;
}


XMLError XMLDocument::SaveFile( const char* filename, bool compact )
{
    if ( !filename ) {
        TIXMLASSERT( false );
        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=<null>" );
        return _errorID;
    }

    FILE* fp = callfopen( filename, "w" );
    if ( !fp ) {
        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=%s", filename );
        return _errorID;
    }
    SaveFile(fp, compact);
    fclose( fp );
    return _errorID;
}


XMLError XMLDocument::SaveFile( FILE* fp, bool compact )
{
    // Clear any error from the last save, otherwise it will get reported
    // for *this* call.
    ClearError();
    XMLPrinter stream( fp, compact );
    Print( &stream );
    return _errorID;
}


XMLError XMLDocument::Parse( const char* xml, size_t nBytes )
{
    Clear();

    if ( nBytes == 0 || !xml || !*xml ) {
        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );
        return _errorID;
    }
    if ( nBytes == static_cast<size_t>(-1) ) {
        nBytes = strlen( xml );
    }
    TIXMLASSERT( _charBuffer == 0 );
    _charBuffer = new char[ nBytes+1 ];
    memcpy( _charBuffer, xml, nBytes );
    _charBuffer[nBytes] = 0;

    Parse();
    if ( Error() ) {
        // clean up now essentially dangling memory.
        // and the parse fail can put objects in the
        // pools that are dead and inaccessible.
        DeleteChildren();
        _elementPool.Clear();
        _attributePool.Clear();
        _textPool.Clear();
        _commentPool.Clear();
    }
    return _errorID;
}


void XMLDocument::Print( XMLPrinter* streamer ) const
{
    if ( streamer ) {
        Accept( streamer );
    }
    else {
        XMLPrinter stdoutStreamer( stdout );
        Accept( &stdoutStreamer );
    }
}


void XMLDocument::ClearError() {
    _errorID = XML_SUCCESS;
    _errorLineNum = 0;
    _errorStr.Reset();
}


void XMLDocument::SetError( XMLError error, int lineNum, const char* format, ... )
{
    TIXMLASSERT( error >= 0 && error < XML_ERROR_COUNT );
    _errorID = error;
    _errorLineNum = lineNum;
	_errorStr.Reset();

    const size_t BUFFER_SIZE = 1000;
    char* buffer = new char[BUFFER_SIZE];

    TIXMLASSERT(sizeof(error) <= sizeof(int));
    TIXML_SNPRINTF(buffer, BUFFER_SIZE, "Error=%s ErrorID=%d (0x%x) Line number=%d", ErrorIDToName(error), int(error), int(error), lineNum);

	if (format) {
		size_t len = strlen(buffer);
		TIXML_SNPRINTF(buffer + len, BUFFER_SIZE - len, ": ");
		len = strlen(buffer);

		va_list va;
		va_start(va, format);
		TIXML_VSNPRINTF(buffer + len, BUFFER_SIZE - len, format, va);
		va_end(va);
	}
	_errorStr.SetStr(buffer);
	delete[] buffer;
}


/*static*/ const char* XMLDocument::ErrorIDToName(XMLError errorID)
{
	TIXMLASSERT( errorID >= 0 && errorID < XML_ERROR_COUNT );
    const char* errorName = _errorNames[errorID];
    TIXMLASSERT( errorName && errorName[0] );
    return errorName;
}

const char* XMLDocument::ErrorStr() const
{
	return _errorStr.Empty() ? "" : _errorStr.GetStr();
}


void XMLDocument::PrintError() const
{
    printf("%s\n", ErrorStr());
}

const char* XMLDocument::ErrorName() const
{
    return ErrorIDToName(_errorID);
}

void XMLDocument::Parse()
{
    TIXMLASSERT( NoChildren() ); // Clear() must have been called previously
    TIXMLASSERT( _charBuffer );
    _parseCurLineNum = 1;
    _parseLineNum = 1;
    char* p = _charBuffer;
    p = XMLUtil::SkipWhiteSpace( p, &_parseCurLineNum );
    p = const_cast<char*>( XMLUtil::ReadBOM( p, &_writeBOM ) );
    if ( !*p ) {
        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );
        return;
    }
    ParseDeep(p, 0, &_parseCurLineNum );
}

void XMLDocument::PushDepth()
{
	_parsingDepth++;
	if (_parsingDepth == TINYXML2_MAX_ELEMENT_DEPTH) {
		SetError(XML_ELEMENT_DEPTH_EXCEEDED, _parseCurLineNum, "Element nesting is too deep." );
	}
}

void XMLDocument::PopDepth()
{
	TIXMLASSERT(_parsingDepth > 0);
	--_parsingDepth;
}

XMLPrinter::XMLPrinter( FILE* file, bool compact, int depth ) :
    _elementJustOpened( false ),
    _stack(),
    _firstElement( true ),
    _fp( file ),
    _depth( depth ),
    _textDepth( -1 ),
    _processEntities( true ),
    _compactMode( compact ),
    _buffer()
{
    for( int i=0; i<ENTITY_RANGE; ++i ) {
        _entityFlag[i] = false;
        _restrictedEntityFlag[i] = false;
    }
    for( int i=0; i<NUM_ENTITIES; ++i ) {
        const char entityValue = entities[i].value;
        const unsigned char flagIndex = static_cast<unsigned char>(entityValue);
        TIXMLASSERT( flagIndex < ENTITY_RANGE );
        _entityFlag[flagIndex] = true;
    }
    _restrictedEntityFlag[static_cast<unsigned char>('&')] = true;
    _restrictedEntityFlag[static_cast<unsigned char>('<')] = true;
    _restrictedEntityFlag[static_cast<unsigned char>('>')] = true;	// not required, but consistency is nice
    _buffer.Push( 0 );
}


void XMLPrinter::Print( const char* format, ... )
{
    va_list     va;
    va_start( va, format );

    if ( _fp ) {
        vfprintf( _fp, format, va );
    }
    else {
        const int len = TIXML_VSCPRINTF( format, va );
        // Close out and re-start the va-args
        va_end( va );
        TIXMLASSERT( len >= 0 );
        va_start( va, format );
        TIXMLASSERT( _buffer.Size() > 0 && _buffer[_buffer.Size() - 1] == 0 );
        char* p = _buffer.PushArr( len ) - 1;	// back up over the null terminator.
		TIXML_VSNPRINTF( p, len+1, format, va );
    }
    va_end( va );
}


void XMLPrinter::Write( const char* data, size_t size )
{
    if ( _fp ) {
        fwrite ( data , sizeof(char), size, _fp);
    }
    else {
        char* p = _buffer.PushArr( static_cast<int>(size) ) - 1;   // back up over the null terminator.
        memcpy( p, data, size );
        p[size] = 0;
    }
}


void XMLPrinter::Putc( char ch )
{
    if ( _fp ) {
        fputc ( ch, _fp);
    }
    else {
        char* p = _buffer.PushArr( sizeof(char) ) - 1;   // back up over the null terminator.
        p[0] = ch;
        p[1] = 0;
    }
}


void XMLPrinter::PrintSpace( int depth )
{
    for( int i=0; i<depth; ++i ) {
        Write( "    " );
    }
}


void XMLPrinter::PrintString( const char* p, bool restricted )
{
    // Look for runs of bytes between entities to print.
    const char* q = p;

    if ( _processEntities ) {
        const bool* flag = restricted ? _restrictedEntityFlag : _entityFlag;
        while ( *q ) {
            TIXMLASSERT( p <= q );
            // Remember, char is sometimes signed. (How many times has that bitten me?)
            if ( *q > 0 && *q < ENTITY_RANGE ) {
                // Check for entities. If one is found, flush
                // the stream up until the entity, write the
                // entity, and keep looking.
                if ( flag[static_cast<unsigned char>(*q)] ) {
                    while ( p < q ) {
                        const size_t delta = q - p;
                        const int toPrint = ( INT_MAX < delta ) ? INT_MAX : static_cast<int>(delta);
                        Write( p, toPrint );
                        p += toPrint;
                    }
                    bool entityPatternPrinted = false;
                    for( int i=0; i<NUM_ENTITIES; ++i ) {
                        if ( entities[i].value == *q ) {
                            Putc( '&' );
                            Write( entities[i].pattern, entities[i].length );
                            Putc( ';' );
                            entityPatternPrinted = true;
                            break;
                        }
                    }
                    if ( !entityPatternPrinted ) {
                        // TIXMLASSERT( entityPatternPrinted ) causes gcc -Wunused-but-set-variable in release
                        TIXMLASSERT( false );
                    }
                    ++p;
                }
            }
            ++q;
            TIXMLASSERT( p <= q );
        }
        // Flush the remaining string. This will be the entire
        // string if an entity wasn't found.
        if ( p < q ) {
            const size_t delta = q - p;
            const int toPrint = ( INT_MAX < delta ) ? INT_MAX : static_cast<int>(delta);
            Write( p, toPrint );
        }
    }
    else {
        Write( p );
    }
}


void XMLPrinter::PushHeader( bool writeBOM, bool writeDec )
{
    if ( writeBOM ) {
        static const unsigned char bom[] = { TIXML_UTF_LEAD_0, TIXML_UTF_LEAD_1, TIXML_UTF_LEAD_2, 0 };
        Write( reinterpret_cast< const char* >( bom ) );
    }
    if ( writeDec ) {
        PushDeclaration( "xml version=\"1.0\"" );
    }
}

void XMLPrinter::PrepareForNewNode( bool compactMode )
{
    SealElementIfJustOpened();

    if ( compactMode ) {
        return;
    }

    if ( _firstElement ) {
        PrintSpace (_depth);
    } else if ( _textDepth < 0) {
        Putc( '\n' );
        PrintSpace( _depth );
    }

    _firstElement = false;
}

void XMLPrinter::OpenElement( const char* name, bool compactMode )
{
    PrepareForNewNode( compactMode );
    _stack.Push( name );

    Write ( "<" );
    Write ( name );

    _elementJustOpened = true;
    ++_depth;
}


void XMLPrinter::PushAttribute( const char* name, const char* value )
{
    TIXMLASSERT( _elementJustOpened );
    Putc ( ' ' );
    Write( name );
    Write( "=\"" );
    PrintString( value, false );
    Putc ( '\"' );
}


void XMLPrinter::PushAttribute( const char* name, int v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    PushAttribute( name, buf );
}


void XMLPrinter::PushAttribute( const char* name, unsigned v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    PushAttribute( name, buf );
}


void XMLPrinter::PushAttribute(const char* name, int64_t v)
{
	char buf[BUF_SIZE];
	XMLUtil::ToStr(v, buf, BUF_SIZE);
	PushAttribute(name, buf);
}


void XMLPrinter::PushAttribute(const char* name, uint64_t v)
{
	char buf[BUF_SIZE];
	XMLUtil::ToStr(v, buf, BUF_SIZE);
	PushAttribute(name, buf);
}


void XMLPrinter::PushAttribute( const char* name, bool v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    PushAttribute( name, buf );
}


void XMLPrinter::PushAttribute( const char* name, double v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    PushAttribute( name, buf );
}


void XMLPrinter::CloseElement( bool compactMode )
{
    --_depth;
    const char* name = _stack.Pop();

    if ( _elementJustOpened ) {
        Write( "/>" );
    }
    else {
        if ( _textDepth < 0 && !compactMode) {
            Putc( '\n' );
            PrintSpace( _depth );
        }
        Write ( "</" );
        Write ( name );
        Write ( ">" );
    }

    if ( _textDepth == _depth ) {
        _textDepth = -1;
    }
    if ( _depth == 0 && !compactMode) {
        Putc( '\n' );
    }
    _elementJustOpened = false;
}


void XMLPrinter::SealElementIfJustOpened()
{
    if ( !_elementJustOpened ) {
        return;
    }
    _elementJustOpened = false;
    Putc( '>' );
}


void XMLPrinter::PushText( const char* text, bool cdata )
{
    _textDepth = _depth-1;

    SealElementIfJustOpened();
    if ( cdata ) {
        Write( "<![CDATA[" );
        Write( text );
        Write( "]]>" );
    }
    else {
        PrintString( text, true );
    }
}


void XMLPrinter::PushText( int64_t value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}


void XMLPrinter::PushText( uint64_t value )
{
	char buf[BUF_SIZE];
	XMLUtil::ToStr(value, buf, BUF_SIZE);
	PushText(buf, false);
}


void XMLPrinter::PushText( int value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}


void XMLPrinter::PushText( unsigned value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}


void XMLPrinter::PushText( bool value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}


void XMLPrinter::PushText( float value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}


void XMLPrinter::PushText( double value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}


void XMLPrinter::PushComment( const char* comment )
{
    PrepareForNewNode( _compactMode );

    Write( "<!--" );
    Write( comment );
    Write( "-->" );
}


void XMLPrinter::PushDeclaration( const char* value )
{
    PrepareForNewNode( _compactMode );

    Write( "<?" );
    Write( value );
    Write( "?>" );
}


void XMLPrinter::PushUnknown( const char* value )
{
    PrepareForNewNode( _compactMode );

    Write( "<!" );
    Write( value );
    Putc( '>' );
}


bool XMLPrinter::VisitEnter( const XMLDocument& doc )
{
    _processEntities = doc.ProcessEntities();
    if ( doc.HasBOM() ) {
        PushHeader( true, false );
    }
    return true;
}


bool XMLPrinter::VisitEnter( const XMLElement& element, const XMLAttribute* attribute )
{
    const XMLElement* parentElem = 0;
    if ( element.Parent() ) {
        parentElem = element.Parent()->ToElement();
    }
    const bool compactMode = parentElem ? CompactMode( *parentElem ) : _compactMode;
    OpenElement( element.Name(), compactMode );
    while ( attribute ) {
        PushAttribute( attribute->Name(), attribute->Value() );
        attribute = attribute->Next();
    }
    return true;
}


bool XMLPrinter::VisitExit( const XMLElement& element )
{
    CloseElement( CompactMode(element) );
    return true;
}


bool XMLPrinter::Visit( const XMLText& text )
{
    PushText( text.Value(), text.CData() );
    return true;
}


bool XMLPrinter::Visit( const XMLComment& comment )
{
    PushComment( comment.Value() );
    return true;
}

bool XMLPrinter::Visit( const XMLDeclaration& declaration )
{
    PushDeclaration( declaration.Value() );
    return true;
}


bool XMLPrinter::Visit( const XMLUnknown& unknown )
{
    PushUnknown( unknown.Value() );
    return true;
}

}   // namespace tinyxml2








namespace NumberDuck
{
	namespace Secret
	{
		XmlNode::XmlNode(tinyxml2::XMLNode* pNode, XmlNode* pParent)
		{
			m_pNode = pNode;
			m_pParent = pParent;
			m_pChildNodeVector = new Vector<XmlNode*>();
		}

		XmlNode::~XmlNode()
		{
			while (m_pChildNodeVector->GetSize())
				delete m_pChildNodeVector->PopBack();
			delete m_pChildNodeVector;
		}

		XmlNode* XmlNode::GetFirstChildElement(const char* szName)
		{
			tinyxml2::XMLElement* pTemp = m_pNode->FirstChildElement(szName);
			if (!pTemp)
				return NULL;

			XmlNode* pChildNode = new XmlNode(pTemp, this);
			m_pChildNodeVector->PushBack(pChildNode);
			return pChildNode;
		}

		// super fucking hax
		XmlNode* XmlNode::GetNextSiblingElement(const char* szName)
		{
			tinyxml2::XMLElement* pTemp = m_pNode->NextSiblingElement(szName);
			if (!pTemp)
				return NULL;

			XmlNode* pSiblingNode = new XmlNode(pTemp, m_pParent);
			m_pParent->m_pChildNodeVector->PushBack(pSiblingNode);
			return pSiblingNode;
		}

		const char* XmlNode::GetValue()
		{
			return m_pNode->Value();
		}

		const char* XmlNode::GetText()
		{
			tinyxml2::XMLElement* pElement = m_pNode->ToElement();
			if (pElement)
				return pElement->GetText();
			return NULL;
		}

		const char* XmlNode::GetAttribute(const char* szName)
		{
			tinyxml2::XMLElement* pElement = m_pNode->ToElement();
			if (pElement)
				return pElement->Attribute(szName);
			return NULL;
		}

		XmlFile::XmlFile() : XmlNode(NULL, NULL)
		{
			m_pDocument = NULL;
		}

		XmlFile::~XmlFile()
		{
			Cleanup();
		}

		bool XmlFile::Load(BlobView* pBlobView)
		{
			const char* szRawXml = (const char*)(pBlobView->GetBlob()->GetData() + pBlobView->GetStart() + pBlobView->GetOffset());
			size_t nSize = (size_t)(pBlobView->GetSize() - pBlobView->GetOffset());
			tinyxml2::XMLError error;

			Cleanup();

			m_pDocument = new tinyxml2::XMLDocument();
			error = m_pDocument->Parse(szRawXml, nSize);
			if (error != tinyxml2::XML_SUCCESS)
			{
				Cleanup();
				return false;
			}

			m_pNode = m_pDocument;

			return true;
		}

		void XmlFile::Cleanup()
		{
			if (m_pDocument)
			{
				delete m_pDocument;
			}
		}
	}
}



/**************************************************************************
 *
 * Copyright 2013-2014 RAD Game Tools and Valve Software
 * Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 **************************************************************************/



typedef unsigned char mz_validate_uint16[sizeof(mz_uint16) == 2 ? 1 : -1];
typedef unsigned char mz_validate_uint32[sizeof(mz_uint32) == 4 ? 1 : -1];
typedef unsigned char mz_validate_uint64[sizeof(mz_uint64) == 8 ? 1 : -1];

#ifdef __cplusplus
extern "C" {
#endif

/* ------------------- zlib-style API's */

mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len)
{
    mz_uint32 i, s1 = (mz_uint32)(adler & 0xffff), s2 = (mz_uint32)(adler >> 16);
    size_t block_len = buf_len % 5552;
    if (!ptr)
        return MZ_ADLER32_INIT;
    while (buf_len)
    {
        for (i = 0; i + 7 < block_len; i += 8, ptr += 8)
        {
            s1 += ptr[0], s2 += s1;
            s1 += ptr[1], s2 += s1;
            s1 += ptr[2], s2 += s1;
            s1 += ptr[3], s2 += s1;
            s1 += ptr[4], s2 += s1;
            s1 += ptr[5], s2 += s1;
            s1 += ptr[6], s2 += s1;
            s1 += ptr[7], s2 += s1;
        }
        for (; i < block_len; ++i)
            s1 += *ptr++, s2 += s1;
        s1 %= 65521U, s2 %= 65521U;
        buf_len -= block_len;
        block_len = 5552;
    }
    return (s2 << 16) + s1;
}

/* Karl Malbrain's compact CRC-32. See "A compact CCITT crc16 and crc32 C implementation that balances processor cache usage against speed": http://www.geocities.com/malbrain/ */
#if 0
    mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len)
    {
        static const mz_uint32 s_crc32[16] = { 0, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
                                               0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c };
        mz_uint32 crcu32 = (mz_uint32)crc;
        if (!ptr)
            return MZ_CRC32_INIT;
        crcu32 = ~crcu32;
        while (buf_len--)
        {
            mz_uint8 b = *ptr++;
            crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)];
            crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)];
        }
        return ~crcu32;
    }
#elif defined(USE_EXTERNAL_MZCRC)
/* If USE_EXTERNAL_CRC is defined, an external module will export the
 * mz_crc32() symbol for us to use, e.g. an SSE-accelerated version.
 * Depending on the impl, it may be necessary to ~ the input/output crc values.
 */
mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len);
#else
/* Faster, but larger CPU cache footprint.
 */
mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len)
{
    static const mz_uint32 s_crc_table[256] =
        {
          0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535,
          0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD,
          0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D,
          0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
          0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4,
          0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
          0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC,
          0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
          0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB,
          0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F,
          0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB,
          0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
          0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA,
          0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE,
          0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A,
          0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
          0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409,
          0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
          0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739,
          0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
          0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268,
          0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0,
          0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8,
          0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
          0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF,
          0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703,
          0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7,
          0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
          0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE,
          0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
          0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6,
          0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
          0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D,
          0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5,
          0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605,
          0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
          0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
        };

    mz_uint32 crc32 = (mz_uint32)crc ^ 0xFFFFFFFF;
    const mz_uint8 *pByte_buf = (const mz_uint8 *)ptr;

    while (buf_len >= 4)
    {
        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[0]) & 0xFF];
        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[1]) & 0xFF];
        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[2]) & 0xFF];
        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[3]) & 0xFF];
        pByte_buf += 4;
        buf_len -= 4;
    }

    while (buf_len)
    {
        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[0]) & 0xFF];
        ++pByte_buf;
        --buf_len;
    }

    return ~crc32;
}
#endif

void mz_free(void *p)
{
    MZ_FREE(p);
}

MINIZ_EXPORT void *miniz_def_alloc_func(void *opaque, size_t items, size_t size)
{
    (void)opaque, (void)items, (void)size;
    return MZ_MALLOC(items * size);
}
MINIZ_EXPORT void miniz_def_free_func(void *opaque, void *address)
{
    (void)opaque, (void)address;
    MZ_FREE(address);
}
MINIZ_EXPORT void *miniz_def_realloc_func(void *opaque, void *address, size_t items, size_t size)
{
    (void)opaque, (void)address, (void)items, (void)size;
    return MZ_REALLOC(address, items * size);
}

const char *mz_version(void)
{
    return MZ_VERSION;
}

#ifndef MINIZ_NO_ZLIB_APIS

#ifndef MINIZ_NO_DEFLATE_APIS

int mz_deflateInit(mz_streamp pStream, int level)
{
    return mz_deflateInit2(pStream, level, MZ_DEFLATED, MZ_DEFAULT_WINDOW_BITS, 9, MZ_DEFAULT_STRATEGY);
}

int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy)
{
    tdefl_compressor *pComp;
    mz_uint comp_flags = TDEFL_COMPUTE_ADLER32 | tdefl_create_comp_flags_from_zip_params(level, window_bits, strategy);

    if (!pStream)
        return MZ_STREAM_ERROR;
    if ((method != MZ_DEFLATED) || ((mem_level < 1) || (mem_level > 9)) || ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS)))
        return MZ_PARAM_ERROR;

    pStream->data_type = 0;
    pStream->adler = MZ_ADLER32_INIT;
    pStream->msg = NULL;
    pStream->reserved = 0;
    pStream->total_in = 0;
    pStream->total_out = 0;
    if (!pStream->zalloc)
        pStream->zalloc = miniz_def_alloc_func;
    if (!pStream->zfree)
        pStream->zfree = miniz_def_free_func;

    pComp = (tdefl_compressor *)pStream->zalloc(pStream->opaque, 1, sizeof(tdefl_compressor));
    if (!pComp)
        return MZ_MEM_ERROR;

    pStream->state = (struct mz_internal_state *)pComp;

    if (tdefl_init(pComp, NULL, NULL, comp_flags) != TDEFL_STATUS_OKAY)
    {
        mz_deflateEnd(pStream);
        return MZ_PARAM_ERROR;
    }

    return MZ_OK;
}

int mz_deflateReset(mz_streamp pStream)
{
    if ((!pStream) || (!pStream->state) || (!pStream->zalloc) || (!pStream->zfree))
        return MZ_STREAM_ERROR;
    pStream->total_in = pStream->total_out = 0;
    tdefl_init((tdefl_compressor *)pStream->state, NULL, NULL, ((tdefl_compressor *)pStream->state)->m_flags);
    return MZ_OK;
}

int mz_deflate(mz_streamp pStream, int flush)
{
    size_t in_bytes, out_bytes;
    mz_ulong orig_total_in, orig_total_out;
    int mz_status = MZ_OK;

    if ((!pStream) || (!pStream->state) || (flush < 0) || (flush > MZ_FINISH) || (!pStream->next_out))
        return MZ_STREAM_ERROR;
    if (!pStream->avail_out)
        return MZ_BUF_ERROR;

    if (flush == MZ_PARTIAL_FLUSH)
        flush = MZ_SYNC_FLUSH;

    if (((tdefl_compressor *)pStream->state)->m_prev_return_status == TDEFL_STATUS_DONE)
        return (flush == MZ_FINISH) ? MZ_STREAM_END : MZ_BUF_ERROR;

    orig_total_in = pStream->total_in;
    orig_total_out = pStream->total_out;
    for (;;)
    {
        tdefl_status defl_status;
        in_bytes = pStream->avail_in;
        out_bytes = pStream->avail_out;

        defl_status = tdefl_compress((tdefl_compressor *)pStream->state, pStream->next_in, &in_bytes, pStream->next_out, &out_bytes, (tdefl_flush)flush);
        pStream->next_in += (mz_uint)in_bytes;
        pStream->avail_in -= (mz_uint)in_bytes;
        pStream->total_in += (mz_uint)in_bytes;
        pStream->adler = tdefl_get_adler32((tdefl_compressor *)pStream->state);

        pStream->next_out += (mz_uint)out_bytes;
        pStream->avail_out -= (mz_uint)out_bytes;
        pStream->total_out += (mz_uint)out_bytes;

        if (defl_status < 0)
        {
            mz_status = MZ_STREAM_ERROR;
            break;
        }
        else if (defl_status == TDEFL_STATUS_DONE)
        {
            mz_status = MZ_STREAM_END;
            break;
        }
        else if (!pStream->avail_out)
            break;
        else if ((!pStream->avail_in) && (flush != MZ_FINISH))
        {
            if ((flush) || (pStream->total_in != orig_total_in) || (pStream->total_out != orig_total_out))
                break;
            return MZ_BUF_ERROR; /* Can't make forward progress without some input.
 */
        }
    }
    return mz_status;
}

int mz_deflateEnd(mz_streamp pStream)
{
    if (!pStream)
        return MZ_STREAM_ERROR;
    if (pStream->state)
    {
        pStream->zfree(pStream->opaque, pStream->state);
        pStream->state = NULL;
    }
    return MZ_OK;
}

mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len)
{
    (void)pStream;
    /* This is really over conservative. (And lame, but it's actually pretty tricky to compute a true upper bound given the way tdefl's blocking works.) */
    return MZ_MAX(128 + (source_len * 110) / 100, 128 + source_len + ((source_len / (31 * 1024)) + 1) * 5);
}

int mz_compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, int level)
{
    int status;
    mz_stream stream;
    memset(&stream, 0, sizeof(stream));

    /* In case mz_ulong is 64-bits (argh I hate longs). */
    if ((mz_uint64)(source_len | *pDest_len) > 0xFFFFFFFFU)
        return MZ_PARAM_ERROR;

    stream.next_in = pSource;
    stream.avail_in = (mz_uint32)source_len;
    stream.next_out = pDest;
    stream.avail_out = (mz_uint32)*pDest_len;

    status = mz_deflateInit(&stream, level);
    if (status != MZ_OK)
        return status;

    status = mz_deflate(&stream, MZ_FINISH);
    if (status != MZ_STREAM_END)
    {
        mz_deflateEnd(&stream);
        return (status == MZ_OK) ? MZ_BUF_ERROR : status;
    }

    *pDest_len = stream.total_out;
    return mz_deflateEnd(&stream);
}

int mz_compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len)
{
    return mz_compress2(pDest, pDest_len, pSource, source_len, MZ_DEFAULT_COMPRESSION);
}

mz_ulong mz_compressBound(mz_ulong source_len)
{
    return mz_deflateBound(NULL, source_len);
}

#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/

#ifndef MINIZ_NO_INFLATE_APIS

typedef struct
{
    tinfl_decompressor m_decomp;
    mz_uint m_dict_ofs, m_dict_avail, m_first_call, m_has_flushed;
    int m_window_bits;
    mz_uint8 m_dict[TINFL_LZ_DICT_SIZE];
    tinfl_status m_last_status;
} inflate_state;

int mz_inflateInit2(mz_streamp pStream, int window_bits)
{
    inflate_state *pDecomp;
    if (!pStream)
        return MZ_STREAM_ERROR;
    if ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS))
        return MZ_PARAM_ERROR;

    pStream->data_type = 0;
    pStream->adler = 0;
    pStream->msg = NULL;
    pStream->total_in = 0;
    pStream->total_out = 0;
    pStream->reserved = 0;
    if (!pStream->zalloc)
        pStream->zalloc = miniz_def_alloc_func;
    if (!pStream->zfree)
        pStream->zfree = miniz_def_free_func;

    pDecomp = (inflate_state *)pStream->zalloc(pStream->opaque, 1, sizeof(inflate_state));
    if (!pDecomp)
        return MZ_MEM_ERROR;

    pStream->state = (struct mz_internal_state *)pDecomp;

    tinfl_init(&pDecomp->m_decomp);
    pDecomp->m_dict_ofs = 0;
    pDecomp->m_dict_avail = 0;
    pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
    pDecomp->m_first_call = 1;
    pDecomp->m_has_flushed = 0;
    pDecomp->m_window_bits = window_bits;

    return MZ_OK;
}

int mz_inflateInit(mz_streamp pStream)
{
    return mz_inflateInit2(pStream, MZ_DEFAULT_WINDOW_BITS);
}

int mz_inflateReset(mz_streamp pStream)
{
    inflate_state *pDecomp;
    if (!pStream)
        return MZ_STREAM_ERROR;

    pStream->data_type = 0;
    pStream->adler = 0;
    pStream->msg = NULL;
    pStream->total_in = 0;
    pStream->total_out = 0;
    pStream->reserved = 0;

    pDecomp = (inflate_state *)pStream->state;

    tinfl_init(&pDecomp->m_decomp);
    pDecomp->m_dict_ofs = 0;
    pDecomp->m_dict_avail = 0;
    pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
    pDecomp->m_first_call = 1;
    pDecomp->m_has_flushed = 0;
    /* pDecomp->m_window_bits = window_bits */;

    return MZ_OK;
}

int mz_inflate(mz_streamp pStream, int flush)
{
    inflate_state *pState;
    mz_uint n, first_call, decomp_flags = TINFL_FLAG_COMPUTE_ADLER32;
    size_t in_bytes, out_bytes, orig_avail_in;
    tinfl_status status;

    if ((!pStream) || (!pStream->state))
        return MZ_STREAM_ERROR;
    if (flush == MZ_PARTIAL_FLUSH)
        flush = MZ_SYNC_FLUSH;
    if ((flush) && (flush != MZ_SYNC_FLUSH) && (flush != MZ_FINISH))
        return MZ_STREAM_ERROR;

    pState = (inflate_state *)pStream->state;
    if (pState->m_window_bits > 0)
        decomp_flags |= TINFL_FLAG_PARSE_ZLIB_HEADER;
    orig_avail_in = pStream->avail_in;

    first_call = pState->m_first_call;
    pState->m_first_call = 0;
    if (pState->m_last_status < 0)
        return MZ_DATA_ERROR;

    if (pState->m_has_flushed && (flush != MZ_FINISH))
        return MZ_STREAM_ERROR;
    pState->m_has_flushed |= (flush == MZ_FINISH);

    if ((flush == MZ_FINISH) && (first_call))
    {
        /* MZ_FINISH on the first call implies that the input and output buffers are large enough to hold the entire compressed/decompressed file. */
        decomp_flags |= TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
        in_bytes = pStream->avail_in;
        out_bytes = pStream->avail_out;
        status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pStream->next_out, pStream->next_out, &out_bytes, decomp_flags);
        pState->m_last_status = status;
        pStream->next_in += (mz_uint)in_bytes;
        pStream->avail_in -= (mz_uint)in_bytes;
        pStream->total_in += (mz_uint)in_bytes;
        pStream->adler = tinfl_get_adler32(&pState->m_decomp);
        pStream->next_out += (mz_uint)out_bytes;
        pStream->avail_out -= (mz_uint)out_bytes;
        pStream->total_out += (mz_uint)out_bytes;

        if (status < 0)
            return MZ_DATA_ERROR;
        else if (status != TINFL_STATUS_DONE)
        {
            pState->m_last_status = TINFL_STATUS_FAILED;
            return MZ_BUF_ERROR;
        }
        return MZ_STREAM_END;
    }
    /* flush != MZ_FINISH then we must assume there's more input. */
    if (flush != MZ_FINISH)
        decomp_flags |= TINFL_FLAG_HAS_MORE_INPUT;

    if (pState->m_dict_avail)
    {
        n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
        memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
        pStream->next_out += n;
        pStream->avail_out -= n;
        pStream->total_out += n;
        pState->m_dict_avail -= n;
        pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);
        return ((pState->m_last_status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
    }

    for (;;)
    {
        in_bytes = pStream->avail_in;
        out_bytes = TINFL_LZ_DICT_SIZE - pState->m_dict_ofs;

        status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pState->m_dict, pState->m_dict + pState->m_dict_ofs, &out_bytes, decomp_flags);
        pState->m_last_status = status;

        pStream->next_in += (mz_uint)in_bytes;
        pStream->avail_in -= (mz_uint)in_bytes;
        pStream->total_in += (mz_uint)in_bytes;
        pStream->adler = tinfl_get_adler32(&pState->m_decomp);

        pState->m_dict_avail = (mz_uint)out_bytes;

        n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
        memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
        pStream->next_out += n;
        pStream->avail_out -= n;
        pStream->total_out += n;
        pState->m_dict_avail -= n;
        pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);

        if (status < 0)
            return MZ_DATA_ERROR; /* Stream is corrupted (there could be some uncompressed data left in the output dictionary - oh well). */
        else if ((status == TINFL_STATUS_NEEDS_MORE_INPUT) && (!orig_avail_in))
            return MZ_BUF_ERROR; /* Signal caller that we can't make forward progress without supplying more input or by setting flush to MZ_FINISH. */
        else if (flush == MZ_FINISH)
        {
            /* The output buffer MUST be large to hold the remaining uncompressed data when flush==MZ_FINISH. */
            if (status == TINFL_STATUS_DONE)
                return pState->m_dict_avail ? MZ_BUF_ERROR : MZ_STREAM_END;
            /* status here must be TINFL_STATUS_HAS_MORE_OUTPUT, which means there's at least 1 more byte on the way. If there's no more room left in the output buffer then something is wrong. */
            else if (!pStream->avail_out)
                return MZ_BUF_ERROR;
        }
        else if ((status == TINFL_STATUS_DONE) || (!pStream->avail_in) || (!pStream->avail_out) || (pState->m_dict_avail))
            break;
    }

    return ((status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
}

int mz_inflateEnd(mz_streamp pStream)
{
    if (!pStream)
        return MZ_STREAM_ERROR;
    if (pStream->state)
    {
        pStream->zfree(pStream->opaque, pStream->state);
        pStream->state = NULL;
    }
    return MZ_OK;
}
int mz_uncompress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong *pSource_len)
{
    mz_stream stream;
    int status;
    memset(&stream, 0, sizeof(stream));

    /* In case mz_ulong is 64-bits (argh I hate longs). */
    if ((mz_uint64)(*pSource_len | *pDest_len) > 0xFFFFFFFFU)
        return MZ_PARAM_ERROR;

    stream.next_in = pSource;
    stream.avail_in = (mz_uint32)*pSource_len;
    stream.next_out = pDest;
    stream.avail_out = (mz_uint32)*pDest_len;

    status = mz_inflateInit(&stream);
    if (status != MZ_OK)
        return status;

    status = mz_inflate(&stream, MZ_FINISH);
    *pSource_len = *pSource_len - stream.avail_in;
    if (status != MZ_STREAM_END)
    {
        mz_inflateEnd(&stream);
        return ((status == MZ_BUF_ERROR) && (!stream.avail_in)) ? MZ_DATA_ERROR : status;
    }
    *pDest_len = stream.total_out;

    return mz_inflateEnd(&stream);
}

int mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len)
{
    return mz_uncompress2(pDest, pDest_len, pSource, &source_len);
}

#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/

const char *mz_error(int err)
{
    static struct
    {
        int m_err;
        const char *m_pDesc;
    } s_error_descs[] =
        {
          { MZ_OK, "" }, { MZ_STREAM_END, "stream end" }, { MZ_NEED_DICT, "need dictionary" }, { MZ_ERRNO, "file error" }, { MZ_STREAM_ERROR, "stream error" }, { MZ_DATA_ERROR, "data error" }, { MZ_MEM_ERROR, "out of memory" }, { MZ_BUF_ERROR, "buf error" }, { MZ_VERSION_ERROR, "version error" }, { MZ_PARAM_ERROR, "parameter error" }
        };
    mz_uint i;
    for (i = 0; i < sizeof(s_error_descs) / sizeof(s_error_descs[0]); ++i)
        if (s_error_descs[i].m_err == err)
            return s_error_descs[i].m_pDesc;
    return NULL;
}

#endif /*MINIZ_NO_ZLIB_APIS */

#ifdef __cplusplus
}
#endif

/*
  This is free and unencumbered software released into the public domain.

  Anyone is free to copy, modify, publish, use, compile, sell, or
  distribute this software, either in source code form or as a compiled
  binary, for any purpose, commercial or non-commercial, and by any
  means.

  In jurisdictions that recognize copyright laws, the author or authors
  of this software dedicate any and all copyright interest in the
  software to the public domain. We make this dedication for the benefit
  of the public at large and to the detriment of our heirs and
  successors. We intend this dedication to be an overt act of
  relinquishment in perpetuity of all present and future rights to this
  software under copyright law.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.

  For more information, please refer to <http://unlicense.org/>
*/
/**************************************************************************
 *
 * Copyright 2013-2014 RAD Game Tools and Valve Software
 * Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 **************************************************************************/



#ifndef MINIZ_NO_DEFLATE_APIS

#ifdef __cplusplus
extern "C" {
#endif

/* ------------------- Low-level Compression (independent from all decompression API's) */

/* Purposely making these tables static for faster init and thread safety. */
static const mz_uint16 s_tdefl_len_sym[256] =
    {
      257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268, 268, 269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272, 272, 272, 272,
      273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274, 274, 274, 274, 275, 275, 275, 275, 275, 275, 275, 275, 276, 276, 276, 276, 276, 276, 276, 276,
      277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,
      279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280,
      281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,
      282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
      283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,
      284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 285
    };

static const mz_uint8 s_tdefl_len_extra[256] =
    {
      0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
      5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0
    };

static const mz_uint8 s_tdefl_small_dist_sym[512] =
    {
      0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11,
      11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13,
      13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
      14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
      16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
      16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
      16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
      17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
      17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
      17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17
    };

static const mz_uint8 s_tdefl_small_dist_extra[512] =
    {
      0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
      5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
      6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
      6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7
    };

static const mz_uint8 s_tdefl_large_dist_sym[128] =
    {
      0, 0, 18, 19, 20, 20, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
      26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
      28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
    };

static const mz_uint8 s_tdefl_large_dist_extra[128] =
    {
      0, 0, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
      13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13
    };

/* Radix sorts tdefl_sym_freq[] array by 16-bit key m_key. Returns ptr to sorted values. */
typedef struct
{
    mz_uint16 m_key, m_sym_index;
} tdefl_sym_freq;
static tdefl_sym_freq *tdefl_radix_sort_syms(mz_uint num_syms, tdefl_sym_freq *pSyms0, tdefl_sym_freq *pSyms1)
{
    mz_uint32 total_passes = 2, pass_shift, pass, i, hist[256 * 2];
    tdefl_sym_freq *pCur_syms = pSyms0, *pNew_syms = pSyms1;
    MZ_CLEAR_ARR(hist);
    for (i = 0; i < num_syms; i++)
    {
        mz_uint freq = pSyms0[i].m_key;
        hist[freq & 0xFF]++;
        hist[256 + ((freq >> 8) & 0xFF)]++;
    }
    while ((total_passes > 1) && (num_syms == hist[(total_passes - 1) * 256]))
        total_passes--;
    for (pass_shift = 0, pass = 0; pass < total_passes; pass++, pass_shift += 8)
    {
        const mz_uint32 *pHist = &hist[pass << 8];
        mz_uint offsets[256], cur_ofs = 0;
        for (i = 0; i < 256; i++)
        {
            offsets[i] = cur_ofs;
            cur_ofs += pHist[i];
        }
        for (i = 0; i < num_syms; i++)
            pNew_syms[offsets[(pCur_syms[i].m_key >> pass_shift) & 0xFF]++] = pCur_syms[i];
        {
            tdefl_sym_freq *t = pCur_syms;
            pCur_syms = pNew_syms;
            pNew_syms = t;
        }
    }
    return pCur_syms;
}

/* tdefl_calculate_minimum_redundancy() originally written by: Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996. */
static void tdefl_calculate_minimum_redundancy(tdefl_sym_freq *A, int n)
{
    int root, leaf, next, avbl, used, dpth;
    if (n == 0)
        return;
    else if (n == 1)
    {
        A[0].m_key = 1;
        return;
    }
    A[0].m_key += A[1].m_key;
    root = 0;
    leaf = 2;
    for (next = 1; next < n - 1; next++)
    {
        if (leaf >= n || A[root].m_key < A[leaf].m_key)
        {
            A[next].m_key = A[root].m_key;
            A[root++].m_key = (mz_uint16)next;
        }
        else
            A[next].m_key = A[leaf++].m_key;
        if (leaf >= n || (root < next && A[root].m_key < A[leaf].m_key))
        {
            A[next].m_key = (mz_uint16)(A[next].m_key + A[root].m_key);
            A[root++].m_key = (mz_uint16)next;
        }
        else
            A[next].m_key = (mz_uint16)(A[next].m_key + A[leaf++].m_key);
    }
    A[n - 2].m_key = 0;
    for (next = n - 3; next >= 0; next--)
        A[next].m_key = A[A[next].m_key].m_key + 1;
    avbl = 1;
    used = dpth = 0;
    root = n - 2;
    next = n - 1;
    while (avbl > 0)
    {
        while (root >= 0 && (int)A[root].m_key == dpth)
        {
            used++;
            root--;
        }
        while (avbl > used)
        {
            A[next--].m_key = (mz_uint16)(dpth);
            avbl--;
        }
        avbl = 2 * used;
        dpth++;
        used = 0;
    }
}

/* Limits canonical Huffman code table's max code size. */
enum
{
    TDEFL_MAX_SUPPORTED_HUFF_CODESIZE = 32
};
static void tdefl_huffman_enforce_max_code_size(int *pNum_codes, int code_list_len, int max_code_size)
{
    int i;
    mz_uint32 total = 0;
    if (code_list_len <= 1)
        return;
    for (i = max_code_size + 1; i <= TDEFL_MAX_SUPPORTED_HUFF_CODESIZE; i++)
        pNum_codes[max_code_size] += pNum_codes[i];
    for (i = max_code_size; i > 0; i--)
        total += (((mz_uint32)pNum_codes[i]) << (max_code_size - i));
    while (total != (1UL << max_code_size))
    {
        pNum_codes[max_code_size]--;
        for (i = max_code_size - 1; i > 0; i--)
            if (pNum_codes[i])
            {
                pNum_codes[i]--;
                pNum_codes[i + 1] += 2;
                break;
            }
        total--;
    }
}

static void tdefl_optimize_huffman_table(tdefl_compressor *d, int table_num, int table_len, int code_size_limit, int static_table)
{
    int i, j, l, num_codes[1 + TDEFL_MAX_SUPPORTED_HUFF_CODESIZE];
    mz_uint next_code[TDEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1];
    MZ_CLEAR_ARR(num_codes);
    if (static_table)
    {
        for (i = 0; i < table_len; i++)
            num_codes[d->m_huff_code_sizes[table_num][i]]++;
    }
    else
    {
        tdefl_sym_freq syms0[TDEFL_MAX_HUFF_SYMBOLS], syms1[TDEFL_MAX_HUFF_SYMBOLS], *pSyms;
        int num_used_syms = 0;
        const mz_uint16 *pSym_count = &d->m_huff_count[table_num][0];
        for (i = 0; i < table_len; i++)
            if (pSym_count[i])
            {
                syms0[num_used_syms].m_key = (mz_uint16)pSym_count[i];
                syms0[num_used_syms++].m_sym_index = (mz_uint16)i;
            }

        pSyms = tdefl_radix_sort_syms(num_used_syms, syms0, syms1);
        tdefl_calculate_minimum_redundancy(pSyms, num_used_syms);

        for (i = 0; i < num_used_syms; i++)
            num_codes[pSyms[i].m_key]++;

        tdefl_huffman_enforce_max_code_size(num_codes, num_used_syms, code_size_limit);

        MZ_CLEAR_ARR(d->m_huff_code_sizes[table_num]);
        MZ_CLEAR_ARR(d->m_huff_codes[table_num]);
        for (i = 1, j = num_used_syms; i <= code_size_limit; i++)
            for (l = num_codes[i]; l > 0; l--)
                d->m_huff_code_sizes[table_num][pSyms[--j].m_sym_index] = (mz_uint8)(i);
    }

    next_code[1] = 0;
    for (j = 0, i = 2; i <= code_size_limit; i++)
        next_code[i] = j = ((j + num_codes[i - 1]) << 1);

    for (i = 0; i < table_len; i++)
    {
        mz_uint rev_code = 0, code, code_size;
        if ((code_size = d->m_huff_code_sizes[table_num][i]) == 0)
            continue;
        code = next_code[code_size]++;
        for (l = code_size; l > 0; l--, code >>= 1)
            rev_code = (rev_code << 1) | (code & 1);
        d->m_huff_codes[table_num][i] = (mz_uint16)rev_code;
    }
}

#define TDEFL_PUT_BITS(b, l)                                       \
    do                                                             \
    {                                                              \
        mz_uint bits = b;                                          \
        mz_uint len = l;                                           \
        MZ_ASSERT(bits <= ((1U << len) - 1U));                     \
        d->m_bit_buffer |= (bits << d->m_bits_in);                 \
        d->m_bits_in += len;                                       \
        while (d->m_bits_in >= 8)                                  \
        {                                                          \
            if (d->m_pOutput_buf < d->m_pOutput_buf_end)           \
                *d->m_pOutput_buf++ = (mz_uint8)(d->m_bit_buffer); \
            d->m_bit_buffer >>= 8;                                 \
            d->m_bits_in -= 8;                                     \
        }                                                          \
    }                                                              \
    MZ_MACRO_END

#define TDEFL_RLE_PREV_CODE_SIZE()                                                                                       \
    {                                                                                                                    \
        if (rle_repeat_count)                                                                                            \
        {                                                                                                                \
            if (rle_repeat_count < 3)                                                                                    \
            {                                                                                                            \
                d->m_huff_count[2][prev_code_size] = (mz_uint16)(d->m_huff_count[2][prev_code_size] + rle_repeat_count); \
                while (rle_repeat_count--)                                                                               \
                    packed_code_sizes[num_packed_code_sizes++] = prev_code_size;                                         \
            }                                                                                                            \
            else                                                                                                         \
            {                                                                                                            \
                d->m_huff_count[2][16] = (mz_uint16)(d->m_huff_count[2][16] + 1);                                        \
                packed_code_sizes[num_packed_code_sizes++] = 16;                                                         \
                packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_repeat_count - 3);                           \
            }                                                                                                            \
            rle_repeat_count = 0;                                                                                        \
        }                                                                                                                \
    }

#define TDEFL_RLE_ZERO_CODE_SIZE()                                                         \
    {                                                                                      \
        if (rle_z_count)                                                                   \
        {                                                                                  \
            if (rle_z_count < 3)                                                           \
            {                                                                              \
                d->m_huff_count[2][0] = (mz_uint16)(d->m_huff_count[2][0] + rle_z_count);  \
                while (rle_z_count--)                                                      \
                    packed_code_sizes[num_packed_code_sizes++] = 0;                        \
            }                                                                              \
            else if (rle_z_count <= 10)                                                    \
            {                                                                              \
                d->m_huff_count[2][17] = (mz_uint16)(d->m_huff_count[2][17] + 1);          \
                packed_code_sizes[num_packed_code_sizes++] = 17;                           \
                packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 3);  \
            }                                                                              \
            else                                                                           \
            {                                                                              \
                d->m_huff_count[2][18] = (mz_uint16)(d->m_huff_count[2][18] + 1);          \
                packed_code_sizes[num_packed_code_sizes++] = 18;                           \
                packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 11); \
            }                                                                              \
            rle_z_count = 0;                                                               \
        }                                                                                  \
    }

static const mz_uint8 s_tdefl_packed_code_size_syms_swizzle[] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };

static void tdefl_start_dynamic_block(tdefl_compressor *d)
{
    int num_lit_codes, num_dist_codes, num_bit_lengths;
    mz_uint i, total_code_sizes_to_pack, num_packed_code_sizes, rle_z_count, rle_repeat_count, packed_code_sizes_index;
    mz_uint8 code_sizes_to_pack[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], packed_code_sizes[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], prev_code_size = 0xFF;

    d->m_huff_count[0][256] = 1;

    tdefl_optimize_huffman_table(d, 0, TDEFL_MAX_HUFF_SYMBOLS_0, 15, MZ_FALSE);
    tdefl_optimize_huffman_table(d, 1, TDEFL_MAX_HUFF_SYMBOLS_1, 15, MZ_FALSE);

    for (num_lit_codes = 286; num_lit_codes > 257; num_lit_codes--)
        if (d->m_huff_code_sizes[0][num_lit_codes - 1])
            break;
    for (num_dist_codes = 30; num_dist_codes > 1; num_dist_codes--)
        if (d->m_huff_code_sizes[1][num_dist_codes - 1])
            break;

    memcpy(code_sizes_to_pack, &d->m_huff_code_sizes[0][0], num_lit_codes);
    memcpy(code_sizes_to_pack + num_lit_codes, &d->m_huff_code_sizes[1][0], num_dist_codes);
    total_code_sizes_to_pack = num_lit_codes + num_dist_codes;
    num_packed_code_sizes = 0;
    rle_z_count = 0;
    rle_repeat_count = 0;

    memset(&d->m_huff_count[2][0], 0, sizeof(d->m_huff_count[2][0]) * TDEFL_MAX_HUFF_SYMBOLS_2);
    for (i = 0; i < total_code_sizes_to_pack; i++)
    {
        mz_uint8 code_size = code_sizes_to_pack[i];
        if (!code_size)
        {
            TDEFL_RLE_PREV_CODE_SIZE();
            if (++rle_z_count == 138)
            {
                TDEFL_RLE_ZERO_CODE_SIZE();
            }
        }
        else
        {
            TDEFL_RLE_ZERO_CODE_SIZE();
            if (code_size != prev_code_size)
            {
                TDEFL_RLE_PREV_CODE_SIZE();
                d->m_huff_count[2][code_size] = (mz_uint16)(d->m_huff_count[2][code_size] + 1);
                packed_code_sizes[num_packed_code_sizes++] = code_size;
            }
            else if (++rle_repeat_count == 6)
            {
                TDEFL_RLE_PREV_CODE_SIZE();
            }
        }
        prev_code_size = code_size;
    }
    if (rle_repeat_count)
    {
        TDEFL_RLE_PREV_CODE_SIZE();
    }
    else
    {
        TDEFL_RLE_ZERO_CODE_SIZE();
    }

    tdefl_optimize_huffman_table(d, 2, TDEFL_MAX_HUFF_SYMBOLS_2, 7, MZ_FALSE);

    TDEFL_PUT_BITS(2, 2);

    TDEFL_PUT_BITS(num_lit_codes - 257, 5);
    TDEFL_PUT_BITS(num_dist_codes - 1, 5);

    for (num_bit_lengths = 18; num_bit_lengths >= 0; num_bit_lengths--)
        if (d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[num_bit_lengths]])
            break;
    num_bit_lengths = MZ_MAX(4, (num_bit_lengths + 1));
    TDEFL_PUT_BITS(num_bit_lengths - 4, 4);
    for (i = 0; (int)i < num_bit_lengths; i++)
        TDEFL_PUT_BITS(d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[i]], 3);

    for (packed_code_sizes_index = 0; packed_code_sizes_index < num_packed_code_sizes;)
    {
        mz_uint code = packed_code_sizes[packed_code_sizes_index++];
        MZ_ASSERT(code < TDEFL_MAX_HUFF_SYMBOLS_2);
        TDEFL_PUT_BITS(d->m_huff_codes[2][code], d->m_huff_code_sizes[2][code]);
        if (code >= 16)
            TDEFL_PUT_BITS(packed_code_sizes[packed_code_sizes_index++], "\02\03\07"[code - 16]);
    }
}

static void tdefl_start_static_block(tdefl_compressor *d)
{
    mz_uint i;
    mz_uint8 *p = &d->m_huff_code_sizes[0][0];

    for (i = 0; i <= 143; ++i)
        *p++ = 8;
    for (; i <= 255; ++i)
        *p++ = 9;
    for (; i <= 279; ++i)
        *p++ = 7;
    for (; i <= 287; ++i)
        *p++ = 8;

    memset(d->m_huff_code_sizes[1], 5, 32);

    tdefl_optimize_huffman_table(d, 0, 288, 15, MZ_TRUE);
    tdefl_optimize_huffman_table(d, 1, 32, 15, MZ_TRUE);

    TDEFL_PUT_BITS(1, 2);
}

static const mz_uint mz_bitmasks[17] = { 0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF };

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS
static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)
{
    mz_uint flags;
    mz_uint8 *pLZ_codes;
    mz_uint8 *pOutput_buf = d->m_pOutput_buf;
    mz_uint8 *pLZ_code_buf_end = d->m_pLZ_code_buf;
    mz_uint64 bit_buffer = d->m_bit_buffer;
    mz_uint bits_in = d->m_bits_in;

#define TDEFL_PUT_BITS_FAST(b, l)                    \
    {                                                \
        bit_buffer |= (((mz_uint64)(b)) << bits_in); \
        bits_in += (l);                              \
    }

    flags = 1;
    for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < pLZ_code_buf_end; flags >>= 1)
    {
        if (flags == 1)
            flags = *pLZ_codes++ | 0x100;

        if (flags & 1)
        {
            mz_uint s0, s1, n0, n1, sym, num_extra_bits;
            mz_uint match_len = pLZ_codes[0];
            mz_uint match_dist = (pLZ_codes[1] | (pLZ_codes[2] << 8));
            pLZ_codes += 3;

            MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
            TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
            TDEFL_PUT_BITS_FAST(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);

            /* This sequence coaxes MSVC into using cmov's vs. jmp's. */
            s0 = s_tdefl_small_dist_sym[match_dist & 511];
            n0 = s_tdefl_small_dist_extra[match_dist & 511];
            s1 = s_tdefl_large_dist_sym[match_dist >> 8];
            n1 = s_tdefl_large_dist_extra[match_dist >> 8];
            sym = (match_dist < 512) ? s0 : s1;
            num_extra_bits = (match_dist < 512) ? n0 : n1;

            MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
            TDEFL_PUT_BITS_FAST(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);
            TDEFL_PUT_BITS_FAST(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);
        }
        else
        {
            mz_uint lit = *pLZ_codes++;
            MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
            TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);

            if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end))
            {
                flags >>= 1;
                lit = *pLZ_codes++;
                MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
                TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);

                if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end))
                {
                    flags >>= 1;
                    lit = *pLZ_codes++;
                    MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
                    TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
                }
            }
        }

        if (pOutput_buf >= d->m_pOutput_buf_end)
            return MZ_FALSE;

        memcpy(pOutput_buf, &bit_buffer, sizeof(mz_uint64));
        pOutput_buf += (bits_in >> 3);
        bit_buffer >>= (bits_in & ~7);
        bits_in &= 7;
    }

#undef TDEFL_PUT_BITS_FAST

    d->m_pOutput_buf = pOutput_buf;
    d->m_bits_in = 0;
    d->m_bit_buffer = 0;

    while (bits_in)
    {
        mz_uint32 n = MZ_MIN(bits_in, 16);
        TDEFL_PUT_BITS((mz_uint)bit_buffer & mz_bitmasks[n], n);
        bit_buffer >>= n;
        bits_in -= n;
    }

    TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);

    return (d->m_pOutput_buf < d->m_pOutput_buf_end);
}
#else
static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)
{
    mz_uint flags;
    mz_uint8 *pLZ_codes;

    flags = 1;
    for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < d->m_pLZ_code_buf; flags >>= 1)
    {
        if (flags == 1)
            flags = *pLZ_codes++ | 0x100;
        if (flags & 1)
        {
            mz_uint sym, num_extra_bits;
            mz_uint match_len = pLZ_codes[0], match_dist = (pLZ_codes[1] | (pLZ_codes[2] << 8));
            pLZ_codes += 3;

            MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
            TDEFL_PUT_BITS(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
            TDEFL_PUT_BITS(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);

            if (match_dist < 512)
            {
                sym = s_tdefl_small_dist_sym[match_dist];
                num_extra_bits = s_tdefl_small_dist_extra[match_dist];
            }
            else
            {
                sym = s_tdefl_large_dist_sym[match_dist >> 8];
                num_extra_bits = s_tdefl_large_dist_extra[match_dist >> 8];
            }
            MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
            TDEFL_PUT_BITS(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);
            TDEFL_PUT_BITS(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);
        }
        else
        {
            mz_uint lit = *pLZ_codes++;
            MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
            TDEFL_PUT_BITS(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
        }
    }

    TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);

    return (d->m_pOutput_buf < d->m_pOutput_buf_end);
}
#endif /* MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS */

static mz_bool tdefl_compress_block(tdefl_compressor *d, mz_bool static_block)
{
    if (static_block)
        tdefl_start_static_block(d);
    else
        tdefl_start_dynamic_block(d);
    return tdefl_compress_lz_codes(d);
}

static const mz_uint s_tdefl_num_probes[11] = { 0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500 };

static int tdefl_flush_block(tdefl_compressor *d, int flush)
{
    mz_uint saved_bit_buf, saved_bits_in;
    mz_uint8 *pSaved_output_buf;
    mz_bool comp_block_succeeded = MZ_FALSE;
    int n, use_raw_block = ((d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS) != 0) && (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size;
    mz_uint8 *pOutput_buf_start = ((d->m_pPut_buf_func == NULL) && ((*d->m_pOut_buf_size - d->m_out_buf_ofs) >= TDEFL_OUT_BUF_SIZE)) ? ((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs) : d->m_output_buf;

    d->m_pOutput_buf = pOutput_buf_start;
    d->m_pOutput_buf_end = d->m_pOutput_buf + TDEFL_OUT_BUF_SIZE - 16;

    MZ_ASSERT(!d->m_output_flush_remaining);
    d->m_output_flush_ofs = 0;
    d->m_output_flush_remaining = 0;

    *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> d->m_num_flags_left);
    d->m_pLZ_code_buf -= (d->m_num_flags_left == 8);

    if ((d->m_flags & TDEFL_WRITE_ZLIB_HEADER) && (!d->m_block_index))
    {
        const mz_uint8 cmf = 0x78;
        mz_uint8 flg, flevel = 3;
        mz_uint header, i, mz_un = sizeof(s_tdefl_num_probes) / sizeof(mz_uint);

        /* Determine compression level by reversing the process in tdefl_create_comp_flags_from_zip_params() */
        for (i = 0; i < mz_un; i++)
            if (s_tdefl_num_probes[i] == (d->m_flags & 0xFFF)) break;

        if (i < 2)
            flevel = 0;
        else if (i < 6)
            flevel = 1;
        else if (i == 6)
            flevel = 2;

        header = cmf << 8 | (flevel << 6);
        header += 31 - (header % 31);
        flg = header & 0xFF;

        TDEFL_PUT_BITS(cmf, 8);
        TDEFL_PUT_BITS(flg, 8);
    }

    TDEFL_PUT_BITS(flush == TDEFL_FINISH, 1);

    pSaved_output_buf = d->m_pOutput_buf;
    saved_bit_buf = d->m_bit_buffer;
    saved_bits_in = d->m_bits_in;

    if (!use_raw_block)
        comp_block_succeeded = tdefl_compress_block(d, (d->m_flags & TDEFL_FORCE_ALL_STATIC_BLOCKS) || (d->m_total_lz_bytes < 48));

    /* If the block gets expanded, forget the current contents of the output buffer and send a raw block instead. */
    if (((use_raw_block) || ((d->m_total_lz_bytes) && ((d->m_pOutput_buf - pSaved_output_buf + 1U) >= d->m_total_lz_bytes))) &&
        ((d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size))
    {
        mz_uint i;
        d->m_pOutput_buf = pSaved_output_buf;
        d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
        TDEFL_PUT_BITS(0, 2);
        if (d->m_bits_in)
        {
            TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
        }
        for (i = 2; i; --i, d->m_total_lz_bytes ^= 0xFFFF)
        {
            TDEFL_PUT_BITS(d->m_total_lz_bytes & 0xFFFF, 16);
        }
        for (i = 0; i < d->m_total_lz_bytes; ++i)
        {
            TDEFL_PUT_BITS(d->m_dict[(d->m_lz_code_buf_dict_pos + i) & TDEFL_LZ_DICT_SIZE_MASK], 8);
        }
    }
    /* Check for the extremely unlikely (if not impossible) case of the compressed block not fitting into the output buffer when using dynamic codes. */
    else if (!comp_block_succeeded)
    {
        d->m_pOutput_buf = pSaved_output_buf;
        d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
        tdefl_compress_block(d, MZ_TRUE);
    }

    if (flush)
    {
        if (flush == TDEFL_FINISH)
        {
            if (d->m_bits_in)
            {
                TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
            }
            if (d->m_flags & TDEFL_WRITE_ZLIB_HEADER)
            {
                mz_uint i, a = d->m_adler32;
                for (i = 0; i < 4; i++)
                {
                    TDEFL_PUT_BITS((a >> 24) & 0xFF, 8);
                    a <<= 8;
                }
            }
        }
        else
        {
            mz_uint i, z = 0;
            TDEFL_PUT_BITS(0, 3);
            if (d->m_bits_in)
            {
                TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
            }
            for (i = 2; i; --i, z ^= 0xFFFF)
            {
                TDEFL_PUT_BITS(z & 0xFFFF, 16);
            }
        }
    }

    MZ_ASSERT(d->m_pOutput_buf < d->m_pOutput_buf_end);

    memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
    memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);

    d->m_pLZ_code_buf = d->m_lz_code_buf + 1;
    d->m_pLZ_flags = d->m_lz_code_buf;
    d->m_num_flags_left = 8;
    d->m_lz_code_buf_dict_pos += d->m_total_lz_bytes;
    d->m_total_lz_bytes = 0;
    d->m_block_index++;

    if ((n = (int)(d->m_pOutput_buf - pOutput_buf_start)) != 0)
    {
        if (d->m_pPut_buf_func)
        {
            *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;
            if (!(*d->m_pPut_buf_func)(d->m_output_buf, n, d->m_pPut_buf_user))
                return (d->m_prev_return_status = TDEFL_STATUS_PUT_BUF_FAILED);
        }
        else if (pOutput_buf_start == d->m_output_buf)
        {
            int bytes_to_copy = (int)MZ_MIN((size_t)n, (size_t)(*d->m_pOut_buf_size - d->m_out_buf_ofs));
            memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf, bytes_to_copy);
            d->m_out_buf_ofs += bytes_to_copy;
            if ((n -= bytes_to_copy) != 0)
            {
                d->m_output_flush_ofs = bytes_to_copy;
                d->m_output_flush_remaining = n;
            }
        }
        else
        {
            d->m_out_buf_ofs += n;
        }
    }

    return d->m_output_flush_remaining;
}

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
#ifdef MINIZ_UNALIGNED_USE_MEMCPY
static mz_uint16 TDEFL_READ_UNALIGNED_WORD(const mz_uint8* p)
{
	mz_uint16 ret;
	memcpy(&ret, p, sizeof(mz_uint16));
	return ret;
}
static mz_uint16 TDEFL_READ_UNALIGNED_WORD2(const mz_uint16* p)
{
	mz_uint16 ret;
	memcpy(&ret, p, sizeof(mz_uint16));
	return ret;
}
#else
#define TDEFL_READ_UNALIGNED_WORD(p) *(const mz_uint16 *)(p)
#define TDEFL_READ_UNALIGNED_WORD2(p) *(const mz_uint16 *)(p)
#endif
static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)
{
    mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;
    mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
    const mz_uint16 *s = (const mz_uint16 *)(d->m_dict + pos), *p, *q;
    mz_uint16 c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]), s01 = TDEFL_READ_UNALIGNED_WORD2(s);
    MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN);
    if (max_match_len <= match_len)
        return;
    for (;;)
    {
        for (;;)
        {
            if (--num_probes_left == 0)
                return;
#define TDEFL_PROBE                                                                             \
    next_probe_pos = d->m_next[probe_pos];                                                      \
    if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist)) \
        return;                                                                                 \
    probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK;                                       \
    if (TDEFL_READ_UNALIGNED_WORD(&d->m_dict[probe_pos + match_len - 1]) == c01)                \
        break;
            TDEFL_PROBE;
            TDEFL_PROBE;
            TDEFL_PROBE;
        }
        if (!dist)
            break;
        q = (const mz_uint16 *)(d->m_dict + probe_pos);
        if (TDEFL_READ_UNALIGNED_WORD2(q) != s01)
            continue;
        p = s;
        probe_len = 32;
        do
        {
        } while ((TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) &&
                 (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (--probe_len > 0));
        if (!probe_len)
        {
            *pMatch_dist = dist;
            *pMatch_len = MZ_MIN(max_match_len, (mz_uint)TDEFL_MAX_MATCH_LEN);
            break;
        }
        else if ((probe_len = ((mz_uint)(p - s) * 2) + (mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q)) > match_len)
        {
            *pMatch_dist = dist;
            if ((*pMatch_len = match_len = MZ_MIN(max_match_len, probe_len)) == max_match_len)
                break;
            c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]);
        }
    }
}
#else
static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)
{
    mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;
    mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
    const mz_uint8 *s = d->m_dict + pos, *p, *q;
    mz_uint8 c0 = d->m_dict[pos + match_len], c1 = d->m_dict[pos + match_len - 1];
    MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN);
    if (max_match_len <= match_len)
        return;
    for (;;)
    {
        for (;;)
        {
            if (--num_probes_left == 0)
                return;
#define TDEFL_PROBE                                                                               \
    next_probe_pos = d->m_next[probe_pos];                                                        \
    if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist))   \
        return;                                                                                   \
    probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK;                                         \
    if ((d->m_dict[probe_pos + match_len] == c0) && (d->m_dict[probe_pos + match_len - 1] == c1)) \
        break;
            TDEFL_PROBE;
            TDEFL_PROBE;
            TDEFL_PROBE;
        }
        if (!dist)
            break;
        p = s;
        q = d->m_dict + probe_pos;
        for (probe_len = 0; probe_len < max_match_len; probe_len++)
            if (*p++ != *q++)
                break;
        if (probe_len > match_len)
        {
            *pMatch_dist = dist;
            if ((*pMatch_len = match_len = probe_len) == max_match_len)
                return;
            c0 = d->m_dict[pos + match_len];
            c1 = d->m_dict[pos + match_len - 1];
        }
    }
}
#endif /* #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES */

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
#ifdef MINIZ_UNALIGNED_USE_MEMCPY
static mz_uint32 TDEFL_READ_UNALIGNED_WORD32(const mz_uint8* p)
{
	mz_uint32 ret;
	memcpy(&ret, p, sizeof(mz_uint32));
	return ret;
}
#else
#define TDEFL_READ_UNALIGNED_WORD32(p) *(const mz_uint32 *)(p)
#endif
static mz_bool tdefl_compress_fast(tdefl_compressor *d)
{
    /* Faster, minimally featured LZRW1-style match+parse loop with better register utilization. Intended for applications where raw throughput is valued more highly than ratio. */
    mz_uint lookahead_pos = d->m_lookahead_pos, lookahead_size = d->m_lookahead_size, dict_size = d->m_dict_size, total_lz_bytes = d->m_total_lz_bytes, num_flags_left = d->m_num_flags_left;
    mz_uint8 *pLZ_code_buf = d->m_pLZ_code_buf, *pLZ_flags = d->m_pLZ_flags;
    mz_uint cur_pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;

    while ((d->m_src_buf_left) || ((d->m_flush) && (lookahead_size)))
    {
        const mz_uint TDEFL_COMP_FAST_LOOKAHEAD_SIZE = 4096;
        mz_uint dst_pos = (lookahead_pos + lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
        mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(d->m_src_buf_left, TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);
        d->m_src_buf_left -= num_bytes_to_process;
        lookahead_size += num_bytes_to_process;

        while (num_bytes_to_process)
        {
            mz_uint32 n = MZ_MIN(TDEFL_LZ_DICT_SIZE - dst_pos, num_bytes_to_process);
            memcpy(d->m_dict + dst_pos, d->m_pSrc, n);
            if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
                memcpy(d->m_dict + TDEFL_LZ_DICT_SIZE + dst_pos, d->m_pSrc, MZ_MIN(n, (TDEFL_MAX_MATCH_LEN - 1) - dst_pos));
            d->m_pSrc += n;
            dst_pos = (dst_pos + n) & TDEFL_LZ_DICT_SIZE_MASK;
            num_bytes_to_process -= n;
        }

        dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - lookahead_size, dict_size);
        if ((!d->m_flush) && (lookahead_size < TDEFL_COMP_FAST_LOOKAHEAD_SIZE))
            break;

        while (lookahead_size >= 4)
        {
            mz_uint cur_match_dist, cur_match_len = 1;
            mz_uint8 *pCur_dict = d->m_dict + cur_pos;
            mz_uint first_trigram = TDEFL_READ_UNALIGNED_WORD32(pCur_dict) & 0xFFFFFF;
            mz_uint hash = (first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8)))) & TDEFL_LEVEL1_HASH_SIZE_MASK;
            mz_uint probe_pos = d->m_hash[hash];
            d->m_hash[hash] = (mz_uint16)lookahead_pos;

            if (((cur_match_dist = (mz_uint16)(lookahead_pos - probe_pos)) <= dict_size) && ((TDEFL_READ_UNALIGNED_WORD32(d->m_dict + (probe_pos &= TDEFL_LZ_DICT_SIZE_MASK)) & 0xFFFFFF) == first_trigram))
            {
                const mz_uint16 *p = (const mz_uint16 *)pCur_dict;
                const mz_uint16 *q = (const mz_uint16 *)(d->m_dict + probe_pos);
                mz_uint32 probe_len = 32;
                do
                {
                } while ((TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) &&
                         (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (--probe_len > 0));
                cur_match_len = ((mz_uint)(p - (const mz_uint16 *)pCur_dict) * 2) + (mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q);
                if (!probe_len)
                    cur_match_len = cur_match_dist ? TDEFL_MAX_MATCH_LEN : 0;

                if ((cur_match_len < TDEFL_MIN_MATCH_LEN) || ((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U * 1024U)))
                {
                    cur_match_len = 1;
                    *pLZ_code_buf++ = (mz_uint8)first_trigram;
                    *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
                    d->m_huff_count[0][(mz_uint8)first_trigram]++;
                }
                else
                {
                    mz_uint32 s0, s1;
                    cur_match_len = MZ_MIN(cur_match_len, lookahead_size);

                    MZ_ASSERT((cur_match_len >= TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 1) && (cur_match_dist <= TDEFL_LZ_DICT_SIZE));

                    cur_match_dist--;

                    pLZ_code_buf[0] = (mz_uint8)(cur_match_len - TDEFL_MIN_MATCH_LEN);
#ifdef MINIZ_UNALIGNED_USE_MEMCPY
					memcpy(&pLZ_code_buf[1], &cur_match_dist, sizeof(cur_match_dist));
#else
                    *(mz_uint16 *)(&pLZ_code_buf[1]) = (mz_uint16)cur_match_dist;
#endif
                    pLZ_code_buf += 3;
                    *pLZ_flags = (mz_uint8)((*pLZ_flags >> 1) | 0x80);

                    s0 = s_tdefl_small_dist_sym[cur_match_dist & 511];
                    s1 = s_tdefl_large_dist_sym[cur_match_dist >> 8];
                    d->m_huff_count[1][(cur_match_dist < 512) ? s0 : s1]++;

                    d->m_huff_count[0][s_tdefl_len_sym[cur_match_len - TDEFL_MIN_MATCH_LEN]]++;
                }
            }
            else
            {
                *pLZ_code_buf++ = (mz_uint8)first_trigram;
                *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
                d->m_huff_count[0][(mz_uint8)first_trigram]++;
            }

            if (--num_flags_left == 0)
            {
                num_flags_left = 8;
                pLZ_flags = pLZ_code_buf++;
            }

            total_lz_bytes += cur_match_len;
            lookahead_pos += cur_match_len;
            dict_size = MZ_MIN(dict_size + cur_match_len, (mz_uint)TDEFL_LZ_DICT_SIZE);
            cur_pos = (cur_pos + cur_match_len) & TDEFL_LZ_DICT_SIZE_MASK;
            MZ_ASSERT(lookahead_size >= cur_match_len);
            lookahead_size -= cur_match_len;

            if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])
            {
                int n;
                d->m_lookahead_pos = lookahead_pos;
                d->m_lookahead_size = lookahead_size;
                d->m_dict_size = dict_size;
                d->m_total_lz_bytes = total_lz_bytes;
                d->m_pLZ_code_buf = pLZ_code_buf;
                d->m_pLZ_flags = pLZ_flags;
                d->m_num_flags_left = num_flags_left;
                if ((n = tdefl_flush_block(d, 0)) != 0)
                    return (n < 0) ? MZ_FALSE : MZ_TRUE;
                total_lz_bytes = d->m_total_lz_bytes;
                pLZ_code_buf = d->m_pLZ_code_buf;
                pLZ_flags = d->m_pLZ_flags;
                num_flags_left = d->m_num_flags_left;
            }
        }

        while (lookahead_size)
        {
            mz_uint8 lit = d->m_dict[cur_pos];

            total_lz_bytes++;
            *pLZ_code_buf++ = lit;
            *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
            if (--num_flags_left == 0)
            {
                num_flags_left = 8;
                pLZ_flags = pLZ_code_buf++;
            }

            d->m_huff_count[0][lit]++;

            lookahead_pos++;
            dict_size = MZ_MIN(dict_size + 1, (mz_uint)TDEFL_LZ_DICT_SIZE);
            cur_pos = (cur_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
            lookahead_size--;

            if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])
            {
                int n;
                d->m_lookahead_pos = lookahead_pos;
                d->m_lookahead_size = lookahead_size;
                d->m_dict_size = dict_size;
                d->m_total_lz_bytes = total_lz_bytes;
                d->m_pLZ_code_buf = pLZ_code_buf;
                d->m_pLZ_flags = pLZ_flags;
                d->m_num_flags_left = num_flags_left;
                if ((n = tdefl_flush_block(d, 0)) != 0)
                    return (n < 0) ? MZ_FALSE : MZ_TRUE;
                total_lz_bytes = d->m_total_lz_bytes;
                pLZ_code_buf = d->m_pLZ_code_buf;
                pLZ_flags = d->m_pLZ_flags;
                num_flags_left = d->m_num_flags_left;
            }
        }
    }

    d->m_lookahead_pos = lookahead_pos;
    d->m_lookahead_size = lookahead_size;
    d->m_dict_size = dict_size;
    d->m_total_lz_bytes = total_lz_bytes;
    d->m_pLZ_code_buf = pLZ_code_buf;
    d->m_pLZ_flags = pLZ_flags;
    d->m_num_flags_left = num_flags_left;
    return MZ_TRUE;
}
#endif /* MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN */

static MZ_FORCEINLINE void tdefl_record_literal(tdefl_compressor *d, mz_uint8 lit)
{
    d->m_total_lz_bytes++;
    *d->m_pLZ_code_buf++ = lit;
    *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> 1);
    if (--d->m_num_flags_left == 0)
    {
        d->m_num_flags_left = 8;
        d->m_pLZ_flags = d->m_pLZ_code_buf++;
    }
    d->m_huff_count[0][lit]++;
}

static MZ_FORCEINLINE void tdefl_record_match(tdefl_compressor *d, mz_uint match_len, mz_uint match_dist)
{
    mz_uint32 s0, s1;

    MZ_ASSERT((match_len >= TDEFL_MIN_MATCH_LEN) && (match_dist >= 1) && (match_dist <= TDEFL_LZ_DICT_SIZE));

    d->m_total_lz_bytes += match_len;

    d->m_pLZ_code_buf[0] = (mz_uint8)(match_len - TDEFL_MIN_MATCH_LEN);

    match_dist -= 1;
    d->m_pLZ_code_buf[1] = (mz_uint8)(match_dist & 0xFF);
    d->m_pLZ_code_buf[2] = (mz_uint8)(match_dist >> 8);
    d->m_pLZ_code_buf += 3;

    *d->m_pLZ_flags = (mz_uint8)((*d->m_pLZ_flags >> 1) | 0x80);
    if (--d->m_num_flags_left == 0)
    {
        d->m_num_flags_left = 8;
        d->m_pLZ_flags = d->m_pLZ_code_buf++;
    }

    s0 = s_tdefl_small_dist_sym[match_dist & 511];
    s1 = s_tdefl_large_dist_sym[(match_dist >> 8) & 127];
    d->m_huff_count[1][(match_dist < 512) ? s0 : s1]++;
    d->m_huff_count[0][s_tdefl_len_sym[match_len - TDEFL_MIN_MATCH_LEN]]++;
}

static mz_bool tdefl_compress_normal(tdefl_compressor *d)
{
    const mz_uint8 *pSrc = d->m_pSrc;
    size_t src_buf_left = d->m_src_buf_left;
    tdefl_flush flush = d->m_flush;

    while ((src_buf_left) || ((flush) && (d->m_lookahead_size)))
    {
        mz_uint len_to_move, cur_match_dist, cur_match_len, cur_pos;
        /* Update dictionary and hash chains. Keeps the lookahead size equal to TDEFL_MAX_MATCH_LEN. */
        if ((d->m_lookahead_size + d->m_dict_size) >= (TDEFL_MIN_MATCH_LEN - 1))
        {
            mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK, ins_pos = d->m_lookahead_pos + d->m_lookahead_size - 2;
            mz_uint hash = (d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK];
            mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(src_buf_left, TDEFL_MAX_MATCH_LEN - d->m_lookahead_size);
            const mz_uint8 *pSrc_end = pSrc ? pSrc + num_bytes_to_process : NULL;
            src_buf_left -= num_bytes_to_process;
            d->m_lookahead_size += num_bytes_to_process;
            while (pSrc != pSrc_end)
            {
                mz_uint8 c = *pSrc++;
                d->m_dict[dst_pos] = c;
                if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
                    d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
                hash = ((hash << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);
                d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];
                d->m_hash[hash] = (mz_uint16)(ins_pos);
                dst_pos = (dst_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
                ins_pos++;
            }
        }
        else
        {
            while ((src_buf_left) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))
            {
                mz_uint8 c = *pSrc++;
                mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
                src_buf_left--;
                d->m_dict[dst_pos] = c;
                if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
                    d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
                if ((++d->m_lookahead_size + d->m_dict_size) >= TDEFL_MIN_MATCH_LEN)
                {
                    mz_uint ins_pos = d->m_lookahead_pos + (d->m_lookahead_size - 1) - 2;
                    mz_uint hash = ((d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << (TDEFL_LZ_HASH_SHIFT * 2)) ^ (d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);
                    d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];
                    d->m_hash[hash] = (mz_uint16)(ins_pos);
                }
            }
        }
        d->m_dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - d->m_lookahead_size, d->m_dict_size);
        if ((!flush) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))
            break;

        /* Simple lazy/greedy parsing state machine. */
        len_to_move = 1;
        cur_match_dist = 0;
        cur_match_len = d->m_saved_match_len ? d->m_saved_match_len : (TDEFL_MIN_MATCH_LEN - 1);
        cur_pos = d->m_lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;
        if (d->m_flags & (TDEFL_RLE_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS))
        {
            if ((d->m_dict_size) && (!(d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS)))
            {
                mz_uint8 c = d->m_dict[(cur_pos - 1) & TDEFL_LZ_DICT_SIZE_MASK];
                cur_match_len = 0;
                while (cur_match_len < d->m_lookahead_size)
                {
                    if (d->m_dict[cur_pos + cur_match_len] != c)
                        break;
                    cur_match_len++;
                }
                if (cur_match_len < TDEFL_MIN_MATCH_LEN)
                    cur_match_len = 0;
                else
                    cur_match_dist = 1;
            }
        }
        else
        {
            tdefl_find_match(d, d->m_lookahead_pos, d->m_dict_size, d->m_lookahead_size, &cur_match_dist, &cur_match_len);
        }
        if (((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U * 1024U)) || (cur_pos == cur_match_dist) || ((d->m_flags & TDEFL_FILTER_MATCHES) && (cur_match_len <= 5)))
        {
            cur_match_dist = cur_match_len = 0;
        }
        if (d->m_saved_match_len)
        {
            if (cur_match_len > d->m_saved_match_len)
            {
                tdefl_record_literal(d, (mz_uint8)d->m_saved_lit);
                if (cur_match_len >= 128)
                {
                    tdefl_record_match(d, cur_match_len, cur_match_dist);
                    d->m_saved_match_len = 0;
                    len_to_move = cur_match_len;
                }
                else
                {
                    d->m_saved_lit = d->m_dict[cur_pos];
                    d->m_saved_match_dist = cur_match_dist;
                    d->m_saved_match_len = cur_match_len;
                }
            }
            else
            {
                tdefl_record_match(d, d->m_saved_match_len, d->m_saved_match_dist);
                len_to_move = d->m_saved_match_len - 1;
                d->m_saved_match_len = 0;
            }
        }
        else if (!cur_match_dist)
            tdefl_record_literal(d, d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)]);
        else if ((d->m_greedy_parsing) || (d->m_flags & TDEFL_RLE_MATCHES) || (cur_match_len >= 128))
        {
            tdefl_record_match(d, cur_match_len, cur_match_dist);
            len_to_move = cur_match_len;
        }
        else
        {
            d->m_saved_lit = d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)];
            d->m_saved_match_dist = cur_match_dist;
            d->m_saved_match_len = cur_match_len;
        }
        /* Move the lookahead forward by len_to_move bytes. */
        d->m_lookahead_pos += len_to_move;
        MZ_ASSERT(d->m_lookahead_size >= len_to_move);
        d->m_lookahead_size -= len_to_move;
        d->m_dict_size = MZ_MIN(d->m_dict_size + len_to_move, (mz_uint)TDEFL_LZ_DICT_SIZE);
        /* Check if it's time to flush the current LZ codes to the internal output buffer. */
        if ((d->m_pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) ||
            ((d->m_total_lz_bytes > 31 * 1024) && (((((mz_uint)(d->m_pLZ_code_buf - d->m_lz_code_buf) * 115) >> 7) >= d->m_total_lz_bytes) || (d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS))))
        {
            int n;
            d->m_pSrc = pSrc;
            d->m_src_buf_left = src_buf_left;
            if ((n = tdefl_flush_block(d, 0)) != 0)
                return (n < 0) ? MZ_FALSE : MZ_TRUE;
        }
    }

    d->m_pSrc = pSrc;
    d->m_src_buf_left = src_buf_left;
    return MZ_TRUE;
}

static tdefl_status tdefl_flush_output_buffer(tdefl_compressor *d)
{
    if (d->m_pIn_buf_size)
    {
        *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;
    }

    if (d->m_pOut_buf_size)
    {
        size_t n = MZ_MIN(*d->m_pOut_buf_size - d->m_out_buf_ofs, d->m_output_flush_remaining);
        memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf + d->m_output_flush_ofs, n);
        d->m_output_flush_ofs += (mz_uint)n;
        d->m_output_flush_remaining -= (mz_uint)n;
        d->m_out_buf_ofs += n;

        *d->m_pOut_buf_size = d->m_out_buf_ofs;
    }

    return (d->m_finished && !d->m_output_flush_remaining) ? TDEFL_STATUS_DONE : TDEFL_STATUS_OKAY;
}

tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pIn_buf_size, void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush)
{
    if (!d)
    {
        if (pIn_buf_size)
            *pIn_buf_size = 0;
        if (pOut_buf_size)
            *pOut_buf_size = 0;
        return TDEFL_STATUS_BAD_PARAM;
    }

    d->m_pIn_buf = pIn_buf;
    d->m_pIn_buf_size = pIn_buf_size;
    d->m_pOut_buf = pOut_buf;
    d->m_pOut_buf_size = pOut_buf_size;
    d->m_pSrc = (const mz_uint8 *)(pIn_buf);
    d->m_src_buf_left = pIn_buf_size ? *pIn_buf_size : 0;
    d->m_out_buf_ofs = 0;
    d->m_flush = flush;

    if (((d->m_pPut_buf_func != NULL) == ((pOut_buf != NULL) || (pOut_buf_size != NULL))) || (d->m_prev_return_status != TDEFL_STATUS_OKAY) ||
        (d->m_wants_to_finish && (flush != TDEFL_FINISH)) || (pIn_buf_size && *pIn_buf_size && !pIn_buf) || (pOut_buf_size && *pOut_buf_size && !pOut_buf))
    {
        if (pIn_buf_size)
            *pIn_buf_size = 0;
        if (pOut_buf_size)
            *pOut_buf_size = 0;
        return (d->m_prev_return_status = TDEFL_STATUS_BAD_PARAM);
    }
    d->m_wants_to_finish |= (flush == TDEFL_FINISH);

    if ((d->m_output_flush_remaining) || (d->m_finished))
        return (d->m_prev_return_status = tdefl_flush_output_buffer(d));

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
    if (((d->m_flags & TDEFL_MAX_PROBES_MASK) == 1) &&
        ((d->m_flags & TDEFL_GREEDY_PARSING_FLAG) != 0) &&
        ((d->m_flags & (TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS | TDEFL_RLE_MATCHES)) == 0))
    {
        if (!tdefl_compress_fast(d))
            return d->m_prev_return_status;
    }
    else
#endif /* #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN */
    {
        if (!tdefl_compress_normal(d))
            return d->m_prev_return_status;
    }

    if ((d->m_flags & (TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32)) && (pIn_buf))
        d->m_adler32 = (mz_uint32)mz_adler32(d->m_adler32, (const mz_uint8 *)pIn_buf, d->m_pSrc - (const mz_uint8 *)pIn_buf);

    if ((flush) && (!d->m_lookahead_size) && (!d->m_src_buf_left) && (!d->m_output_flush_remaining))
    {
        if (tdefl_flush_block(d, flush) < 0)
            return d->m_prev_return_status;
        d->m_finished = (flush == TDEFL_FINISH);
        if (flush == TDEFL_FULL_FLUSH)
        {
            MZ_CLEAR_ARR(d->m_hash);
            MZ_CLEAR_ARR(d->m_next);
            d->m_dict_size = 0;
        }
    }

    return (d->m_prev_return_status = tdefl_flush_output_buffer(d));
}

tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush)
{
    MZ_ASSERT(d->m_pPut_buf_func);
    return tdefl_compress(d, pIn_buf, &in_buf_size, NULL, NULL, flush);
}

tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
{
    d->m_pPut_buf_func = pPut_buf_func;
    d->m_pPut_buf_user = pPut_buf_user;
    d->m_flags = (mz_uint)(flags);
    d->m_max_probes[0] = 1 + ((flags & 0xFFF) + 2) / 3;
    d->m_greedy_parsing = (flags & TDEFL_GREEDY_PARSING_FLAG) != 0;
    d->m_max_probes[1] = 1 + (((flags & 0xFFF) >> 2) + 2) / 3;
    if (!(flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG))
        MZ_CLEAR_ARR(d->m_hash);
    d->m_lookahead_pos = d->m_lookahead_size = d->m_dict_size = d->m_total_lz_bytes = d->m_lz_code_buf_dict_pos = d->m_bits_in = 0;
    d->m_output_flush_ofs = d->m_output_flush_remaining = d->m_finished = d->m_block_index = d->m_bit_buffer = d->m_wants_to_finish = 0;
    d->m_pLZ_code_buf = d->m_lz_code_buf + 1;
    d->m_pLZ_flags = d->m_lz_code_buf;
    *d->m_pLZ_flags = 0;
    d->m_num_flags_left = 8;
    d->m_pOutput_buf = d->m_output_buf;
    d->m_pOutput_buf_end = d->m_output_buf;
    d->m_prev_return_status = TDEFL_STATUS_OKAY;
    d->m_saved_match_dist = d->m_saved_match_len = d->m_saved_lit = 0;
    d->m_adler32 = 1;
    d->m_pIn_buf = NULL;
    d->m_pOut_buf = NULL;
    d->m_pIn_buf_size = NULL;
    d->m_pOut_buf_size = NULL;
    d->m_flush = TDEFL_NO_FLUSH;
    d->m_pSrc = NULL;
    d->m_src_buf_left = 0;
    d->m_out_buf_ofs = 0;
    if (!(flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG))
        MZ_CLEAR_ARR(d->m_dict);
    memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
    memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);
    return TDEFL_STATUS_OKAY;
}

tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d)
{
    return d->m_prev_return_status;
}

mz_uint32 tdefl_get_adler32(tdefl_compressor *d)
{
    return d->m_adler32;
}

mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
{
    tdefl_compressor *pComp;
    mz_bool succeeded;
    if (((buf_len) && (!pBuf)) || (!pPut_buf_func))
        return MZ_FALSE;
    pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
    if (!pComp)
        return MZ_FALSE;
    succeeded = (tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags) == TDEFL_STATUS_OKAY);
    succeeded = succeeded && (tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH) == TDEFL_STATUS_DONE);
    MZ_FREE(pComp);
    return succeeded;
}

typedef struct
{
    size_t m_size, m_capacity;
    mz_uint8 *m_pBuf;
    mz_bool m_expandable;
} tdefl_output_buffer;

static mz_bool tdefl_output_buffer_putter(const void *pBuf, int len, void *pUser)
{
    tdefl_output_buffer *p = (tdefl_output_buffer *)pUser;
    size_t new_size = p->m_size + len;
    if (new_size > p->m_capacity)
    {
        size_t new_capacity = p->m_capacity;
        mz_uint8 *pNew_buf;
        if (!p->m_expandable)
            return MZ_FALSE;
        do
        {
            new_capacity = MZ_MAX(128U, new_capacity << 1U);
        } while (new_size > new_capacity);
        pNew_buf = (mz_uint8 *)MZ_REALLOC(p->m_pBuf, new_capacity);
        if (!pNew_buf)
            return MZ_FALSE;
        p->m_pBuf = pNew_buf;
        p->m_capacity = new_capacity;
    }
    memcpy((mz_uint8 *)p->m_pBuf + p->m_size, pBuf, len);
    p->m_size = new_size;
    return MZ_TRUE;
}

void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
{
    tdefl_output_buffer out_buf;
    MZ_CLEAR_OBJ(out_buf);
    if (!pOut_len)
        return MZ_FALSE;
    else
        *pOut_len = 0;
    out_buf.m_expandable = MZ_TRUE;
    if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))
        return NULL;
    *pOut_len = out_buf.m_size;
    return out_buf.m_pBuf;
}

size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)
{
    tdefl_output_buffer out_buf;
    MZ_CLEAR_OBJ(out_buf);
    if (!pOut_buf)
        return 0;
    out_buf.m_pBuf = (mz_uint8 *)pOut_buf;
    out_buf.m_capacity = out_buf_len;
    if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))
        return 0;
    return out_buf.m_size;
}



/* level may actually range from [0,10] (10 is a "hidden" max level, where we want a bit more compression and it's fine if throughput to fall off a cliff on some files). */
mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy)
{
    mz_uint comp_flags = s_tdefl_num_probes[(level >= 0) ? MZ_MIN(10, level) : MZ_DEFAULT_LEVEL] | ((level <= 3) ? TDEFL_GREEDY_PARSING_FLAG : 0);
    if (window_bits > 0)
        comp_flags |= TDEFL_WRITE_ZLIB_HEADER;

    if (!level)
        comp_flags |= TDEFL_FORCE_ALL_RAW_BLOCKS;
    else if (strategy == MZ_FILTERED)
        comp_flags |= TDEFL_FILTER_MATCHES;
    else if (strategy == MZ_HUFFMAN_ONLY)
        comp_flags &= ~TDEFL_MAX_PROBES_MASK;
    else if (strategy == MZ_FIXED)
        comp_flags |= TDEFL_FORCE_ALL_STATIC_BLOCKS;
    else if (strategy == MZ_RLE)
        comp_flags |= TDEFL_RLE_MATCHES;

    return comp_flags;
}

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4204) /* nonstandard extension used : non-constant aggregate initializer (also supported by GNU C and C99, so no big deal) */
#endif

/* Simple PNG writer function by Alex Evans, 2011. Released into the public domain: https://gist.github.com/908299, more context at
 http://altdevblogaday.org/2011/04/06/a-smaller-jpg-encoder/.
 This is actually a modification of Alex's original code so PNG files generated by this function pass pngcheck. */
void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip)
{
    /* Using a local copy of this array here in case MINIZ_NO_ZLIB_APIS was defined. */
    static const mz_uint s_tdefl_png_num_probes[11] = { 0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500 };
    tdefl_compressor *pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
    tdefl_output_buffer out_buf;
    int i, bpl = w * num_chans, y, z;
    mz_uint32 c;
    *pLen_out = 0;
    if (!pComp)
        return NULL;
    MZ_CLEAR_OBJ(out_buf);
    out_buf.m_expandable = MZ_TRUE;
    out_buf.m_capacity = 57 + MZ_MAX(64, (1 + bpl) * h);
    if (NULL == (out_buf.m_pBuf = (mz_uint8 *)MZ_MALLOC(out_buf.m_capacity)))
    {
        MZ_FREE(pComp);
        return NULL;
    }
    /* write dummy header */
    for (z = 41; z; --z)
        tdefl_output_buffer_putter(&z, 1, &out_buf);
    /* compress image data */
    tdefl_init(pComp, tdefl_output_buffer_putter, &out_buf, s_tdefl_png_num_probes[MZ_MIN(10, level)] | TDEFL_WRITE_ZLIB_HEADER);
    for (y = 0; y < h; ++y)
    {
        tdefl_compress_buffer(pComp, &z, 1, TDEFL_NO_FLUSH);
        tdefl_compress_buffer(pComp, (mz_uint8 *)pImage + (flip ? (h - 1 - y) : y) * bpl, bpl, TDEFL_NO_FLUSH);
    }
    if (tdefl_compress_buffer(pComp, NULL, 0, TDEFL_FINISH) != TDEFL_STATUS_DONE)
    {
        MZ_FREE(pComp);
        MZ_FREE(out_buf.m_pBuf);
        return NULL;
    }
    /* write real header */
    *pLen_out = out_buf.m_size - 41;
    {
        static const mz_uint8 chans[] = { 0x00, 0x00, 0x04, 0x02, 0x06 };
        mz_uint8 pnghdr[41] = { 0x89, 0x50, 0x4e, 0x47, 0x0d,
                                0x0a, 0x1a, 0x0a, 0x00, 0x00,
                                0x00, 0x0d, 0x49, 0x48, 0x44,
                                0x52, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x08,
                                0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x49, 0x44, 0x41,
                                0x54 };
        pnghdr[18] = (mz_uint8)(w >> 8);
        pnghdr[19] = (mz_uint8)w;
        pnghdr[22] = (mz_uint8)(h >> 8);
        pnghdr[23] = (mz_uint8)h;
        pnghdr[25] = chans[num_chans];
        pnghdr[33] = (mz_uint8)(*pLen_out >> 24);
        pnghdr[34] = (mz_uint8)(*pLen_out >> 16);
        pnghdr[35] = (mz_uint8)(*pLen_out >> 8);
        pnghdr[36] = (mz_uint8)*pLen_out;
        c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, pnghdr + 12, 17);
        for (i = 0; i < 4; ++i, c <<= 8)
            ((mz_uint8 *)(pnghdr + 29))[i] = (mz_uint8)(c >> 24);
        memcpy(out_buf.m_pBuf, pnghdr, 41);
    }
    /* write footer (IDAT CRC-32, followed by IEND chunk) */
    if (!tdefl_output_buffer_putter("\0\0\0\0\0\0\0\0\x49\x45\x4e\x44\xae\x42\x60\x82", 16, &out_buf))
    {
        *pLen_out = 0;
        MZ_FREE(pComp);
        MZ_FREE(out_buf.m_pBuf);
        return NULL;
    }
    c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, out_buf.m_pBuf + 41 - 4, *pLen_out + 4);
    for (i = 0; i < 4; ++i, c <<= 8)
        (out_buf.m_pBuf + out_buf.m_size - 16)[i] = (mz_uint8)(c >> 24);
    /* compute final size of file, grab compressed data buffer and return */
    *pLen_out += 57;
    MZ_FREE(pComp);
    return out_buf.m_pBuf;
}
void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h, int num_chans, size_t *pLen_out)
{
    /* Level 6 corresponds to TDEFL_DEFAULT_MAX_PROBES or MZ_DEFAULT_LEVEL (but we can't depend on MZ_DEFAULT_LEVEL being available in case the zlib API's where #defined out) */
    return tdefl_write_image_to_png_file_in_memory_ex(pImage, w, h, num_chans, pLen_out, 6, MZ_FALSE);
}

#ifndef MINIZ_NO_MALLOC
/* Allocate the tdefl_compressor and tinfl_decompressor structures in C so that */
/* non-C language bindings to tdefL_ and tinfl_ API don't need to worry about */
/* structure size and allocation mechanism. */
tdefl_compressor *tdefl_compressor_alloc(void)
{
    return (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
}

void tdefl_compressor_free(tdefl_compressor *pComp)
{
    MZ_FREE(pComp);
}
#endif

#ifdef _MSC_VER
#pragma warning(pop)
#endif

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/
 /**************************************************************************
 *
 * Copyright 2013-2014 RAD Game Tools and Valve Software
 * Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 **************************************************************************/



#ifndef MINIZ_NO_INFLATE_APIS

#ifdef __cplusplus
extern "C" {
#endif

/* ------------------- Low-level Decompression (completely independent from all compression API's) */

#define TINFL_MEMCPY(d, s, l) memcpy(d, s, l)
#define TINFL_MEMSET(p, c, l) memset(p, c, l)

#define TINFL_CR_BEGIN  \
    switch (r->m_state) \
    {                   \
        case 0:
#define TINFL_CR_RETURN(state_index, result) \
    do                                       \
    {                                        \
        status = result;                     \
        r->m_state = state_index;            \
        goto common_exit;                    \
        case state_index:;                   \
    }                                        \
    MZ_MACRO_END
#define TINFL_CR_RETURN_FOREVER(state_index, result) \
    do                                               \
    {                                                \
        for (;;)                                     \
        {                                            \
            TINFL_CR_RETURN(state_index, result);    \
        }                                            \
    }                                                \
    MZ_MACRO_END
#define TINFL_CR_FINISH }

#define TINFL_GET_BYTE(state_index, c)                                                                                                                           \
    do                                                                                                                                                           \
    {                                                                                                                                                            \
        while (pIn_buf_cur >= pIn_buf_end)                                                                                                                       \
        {                                                                                                                                                        \
            TINFL_CR_RETURN(state_index, (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) ? TINFL_STATUS_NEEDS_MORE_INPUT : TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS); \
        }                                                                                                                                                        \
        c = *pIn_buf_cur++;                                                                                                                                      \
    }                                                                                                                                                            \
    MZ_MACRO_END

#define TINFL_NEED_BITS(state_index, n)                \
    do                                                 \
    {                                                  \
        mz_uint c;                                     \
        TINFL_GET_BYTE(state_index, c);                \
        bit_buf |= (((tinfl_bit_buf_t)c) << num_bits); \
        num_bits += 8;                                 \
    } while (num_bits < (mz_uint)(n))
#define TINFL_SKIP_BITS(state_index, n)      \
    do                                       \
    {                                        \
        if (num_bits < (mz_uint)(n))         \
        {                                    \
            TINFL_NEED_BITS(state_index, n); \
        }                                    \
        bit_buf >>= (n);                     \
        num_bits -= (n);                     \
    }                                        \
    MZ_MACRO_END
#define TINFL_GET_BITS(state_index, b, n)    \
    do                                       \
    {                                        \
        if (num_bits < (mz_uint)(n))         \
        {                                    \
            TINFL_NEED_BITS(state_index, n); \
        }                                    \
        b = bit_buf & ((1 << (n)) - 1);      \
        bit_buf >>= (n);                     \
        num_bits -= (n);                     \
    }                                        \
    MZ_MACRO_END

/* TINFL_HUFF_BITBUF_FILL() is only used rarely, when the number of bytes remaining in the input buffer falls below 2. */
/* It reads just enough bytes from the input stream that are needed to decode the next Huffman code (and absolutely no more). It works by trying to fully decode a */
/* Huffman code by using whatever bits are currently present in the bit buffer. If this fails, it reads another byte, and tries again until it succeeds or until the */
/* bit buffer contains >=15 bits (deflate's max. Huffman code size). */
#define TINFL_HUFF_BITBUF_FILL(state_index, pLookUp, pTree)                    \
    do                                                                         \
    {                                                                          \
        temp = pLookUp[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)];                \
        if (temp >= 0)                                                         \
        {                                                                      \
            code_len = temp >> 9;                                              \
            if ((code_len) && (num_bits >= code_len))                          \
                break;                                                         \
        }                                                                      \
        else if (num_bits > TINFL_FAST_LOOKUP_BITS)                            \
        {                                                                      \
            code_len = TINFL_FAST_LOOKUP_BITS;                                 \
            do                                                                 \
            {                                                                  \
                temp = pTree[~temp + ((bit_buf >> code_len++) & 1)];           \
            } while ((temp < 0) && (num_bits >= (code_len + 1)));              \
            if (temp >= 0)                                                     \
                break;                                                         \
        }                                                                      \
        TINFL_GET_BYTE(state_index, c);                                        \
        bit_buf |= (((tinfl_bit_buf_t)c) << num_bits);                         \
        num_bits += 8;                                                         \
    } while (num_bits < 15);

/* TINFL_HUFF_DECODE() decodes the next Huffman coded symbol. It's more complex than you would initially expect because the zlib API expects the decompressor to never read */
/* beyond the final byte of the deflate stream. (In other words, when this macro wants to read another byte from the input, it REALLY needs another byte in order to fully */
/* decode the next Huffman code.) Handling this properly is particularly important on raw deflate (non-zlib) streams, which aren't followed by a byte aligned adler-32. */
/* The slow path is only executed at the very end of the input buffer. */
/* v1.16: The original macro handled the case at the very end of the passed-in input buffer, but we also need to handle the case where the user passes in 1+zillion bytes */
/* following the deflate data and our non-conservative read-ahead path won't kick in here on this code. This is much trickier. */
#define TINFL_HUFF_DECODE(state_index, sym, pLookUp, pTree)                                                                         \
    do                                                                                                                              \
    {                                                                                                                               \
        int temp;                                                                                                                   \
        mz_uint code_len, c;                                                                                                        \
        if (num_bits < 15)                                                                                                          \
        {                                                                                                                           \
            if ((pIn_buf_end - pIn_buf_cur) < 2)                                                                                    \
            {                                                                                                                       \
                TINFL_HUFF_BITBUF_FILL(state_index, pLookUp, pTree);                                                                \
            }                                                                                                                       \
            else                                                                                                                    \
            {                                                                                                                       \
                bit_buf |= (((tinfl_bit_buf_t)pIn_buf_cur[0]) << num_bits) | (((tinfl_bit_buf_t)pIn_buf_cur[1]) << (num_bits + 8)); \
                pIn_buf_cur += 2;                                                                                                   \
                num_bits += 16;                                                                                                     \
            }                                                                                                                       \
        }                                                                                                                           \
        if ((temp = pLookUp[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)                                                          \
            code_len = temp >> 9, temp &= 511;                                                                                      \
        else                                                                                                                        \
        {                                                                                                                           \
            code_len = TINFL_FAST_LOOKUP_BITS;                                                                                      \
            do                                                                                                                      \
            {                                                                                                                       \
                temp = pTree[~temp + ((bit_buf >> code_len++) & 1)];                                                                \
            } while (temp < 0);                                                                                                     \
        }                                                                                                                           \
        sym = temp;                                                                                                                 \
        bit_buf >>= code_len;                                                                                                       \
        num_bits -= code_len;                                                                                                       \
    }                                                                                                                               \
    MZ_MACRO_END

static void tinfl_clear_tree(tinfl_decompressor *r)
{
    if (r->m_type == 0)
        MZ_CLEAR_ARR(r->m_tree_0);
    else if (r->m_type == 1)
        MZ_CLEAR_ARR(r->m_tree_1);
    else
        MZ_CLEAR_ARR(r->m_tree_2);
}

tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags)
{
    static const mz_uint16 s_length_base[31] = { 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 };
    static const mz_uint8 s_length_extra[31] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0 };
    static const mz_uint16 s_dist_base[32] = { 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0 };
    static const mz_uint8 s_dist_extra[32] = { 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 };
    static const mz_uint8 s_length_dezigzag[19] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };
    static const mz_uint16 s_min_table_sizes[3] = { 257, 1, 4 };

    mz_int16 *pTrees[3];
    mz_uint8 *pCode_sizes[3];

    tinfl_status status = TINFL_STATUS_FAILED;
    mz_uint32 num_bits, dist, counter, num_extra;
    tinfl_bit_buf_t bit_buf;
    const mz_uint8 *pIn_buf_cur = pIn_buf_next, *const pIn_buf_end = pIn_buf_next + *pIn_buf_size;
    mz_uint8 *pOut_buf_cur = pOut_buf_next, *const pOut_buf_end = pOut_buf_next ? pOut_buf_next + *pOut_buf_size : NULL;
    size_t out_buf_size_mask = (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF) ? (size_t)-1 : ((pOut_buf_next - pOut_buf_start) + *pOut_buf_size) - 1, dist_from_out_buf_start;

    /* Ensure the output buffer's size is a power of 2, unless the output buffer is large enough to hold the entire output file (in which case it doesn't matter). */
    if (((out_buf_size_mask + 1) & out_buf_size_mask) || (pOut_buf_next < pOut_buf_start))
    {
        *pIn_buf_size = *pOut_buf_size = 0;
        return TINFL_STATUS_BAD_PARAM;
    }

    pTrees[0] = r->m_tree_0;
    pTrees[1] = r->m_tree_1;
    pTrees[2] = r->m_tree_2;
    pCode_sizes[0] = r->m_code_size_0;
    pCode_sizes[1] = r->m_code_size_1;
    pCode_sizes[2] = r->m_code_size_2;

    num_bits = r->m_num_bits;
    bit_buf = r->m_bit_buf;
    dist = r->m_dist;
    counter = r->m_counter;
    num_extra = r->m_num_extra;
    dist_from_out_buf_start = r->m_dist_from_out_buf_start;
    TINFL_CR_BEGIN

    bit_buf = num_bits = dist = counter = num_extra = r->m_zhdr0 = r->m_zhdr1 = 0;
    r->m_z_adler32 = r->m_check_adler32 = 1;
    if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER)
    {
        TINFL_GET_BYTE(1, r->m_zhdr0);
        TINFL_GET_BYTE(2, r->m_zhdr1);
        counter = (((r->m_zhdr0 * 256 + r->m_zhdr1) % 31 != 0) || (r->m_zhdr1 & 32) || ((r->m_zhdr0 & 15) != 8));
        if (!(decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))
            counter |= (((1U << (8U + (r->m_zhdr0 >> 4))) > 32768U) || ((out_buf_size_mask + 1) < (size_t)((size_t)1 << (8U + (r->m_zhdr0 >> 4)))));
        if (counter)
        {
            TINFL_CR_RETURN_FOREVER(36, TINFL_STATUS_FAILED);
        }
    }

    do
    {
        TINFL_GET_BITS(3, r->m_final, 3);
        r->m_type = r->m_final >> 1;
        if (r->m_type == 0)
        {
            TINFL_SKIP_BITS(5, num_bits & 7);
            for (counter = 0; counter < 4; ++counter)
            {
                if (num_bits)
                    TINFL_GET_BITS(6, r->m_raw_header[counter], 8);
                else
                    TINFL_GET_BYTE(7, r->m_raw_header[counter]);
            }
            if ((counter = (r->m_raw_header[0] | (r->m_raw_header[1] << 8))) != (mz_uint)(0xFFFF ^ (r->m_raw_header[2] | (r->m_raw_header[3] << 8))))
            {
                TINFL_CR_RETURN_FOREVER(39, TINFL_STATUS_FAILED);
            }
            while ((counter) && (num_bits))
            {
                TINFL_GET_BITS(51, dist, 8);
                while (pOut_buf_cur >= pOut_buf_end)
                {
                    TINFL_CR_RETURN(52, TINFL_STATUS_HAS_MORE_OUTPUT);
                }
                *pOut_buf_cur++ = (mz_uint8)dist;
                counter--;
            }
            while (counter)
            {
                size_t n;
                while (pOut_buf_cur >= pOut_buf_end)
                {
                    TINFL_CR_RETURN(9, TINFL_STATUS_HAS_MORE_OUTPUT);
                }
                while (pIn_buf_cur >= pIn_buf_end)
                {
                    TINFL_CR_RETURN(38, (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) ? TINFL_STATUS_NEEDS_MORE_INPUT : TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS);
                }
                n = MZ_MIN(MZ_MIN((size_t)(pOut_buf_end - pOut_buf_cur), (size_t)(pIn_buf_end - pIn_buf_cur)), counter);
                TINFL_MEMCPY(pOut_buf_cur, pIn_buf_cur, n);
                pIn_buf_cur += n;
                pOut_buf_cur += n;
                counter -= (mz_uint)n;
            }
        }
        else if (r->m_type == 3)
        {
            TINFL_CR_RETURN_FOREVER(10, TINFL_STATUS_FAILED);
        }
        else
        {
            if (r->m_type == 1)
            {
                mz_uint8 *p = r->m_code_size_0;
                mz_uint i;
                r->m_table_sizes[0] = 288;
                r->m_table_sizes[1] = 32;
                TINFL_MEMSET(r->m_code_size_1, 5, 32);
                for (i = 0; i <= 143; ++i)
                    *p++ = 8;
                for (; i <= 255; ++i)
                    *p++ = 9;
                for (; i <= 279; ++i)
                    *p++ = 7;
                for (; i <= 287; ++i)
                    *p++ = 8;
            }
            else
            {
                for (counter = 0; counter < 3; counter++)
                {
                    TINFL_GET_BITS(11, r->m_table_sizes[counter], "\05\05\04"[counter]);
                    r->m_table_sizes[counter] += s_min_table_sizes[counter];
                }
                MZ_CLEAR_ARR(r->m_code_size_2);
                for (counter = 0; counter < r->m_table_sizes[2]; counter++)
                {
                    mz_uint s;
                    TINFL_GET_BITS(14, s, 3);
                    r->m_code_size_2[s_length_dezigzag[counter]] = (mz_uint8)s;
                }
                r->m_table_sizes[2] = 19;
            }
            for (; (int)r->m_type >= 0; r->m_type--)
            {
                int tree_next, tree_cur;
                mz_int16 *pLookUp;
                mz_int16 *pTree;
                mz_uint8 *pCode_size;
                mz_uint i, j, used_syms, total, sym_index, next_code[17], total_syms[16];
                pLookUp = r->m_look_up[r->m_type];
                pTree = pTrees[r->m_type];
                pCode_size = pCode_sizes[r->m_type];
                MZ_CLEAR_ARR(total_syms);
                TINFL_MEMSET(pLookUp, 0, sizeof(r->m_look_up[0]));
                tinfl_clear_tree(r);
                for (i = 0; i < r->m_table_sizes[r->m_type]; ++i)
                    total_syms[pCode_size[i]]++;
                used_syms = 0, total = 0;
                next_code[0] = next_code[1] = 0;
                for (i = 1; i <= 15; ++i)
                {
                    used_syms += total_syms[i];
                    next_code[i + 1] = (total = ((total + total_syms[i]) << 1));
                }
                if ((65536 != total) && (used_syms > 1))
                {
                    TINFL_CR_RETURN_FOREVER(35, TINFL_STATUS_FAILED);
                }
                for (tree_next = -1, sym_index = 0; sym_index < r->m_table_sizes[r->m_type]; ++sym_index)
                {
                    mz_uint rev_code = 0, l, cur_code, code_size = pCode_size[sym_index];
                    if (!code_size)
                        continue;
                    cur_code = next_code[code_size]++;
                    for (l = code_size; l > 0; l--, cur_code >>= 1)
                        rev_code = (rev_code << 1) | (cur_code & 1);
                    if (code_size <= TINFL_FAST_LOOKUP_BITS)
                    {
                        mz_int16 k = (mz_int16)((code_size << 9) | sym_index);
                        while (rev_code < TINFL_FAST_LOOKUP_SIZE)
                        {
                            pLookUp[rev_code] = k;
                            rev_code += (1 << code_size);
                        }
                        continue;
                    }
                    if (0 == (tree_cur = pLookUp[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)]))
                    {
                        pLookUp[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)] = (mz_int16)tree_next;
                        tree_cur = tree_next;
                        tree_next -= 2;
                    }
                    rev_code >>= (TINFL_FAST_LOOKUP_BITS - 1);
                    for (j = code_size; j > (TINFL_FAST_LOOKUP_BITS + 1); j--)
                    {
                        tree_cur -= ((rev_code >>= 1) & 1);
                        if (!pTree[-tree_cur - 1])
                        {
                            pTree[-tree_cur - 1] = (mz_int16)tree_next;
                            tree_cur = tree_next;
                            tree_next -= 2;
                        }
                        else
                            tree_cur = pTree[-tree_cur - 1];
                    }
                    tree_cur -= ((rev_code >>= 1) & 1);
                    pTree[-tree_cur - 1] = (mz_int16)sym_index;
                }
                if (r->m_type == 2)
                {
                    for (counter = 0; counter < (r->m_table_sizes[0] + r->m_table_sizes[1]);)
                    {
                        mz_uint s;
                        TINFL_HUFF_DECODE(16, dist, r->m_look_up[2], r->m_tree_2);
                        if (dist < 16)
                        {
                            r->m_len_codes[counter++] = (mz_uint8)dist;
                            continue;
                        }
                        if ((dist == 16) && (!counter))
                        {
                            TINFL_CR_RETURN_FOREVER(17, TINFL_STATUS_FAILED);
                        }
                        num_extra = "\02\03\07"[dist - 16];
                        TINFL_GET_BITS(18, s, num_extra);
                        s += "\03\03\013"[dist - 16];
                        TINFL_MEMSET(r->m_len_codes + counter, (dist == 16) ? r->m_len_codes[counter - 1] : 0, s);
                        counter += s;
                    }
                    if ((r->m_table_sizes[0] + r->m_table_sizes[1]) != counter)
                    {
                        TINFL_CR_RETURN_FOREVER(21, TINFL_STATUS_FAILED);
                    }
                    TINFL_MEMCPY(r->m_code_size_0, r->m_len_codes, r->m_table_sizes[0]);
                    TINFL_MEMCPY(r->m_code_size_1, r->m_len_codes + r->m_table_sizes[0], r->m_table_sizes[1]);
                }
            }
            for (;;)
            {
                mz_uint8 *pSrc;
                for (;;)
                {
                    if (((pIn_buf_end - pIn_buf_cur) < 4) || ((pOut_buf_end - pOut_buf_cur) < 2))
                    {
                        TINFL_HUFF_DECODE(23, counter, r->m_look_up[0], r->m_tree_0);
                        if (counter >= 256)
                            break;
                        while (pOut_buf_cur >= pOut_buf_end)
                        {
                            TINFL_CR_RETURN(24, TINFL_STATUS_HAS_MORE_OUTPUT);
                        }
                        *pOut_buf_cur++ = (mz_uint8)counter;
                    }
                    else
                    {
                        int sym2;
                        mz_uint code_len;
#if TINFL_USE_64BIT_BITBUF
                        if (num_bits < 30)
                        {
                            bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE32(pIn_buf_cur)) << num_bits);
                            pIn_buf_cur += 4;
                            num_bits += 32;
                        }
#else
                        if (num_bits < 15)
                        {
                            bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits);
                            pIn_buf_cur += 2;
                            num_bits += 16;
                        }
#endif
                        if ((sym2 = r->m_look_up[0][bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)
                            code_len = sym2 >> 9;
                        else
                        {
                            code_len = TINFL_FAST_LOOKUP_BITS;
                            do
                            {
                                sym2 = r->m_tree_0[~sym2 + ((bit_buf >> code_len++) & 1)];
                            } while (sym2 < 0);
                        }
                        counter = sym2;
                        bit_buf >>= code_len;
                        num_bits -= code_len;
                        if (counter & 256)
                            break;

#if !TINFL_USE_64BIT_BITBUF
                        if (num_bits < 15)
                        {
                            bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits);
                            pIn_buf_cur += 2;
                            num_bits += 16;
                        }
#endif
                        if ((sym2 = r->m_look_up[0][bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)
                            code_len = sym2 >> 9;
                        else
                        {
                            code_len = TINFL_FAST_LOOKUP_BITS;
                            do
                            {
                                sym2 = r->m_tree_0[~sym2 + ((bit_buf >> code_len++) & 1)];
                            } while (sym2 < 0);
                        }
                        bit_buf >>= code_len;
                        num_bits -= code_len;

                        pOut_buf_cur[0] = (mz_uint8)counter;
                        if (sym2 & 256)
                        {
                            pOut_buf_cur++;
                            counter = sym2;
                            break;
                        }
                        pOut_buf_cur[1] = (mz_uint8)sym2;
                        pOut_buf_cur += 2;
                    }
                }
                if ((counter &= 511) == 256)
                    break;

                num_extra = s_length_extra[counter - 257];
                counter = s_length_base[counter - 257];
                if (num_extra)
                {
                    mz_uint extra_bits;
                    TINFL_GET_BITS(25, extra_bits, num_extra);
                    counter += extra_bits;
                }

                TINFL_HUFF_DECODE(26, dist, r->m_look_up[1], r->m_tree_1);
                num_extra = s_dist_extra[dist];
                dist = s_dist_base[dist];
                if (num_extra)
                {
                    mz_uint extra_bits;
                    TINFL_GET_BITS(27, extra_bits, num_extra);
                    dist += extra_bits;
                }

                dist_from_out_buf_start = pOut_buf_cur - pOut_buf_start;
                if ((dist == 0 || dist > dist_from_out_buf_start || dist_from_out_buf_start == 0) && (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))
                {
                    TINFL_CR_RETURN_FOREVER(37, TINFL_STATUS_FAILED);
                }

                pSrc = pOut_buf_start + ((dist_from_out_buf_start - dist) & out_buf_size_mask);

                if ((MZ_MAX(pOut_buf_cur, pSrc) + counter) > pOut_buf_end)
                {
                    while (counter--)
                    {
                        while (pOut_buf_cur >= pOut_buf_end)
                        {
                            TINFL_CR_RETURN(53, TINFL_STATUS_HAS_MORE_OUTPUT);
                        }
                        *pOut_buf_cur++ = pOut_buf_start[(dist_from_out_buf_start++ - dist) & out_buf_size_mask];
                    }
                    continue;
                }
#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
                else if ((counter >= 9) && (counter <= dist))
                {
                    const mz_uint8 *pSrc_end = pSrc + (counter & ~7);
                    do
                    {
#ifdef MINIZ_UNALIGNED_USE_MEMCPY
						memcpy(pOut_buf_cur, pSrc, sizeof(mz_uint32)*2);
#else
                        ((mz_uint32 *)pOut_buf_cur)[0] = ((const mz_uint32 *)pSrc)[0];
                        ((mz_uint32 *)pOut_buf_cur)[1] = ((const mz_uint32 *)pSrc)[1];
#endif
                        pOut_buf_cur += 8;
                    } while ((pSrc += 8) < pSrc_end);
                    if ((counter &= 7) < 3)
                    {
                        if (counter)
                        {
                            pOut_buf_cur[0] = pSrc[0];
                            if (counter > 1)
                                pOut_buf_cur[1] = pSrc[1];
                            pOut_buf_cur += counter;
                        }
                        continue;
                    }
                }
#endif
                while(counter>2)
                {
                    pOut_buf_cur[0] = pSrc[0];
                    pOut_buf_cur[1] = pSrc[1];
                    pOut_buf_cur[2] = pSrc[2];
                    pOut_buf_cur += 3;
                    pSrc += 3;
					counter -= 3;
                }
                if (counter > 0)
                {
                    pOut_buf_cur[0] = pSrc[0];
                    if (counter > 1)
                        pOut_buf_cur[1] = pSrc[1];
                    pOut_buf_cur += counter;
                }
            }
        }
    } while (!(r->m_final & 1));

    /* Ensure byte alignment and put back any bytes from the bitbuf if we've looked ahead too far on gzip, or other Deflate streams followed by arbitrary data. */
    /* I'm being super conservative here. A number of simplifications can be made to the byte alignment part, and the Adler32 check shouldn't ever need to worry about reading from the bitbuf now. */
    TINFL_SKIP_BITS(32, num_bits & 7);
    while ((pIn_buf_cur > pIn_buf_next) && (num_bits >= 8))
    {
        --pIn_buf_cur;
        num_bits -= 8;
    }
    bit_buf &= ~(~(tinfl_bit_buf_t)0 << num_bits);
    MZ_ASSERT(!num_bits); /* if this assert fires then we've read beyond the end of non-deflate/zlib streams with following data (such as gzip streams). */

    if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER)
    {
        for (counter = 0; counter < 4; ++counter)
        {
            mz_uint s;
            if (num_bits)
                TINFL_GET_BITS(41, s, 8);
            else
                TINFL_GET_BYTE(42, s);
            r->m_z_adler32 = (r->m_z_adler32 << 8) | s;
        }
    }
    TINFL_CR_RETURN_FOREVER(34, TINFL_STATUS_DONE);

    TINFL_CR_FINISH

common_exit:
    /* As long as we aren't telling the caller that we NEED more input to make forward progress: */
    /* Put back any bytes from the bitbuf in case we've looked ahead too far on gzip, or other Deflate streams followed by arbitrary data. */
    /* We need to be very careful here to NOT push back any bytes we definitely know we need to make forward progress, though, or we'll lock the caller up into an inf loop. */
    if ((status != TINFL_STATUS_NEEDS_MORE_INPUT) && (status != TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS))
    {
        while ((pIn_buf_cur > pIn_buf_next) && (num_bits >= 8))
        {
            --pIn_buf_cur;
            num_bits -= 8;
        }
    }
    r->m_num_bits = num_bits;
    r->m_bit_buf = bit_buf & ~(~(tinfl_bit_buf_t)0 << num_bits);
    r->m_dist = dist;
    r->m_counter = counter;
    r->m_num_extra = num_extra;
    r->m_dist_from_out_buf_start = dist_from_out_buf_start;
    *pIn_buf_size = pIn_buf_cur - pIn_buf_next;
    *pOut_buf_size = pOut_buf_cur - pOut_buf_next;
    if ((decomp_flags & (TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32)) && (status >= 0))
    {
        const mz_uint8 *ptr = pOut_buf_next;
        size_t buf_len = *pOut_buf_size;
        mz_uint32 i, s1 = r->m_check_adler32 & 0xffff, s2 = r->m_check_adler32 >> 16;
        size_t block_len = buf_len % 5552;
        while (buf_len)
        {
            for (i = 0; i + 7 < block_len; i += 8, ptr += 8)
            {
                s1 += ptr[0], s2 += s1;
                s1 += ptr[1], s2 += s1;
                s1 += ptr[2], s2 += s1;
                s1 += ptr[3], s2 += s1;
                s1 += ptr[4], s2 += s1;
                s1 += ptr[5], s2 += s1;
                s1 += ptr[6], s2 += s1;
                s1 += ptr[7], s2 += s1;
            }
            for (; i < block_len; ++i)
                s1 += *ptr++, s2 += s1;
            s1 %= 65521U, s2 %= 65521U;
            buf_len -= block_len;
            block_len = 5552;
        }
        r->m_check_adler32 = (s2 << 16) + s1;
        if ((status == TINFL_STATUS_DONE) && (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) && (r->m_check_adler32 != r->m_z_adler32))
            status = TINFL_STATUS_ADLER32_MISMATCH;
    }
    return status;
}

/* Higher level helper functions. */
void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
{
    tinfl_decompressor decomp;
    void *pBuf = NULL, *pNew_buf;
    size_t src_buf_ofs = 0, out_buf_capacity = 0;
    *pOut_len = 0;
    tinfl_init(&decomp);
    for (;;)
    {
        size_t src_buf_size = src_buf_len - src_buf_ofs, dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity;
        tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8 *)pSrc_buf + src_buf_ofs, &src_buf_size, (mz_uint8 *)pBuf, pBuf ? (mz_uint8 *)pBuf + *pOut_len : NULL, &dst_buf_size,
                                               (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
        if ((status < 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT))
        {
            MZ_FREE(pBuf);
            *pOut_len = 0;
            return NULL;
        }
        src_buf_ofs += src_buf_size;
        *pOut_len += dst_buf_size;
        if (status == TINFL_STATUS_DONE)
            break;
        new_out_buf_capacity = out_buf_capacity * 2;
        if (new_out_buf_capacity < 128)
            new_out_buf_capacity = 128;
        pNew_buf = MZ_REALLOC(pBuf, new_out_buf_capacity);
        if (!pNew_buf)
        {
            MZ_FREE(pBuf);
            *pOut_len = 0;
            return NULL;
        }
        pBuf = pNew_buf;
        out_buf_capacity = new_out_buf_capacity;
    }
    return pBuf;
}

size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)
{
    tinfl_decompressor decomp;
    tinfl_status status;
    tinfl_init(&decomp);
    status = tinfl_decompress(&decomp, (const mz_uint8 *)pSrc_buf, &src_buf_len, (mz_uint8 *)pOut_buf, (mz_uint8 *)pOut_buf, &out_buf_len, (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
    return (status != TINFL_STATUS_DONE) ? TINFL_DECOMPRESS_MEM_TO_MEM_FAILED : out_buf_len;
}

int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
{
    int result = 0;
    tinfl_decompressor decomp;
    mz_uint8 *pDict = (mz_uint8 *)MZ_MALLOC(TINFL_LZ_DICT_SIZE);
    size_t in_buf_ofs = 0, dict_ofs = 0;
    if (!pDict)
        return TINFL_STATUS_FAILED;
    memset(pDict,0,TINFL_LZ_DICT_SIZE);
    tinfl_init(&decomp);
    for (;;)
    {
        size_t in_buf_size = *pIn_buf_size - in_buf_ofs, dst_buf_size = TINFL_LZ_DICT_SIZE - dict_ofs;
        tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8 *)pIn_buf + in_buf_ofs, &in_buf_size, pDict, pDict + dict_ofs, &dst_buf_size,
                                               (flags & ~(TINFL_FLAG_HAS_MORE_INPUT | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));
        in_buf_ofs += in_buf_size;
        if ((dst_buf_size) && (!(*pPut_buf_func)(pDict + dict_ofs, (int)dst_buf_size, pPut_buf_user)))
            break;
        if (status != TINFL_STATUS_HAS_MORE_OUTPUT)
        {
            result = (status == TINFL_STATUS_DONE);
            break;
        }
        dict_ofs = (dict_ofs + dst_buf_size) & (TINFL_LZ_DICT_SIZE - 1);
    }
    MZ_FREE(pDict);
    *pIn_buf_size = in_buf_ofs;
    return result;
}

#ifndef MINIZ_NO_MALLOC
tinfl_decompressor *tinfl_decompressor_alloc(void)
{
    tinfl_decompressor *pDecomp = (tinfl_decompressor *)MZ_MALLOC(sizeof(tinfl_decompressor));
    if (pDecomp)
        tinfl_init(pDecomp);
    return pDecomp;
}

void tinfl_decompressor_free(tinfl_decompressor *pDecomp)
{
    MZ_FREE(pDecomp);
}
#endif

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/
 /**************************************************************************
 *
 * Copyright 2013-2014 RAD Game Tools and Valve Software
 * Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
 * Copyright 2016 Martin Raiber
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 **************************************************************************/


#ifndef MINIZ_NO_ARCHIVE_APIS

#ifdef __cplusplus
extern "C" {
#endif

/* ------------------- .ZIP archive reading */

#ifdef MINIZ_NO_STDIO
#define MZ_FILE void *
#else
#include <sys/stat.h>

#if defined(_MSC_VER) || defined(__MINGW64__)

#define WIN32_LEAN_AND_MEAN
#include <windows.h>

static WCHAR* mz_utf8z_to_widechar(const char* str)
{
  int reqChars = MultiByteToWideChar(CP_UTF8, 0, str, -1, NULL, 0);
  WCHAR* wStr = (WCHAR*)malloc(reqChars * sizeof(WCHAR));
  MultiByteToWideChar(CP_UTF8, 0, str, -1, wStr, reqChars);
  return wStr;
}

static FILE *mz_fopen(const char *pFilename, const char *pMode)
{
  WCHAR* wFilename = mz_utf8z_to_widechar(pFilename);
  WCHAR* wMode = mz_utf8z_to_widechar(pMode);
  FILE* pFile = NULL;
  errno_t err = _wfopen_s(&pFile, wFilename, wMode);
  free(wFilename);
  free(wMode);
  return err ? NULL : pFile;
}

static FILE *mz_freopen(const char *pPath, const char *pMode, FILE *pStream)
{
  WCHAR* wPath = mz_utf8z_to_widechar(pPath);
  WCHAR* wMode = mz_utf8z_to_widechar(pMode);
  FILE* pFile = NULL;
  errno_t err = _wfreopen_s(&pFile, wPath, wMode, pStream);
  free(wPath);
  free(wMode);
  return err ? NULL : pFile;
}

static int mz_stat64(const char *path, struct __stat64 *buffer)
{
  WCHAR* wPath = mz_utf8z_to_widechar(path);
  int res = _wstat64(wPath, buffer);
  free(wPath);
  return res;
}

#ifndef MINIZ_NO_TIME
#include <sys/utime.h>
#endif
#define MZ_FOPEN mz_fopen
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 _ftelli64
#define MZ_FSEEK64 _fseeki64
#define MZ_FILE_STAT_STRUCT _stat64
#define MZ_FILE_STAT mz_stat64 
#define MZ_FFLUSH fflush
#define MZ_FREOPEN mz_freopen
#define MZ_DELETE_FILE remove

#elif defined(__MINGW32__) || defined(__WATCOMC__)
#ifndef MINIZ_NO_TIME
#include <sys/utime.h>
#endif
#define MZ_FOPEN(f, m) fopen(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 _ftelli64
#define MZ_FSEEK64 _fseeki64
#define MZ_FILE_STAT_STRUCT stat
#define MZ_FILE_STAT stat
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
#define MZ_DELETE_FILE remove

#elif defined(__TINYC__)
#ifndef MINIZ_NO_TIME
#include <sys/utime.h>
#endif
#define MZ_FOPEN(f, m) fopen(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 ftell
#define MZ_FSEEK64 fseek
#define MZ_FILE_STAT_STRUCT stat
#define MZ_FILE_STAT stat
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
#define MZ_DELETE_FILE remove

#elif defined(__USE_LARGEFILE64) /* gcc, clang */
#ifndef MINIZ_NO_TIME
#include <utime.h>
#endif
#define MZ_FOPEN(f, m) fopen64(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 ftello64
#define MZ_FSEEK64 fseeko64
#define MZ_FILE_STAT_STRUCT stat64
#define MZ_FILE_STAT stat64
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(p, m, s) freopen64(p, m, s)
#define MZ_DELETE_FILE remove

#elif defined(__APPLE__) || defined(__FreeBSD__)
#ifndef MINIZ_NO_TIME
#include <utime.h>
#endif
#define MZ_FOPEN(f, m) fopen(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 ftello
#define MZ_FSEEK64 fseeko
#define MZ_FILE_STAT_STRUCT stat
#define MZ_FILE_STAT stat
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(p, m, s) freopen(p, m, s)
#define MZ_DELETE_FILE remove

#else
#pragma message("Using fopen, ftello, fseeko, stat() etc. path for file I/O - this path may not support large files.")
#ifndef MINIZ_NO_TIME
#include <utime.h>
#endif
#define MZ_FOPEN(f, m) fopen(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#ifdef __STRICT_ANSI__
#define MZ_FTELL64 ftell
#define MZ_FSEEK64 fseek
#else
#define MZ_FTELL64 ftello
#define MZ_FSEEK64 fseeko
#endif
#define MZ_FILE_STAT_STRUCT stat
#define MZ_FILE_STAT stat
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
#define MZ_DELETE_FILE remove
#endif /* #ifdef _MSC_VER */
#endif /* #ifdef MINIZ_NO_STDIO */

#define MZ_TOLOWER(c) ((((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c))

/* Various ZIP archive enums. To completely avoid cross platform compiler alignment and platform endian issues, miniz.c doesn't use structs for any of this stuff. */
enum
{
    /* ZIP archive identifiers and record sizes */
    MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06054b50,
    MZ_ZIP_CENTRAL_DIR_HEADER_SIG = 0x02014b50,
    MZ_ZIP_LOCAL_DIR_HEADER_SIG = 0x04034b50,
    MZ_ZIP_LOCAL_DIR_HEADER_SIZE = 30,
    MZ_ZIP_CENTRAL_DIR_HEADER_SIZE = 46,
    MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE = 22,

    /* ZIP64 archive identifier and record sizes */
    MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06064b50,
    MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG = 0x07064b50,
    MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE = 56,
    MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE = 20,
    MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID = 0x0001,
    MZ_ZIP_DATA_DESCRIPTOR_ID = 0x08074b50,
    MZ_ZIP_DATA_DESCRIPTER_SIZE64 = 24,
    MZ_ZIP_DATA_DESCRIPTER_SIZE32 = 16,

    /* Central directory header record offsets */
    MZ_ZIP_CDH_SIG_OFS = 0,
    MZ_ZIP_CDH_VERSION_MADE_BY_OFS = 4,
    MZ_ZIP_CDH_VERSION_NEEDED_OFS = 6,
    MZ_ZIP_CDH_BIT_FLAG_OFS = 8,
    MZ_ZIP_CDH_METHOD_OFS = 10,
    MZ_ZIP_CDH_FILE_TIME_OFS = 12,
    MZ_ZIP_CDH_FILE_DATE_OFS = 14,
    MZ_ZIP_CDH_CRC32_OFS = 16,
    MZ_ZIP_CDH_COMPRESSED_SIZE_OFS = 20,
    MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS = 24,
    MZ_ZIP_CDH_FILENAME_LEN_OFS = 28,
    MZ_ZIP_CDH_EXTRA_LEN_OFS = 30,
    MZ_ZIP_CDH_COMMENT_LEN_OFS = 32,
    MZ_ZIP_CDH_DISK_START_OFS = 34,
    MZ_ZIP_CDH_INTERNAL_ATTR_OFS = 36,
    MZ_ZIP_CDH_EXTERNAL_ATTR_OFS = 38,
    MZ_ZIP_CDH_LOCAL_HEADER_OFS = 42,

    /* Local directory header offsets */
    MZ_ZIP_LDH_SIG_OFS = 0,
    MZ_ZIP_LDH_VERSION_NEEDED_OFS = 4,
    MZ_ZIP_LDH_BIT_FLAG_OFS = 6,
    MZ_ZIP_LDH_METHOD_OFS = 8,
    MZ_ZIP_LDH_FILE_TIME_OFS = 10,
    MZ_ZIP_LDH_FILE_DATE_OFS = 12,
    MZ_ZIP_LDH_CRC32_OFS = 14,
    MZ_ZIP_LDH_COMPRESSED_SIZE_OFS = 18,
    MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS = 22,
    MZ_ZIP_LDH_FILENAME_LEN_OFS = 26,
    MZ_ZIP_LDH_EXTRA_LEN_OFS = 28,
    MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR = 1 << 3,

    /* End of central directory offsets */
    MZ_ZIP_ECDH_SIG_OFS = 0,
    MZ_ZIP_ECDH_NUM_THIS_DISK_OFS = 4,
    MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS = 6,
    MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 8,
    MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS = 10,
    MZ_ZIP_ECDH_CDIR_SIZE_OFS = 12,
    MZ_ZIP_ECDH_CDIR_OFS_OFS = 16,
    MZ_ZIP_ECDH_COMMENT_SIZE_OFS = 20,

    /* ZIP64 End of central directory locator offsets */
    MZ_ZIP64_ECDL_SIG_OFS = 0,                    /* 4 bytes */
    MZ_ZIP64_ECDL_NUM_DISK_CDIR_OFS = 4,          /* 4 bytes */
    MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS = 8,  /* 8 bytes */
    MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS = 16, /* 4 bytes */

    /* ZIP64 End of central directory header offsets */
    MZ_ZIP64_ECDH_SIG_OFS = 0,                       /* 4 bytes */
    MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS = 4,            /* 8 bytes */
    MZ_ZIP64_ECDH_VERSION_MADE_BY_OFS = 12,          /* 2 bytes */
    MZ_ZIP64_ECDH_VERSION_NEEDED_OFS = 14,           /* 2 bytes */
    MZ_ZIP64_ECDH_NUM_THIS_DISK_OFS = 16,            /* 4 bytes */
    MZ_ZIP64_ECDH_NUM_DISK_CDIR_OFS = 20,            /* 4 bytes */
    MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 24, /* 8 bytes */
    MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS = 32,       /* 8 bytes */
    MZ_ZIP64_ECDH_CDIR_SIZE_OFS = 40,                /* 8 bytes */
    MZ_ZIP64_ECDH_CDIR_OFS_OFS = 48,                 /* 8 bytes */
    MZ_ZIP_VERSION_MADE_BY_DOS_FILESYSTEM_ID = 0,
    MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG = 0x10,
    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED = 1,
    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG = 32,
    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION = 64,
    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_LOCAL_DIR_IS_MASKED = 8192,
    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8 = 1 << 11
};

typedef struct
{
    void *m_p;
    size_t m_size, m_capacity;
    mz_uint m_element_size;
} mz_zip_array;

struct mz_zip_internal_state_tag
{
    mz_zip_array m_central_dir;
    mz_zip_array m_central_dir_offsets;
    mz_zip_array m_sorted_central_dir_offsets;

    /* The flags passed in when the archive is initially opened. */
    mz_uint32 m_init_flags;

    /* MZ_TRUE if the archive has a zip64 end of central directory headers, etc. */
    mz_bool m_zip64;

    /* MZ_TRUE if we found zip64 extended info in the central directory (m_zip64 will also be slammed to true too, even if we didn't find a zip64 end of central dir header, etc.) */
    mz_bool m_zip64_has_extended_info_fields;

    /* These fields are used by the file, FILE, memory, and memory/heap read/write helpers. */
    MZ_FILE *m_pFile;
    mz_uint64 m_file_archive_start_ofs;

    void *m_pMem;
    size_t m_mem_size;
    size_t m_mem_capacity;
};

#define MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(array_ptr, element_size) (array_ptr)->m_element_size = element_size

#if defined(DEBUG) || defined(_DEBUG)
static MZ_FORCEINLINE mz_uint mz_zip_array_range_check(const mz_zip_array *pArray, mz_uint index)
{
    MZ_ASSERT(index < pArray->m_size);
    return index;
}
#define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) ((element_type *)((array_ptr)->m_p))[mz_zip_array_range_check(array_ptr, index)]
#else
#define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) ((element_type *)((array_ptr)->m_p))[index]
#endif

static MZ_FORCEINLINE void mz_zip_array_init(mz_zip_array *pArray, mz_uint32 element_size)
{
    memset(pArray, 0, sizeof(mz_zip_array));
    pArray->m_element_size = element_size;
}

static MZ_FORCEINLINE void mz_zip_array_clear(mz_zip_archive *pZip, mz_zip_array *pArray)
{
    pZip->m_pFree(pZip->m_pAlloc_opaque, pArray->m_p);
    memset(pArray, 0, sizeof(mz_zip_array));
}

static mz_bool mz_zip_array_ensure_capacity(mz_zip_archive *pZip, mz_zip_array *pArray, size_t min_new_capacity, mz_uint growing)
{
    void *pNew_p;
    size_t new_capacity = min_new_capacity;
    MZ_ASSERT(pArray->m_element_size);
    if (pArray->m_capacity >= min_new_capacity)
        return MZ_TRUE;
    if (growing)
    {
        new_capacity = MZ_MAX(1, pArray->m_capacity);
        while (new_capacity < min_new_capacity)
            new_capacity *= 2;
    }
    if (NULL == (pNew_p = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pArray->m_p, pArray->m_element_size, new_capacity)))
        return MZ_FALSE;
    pArray->m_p = pNew_p;
    pArray->m_capacity = new_capacity;
    return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_array_reserve(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_capacity, mz_uint growing)
{
    if (new_capacity > pArray->m_capacity)
    {
        if (!mz_zip_array_ensure_capacity(pZip, pArray, new_capacity, growing))
            return MZ_FALSE;
    }
    return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_array_resize(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_size, mz_uint growing)
{
    if (new_size > pArray->m_capacity)
    {
        if (!mz_zip_array_ensure_capacity(pZip, pArray, new_size, growing))
            return MZ_FALSE;
    }
    pArray->m_size = new_size;
    return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_array_ensure_room(mz_zip_archive *pZip, mz_zip_array *pArray, size_t n)
{
    return mz_zip_array_reserve(pZip, pArray, pArray->m_size + n, MZ_TRUE);
}

static MZ_FORCEINLINE mz_bool mz_zip_array_push_back(mz_zip_archive *pZip, mz_zip_array *pArray, const void *pElements, size_t n)
{
    size_t orig_size = pArray->m_size;
    if (!mz_zip_array_resize(pZip, pArray, orig_size + n, MZ_TRUE))
        return MZ_FALSE;
    if (n > 0)
        memcpy((mz_uint8 *)pArray->m_p + orig_size * pArray->m_element_size, pElements, n * pArray->m_element_size);
    return MZ_TRUE;
}

#ifndef MINIZ_NO_TIME
static MZ_TIME_T mz_zip_dos_to_time_t(int dos_time, int dos_date)
{
    struct tm tm;
    memset(&tm, 0, sizeof(tm));
    tm.tm_isdst = -1;
    tm.tm_year = ((dos_date >> 9) & 127) + 1980 - 1900;
    tm.tm_mon = ((dos_date >> 5) & 15) - 1;
    tm.tm_mday = dos_date & 31;
    tm.tm_hour = (dos_time >> 11) & 31;
    tm.tm_min = (dos_time >> 5) & 63;
    tm.tm_sec = (dos_time << 1) & 62;
    return mktime(&tm);
}

#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
static void mz_zip_time_t_to_dos_time(MZ_TIME_T time, mz_uint16 *pDOS_time, mz_uint16 *pDOS_date)
{
#ifdef _MSC_VER
    struct tm tm_struct;
    struct tm *tm = &tm_struct;
    errno_t err = localtime_s(tm, &time);
    if (err)
    {
        *pDOS_date = 0;
        *pDOS_time = 0;
        return;
    }
#else
    struct tm *tm = localtime(&time);
#endif /* #ifdef _MSC_VER */

    *pDOS_time = (mz_uint16)(((tm->tm_hour) << 11) + ((tm->tm_min) << 5) + ((tm->tm_sec) >> 1));
    *pDOS_date = (mz_uint16)(((tm->tm_year + 1900 - 1980) << 9) + ((tm->tm_mon + 1) << 5) + tm->tm_mday);
}
#endif /* MINIZ_NO_ARCHIVE_WRITING_APIS */

#ifndef MINIZ_NO_STDIO
#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
static mz_bool mz_zip_get_file_modified_time(const char *pFilename, MZ_TIME_T *pTime)
{
    struct MZ_FILE_STAT_STRUCT file_stat;

    /* On Linux with x86 glibc, this call will fail on large files (I think >= 0x80000000 bytes) unless you compiled with _LARGEFILE64_SOURCE. Argh. */
    if (MZ_FILE_STAT(pFilename, &file_stat) != 0)
        return MZ_FALSE;

    *pTime = file_stat.st_mtime;

    return MZ_TRUE;
}
#endif /* #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS*/

static mz_bool mz_zip_set_file_times(const char *pFilename, MZ_TIME_T access_time, MZ_TIME_T modified_time)
{
    struct utimbuf t;

    memset(&t, 0, sizeof(t));
    t.actime = access_time;
    t.modtime = modified_time;

    return !utime(pFilename, &t);
}
#endif /* #ifndef MINIZ_NO_STDIO */
#endif /* #ifndef MINIZ_NO_TIME */

static MZ_FORCEINLINE mz_bool mz_zip_set_error(mz_zip_archive *pZip, mz_zip_error err_num)
{
    if (pZip)
        pZip->m_last_error = err_num;
    return MZ_FALSE;
}

static mz_bool mz_zip_reader_init_internal(mz_zip_archive *pZip, mz_uint flags)
{
    (void)flags;
    if ((!pZip) || (pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (!pZip->m_pAlloc)
        pZip->m_pAlloc = miniz_def_alloc_func;
    if (!pZip->m_pFree)
        pZip->m_pFree = miniz_def_free_func;
    if (!pZip->m_pRealloc)
        pZip->m_pRealloc = miniz_def_realloc_func;

    pZip->m_archive_size = 0;
    pZip->m_central_directory_file_ofs = 0;
    pZip->m_total_files = 0;
    pZip->m_last_error = MZ_ZIP_NO_ERROR;

    if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

    memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));
    pZip->m_pState->m_init_flags = flags;
    pZip->m_pState->m_zip64 = MZ_FALSE;
    pZip->m_pState->m_zip64_has_extended_info_fields = MZ_FALSE;

    pZip->m_zip_mode = MZ_ZIP_MODE_READING;

    return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_reader_filename_less(const mz_zip_array *pCentral_dir_array, const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, mz_uint r_index)
{
    const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
    const mz_uint8 *pR = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, r_index));
    mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS), r_len = MZ_READ_LE16(pR + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    mz_uint8 l = 0, r = 0;
    pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
    pR += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
    pE = pL + MZ_MIN(l_len, r_len);
    while (pL < pE)
    {
        if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
            break;
        pL++;
        pR++;
    }
    return (pL == pE) ? (l_len < r_len) : (l < r);
}

#define MZ_SWAP_UINT32(a, b) \
    do                       \
    {                        \
        mz_uint32 t = a;     \
        a = b;               \
        b = t;               \
    }                        \
    MZ_MACRO_END

/* Heap sort of lowercased filenames, used to help accelerate plain central directory searches by mz_zip_reader_locate_file(). (Could also use qsort(), but it could allocate memory.) */
static void mz_zip_reader_sort_central_dir_offsets_by_filename(mz_zip_archive *pZip)
{
    mz_zip_internal_state *pState = pZip->m_pState;
    const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
    const mz_zip_array *pCentral_dir = &pState->m_central_dir;
    mz_uint32 *pIndices;
    mz_uint32 start, end;
    const mz_uint32 size = pZip->m_total_files;

    if (size <= 1U)
        return;

    pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);

    start = (size - 2U) >> 1U;
    for (;;)
    {
        mz_uint64 child, root = start;
        for (;;)
        {
            if ((child = (root << 1U) + 1U) >= size)
                break;
            child += (((child + 1U) < size) && (mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1U])));
            if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child]))
                break;
            MZ_SWAP_UINT32(pIndices[root], pIndices[child]);
            root = child;
        }
        if (!start)
            break;
        start--;
    }

    end = size - 1;
    while (end > 0)
    {
        mz_uint64 child, root = 0;
        MZ_SWAP_UINT32(pIndices[end], pIndices[0]);
        for (;;)
        {
            if ((child = (root << 1U) + 1U) >= end)
                break;
            child += (((child + 1U) < end) && mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1U]));
            if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child]))
                break;
            MZ_SWAP_UINT32(pIndices[root], pIndices[child]);
            root = child;
        }
        end--;
    }
}

static mz_bool mz_zip_reader_locate_header_sig(mz_zip_archive *pZip, mz_uint32 record_sig, mz_uint32 record_size, mz_int64 *pOfs)
{
    mz_int64 cur_file_ofs;
    mz_uint32 buf_u32[4096 / sizeof(mz_uint32)];
    mz_uint8 *pBuf = (mz_uint8 *)buf_u32;

    /* Basic sanity checks - reject files which are too small */
    if (pZip->m_archive_size < record_size)
        return MZ_FALSE;

    /* Find the record by scanning the file from the end towards the beginning. */
    cur_file_ofs = MZ_MAX((mz_int64)pZip->m_archive_size - (mz_int64)sizeof(buf_u32), 0);
    for (;;)
    {
        int i, n = (int)MZ_MIN(sizeof(buf_u32), pZip->m_archive_size - cur_file_ofs);

        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, n) != (mz_uint)n)
            return MZ_FALSE;

        for (i = n - 4; i >= 0; --i)
        {
            mz_uint s = MZ_READ_LE32(pBuf + i);
            if (s == record_sig)
            {
                if ((pZip->m_archive_size - (cur_file_ofs + i)) >= record_size)
                    break;
            }
        }

        if (i >= 0)
        {
            cur_file_ofs += i;
            break;
        }

        /* Give up if we've searched the entire file, or we've gone back "too far" (~64kb) */
        if ((!cur_file_ofs) || ((pZip->m_archive_size - cur_file_ofs) >= (MZ_UINT16_MAX + record_size)))
            return MZ_FALSE;

        cur_file_ofs = MZ_MAX(cur_file_ofs - (sizeof(buf_u32) - 3), 0);
    }

    *pOfs = cur_file_ofs;
    return MZ_TRUE;
}

static mz_bool mz_zip_reader_read_central_dir(mz_zip_archive *pZip, mz_uint flags)
{
    mz_uint cdir_size = 0, cdir_entries_on_this_disk = 0, num_this_disk = 0, cdir_disk_index = 0;
    mz_uint64 cdir_ofs = 0;
    mz_int64 cur_file_ofs = 0;
    const mz_uint8 *p;

    mz_uint32 buf_u32[4096 / sizeof(mz_uint32)];
    mz_uint8 *pBuf = (mz_uint8 *)buf_u32;
    mz_bool sort_central_dir = ((flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0);
    mz_uint32 zip64_end_of_central_dir_locator_u32[(MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pZip64_locator = (mz_uint8 *)zip64_end_of_central_dir_locator_u32;

    mz_uint32 zip64_end_of_central_dir_header_u32[(MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pZip64_end_of_central_dir = (mz_uint8 *)zip64_end_of_central_dir_header_u32;

    mz_uint64 zip64_end_of_central_dir_ofs = 0;

    /* Basic sanity checks - reject files which are too small, and check the first 4 bytes of the file to make sure a local header is there. */
    if (pZip->m_archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);

    if (!mz_zip_reader_locate_header_sig(pZip, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE, &cur_file_ofs))
        return mz_zip_set_error(pZip, MZ_ZIP_FAILED_FINDING_CENTRAL_DIR);

    /* Read and verify the end of central directory record. */
    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

    if (MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_SIG_OFS) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG)
        return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);

    if (cur_file_ofs >= (MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE + MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE))
    {
        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs - MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE, pZip64_locator, MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE) == MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE)
        {
            if (MZ_READ_LE32(pZip64_locator + MZ_ZIP64_ECDL_SIG_OFS) == MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG)
            {
                zip64_end_of_central_dir_ofs = MZ_READ_LE64(pZip64_locator + MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS);
                if (zip64_end_of_central_dir_ofs > (pZip->m_archive_size - MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE))
                    return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);

                if (pZip->m_pRead(pZip->m_pIO_opaque, zip64_end_of_central_dir_ofs, pZip64_end_of_central_dir, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE) == MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE)
                {
                    if (MZ_READ_LE32(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_SIG_OFS) == MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG)
                    {
                        pZip->m_pState->m_zip64 = MZ_TRUE;
                    }
                }
            }
        }
    }

    pZip->m_total_files = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS);
    cdir_entries_on_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS);
    num_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_THIS_DISK_OFS);
    cdir_disk_index = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS);
    cdir_size = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_SIZE_OFS);
    cdir_ofs = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_OFS_OFS);

    if (pZip->m_pState->m_zip64)
    {
        mz_uint32 zip64_total_num_of_disks = MZ_READ_LE32(pZip64_locator + MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS);
        mz_uint64 zip64_cdir_total_entries = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS);
        mz_uint64 zip64_cdir_total_entries_on_this_disk = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS);
        mz_uint64 zip64_size_of_end_of_central_dir_record = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS);
        mz_uint64 zip64_size_of_central_directory = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_SIZE_OFS);

        if (zip64_size_of_end_of_central_dir_record < (MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE - 12))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

        if (zip64_total_num_of_disks != 1U)
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);

        /* Check for miniz's practical limits */
        if (zip64_cdir_total_entries > MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);

        pZip->m_total_files = (mz_uint32)zip64_cdir_total_entries;

        if (zip64_cdir_total_entries_on_this_disk > MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);

        cdir_entries_on_this_disk = (mz_uint32)zip64_cdir_total_entries_on_this_disk;

        /* Check for miniz's current practical limits (sorry, this should be enough for millions of files) */
        if (zip64_size_of_central_directory > MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);

        cdir_size = (mz_uint32)zip64_size_of_central_directory;

        num_this_disk = MZ_READ_LE32(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_NUM_THIS_DISK_OFS);

        cdir_disk_index = MZ_READ_LE32(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_NUM_DISK_CDIR_OFS);

        cdir_ofs = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_OFS_OFS);
    }

    if (pZip->m_total_files != cdir_entries_on_this_disk)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);

    if (((num_this_disk | cdir_disk_index) != 0) && ((num_this_disk != 1) || (cdir_disk_index != 1)))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);

    if (cdir_size < (mz_uint64)pZip->m_total_files * MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    if ((cdir_ofs + (mz_uint64)cdir_size) > pZip->m_archive_size)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    pZip->m_central_directory_file_ofs = cdir_ofs;

    if (pZip->m_total_files)
    {
        mz_uint i, n;
        /* Read the entire central directory into a heap block, and allocate another heap block to hold the unsorted central dir file record offsets, and possibly another to hold the sorted indices. */
        if ((!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir, cdir_size, MZ_FALSE)) ||
            (!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir_offsets, pZip->m_total_files, MZ_FALSE)))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

        if (sort_central_dir)
        {
            if (!mz_zip_array_resize(pZip, &pZip->m_pState->m_sorted_central_dir_offsets, pZip->m_total_files, MZ_FALSE))
                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        if (pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs, pZip->m_pState->m_central_dir.m_p, cdir_size) != cdir_size)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

        /* Now create an index into the central directory file records, do some basic sanity checking on each record */
        p = (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p;
        for (n = cdir_size, i = 0; i < pZip->m_total_files; ++i)
        {
            mz_uint total_header_size, disk_index, bit_flags, filename_size, ext_data_size;
            mz_uint64 comp_size, decomp_size, local_header_ofs;

            if ((n < MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) || (MZ_READ_LE32(p) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG))
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

            MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, i) = (mz_uint32)(p - (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p);

            if (sort_central_dir)
                MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_sorted_central_dir_offsets, mz_uint32, i) = i;

            comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
            decomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
            local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
            filename_size = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
            ext_data_size = MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS);

            if ((!pZip->m_pState->m_zip64_has_extended_info_fields) &&
                (ext_data_size) &&
                (MZ_MAX(MZ_MAX(comp_size, decomp_size), local_header_ofs) == MZ_UINT32_MAX))
            {
                /* Attempt to find zip64 extended information field in the entry's extra data */
                mz_uint32 extra_size_remaining = ext_data_size;

                if (extra_size_remaining)
                {
					const mz_uint8 *pExtra_data;
					void* buf = NULL;

					if (MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + ext_data_size > n)
					{
						buf = MZ_MALLOC(ext_data_size);
						if(buf==NULL)
							return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

						if (pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size, buf, ext_data_size) != ext_data_size)
						{
							MZ_FREE(buf);
							return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
						}

						pExtra_data = (mz_uint8*)buf;
					}
					else
					{
						pExtra_data = p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size;
					}

                    do
                    {
                        mz_uint32 field_id;
                        mz_uint32 field_data_size;

						if (extra_size_remaining < (sizeof(mz_uint16) * 2))
						{
							MZ_FREE(buf);
							return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
						}

                        field_id = MZ_READ_LE16(pExtra_data);
                        field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));

						if ((field_data_size + sizeof(mz_uint16) * 2) > extra_size_remaining)
						{
							MZ_FREE(buf);
							return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
						}

                        if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
                        {
                            /* Ok, the archive didn't have any zip64 headers but it uses a zip64 extended information field so mark it as zip64 anyway (this can occur with infozip's zip util when it reads compresses files from stdin). */
                            pZip->m_pState->m_zip64 = MZ_TRUE;
                            pZip->m_pState->m_zip64_has_extended_info_fields = MZ_TRUE;
                            break;
                        }

                        pExtra_data += sizeof(mz_uint16) * 2 + field_data_size;
                        extra_size_remaining = extra_size_remaining - sizeof(mz_uint16) * 2 - field_data_size;
                    } while (extra_size_remaining);

					MZ_FREE(buf);
                }
            }

            /* I've seen archives that aren't marked as zip64 that uses zip64 ext data, argh */
            if ((comp_size != MZ_UINT32_MAX) && (decomp_size != MZ_UINT32_MAX))
            {
                if (((!MZ_READ_LE32(p + MZ_ZIP_CDH_METHOD_OFS)) && (decomp_size != comp_size)) || (decomp_size && !comp_size))
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
            }

            disk_index = MZ_READ_LE16(p + MZ_ZIP_CDH_DISK_START_OFS);
            if ((disk_index == MZ_UINT16_MAX) || ((disk_index != num_this_disk) && (disk_index != 1)))
                return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);

            if (comp_size != MZ_UINT32_MAX)
            {
                if (((mz_uint64)MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS) + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + comp_size) > pZip->m_archive_size)
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
            }

            bit_flags = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
            if (bit_flags & MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_LOCAL_DIR_IS_MASKED)
                return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);

            if ((total_header_size = MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS)) > n)
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

            n -= total_header_size;
            p += total_header_size;
        }
    }

    if (sort_central_dir)
        mz_zip_reader_sort_central_dir_offsets_by_filename(pZip);

    return MZ_TRUE;
}

void mz_zip_zero_struct(mz_zip_archive *pZip)
{
    if (pZip)
        MZ_CLEAR_PTR(pZip);
}

static mz_bool mz_zip_reader_end_internal(mz_zip_archive *pZip, mz_bool set_last_error)
{
    mz_bool status = MZ_TRUE;

    if (!pZip)
        return MZ_FALSE;

    if ((!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
    {
        if (set_last_error)
            pZip->m_last_error = MZ_ZIP_INVALID_PARAMETER;

        return MZ_FALSE;
    }

    if (pZip->m_pState)
    {
        mz_zip_internal_state *pState = pZip->m_pState;
        pZip->m_pState = NULL;

        mz_zip_array_clear(pZip, &pState->m_central_dir);
        mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
        mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);

#ifndef MINIZ_NO_STDIO
        if (pState->m_pFile)
        {
            if (pZip->m_zip_type == MZ_ZIP_TYPE_FILE)
            {
                if (MZ_FCLOSE(pState->m_pFile) == EOF)
                {
                    if (set_last_error)
                        pZip->m_last_error = MZ_ZIP_FILE_CLOSE_FAILED;
                    status = MZ_FALSE;
                }
            }
            pState->m_pFile = NULL;
        }
#endif /* #ifndef MINIZ_NO_STDIO */

        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
    }
    pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;

    return status;
}

mz_bool mz_zip_reader_end(mz_zip_archive *pZip)
{
    return mz_zip_reader_end_internal(pZip, MZ_TRUE);
}
mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint flags)
{
    if ((!pZip) || (!pZip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (!mz_zip_reader_init_internal(pZip, flags))
        return MZ_FALSE;

    pZip->m_zip_type = MZ_ZIP_TYPE_USER;
    pZip->m_archive_size = size;

    if (!mz_zip_reader_read_central_dir(pZip, flags))
    {
        mz_zip_reader_end_internal(pZip, MZ_FALSE);
        return MZ_FALSE;
    }

    return MZ_TRUE;
}

static size_t mz_zip_mem_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
{
    mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
    size_t s = (file_ofs >= pZip->m_archive_size) ? 0 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n);
    memcpy(pBuf, (const mz_uint8 *)pZip->m_pState->m_pMem + file_ofs, s);
    return s;
}

mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint flags)
{
    if (!pMem)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);

    if (!mz_zip_reader_init_internal(pZip, flags))
        return MZ_FALSE;

    pZip->m_zip_type = MZ_ZIP_TYPE_MEMORY;
    pZip->m_archive_size = size;
    pZip->m_pRead = mz_zip_mem_read_func;
    pZip->m_pIO_opaque = pZip;
    pZip->m_pNeeds_keepalive = NULL;

#ifdef __cplusplus
    pZip->m_pState->m_pMem = const_cast<void *>(pMem);
#else
    pZip->m_pState->m_pMem = (void *)pMem;
#endif

    pZip->m_pState->m_mem_size = size;

    if (!mz_zip_reader_read_central_dir(pZip, flags))
    {
        mz_zip_reader_end_internal(pZip, MZ_FALSE);
        return MZ_FALSE;
    }

    return MZ_TRUE;
}

#ifndef MINIZ_NO_STDIO
static size_t mz_zip_file_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
{
    mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
    mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);

    file_ofs += pZip->m_pState->m_file_archive_start_ofs;

    if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
        return 0;

    return MZ_FREAD(pBuf, 1, n, pZip->m_pState->m_pFile);
}

mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags)
{
    return mz_zip_reader_init_file_v2(pZip, pFilename, flags, 0, 0);
}

mz_bool mz_zip_reader_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags, mz_uint64 file_start_ofs, mz_uint64 archive_size)
{
    mz_uint64 file_size;
    MZ_FILE *pFile;

    if ((!pZip) || (!pFilename) || ((archive_size) && (archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pFile = MZ_FOPEN(pFilename, "rb");
    if (!pFile)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);

    file_size = archive_size;
    if (!file_size)
    {
        if (MZ_FSEEK64(pFile, 0, SEEK_END))
        {
            MZ_FCLOSE(pFile);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_SEEK_FAILED);
        }

        file_size = MZ_FTELL64(pFile);
    }

    /* TODO: Better sanity check archive_size and the # of actual remaining bytes */

    if (file_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
    {
	MZ_FCLOSE(pFile);
        return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
    }

    if (!mz_zip_reader_init_internal(pZip, flags))
    {
        MZ_FCLOSE(pFile);
        return MZ_FALSE;
    }

    pZip->m_zip_type = MZ_ZIP_TYPE_FILE;
    pZip->m_pRead = mz_zip_file_read_func;
    pZip->m_pIO_opaque = pZip;
    pZip->m_pState->m_pFile = pFile;
    pZip->m_archive_size = file_size;
    pZip->m_pState->m_file_archive_start_ofs = file_start_ofs;

    if (!mz_zip_reader_read_central_dir(pZip, flags))
    {
        mz_zip_reader_end_internal(pZip, MZ_FALSE);
        return MZ_FALSE;
    }

    return MZ_TRUE;
}

mz_bool mz_zip_reader_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint64 archive_size, mz_uint flags)
{
    mz_uint64 cur_file_ofs;

    if ((!pZip) || (!pFile))
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);

    cur_file_ofs = MZ_FTELL64(pFile);

    if (!archive_size)
    {
        if (MZ_FSEEK64(pFile, 0, SEEK_END))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_SEEK_FAILED);

        archive_size = MZ_FTELL64(pFile) - cur_file_ofs;

        if (archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
            return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
    }

    if (!mz_zip_reader_init_internal(pZip, flags))
        return MZ_FALSE;

    pZip->m_zip_type = MZ_ZIP_TYPE_CFILE;
    pZip->m_pRead = mz_zip_file_read_func;

    pZip->m_pIO_opaque = pZip;
    pZip->m_pState->m_pFile = pFile;
    pZip->m_archive_size = archive_size;
    pZip->m_pState->m_file_archive_start_ofs = cur_file_ofs;

    if (!mz_zip_reader_read_central_dir(pZip, flags))
    {
        mz_zip_reader_end_internal(pZip, MZ_FALSE);
        return MZ_FALSE;
    }

    return MZ_TRUE;
}

#endif /* #ifndef MINIZ_NO_STDIO */

static MZ_FORCEINLINE const mz_uint8 *mz_zip_get_cdh(mz_zip_archive *pZip, mz_uint file_index)
{
    if ((!pZip) || (!pZip->m_pState) || (file_index >= pZip->m_total_files))
        return NULL;
    return &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
}

mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index)
{
    mz_uint m_bit_flag;
    const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
    if (!p)
    {
        mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        return MZ_FALSE;
    }

    m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
    return (m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION)) != 0;
}

mz_bool mz_zip_reader_is_file_supported(mz_zip_archive *pZip, mz_uint file_index)
{
    mz_uint bit_flag;
    mz_uint method;

    const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
    if (!p)
    {
        mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        return MZ_FALSE;
    }

    method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);
    bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);

    if ((method != 0) && (method != MZ_DEFLATED))
    {
        mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);
        return MZ_FALSE;
    }

    if (bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION))
    {
        mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);
        return MZ_FALSE;
    }

    if (bit_flag & MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG)
    {
        mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);
        return MZ_FALSE;
    }

    return MZ_TRUE;
}

mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index)
{
    mz_uint filename_len, attribute_mapping_id, external_attr;
    const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
    if (!p)
    {
        mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        return MZ_FALSE;
    }

    filename_len = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    if (filename_len)
    {
        if (*(p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_len - 1) == '/')
            return MZ_TRUE;
    }

    /* Bugfix: This code was also checking if the internal attribute was non-zero, which wasn't correct. */
    /* Most/all zip writers (hopefully) set DOS file/directory attributes in the low 16-bits, so check for the DOS directory flag and ignore the source OS ID in the created by field. */
    /* FIXME: Remove this check? Is it necessary - we already check the filename. */
    attribute_mapping_id = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS) >> 8;
    (void)attribute_mapping_id;

    external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
    if ((external_attr & MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG) != 0)
    {
        return MZ_TRUE;
    }

    return MZ_FALSE;
}

static mz_bool mz_zip_file_stat_internal(mz_zip_archive *pZip, mz_uint file_index, const mz_uint8 *pCentral_dir_header, mz_zip_archive_file_stat *pStat, mz_bool *pFound_zip64_extra_data)
{
    mz_uint n;
    const mz_uint8 *p = pCentral_dir_header;

    if (pFound_zip64_extra_data)
        *pFound_zip64_extra_data = MZ_FALSE;

    if ((!p) || (!pStat))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    /* Extract fields from the central directory record. */
    pStat->m_file_index = file_index;
    pStat->m_central_dir_ofs = MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index);
    pStat->m_version_made_by = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS);
    pStat->m_version_needed = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_NEEDED_OFS);
    pStat->m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
    pStat->m_method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);
#ifndef MINIZ_NO_TIME
    pStat->m_time = mz_zip_dos_to_time_t(MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_TIME_OFS), MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_DATE_OFS));
#endif
    pStat->m_crc32 = MZ_READ_LE32(p + MZ_ZIP_CDH_CRC32_OFS);
    pStat->m_comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
    pStat->m_uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
    pStat->m_internal_attr = MZ_READ_LE16(p + MZ_ZIP_CDH_INTERNAL_ATTR_OFS);
    pStat->m_external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
    pStat->m_local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);

    /* Copy as much of the filename and comment as possible. */
    n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1);
    memcpy(pStat->m_filename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
    pStat->m_filename[n] = '\0';

    n = MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS);
    n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE - 1);
    pStat->m_comment_size = n;
    memcpy(pStat->m_comment, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS), n);
    pStat->m_comment[n] = '\0';

    /* Set some flags for convienance */
    pStat->m_is_directory = mz_zip_reader_is_file_a_directory(pZip, file_index);
    pStat->m_is_encrypted = mz_zip_reader_is_file_encrypted(pZip, file_index);
    pStat->m_is_supported = mz_zip_reader_is_file_supported(pZip, file_index);

    /* See if we need to read any zip64 extended information fields. */
    /* Confusingly, these zip64 fields can be present even on non-zip64 archives (Debian zip on a huge files from stdin piped to stdout creates them). */
    if (MZ_MAX(MZ_MAX(pStat->m_comp_size, pStat->m_uncomp_size), pStat->m_local_header_ofs) == MZ_UINT32_MAX)
    {
        /* Attempt to find zip64 extended information field in the entry's extra data */
        mz_uint32 extra_size_remaining = MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS);

        if (extra_size_remaining)
        {
            const mz_uint8 *pExtra_data = p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);

            do
            {
                mz_uint32 field_id;
                mz_uint32 field_data_size;

                if (extra_size_remaining < (sizeof(mz_uint16) * 2))
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                field_id = MZ_READ_LE16(pExtra_data);
                field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));

                if ((field_data_size + sizeof(mz_uint16) * 2) > extra_size_remaining)
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
                {
                    const mz_uint8 *pField_data = pExtra_data + sizeof(mz_uint16) * 2;
                    mz_uint32 field_data_remaining = field_data_size;

                    if (pFound_zip64_extra_data)
                        *pFound_zip64_extra_data = MZ_TRUE;

                    if (pStat->m_uncomp_size == MZ_UINT32_MAX)
                    {
                        if (field_data_remaining < sizeof(mz_uint64))
                            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                        pStat->m_uncomp_size = MZ_READ_LE64(pField_data);
                        pField_data += sizeof(mz_uint64);
                        field_data_remaining -= sizeof(mz_uint64);
                    }

                    if (pStat->m_comp_size == MZ_UINT32_MAX)
                    {
                        if (field_data_remaining < sizeof(mz_uint64))
                            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                        pStat->m_comp_size = MZ_READ_LE64(pField_data);
                        pField_data += sizeof(mz_uint64);
                        field_data_remaining -= sizeof(mz_uint64);
                    }

                    if (pStat->m_local_header_ofs == MZ_UINT32_MAX)
                    {
                        if (field_data_remaining < sizeof(mz_uint64))
                            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                        pStat->m_local_header_ofs = MZ_READ_LE64(pField_data);
                        pField_data += sizeof(mz_uint64);
                        field_data_remaining -= sizeof(mz_uint64);
                    }

                    break;
                }

                pExtra_data += sizeof(mz_uint16) * 2 + field_data_size;
                extra_size_remaining = extra_size_remaining - sizeof(mz_uint16) * 2 - field_data_size;
            } while (extra_size_remaining);
        }
    }

    return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_string_equal(const char *pA, const char *pB, mz_uint len, mz_uint flags)
{
    mz_uint i;
    if (flags & MZ_ZIP_FLAG_CASE_SENSITIVE)
        return 0 == memcmp(pA, pB, len);
    for (i = 0; i < len; ++i)
        if (MZ_TOLOWER(pA[i]) != MZ_TOLOWER(pB[i]))
            return MZ_FALSE;
    return MZ_TRUE;
}

static MZ_FORCEINLINE int mz_zip_filename_compare(const mz_zip_array *pCentral_dir_array, const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, const char *pR, mz_uint r_len)
{
    const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
    mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    mz_uint8 l = 0, r = 0;
    pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
    pE = pL + MZ_MIN(l_len, r_len);
    while (pL < pE)
    {
        if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
            break;
        pL++;
        pR++;
    }
    return (pL == pE) ? (int)(l_len - r_len) : (l - r);
}

static mz_bool mz_zip_locate_file_binary_search(mz_zip_archive *pZip, const char *pFilename, mz_uint32 *pIndex)
{
    mz_zip_internal_state *pState = pZip->m_pState;
    const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
    const mz_zip_array *pCentral_dir = &pState->m_central_dir;
    mz_uint32 *pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);
    const mz_uint32 size = pZip->m_total_files;
    const mz_uint filename_len = (mz_uint)strlen(pFilename);

    if (pIndex)
        *pIndex = 0;

    if (size)
    {
        /* yes I could use uint32_t's, but then we would have to add some special case checks in the loop, argh, and */
        /* honestly the major expense here on 32-bit CPU's will still be the filename compare */
        mz_int64 l = 0, h = (mz_int64)size - 1;

        while (l <= h)
        {
            mz_int64 m = l + ((h - l) >> 1);
            mz_uint32 file_index = pIndices[(mz_uint32)m];

            int comp = mz_zip_filename_compare(pCentral_dir, pCentral_dir_offsets, file_index, pFilename, filename_len);
            if (!comp)
            {
                if (pIndex)
                    *pIndex = file_index;
                return MZ_TRUE;
            }
            else if (comp < 0)
                l = m + 1;
            else
                h = m - 1;
        }
    }

    return mz_zip_set_error(pZip, MZ_ZIP_FILE_NOT_FOUND);
}

int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags)
{
    mz_uint32 index;
    if (!mz_zip_reader_locate_file_v2(pZip, pName, pComment, flags, &index))
        return -1;
    else
        return (int)index;
}

mz_bool mz_zip_reader_locate_file_v2(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags, mz_uint32 *pIndex)
{
    mz_uint file_index;
    size_t name_len, comment_len;

    if (pIndex)
        *pIndex = 0;

    if ((!pZip) || (!pZip->m_pState) || (!pName))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    /* See if we can use a binary search */
    if (((pZip->m_pState->m_init_flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0) &&
        (pZip->m_zip_mode == MZ_ZIP_MODE_READING) &&
        ((flags & (MZ_ZIP_FLAG_IGNORE_PATH | MZ_ZIP_FLAG_CASE_SENSITIVE)) == 0) && (!pComment) && (pZip->m_pState->m_sorted_central_dir_offsets.m_size))
    {
        return mz_zip_locate_file_binary_search(pZip, pName, pIndex);
    }

    /* Locate the entry by scanning the entire central directory */
    name_len = strlen(pName);
    if (name_len > MZ_UINT16_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    comment_len = pComment ? strlen(pComment) : 0;
    if (comment_len > MZ_UINT16_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    for (file_index = 0; file_index < pZip->m_total_files; file_index++)
    {
        const mz_uint8 *pHeader = &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
        mz_uint filename_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_FILENAME_LEN_OFS);
        const char *pFilename = (const char *)pHeader + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
        if (filename_len < name_len)
            continue;
        if (comment_len)
        {
            mz_uint file_extra_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_EXTRA_LEN_OFS), file_comment_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_COMMENT_LEN_OFS);
            const char *pFile_comment = pFilename + filename_len + file_extra_len;
            if ((file_comment_len != comment_len) || (!mz_zip_string_equal(pComment, pFile_comment, file_comment_len, flags)))
                continue;
        }
        if ((flags & MZ_ZIP_FLAG_IGNORE_PATH) && (filename_len))
        {
            int ofs = filename_len - 1;
            do
            {
                if ((pFilename[ofs] == '/') || (pFilename[ofs] == '\\') || (pFilename[ofs] == ':'))
                    break;
            } while (--ofs >= 0);
            ofs++;
            pFilename += ofs;
            filename_len -= ofs;
        }
        if ((filename_len == name_len) && (mz_zip_string_equal(pName, pFilename, filename_len, flags)))
        {
            if (pIndex)
                *pIndex = file_index;
            return MZ_TRUE;
        }
    }

    return mz_zip_set_error(pZip, MZ_ZIP_FILE_NOT_FOUND);
}

static
mz_bool mz_zip_reader_extract_to_mem_no_alloc1(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size, const mz_zip_archive_file_stat *st)
{
    int status = TINFL_STATUS_DONE;
    mz_uint64 needed_size, cur_file_ofs, comp_remaining, out_buf_ofs = 0, read_buf_size, read_buf_ofs = 0, read_buf_avail;
    mz_zip_archive_file_stat file_stat;
    void *pRead_buf;
    mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
    tinfl_decompressor inflator;

    if ((!pZip) || (!pZip->m_pState) || ((buf_size) && (!pBuf)) || ((user_read_buf_size) && (!pUser_read_buf)) || (!pZip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (st) {
        file_stat = *st;
    } else
    if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
        return MZ_FALSE;

    /* A directory or zero length file */
    if ((file_stat.m_is_directory) || (!file_stat.m_comp_size))
        return MZ_TRUE;

    /* Encryption and patch files are not supported. */
    if (file_stat.m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);

    /* This function only supports decompressing stored and deflate. */
    if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);

    /* Ensure supplied output buffer is large enough. */
    needed_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? file_stat.m_comp_size : file_stat.m_uncomp_size;
    if (buf_size < needed_size)
        return mz_zip_set_error(pZip, MZ_ZIP_BUF_TOO_SMALL);

    /* Read and parse the local directory entry. */
    cur_file_ofs = file_stat.m_local_header_ofs;
    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

    if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
    if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))
    {
        /* The file is stored or the caller has requested the compressed data. */
        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, (size_t)needed_size) != needed_size)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
        if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) == 0)
        {
            if (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32)
                return mz_zip_set_error(pZip, MZ_ZIP_CRC_CHECK_FAILED);
        }
#endif

        return MZ_TRUE;
    }

    /* Decompress the file either directly from memory or from a file input buffer. */
    tinfl_init(&inflator);

    if (pZip->m_pState->m_pMem)
    {
        /* Read directly from the archive in memory. */
        pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
        read_buf_size = read_buf_avail = file_stat.m_comp_size;
        comp_remaining = 0;
    }
    else if (pUser_read_buf)
    {
        /* Use a user provided read buffer. */
        if (!user_read_buf_size)
            return MZ_FALSE;
        pRead_buf = (mz_uint8 *)pUser_read_buf;
        read_buf_size = user_read_buf_size;
        read_buf_avail = 0;
        comp_remaining = file_stat.m_comp_size;
    }
    else
    {
        /* Temporarily allocate a read buffer. */
        read_buf_size = MZ_MIN(file_stat.m_comp_size, (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE);
        if (((sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))
            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

        if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size)))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

        read_buf_avail = 0;
        comp_remaining = file_stat.m_comp_size;
    }

    do
    {
        /* The size_t cast here should be OK because we've verified that the output buffer is >= file_stat.m_uncomp_size above */
        size_t in_buf_size, out_buf_size = (size_t)(file_stat.m_uncomp_size - out_buf_ofs);
        if ((!read_buf_avail) && (!pZip->m_pState->m_pMem))
        {
            read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
            if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
            {
                status = TINFL_STATUS_FAILED;
                mz_zip_set_error(pZip, MZ_ZIP_DECOMPRESSION_FAILED);
                break;
            }
            cur_file_ofs += read_buf_avail;
            comp_remaining -= read_buf_avail;
            read_buf_ofs = 0;
        }
        in_buf_size = (size_t)read_buf_avail;
        status = tinfl_decompress(&inflator, (mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pBuf, (mz_uint8 *)pBuf + out_buf_ofs, &out_buf_size, TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF | (comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0));
        read_buf_avail -= in_buf_size;
        read_buf_ofs += in_buf_size;
        out_buf_ofs += out_buf_size;
    } while (status == TINFL_STATUS_NEEDS_MORE_INPUT);

    if (status == TINFL_STATUS_DONE)
    {
        /* Make sure the entire file was decompressed, and check its CRC. */
        if (out_buf_ofs != file_stat.m_uncomp_size)
        {
            mz_zip_set_error(pZip, MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
            status = TINFL_STATUS_FAILED;
        }
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
        else if (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32)
        {
            mz_zip_set_error(pZip, MZ_ZIP_CRC_CHECK_FAILED);
            status = TINFL_STATUS_FAILED;
        }
#endif
    }

    if ((!pZip->m_pState->m_pMem) && (!pUser_read_buf))
        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);

    return status == TINFL_STATUS_DONE;
}

mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)
{
    return mz_zip_reader_extract_to_mem_no_alloc1(pZip, file_index, pBuf, buf_size, flags, pUser_read_buf, user_read_buf_size, NULL);
}

mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)
{
    mz_uint32 file_index;
    if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
        return MZ_FALSE;
    return mz_zip_reader_extract_to_mem_no_alloc1(pZip, file_index, pBuf, buf_size, flags, pUser_read_buf, user_read_buf_size, NULL);
}

mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags)
{
    return mz_zip_reader_extract_to_mem_no_alloc1(pZip, file_index, pBuf, buf_size, flags, NULL, 0, NULL);
}

mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags)
{
    return mz_zip_reader_extract_file_to_mem_no_alloc(pZip, pFilename, pBuf, buf_size, flags, NULL, 0);
}

void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags)
{
    mz_zip_archive_file_stat file_stat;
    mz_uint64 alloc_size;
    void *pBuf;

    if (pSize)
        *pSize = 0;

    if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
        return NULL;

    alloc_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? file_stat.m_comp_size : file_stat.m_uncomp_size;
    if (((sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))
    {
        mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
        return NULL;
    }

    if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)alloc_size)))
    {
        mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        return NULL;
    }

    if (!mz_zip_reader_extract_to_mem_no_alloc1(pZip, file_index, pBuf, (size_t)alloc_size, flags, NULL, 0, &file_stat))
    {
        pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
        return NULL;
    }

    if (pSize)
        *pSize = (size_t)alloc_size;
    return pBuf;
}

void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags)
{
    mz_uint32 file_index;
    if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
    {
        if (pSize)
            *pSize = 0;
        return MZ_FALSE;
    }
    return mz_zip_reader_extract_to_heap(pZip, file_index, pSize, flags);
}

mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)
{
    int status = TINFL_STATUS_DONE;
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
    mz_uint file_crc32 = MZ_CRC32_INIT;
#endif
    mz_uint64 read_buf_size, read_buf_ofs = 0, read_buf_avail, comp_remaining, out_buf_ofs = 0, cur_file_ofs;
    mz_zip_archive_file_stat file_stat;
    void *pRead_buf = NULL;
    void *pWrite_buf = NULL;
    mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;

    if ((!pZip) || (!pZip->m_pState) || (!pCallback) || (!pZip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
        return MZ_FALSE;

    /* A directory or zero length file */
    if ((file_stat.m_is_directory) || (!file_stat.m_comp_size))
        return MZ_TRUE;

    /* Encryption and patch files are not supported. */
    if (file_stat.m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);

    /* This function only supports decompressing stored and deflate. */
    if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);

    /* Read and do some minimal validation of the local directory entry (this doesn't crack the zip64 stuff, which we already have from the central dir) */
    cur_file_ofs = file_stat.m_local_header_ofs;
    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

    if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
    if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    /* Decompress the file either directly from memory or from a file input buffer. */
    if (pZip->m_pState->m_pMem)
    {
        pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
        read_buf_size = read_buf_avail = file_stat.m_comp_size;
        comp_remaining = 0;
    }
    else
    {
        read_buf_size = MZ_MIN(file_stat.m_comp_size, (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE);
        if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size)))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

        read_buf_avail = 0;
        comp_remaining = file_stat.m_comp_size;
    }

    if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))
    {
        /* The file is stored or the caller has requested the compressed data. */
        if (pZip->m_pState->m_pMem)
        {
            if (((sizeof(size_t) == sizeof(mz_uint32))) && (file_stat.m_comp_size > MZ_UINT32_MAX))
                return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

            if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)file_stat.m_comp_size) != file_stat.m_comp_size)
            {
                mz_zip_set_error(pZip, MZ_ZIP_WRITE_CALLBACK_FAILED);
                status = TINFL_STATUS_FAILED;
            }
            else if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
            {
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
                file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf, (size_t)file_stat.m_comp_size);
#endif
            }

            cur_file_ofs += file_stat.m_comp_size;
            out_buf_ofs += file_stat.m_comp_size;
            comp_remaining = 0;
        }
        else
        {
            while (comp_remaining)
            {
                read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
                if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
                {
                    mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                    status = TINFL_STATUS_FAILED;
                    break;
                }

#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
                if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
                {
                    file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf, (size_t)read_buf_avail);
                }
#endif

                if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
                {
                    mz_zip_set_error(pZip, MZ_ZIP_WRITE_CALLBACK_FAILED);
                    status = TINFL_STATUS_FAILED;
                    break;
                }

                cur_file_ofs += read_buf_avail;
                out_buf_ofs += read_buf_avail;
                comp_remaining -= read_buf_avail;
            }
        }
    }
    else
    {
        tinfl_decompressor inflator;
        tinfl_init(&inflator);

        if (NULL == (pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, TINFL_LZ_DICT_SIZE)))
        {
            mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            status = TINFL_STATUS_FAILED;
        }
        else
        {
            do
            {
                mz_uint8 *pWrite_buf_cur = (mz_uint8 *)pWrite_buf + (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
                size_t in_buf_size, out_buf_size = TINFL_LZ_DICT_SIZE - (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
                if ((!read_buf_avail) && (!pZip->m_pState->m_pMem))
                {
                    read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
                    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
                    {
                        mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                        status = TINFL_STATUS_FAILED;
                        break;
                    }
                    cur_file_ofs += read_buf_avail;
                    comp_remaining -= read_buf_avail;
                    read_buf_ofs = 0;
                }

                in_buf_size = (size_t)read_buf_avail;
                status = tinfl_decompress(&inflator, (const mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pWrite_buf, pWrite_buf_cur, &out_buf_size, comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);
                read_buf_avail -= in_buf_size;
                read_buf_ofs += in_buf_size;

                if (out_buf_size)
                {
                    if (pCallback(pOpaque, out_buf_ofs, pWrite_buf_cur, out_buf_size) != out_buf_size)
                    {
                        mz_zip_set_error(pZip, MZ_ZIP_WRITE_CALLBACK_FAILED);
                        status = TINFL_STATUS_FAILED;
                        break;
                    }

#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
                    file_crc32 = (mz_uint32)mz_crc32(file_crc32, pWrite_buf_cur, out_buf_size);
#endif
                    if ((out_buf_ofs += out_buf_size) > file_stat.m_uncomp_size)
                    {
                        mz_zip_set_error(pZip, MZ_ZIP_DECOMPRESSION_FAILED);
                        status = TINFL_STATUS_FAILED;
                        break;
                    }
                }
            } while ((status == TINFL_STATUS_NEEDS_MORE_INPUT) || (status == TINFL_STATUS_HAS_MORE_OUTPUT));
        }
    }

    if ((status == TINFL_STATUS_DONE) && (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
    {
        /* Make sure the entire file was decompressed, and check its CRC. */
        if (out_buf_ofs != file_stat.m_uncomp_size)
        {
            mz_zip_set_error(pZip, MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
            status = TINFL_STATUS_FAILED;
        }
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
        else if (file_crc32 != file_stat.m_crc32)
        {
            mz_zip_set_error(pZip, MZ_ZIP_DECOMPRESSION_FAILED);
            status = TINFL_STATUS_FAILED;
        }
#endif
    }

    if (!pZip->m_pState->m_pMem)
        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);

    if (pWrite_buf)
        pZip->m_pFree(pZip->m_pAlloc_opaque, pWrite_buf);

    return status == TINFL_STATUS_DONE;
}

mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)
{
    mz_uint32 file_index;
    if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
        return MZ_FALSE;

    return mz_zip_reader_extract_to_callback(pZip, file_index, pCallback, pOpaque, flags);
}

mz_zip_reader_extract_iter_state* mz_zip_reader_extract_iter_new(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags)
{
    mz_zip_reader_extract_iter_state *pState;
    mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;

    /* Argument sanity check */
    if ((!pZip) || (!pZip->m_pState))
        return NULL;

    /* Allocate an iterator status structure */
    pState = (mz_zip_reader_extract_iter_state*)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_reader_extract_iter_state));
    if (!pState)
    {
        mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        return NULL;
    }

    /* Fetch file details */
    if (!mz_zip_reader_file_stat(pZip, file_index, &pState->file_stat))
    {
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        return NULL;
    }

    /* Encryption and patch files are not supported. */
    if (pState->file_stat.m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG))
    {
        mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        return NULL;
    }

    /* This function only supports decompressing stored and deflate. */
    if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (pState->file_stat.m_method != 0) && (pState->file_stat.m_method != MZ_DEFLATED))
    {
        mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        return NULL;
    }

    /* Init state - save args */
    pState->pZip = pZip;
    pState->flags = flags;

    /* Init state - reset variables to defaults */
    pState->status = TINFL_STATUS_DONE;
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
    pState->file_crc32 = MZ_CRC32_INIT;
#endif
    pState->read_buf_ofs = 0;
    pState->out_buf_ofs = 0;
    pState->pRead_buf = NULL;
    pState->pWrite_buf = NULL;
    pState->out_blk_remain = 0;

    /* Read and parse the local directory entry. */
    pState->cur_file_ofs = pState->file_stat.m_local_header_ofs;
    if (pZip->m_pRead(pZip->m_pIO_opaque, pState->cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
    {
        mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        return NULL;
    }

    if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
    {
        mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        return NULL;
    }

    pState->cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
    if ((pState->cur_file_ofs + pState->file_stat.m_comp_size) > pZip->m_archive_size)
    {
        mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        return NULL;
    }

    /* Decompress the file either directly from memory or from a file input buffer. */
    if (pZip->m_pState->m_pMem)
    {
        pState->pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + pState->cur_file_ofs;
        pState->read_buf_size = pState->read_buf_avail = pState->file_stat.m_comp_size;
        pState->comp_remaining = pState->file_stat.m_comp_size;
    }
    else
    {
        if (!((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!pState->file_stat.m_method)))
        {
            /* Decompression required, therefore intermediate read buffer required */
            pState->read_buf_size = MZ_MIN(pState->file_stat.m_comp_size, (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE);
            if (NULL == (pState->pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)pState->read_buf_size)))
            {
                mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
                pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
                return NULL;
            }
        }
        else
        {
            /* Decompression not required - we will be reading directly into user buffer, no temp buf required */
            pState->read_buf_size = 0;
        }
        pState->read_buf_avail = 0;
        pState->comp_remaining = pState->file_stat.m_comp_size;
    }

    if (!((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!pState->file_stat.m_method)))
    {
        /* Decompression required, init decompressor */
        tinfl_init( &pState->inflator );

        /* Allocate write buffer */
        if (NULL == (pState->pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, TINFL_LZ_DICT_SIZE)))
        {
            mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            if (pState->pRead_buf)
                pZip->m_pFree(pZip->m_pAlloc_opaque, pState->pRead_buf);
            pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
            return NULL;
        }
    }

    return pState;
}

mz_zip_reader_extract_iter_state* mz_zip_reader_extract_file_iter_new(mz_zip_archive *pZip, const char *pFilename, mz_uint flags)
{
    mz_uint32 file_index;

    /* Locate file index by name */
    if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
        return NULL;

    /* Construct iterator */
    return mz_zip_reader_extract_iter_new(pZip, file_index, flags);
}

size_t mz_zip_reader_extract_iter_read(mz_zip_reader_extract_iter_state* pState, void* pvBuf, size_t buf_size)
{
    size_t copied_to_caller = 0;

    /* Argument sanity check */
    if ((!pState) || (!pState->pZip) || (!pState->pZip->m_pState) || (!pvBuf))
        return 0;

    if ((pState->flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!pState->file_stat.m_method))
    {
        /* The file is stored or the caller has requested the compressed data, calc amount to return. */
        copied_to_caller = (size_t)MZ_MIN( buf_size, pState->comp_remaining );

        /* Zip is in memory....or requires reading from a file? */
        if (pState->pZip->m_pState->m_pMem)
        {
            /* Copy data to caller's buffer */
            memcpy( pvBuf, pState->pRead_buf, copied_to_caller );
            pState->pRead_buf = ((mz_uint8*)pState->pRead_buf) + copied_to_caller;
        }
        else
        {
            /* Read directly into caller's buffer */
            if (pState->pZip->m_pRead(pState->pZip->m_pIO_opaque, pState->cur_file_ofs, pvBuf, copied_to_caller) != copied_to_caller)
            {
                /* Failed to read all that was asked for, flag failure and alert user */
                mz_zip_set_error(pState->pZip, MZ_ZIP_FILE_READ_FAILED);
                pState->status = TINFL_STATUS_FAILED;
                copied_to_caller = 0;
            }
        }

#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
        /* Compute CRC if not returning compressed data only */
        if (!(pState->flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
            pState->file_crc32 = (mz_uint32)mz_crc32(pState->file_crc32, (const mz_uint8 *)pvBuf, copied_to_caller);
#endif

        /* Advance offsets, dec counters */
        pState->cur_file_ofs += copied_to_caller;
        pState->out_buf_ofs += copied_to_caller;
        pState->comp_remaining -= copied_to_caller;
    }
    else
    {
        do
        {
            /* Calc ptr to write buffer - given current output pos and block size */
            mz_uint8 *pWrite_buf_cur = (mz_uint8 *)pState->pWrite_buf + (pState->out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));

            /* Calc max output size - given current output pos and block size */
            size_t in_buf_size, out_buf_size = TINFL_LZ_DICT_SIZE - (pState->out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));

            if (!pState->out_blk_remain)
            {
                /* Read more data from file if none available (and reading from file) */
                if ((!pState->read_buf_avail) && (!pState->pZip->m_pState->m_pMem))
                {
                    /* Calc read size */
                    pState->read_buf_avail = MZ_MIN(pState->read_buf_size, pState->comp_remaining);
                    if (pState->pZip->m_pRead(pState->pZip->m_pIO_opaque, pState->cur_file_ofs, pState->pRead_buf, (size_t)pState->read_buf_avail) != pState->read_buf_avail)
                    {
                        mz_zip_set_error(pState->pZip, MZ_ZIP_FILE_READ_FAILED);
                        pState->status = TINFL_STATUS_FAILED;
                        break;
                    }

                    /* Advance offsets, dec counters */
                    pState->cur_file_ofs += pState->read_buf_avail;
                    pState->comp_remaining -= pState->read_buf_avail;
                    pState->read_buf_ofs = 0;
                }

                /* Perform decompression */
                in_buf_size = (size_t)pState->read_buf_avail;
                pState->status = tinfl_decompress(&pState->inflator, (const mz_uint8 *)pState->pRead_buf + pState->read_buf_ofs, &in_buf_size, (mz_uint8 *)pState->pWrite_buf, pWrite_buf_cur, &out_buf_size, pState->comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);
                pState->read_buf_avail -= in_buf_size;
                pState->read_buf_ofs += in_buf_size;

                /* Update current output block size remaining */
                pState->out_blk_remain = out_buf_size;
            }

            if (pState->out_blk_remain)
            {
                /* Calc amount to return. */
                size_t to_copy = MZ_MIN( (buf_size - copied_to_caller), pState->out_blk_remain );

                /* Copy data to caller's buffer */
                memcpy( (mz_uint8*)pvBuf + copied_to_caller, pWrite_buf_cur, to_copy );

#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
                /* Perform CRC */
                pState->file_crc32 = (mz_uint32)mz_crc32(pState->file_crc32, pWrite_buf_cur, to_copy);
#endif

                /* Decrement data consumed from block */
                pState->out_blk_remain -= to_copy;

                /* Inc output offset, while performing sanity check */
                if ((pState->out_buf_ofs += to_copy) > pState->file_stat.m_uncomp_size)
                {
                    mz_zip_set_error(pState->pZip, MZ_ZIP_DECOMPRESSION_FAILED);
                    pState->status = TINFL_STATUS_FAILED;
                    break;
                }

                /* Increment counter of data copied to caller */
                copied_to_caller += to_copy;
            }
        } while ( (copied_to_caller < buf_size) && ((pState->status == TINFL_STATUS_NEEDS_MORE_INPUT) || (pState->status == TINFL_STATUS_HAS_MORE_OUTPUT)) );
    }

    /* Return how many bytes were copied into user buffer */
    return copied_to_caller;
}

mz_bool mz_zip_reader_extract_iter_free(mz_zip_reader_extract_iter_state* pState)
{
    int status;

    /* Argument sanity check */
    if ((!pState) || (!pState->pZip) || (!pState->pZip->m_pState))
        return MZ_FALSE;

    /* Was decompression completed and requested? */
    if ((pState->status == TINFL_STATUS_DONE) && (!(pState->flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
    {
        /* Make sure the entire file was decompressed, and check its CRC. */
        if (pState->out_buf_ofs != pState->file_stat.m_uncomp_size)
        {
            mz_zip_set_error(pState->pZip, MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
            pState->status = TINFL_STATUS_FAILED;
        }
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
        else if (pState->file_crc32 != pState->file_stat.m_crc32)
        {
            mz_zip_set_error(pState->pZip, MZ_ZIP_DECOMPRESSION_FAILED);
            pState->status = TINFL_STATUS_FAILED;
        }
#endif
    }

    /* Free buffers */
    if (!pState->pZip->m_pState->m_pMem)
        pState->pZip->m_pFree(pState->pZip->m_pAlloc_opaque, pState->pRead_buf);
    if (pState->pWrite_buf)
        pState->pZip->m_pFree(pState->pZip->m_pAlloc_opaque, pState->pWrite_buf);

    /* Save status */
    status = pState->status;

    /* Free context */
    pState->pZip->m_pFree(pState->pZip->m_pAlloc_opaque, pState);

    return status == TINFL_STATUS_DONE;
}

#ifndef MINIZ_NO_STDIO
static size_t mz_zip_file_write_callback(void *pOpaque, mz_uint64 ofs, const void *pBuf, size_t n)
{
    (void)ofs;

    return MZ_FWRITE(pBuf, 1, n, (MZ_FILE *)pOpaque);
}

mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags)
{
    mz_bool status;
    mz_zip_archive_file_stat file_stat;
    MZ_FILE *pFile;

    if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
        return MZ_FALSE;

    if ((file_stat.m_is_directory) || (!file_stat.m_is_supported))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);

    pFile = MZ_FOPEN(pDst_filename, "wb");
    if (!pFile)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);

    status = mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_file_write_callback, pFile, flags);

    if (MZ_FCLOSE(pFile) == EOF)
    {
        if (status)
            mz_zip_set_error(pZip, MZ_ZIP_FILE_CLOSE_FAILED);

        status = MZ_FALSE;
    }

#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_STDIO)
    if (status)
        mz_zip_set_file_times(pDst_filename, file_stat.m_time, file_stat.m_time);
#endif

    return status;
}

mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags)
{
    mz_uint32 file_index;
    if (!mz_zip_reader_locate_file_v2(pZip, pArchive_filename, NULL, flags, &file_index))
        return MZ_FALSE;

    return mz_zip_reader_extract_to_file(pZip, file_index, pDst_filename, flags);
}

mz_bool mz_zip_reader_extract_to_cfile(mz_zip_archive *pZip, mz_uint file_index, MZ_FILE *pFile, mz_uint flags)
{
    mz_zip_archive_file_stat file_stat;

    if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
        return MZ_FALSE;

    if ((file_stat.m_is_directory) || (!file_stat.m_is_supported))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);

    return mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_file_write_callback, pFile, flags);
}

mz_bool mz_zip_reader_extract_file_to_cfile(mz_zip_archive *pZip, const char *pArchive_filename, MZ_FILE *pFile, mz_uint flags)
{
    mz_uint32 file_index;
    if (!mz_zip_reader_locate_file_v2(pZip, pArchive_filename, NULL, flags, &file_index))
        return MZ_FALSE;

    return mz_zip_reader_extract_to_cfile(pZip, file_index, pFile, flags);
}
#endif /* #ifndef MINIZ_NO_STDIO */

static size_t mz_zip_compute_crc32_callback(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
{
    mz_uint32 *p = (mz_uint32 *)pOpaque;
    (void)file_ofs;
    *p = (mz_uint32)mz_crc32(*p, (const mz_uint8 *)pBuf, n);
    return n;
}

mz_bool mz_zip_validate_file(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags)
{
    mz_zip_archive_file_stat file_stat;
    mz_zip_internal_state *pState;
    const mz_uint8 *pCentral_dir_header;
    mz_bool found_zip64_ext_data_in_cdir = MZ_FALSE;
    mz_bool found_zip64_ext_data_in_ldir = MZ_FALSE;
    mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
    mz_uint64 local_header_ofs = 0;
    mz_uint32 local_header_filename_len, local_header_extra_len, local_header_crc32;
    mz_uint64 local_header_comp_size, local_header_uncomp_size;
    mz_uint32 uncomp_crc32 = MZ_CRC32_INIT;
    mz_bool has_data_descriptor;
    mz_uint32 local_header_bit_flags;

    mz_zip_array file_data_array;
    mz_zip_array_init(&file_data_array, 1);

    if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || (!pZip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (file_index > pZip->m_total_files)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pState = pZip->m_pState;

    pCentral_dir_header = mz_zip_get_cdh(pZip, file_index);

    if (!mz_zip_file_stat_internal(pZip, file_index, pCentral_dir_header, &file_stat, &found_zip64_ext_data_in_cdir))
        return MZ_FALSE;

    /* A directory or zero length file */
    if ((file_stat.m_is_directory) || (!file_stat.m_uncomp_size))
        return MZ_TRUE;

    /* Encryption and patch files are not supported. */
    if (file_stat.m_is_encrypted)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);

    /* This function only supports stored and deflate. */
    if ((file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);

    if (!file_stat.m_is_supported)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);

    /* Read and parse the local directory entry. */
    local_header_ofs = file_stat.m_local_header_ofs;
    if (pZip->m_pRead(pZip->m_pIO_opaque, local_header_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

    if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    local_header_filename_len = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS);
    local_header_extra_len = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
    local_header_comp_size = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS);
    local_header_uncomp_size = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS);
    local_header_crc32 = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_CRC32_OFS);
    local_header_bit_flags = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS);
    has_data_descriptor = (local_header_bit_flags & 8) != 0;

    if (local_header_filename_len != strlen(file_stat.m_filename))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    if ((local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + local_header_filename_len + local_header_extra_len + file_stat.m_comp_size) > pZip->m_archive_size)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    if (!mz_zip_array_resize(pZip, &file_data_array, MZ_MAX(local_header_filename_len, local_header_extra_len), MZ_FALSE))
    {
        mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        goto handle_failure;
    }

    if (local_header_filename_len)
    {
        if (pZip->m_pRead(pZip->m_pIO_opaque, local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE, file_data_array.m_p, local_header_filename_len) != local_header_filename_len)
        {
            mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
            goto handle_failure;
        }

        /* I've seen 1 archive that had the same pathname, but used backslashes in the local dir and forward slashes in the central dir. Do we care about this? For now, this case will fail validation. */
        if (memcmp(file_stat.m_filename, file_data_array.m_p, local_header_filename_len) != 0)
        {
            mz_zip_set_error(pZip, MZ_ZIP_VALIDATION_FAILED);
            goto handle_failure;
        }
    }

    if ((local_header_extra_len) && ((local_header_comp_size == MZ_UINT32_MAX) || (local_header_uncomp_size == MZ_UINT32_MAX)))
    {
        mz_uint32 extra_size_remaining = local_header_extra_len;
        const mz_uint8 *pExtra_data = (const mz_uint8 *)file_data_array.m_p;

        if (pZip->m_pRead(pZip->m_pIO_opaque, local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + local_header_filename_len, file_data_array.m_p, local_header_extra_len) != local_header_extra_len)
        {
            mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
            goto handle_failure;
        }

        do
        {
            mz_uint32 field_id, field_data_size, field_total_size;

            if (extra_size_remaining < (sizeof(mz_uint16) * 2))
            {
                mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                goto handle_failure;
            }

            field_id = MZ_READ_LE16(pExtra_data);
            field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));
            field_total_size = field_data_size + sizeof(mz_uint16) * 2;

            if (field_total_size > extra_size_remaining)
            {
                mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                goto handle_failure;
            }

            if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
            {
                const mz_uint8 *pSrc_field_data = pExtra_data + sizeof(mz_uint32);

                if (field_data_size < sizeof(mz_uint64) * 2)
                {
                    mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                    goto handle_failure;
                }

                local_header_uncomp_size = MZ_READ_LE64(pSrc_field_data);
                local_header_comp_size = MZ_READ_LE64(pSrc_field_data + sizeof(mz_uint64));

                found_zip64_ext_data_in_ldir = MZ_TRUE;
                break;
            }

            pExtra_data += field_total_size;
            extra_size_remaining -= field_total_size;
        } while (extra_size_remaining);
    }

    /* TODO: parse local header extra data when local_header_comp_size is 0xFFFFFFFF! (big_descriptor.zip) */
    /* I've seen zips in the wild with the data descriptor bit set, but proper local header values and bogus data descriptors */
    if ((has_data_descriptor) && (!local_header_comp_size) && (!local_header_crc32))
    {
        mz_uint8 descriptor_buf[32];
        mz_bool has_id;
        const mz_uint8 *pSrc;
        mz_uint32 file_crc32;
        mz_uint64 comp_size = 0, uncomp_size = 0;

        mz_uint32 num_descriptor_uint32s = ((pState->m_zip64) || (found_zip64_ext_data_in_ldir)) ? 6 : 4;

        if (pZip->m_pRead(pZip->m_pIO_opaque, local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + local_header_filename_len + local_header_extra_len + file_stat.m_comp_size, descriptor_buf, sizeof(mz_uint32) * num_descriptor_uint32s) != (sizeof(mz_uint32) * num_descriptor_uint32s))
        {
            mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
            goto handle_failure;
        }

        has_id = (MZ_READ_LE32(descriptor_buf) == MZ_ZIP_DATA_DESCRIPTOR_ID);
        pSrc = has_id ? (descriptor_buf + sizeof(mz_uint32)) : descriptor_buf;

        file_crc32 = MZ_READ_LE32(pSrc);

        if ((pState->m_zip64) || (found_zip64_ext_data_in_ldir))
        {
            comp_size = MZ_READ_LE64(pSrc + sizeof(mz_uint32));
            uncomp_size = MZ_READ_LE64(pSrc + sizeof(mz_uint32) + sizeof(mz_uint64));
        }
        else
        {
            comp_size = MZ_READ_LE32(pSrc + sizeof(mz_uint32));
            uncomp_size = MZ_READ_LE32(pSrc + sizeof(mz_uint32) + sizeof(mz_uint32));
        }

        if ((file_crc32 != file_stat.m_crc32) || (comp_size != file_stat.m_comp_size) || (uncomp_size != file_stat.m_uncomp_size))
        {
            mz_zip_set_error(pZip, MZ_ZIP_VALIDATION_FAILED);
            goto handle_failure;
        }
    }
    else
    {
        if ((local_header_crc32 != file_stat.m_crc32) || (local_header_comp_size != file_stat.m_comp_size) || (local_header_uncomp_size != file_stat.m_uncomp_size))
        {
            mz_zip_set_error(pZip, MZ_ZIP_VALIDATION_FAILED);
            goto handle_failure;
        }
    }

    mz_zip_array_clear(pZip, &file_data_array);

    if ((flags & MZ_ZIP_FLAG_VALIDATE_HEADERS_ONLY) == 0)
    {
        if (!mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_compute_crc32_callback, &uncomp_crc32, 0))
            return MZ_FALSE;

        /* 1 more check to be sure, although the extract checks too. */
        if (uncomp_crc32 != file_stat.m_crc32)
        {
            mz_zip_set_error(pZip, MZ_ZIP_VALIDATION_FAILED);
            return MZ_FALSE;
        }
    }

    return MZ_TRUE;

handle_failure:
    mz_zip_array_clear(pZip, &file_data_array);
    return MZ_FALSE;
}

mz_bool mz_zip_validate_archive(mz_zip_archive *pZip, mz_uint flags)
{
    mz_zip_internal_state *pState;
    mz_uint32 i;

    if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || (!pZip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pState = pZip->m_pState;

    /* Basic sanity checks */
    if (!pState->m_zip64)
    {
        if (pZip->m_total_files > MZ_UINT16_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);

        if (pZip->m_archive_size > MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
    }
    else
    {
        if (pState->m_central_dir.m_size >= MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
    }

    for (i = 0; i < pZip->m_total_files; i++)
    {
        if (MZ_ZIP_FLAG_VALIDATE_LOCATE_FILE_FLAG & flags)
        {
            mz_uint32 found_index;
            mz_zip_archive_file_stat stat;

            if (!mz_zip_reader_file_stat(pZip, i, &stat))
                return MZ_FALSE;

            if (!mz_zip_reader_locate_file_v2(pZip, stat.m_filename, NULL, 0, &found_index))
                return MZ_FALSE;

            /* This check can fail if there are duplicate filenames in the archive (which we don't check for when writing - that's up to the user) */
            if (found_index != i)
                return mz_zip_set_error(pZip, MZ_ZIP_VALIDATION_FAILED);
        }

        if (!mz_zip_validate_file(pZip, i, flags))
            return MZ_FALSE;
    }

    return MZ_TRUE;
}

mz_bool mz_zip_validate_mem_archive(const void *pMem, size_t size, mz_uint flags, mz_zip_error *pErr)
{
    mz_bool success = MZ_TRUE;
    mz_zip_archive zip;
    mz_zip_error actual_err = MZ_ZIP_NO_ERROR;

    if ((!pMem) || (!size))
    {
        if (pErr)
            *pErr = MZ_ZIP_INVALID_PARAMETER;
        return MZ_FALSE;
    }

    mz_zip_zero_struct(&zip);

    if (!mz_zip_reader_init_mem(&zip, pMem, size, flags))
    {
        if (pErr)
            *pErr = zip.m_last_error;
        return MZ_FALSE;
    }

    if (!mz_zip_validate_archive(&zip, flags))
    {
        actual_err = zip.m_last_error;
        success = MZ_FALSE;
    }

    if (!mz_zip_reader_end_internal(&zip, success))
    {
        if (!actual_err)
            actual_err = zip.m_last_error;
        success = MZ_FALSE;
    }

    if (pErr)
        *pErr = actual_err;

    return success;
}

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_validate_file_archive(const char *pFilename, mz_uint flags, mz_zip_error *pErr)
{
    mz_bool success = MZ_TRUE;
    mz_zip_archive zip;
    mz_zip_error actual_err = MZ_ZIP_NO_ERROR;

    if (!pFilename)
    {
        if (pErr)
            *pErr = MZ_ZIP_INVALID_PARAMETER;
        return MZ_FALSE;
    }

    mz_zip_zero_struct(&zip);

    if (!mz_zip_reader_init_file_v2(&zip, pFilename, flags, 0, 0))
    {
        if (pErr)
            *pErr = zip.m_last_error;
        return MZ_FALSE;
    }

    if (!mz_zip_validate_archive(&zip, flags))
    {
        actual_err = zip.m_last_error;
        success = MZ_FALSE;
    }

    if (!mz_zip_reader_end_internal(&zip, success))
    {
        if (!actual_err)
            actual_err = zip.m_last_error;
        success = MZ_FALSE;
    }

    if (pErr)
        *pErr = actual_err;

    return success;
}
#endif /* #ifndef MINIZ_NO_STDIO */

/* ------------------- .ZIP archive writing */

#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

static MZ_FORCEINLINE void mz_write_le16(mz_uint8 *p, mz_uint16 v)
{
    p[0] = (mz_uint8)v;
    p[1] = (mz_uint8)(v >> 8);
}
static MZ_FORCEINLINE void mz_write_le32(mz_uint8 *p, mz_uint32 v)
{
    p[0] = (mz_uint8)v;
    p[1] = (mz_uint8)(v >> 8);
    p[2] = (mz_uint8)(v >> 16);
    p[3] = (mz_uint8)(v >> 24);
}
static MZ_FORCEINLINE void mz_write_le64(mz_uint8 *p, mz_uint64 v)
{
    mz_write_le32(p, (mz_uint32)v);
    mz_write_le32(p + sizeof(mz_uint32), (mz_uint32)(v >> 32));
}

#define MZ_WRITE_LE16(p, v) mz_write_le16((mz_uint8 *)(p), (mz_uint16)(v))
#define MZ_WRITE_LE32(p, v) mz_write_le32((mz_uint8 *)(p), (mz_uint32)(v))
#define MZ_WRITE_LE64(p, v) mz_write_le64((mz_uint8 *)(p), (mz_uint64)(v))

static size_t mz_zip_heap_write_func(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
{
    mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
    mz_zip_internal_state *pState = pZip->m_pState;
    mz_uint64 new_size = MZ_MAX(file_ofs + n, pState->m_mem_size);

    if (!n)
        return 0;

    /* An allocation this big is likely to just fail on 32-bit systems, so don't even go there. */
    if ((sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF))
    {
        mz_zip_set_error(pZip, MZ_ZIP_FILE_TOO_LARGE);
        return 0;
    }

    if (new_size > pState->m_mem_capacity)
    {
        void *pNew_block;
        size_t new_capacity = MZ_MAX(64, pState->m_mem_capacity);

        while (new_capacity < new_size)
            new_capacity *= 2;

        if (NULL == (pNew_block = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pState->m_pMem, 1, new_capacity)))
        {
            mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            return 0;
        }

        pState->m_pMem = pNew_block;
        pState->m_mem_capacity = new_capacity;
    }
    memcpy((mz_uint8 *)pState->m_pMem + file_ofs, pBuf, n);
    pState->m_mem_size = (size_t)new_size;
    return n;
}

static mz_bool mz_zip_writer_end_internal(mz_zip_archive *pZip, mz_bool set_last_error)
{
    mz_zip_internal_state *pState;
    mz_bool status = MZ_TRUE;

    if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || ((pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) && (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED)))
    {
        if (set_last_error)
            mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        return MZ_FALSE;
    }

    pState = pZip->m_pState;
    pZip->m_pState = NULL;
    mz_zip_array_clear(pZip, &pState->m_central_dir);
    mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
    mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);

#ifndef MINIZ_NO_STDIO
    if (pState->m_pFile)
    {
        if (pZip->m_zip_type == MZ_ZIP_TYPE_FILE)
        {
            if (MZ_FCLOSE(pState->m_pFile) == EOF)
            {
                if (set_last_error)
                    mz_zip_set_error(pZip, MZ_ZIP_FILE_CLOSE_FAILED);
                status = MZ_FALSE;
            }
        }

        pState->m_pFile = NULL;
    }
#endif /* #ifndef MINIZ_NO_STDIO */

    if ((pZip->m_pWrite == mz_zip_heap_write_func) && (pState->m_pMem))
    {
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState->m_pMem);
        pState->m_pMem = NULL;
    }

    pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
    pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
    return status;
}

mz_bool mz_zip_writer_init_v2(mz_zip_archive *pZip, mz_uint64 existing_size, mz_uint flags)
{
    mz_bool zip64 = (flags & MZ_ZIP_FLAG_WRITE_ZIP64) != 0;

    if ((!pZip) || (pZip->m_pState) || (!pZip->m_pWrite) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
    {
        if (!pZip->m_pRead)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
    }

    if (pZip->m_file_offset_alignment)
    {
        /* Ensure user specified file offset alignment is a power of 2. */
        if (pZip->m_file_offset_alignment & (pZip->m_file_offset_alignment - 1))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
    }

    if (!pZip->m_pAlloc)
        pZip->m_pAlloc = miniz_def_alloc_func;
    if (!pZip->m_pFree)
        pZip->m_pFree = miniz_def_free_func;
    if (!pZip->m_pRealloc)
        pZip->m_pRealloc = miniz_def_realloc_func;

    pZip->m_archive_size = existing_size;
    pZip->m_central_directory_file_ofs = 0;
    pZip->m_total_files = 0;

    if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

    memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));

    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));

    pZip->m_pState->m_zip64 = zip64;
    pZip->m_pState->m_zip64_has_extended_info_fields = zip64;

    pZip->m_zip_type = MZ_ZIP_TYPE_USER;
    pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;

    return MZ_TRUE;
}

mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size)
{
    return mz_zip_writer_init_v2(pZip, existing_size, 0);
}

mz_bool mz_zip_writer_init_heap_v2(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size, mz_uint flags)
{
    pZip->m_pWrite = mz_zip_heap_write_func;
    pZip->m_pNeeds_keepalive = NULL;

    if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
        pZip->m_pRead = mz_zip_mem_read_func;

    pZip->m_pIO_opaque = pZip;

    if (!mz_zip_writer_init_v2(pZip, size_to_reserve_at_beginning, flags))
        return MZ_FALSE;

    pZip->m_zip_type = MZ_ZIP_TYPE_HEAP;

    if (0 != (initial_allocation_size = MZ_MAX(initial_allocation_size, size_to_reserve_at_beginning)))
    {
        if (NULL == (pZip->m_pState->m_pMem = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, initial_allocation_size)))
        {
            mz_zip_writer_end_internal(pZip, MZ_FALSE);
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }
        pZip->m_pState->m_mem_capacity = initial_allocation_size;
    }

    return MZ_TRUE;
}

mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size)
{
    return mz_zip_writer_init_heap_v2(pZip, size_to_reserve_at_beginning, initial_allocation_size, 0);
}

#ifndef MINIZ_NO_STDIO
static size_t mz_zip_file_write_func(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
{
    mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
    mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);

    file_ofs += pZip->m_pState->m_file_archive_start_ofs;

    if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
    {
        mz_zip_set_error(pZip, MZ_ZIP_FILE_SEEK_FAILED);
        return 0;
    }

    return MZ_FWRITE(pBuf, 1, n, pZip->m_pState->m_pFile);
}

mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning)
{
    return mz_zip_writer_init_file_v2(pZip, pFilename, size_to_reserve_at_beginning, 0);
}

mz_bool mz_zip_writer_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning, mz_uint flags)
{
    MZ_FILE *pFile;

    pZip->m_pWrite = mz_zip_file_write_func;
    pZip->m_pNeeds_keepalive = NULL;

    if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
        pZip->m_pRead = mz_zip_file_read_func;

    pZip->m_pIO_opaque = pZip;

    if (!mz_zip_writer_init_v2(pZip, size_to_reserve_at_beginning, flags))
        return MZ_FALSE;

    if (NULL == (pFile = MZ_FOPEN(pFilename, (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING) ? "w+b" : "wb")))
    {
        mz_zip_writer_end(pZip);
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);
    }

    pZip->m_pState->m_pFile = pFile;
    pZip->m_zip_type = MZ_ZIP_TYPE_FILE;

    if (size_to_reserve_at_beginning)
    {
        mz_uint64 cur_ofs = 0;
        char buf[4096];

        MZ_CLEAR_ARR(buf);

        do
        {
            size_t n = (size_t)MZ_MIN(sizeof(buf), size_to_reserve_at_beginning);
            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_ofs, buf, n) != n)
            {
                mz_zip_writer_end(pZip);
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
            }
            cur_ofs += n;
            size_to_reserve_at_beginning -= n;
        } while (size_to_reserve_at_beginning);
    }

    return MZ_TRUE;
}

mz_bool mz_zip_writer_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint flags)
{
    pZip->m_pWrite = mz_zip_file_write_func;
    pZip->m_pNeeds_keepalive = NULL;

    if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
        pZip->m_pRead = mz_zip_file_read_func;

    pZip->m_pIO_opaque = pZip;

    if (!mz_zip_writer_init_v2(pZip, 0, flags))
        return MZ_FALSE;

    pZip->m_pState->m_pFile = pFile;
    pZip->m_pState->m_file_archive_start_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
    pZip->m_zip_type = MZ_ZIP_TYPE_CFILE;

    return MZ_TRUE;
}
#endif /* #ifndef MINIZ_NO_STDIO */

mz_bool mz_zip_writer_init_from_reader_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags)
{
    mz_zip_internal_state *pState;

    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (flags & MZ_ZIP_FLAG_WRITE_ZIP64)
    {
        /* We don't support converting a non-zip64 file to zip64 - this seems like more trouble than it's worth. (What about the existing 32-bit data descriptors that could follow the compressed data?) */
        if (!pZip->m_pState->m_zip64)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
    }

    /* No sense in trying to write to an archive that's already at the support max size */
    if (pZip->m_pState->m_zip64)
    {
        if (pZip->m_total_files == MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }
    else
    {
        if (pZip->m_total_files == MZ_UINT16_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);

        if ((pZip->m_archive_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_ZIP_LOCAL_DIR_HEADER_SIZE) > MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_TOO_LARGE);
    }

    pState = pZip->m_pState;

    if (pState->m_pFile)
    {
#ifdef MINIZ_NO_STDIO
        (void)pFilename;
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
#else
        if (pZip->m_pIO_opaque != pZip)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        if (pZip->m_zip_type == MZ_ZIP_TYPE_FILE)
        {
            if (!pFilename)
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

            /* Archive is being read from stdio and was originally opened only for reading. Try to reopen as writable. */
            if (NULL == (pState->m_pFile = MZ_FREOPEN(pFilename, "r+b", pState->m_pFile)))
            {
                /* The mz_zip_archive is now in a bogus state because pState->m_pFile is NULL, so just close it. */
                mz_zip_reader_end_internal(pZip, MZ_FALSE);
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);
            }
        }

        pZip->m_pWrite = mz_zip_file_write_func;
        pZip->m_pNeeds_keepalive = NULL;
#endif /* #ifdef MINIZ_NO_STDIO */
    }
    else if (pState->m_pMem)
    {
        /* Archive lives in a memory block. Assume it's from the heap that we can resize using the realloc callback. */
        if (pZip->m_pIO_opaque != pZip)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        pState->m_mem_capacity = pState->m_mem_size;
        pZip->m_pWrite = mz_zip_heap_write_func;
        pZip->m_pNeeds_keepalive = NULL;
    }
    /* Archive is being read via a user provided read function - make sure the user has specified a write function too. */
    else if (!pZip->m_pWrite)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    /* Start writing new files at the archive's current central directory location. */
    /* TODO: We could add a flag that lets the user start writing immediately AFTER the existing central dir - this would be safer. */
    pZip->m_archive_size = pZip->m_central_directory_file_ofs;
    pZip->m_central_directory_file_ofs = 0;

    /* Clear the sorted central dir offsets, they aren't useful or maintained now. */
    /* Even though we're now in write mode, files can still be extracted and verified, but file locates will be slow. */
    /* TODO: We could easily maintain the sorted central directory offsets. */
    mz_zip_array_clear(pZip, &pZip->m_pState->m_sorted_central_dir_offsets);

    pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;

    return MZ_TRUE;
}

mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename)
{
    return mz_zip_writer_init_from_reader_v2(pZip, pFilename, 0);
}

/* TODO: pArchive_name is a terrible name here! */
mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags)
{
    return mz_zip_writer_add_mem_ex(pZip, pArchive_name, pBuf, buf_size, NULL, 0, level_and_flags, 0, 0);
}

typedef struct
{
    mz_zip_archive *m_pZip;
    mz_uint64 m_cur_archive_file_ofs;
    mz_uint64 m_comp_size;
} mz_zip_writer_add_state;

static mz_bool mz_zip_writer_add_put_buf_callback(const void *pBuf, int len, void *pUser)
{
    mz_zip_writer_add_state *pState = (mz_zip_writer_add_state *)pUser;
    if ((int)pState->m_pZip->m_pWrite(pState->m_pZip->m_pIO_opaque, pState->m_cur_archive_file_ofs, pBuf, len) != len)
        return MZ_FALSE;

    pState->m_cur_archive_file_ofs += len;
    pState->m_comp_size += len;
    return MZ_TRUE;
}

#define MZ_ZIP64_MAX_LOCAL_EXTRA_FIELD_SIZE (sizeof(mz_uint16) * 2 + sizeof(mz_uint64) * 2)
#define MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE (sizeof(mz_uint16) * 2 + sizeof(mz_uint64) * 3)
static mz_uint32 mz_zip_writer_create_zip64_extra_data(mz_uint8 *pBuf, mz_uint64 *pUncomp_size, mz_uint64 *pComp_size, mz_uint64 *pLocal_header_ofs)
{
    mz_uint8 *pDst = pBuf;
    mz_uint32 field_size = 0;

    MZ_WRITE_LE16(pDst + 0, MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID);
    MZ_WRITE_LE16(pDst + 2, 0);
    pDst += sizeof(mz_uint16) * 2;

    if (pUncomp_size)
    {
        MZ_WRITE_LE64(pDst, *pUncomp_size);
        pDst += sizeof(mz_uint64);
        field_size += sizeof(mz_uint64);
    }

    if (pComp_size)
    {
        MZ_WRITE_LE64(pDst, *pComp_size);
        pDst += sizeof(mz_uint64);
        field_size += sizeof(mz_uint64);
    }

    if (pLocal_header_ofs)
    {
        MZ_WRITE_LE64(pDst, *pLocal_header_ofs);
        pDst += sizeof(mz_uint64);
        field_size += sizeof(mz_uint64);
    }

    MZ_WRITE_LE16(pBuf + 2, field_size);

    return (mz_uint32)(pDst - pBuf);
}

static mz_bool mz_zip_writer_create_local_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size, mz_uint16 extra_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date)
{
    (void)pZip;
    memset(pDst, 0, MZ_ZIP_LOCAL_DIR_HEADER_SIZE);
    MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_SIG_OFS, MZ_ZIP_LOCAL_DIR_HEADER_SIG);
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_VERSION_NEEDED_OFS, method ? 20 : 0);
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_BIT_FLAG_OFS, bit_flags);
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_METHOD_OFS, method);
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_TIME_OFS, dos_time);
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_DATE_OFS, dos_date);
    MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_CRC32_OFS, uncomp_crc32);
    MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS, MZ_MIN(comp_size, MZ_UINT32_MAX));
    MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS, MZ_MIN(uncomp_size, MZ_UINT32_MAX));
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILENAME_LEN_OFS, filename_size);
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_EXTRA_LEN_OFS, extra_size);
    return MZ_TRUE;
}

static mz_bool mz_zip_writer_create_central_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst,
                                                       mz_uint16 filename_size, mz_uint16 extra_size, mz_uint16 comment_size,
                                                       mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32,
                                                       mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date,
                                                       mz_uint64 local_header_ofs, mz_uint32 ext_attributes)
{
    (void)pZip;
    memset(pDst, 0, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_SIG_OFS, MZ_ZIP_CENTRAL_DIR_HEADER_SIG);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_VERSION_NEEDED_OFS, method ? 20 : 0);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_BIT_FLAG_OFS, bit_flags);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_METHOD_OFS, method);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_TIME_OFS, dos_time);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_DATE_OFS, dos_date);
    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_CRC32_OFS, uncomp_crc32);
    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, MZ_MIN(comp_size, MZ_UINT32_MAX));
    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, MZ_MIN(uncomp_size, MZ_UINT32_MAX));
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILENAME_LEN_OFS, filename_size);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_EXTRA_LEN_OFS, extra_size);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_COMMENT_LEN_OFS, comment_size);
    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS, ext_attributes);
    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_LOCAL_HEADER_OFS, MZ_MIN(local_header_ofs, MZ_UINT32_MAX));
    return MZ_TRUE;
}

static mz_bool mz_zip_writer_add_to_central_dir(mz_zip_archive *pZip, const char *pFilename, mz_uint16 filename_size,
                                                const void *pExtra, mz_uint16 extra_size, const void *pComment, mz_uint16 comment_size,
                                                mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32,
                                                mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date,
                                                mz_uint64 local_header_ofs, mz_uint32 ext_attributes,
                                                const char *user_extra_data, mz_uint user_extra_data_len)
{
    mz_zip_internal_state *pState = pZip->m_pState;
    mz_uint32 central_dir_ofs = (mz_uint32)pState->m_central_dir.m_size;
    size_t orig_central_dir_size = pState->m_central_dir.m_size;
    mz_uint8 central_dir_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];

    if (!pZip->m_pState->m_zip64)
    {
        if (local_header_ofs > 0xFFFFFFFF)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_TOO_LARGE);
    }

    /* miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet */
    if (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + extra_size + user_extra_data_len + comment_size) >= MZ_UINT32_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);

    if (!mz_zip_writer_create_central_dir_header(pZip, central_dir_header, filename_size, (mz_uint16)(extra_size + user_extra_data_len), comment_size, uncomp_size, comp_size, uncomp_crc32, method, bit_flags, dos_time, dos_date, local_header_ofs, ext_attributes))
        return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

    if ((!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_dir_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)) ||
        (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pFilename, filename_size)) ||
        (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pExtra, extra_size)) ||
        (!mz_zip_array_push_back(pZip, &pState->m_central_dir, user_extra_data, user_extra_data_len)) ||
        (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pComment, comment_size)) ||
        (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &central_dir_ofs, 1)))
    {
        /* Try to resize the central directory array back into its original state. */
        mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
    }

    return MZ_TRUE;
}

static mz_bool mz_zip_writer_validate_archive_name(const char *pArchive_name)
{
    /* Basic ZIP archive filename validity checks: Valid filenames cannot start with a forward slash, cannot contain a drive letter, and cannot use DOS-style backward slashes. */
    if (*pArchive_name == '/')
        return MZ_FALSE;

    /* Making sure the name does not contain drive letters or DOS style backward slashes is the responsibility of the program using miniz*/

    return MZ_TRUE;
}

static mz_uint mz_zip_writer_compute_padding_needed_for_file_alignment(mz_zip_archive *pZip)
{
    mz_uint32 n;
    if (!pZip->m_file_offset_alignment)
        return 0;
    n = (mz_uint32)(pZip->m_archive_size & (pZip->m_file_offset_alignment - 1));
    return (mz_uint)((pZip->m_file_offset_alignment - n) & (pZip->m_file_offset_alignment - 1));
}

static mz_bool mz_zip_writer_write_zeros(mz_zip_archive *pZip, mz_uint64 cur_file_ofs, mz_uint32 n)
{
    char buf[4096];
    memset(buf, 0, MZ_MIN(sizeof(buf), n));
    while (n)
    {
        mz_uint32 s = MZ_MIN(sizeof(buf), n);
        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_file_ofs, buf, s) != s)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_file_ofs += s;
        n -= s;
    }
    return MZ_TRUE;
}

mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
                                 mz_uint64 uncomp_size, mz_uint32 uncomp_crc32)
{
    return mz_zip_writer_add_mem_ex_v2(pZip, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, uncomp_size, uncomp_crc32, NULL, NULL, 0, NULL, 0);
}

mz_bool mz_zip_writer_add_mem_ex_v2(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size,
                                    mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32, MZ_TIME_T *last_modified,
                                    const char *user_extra_data, mz_uint user_extra_data_len, const char *user_extra_data_central, mz_uint user_extra_data_central_len)
{
    mz_uint16 method = 0, dos_time = 0, dos_date = 0;
    mz_uint level, ext_attributes = 0, num_alignment_padding_bytes;
    mz_uint64 local_dir_header_ofs = pZip->m_archive_size, cur_archive_file_ofs = pZip->m_archive_size, comp_size = 0;
    size_t archive_name_size;
    mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
    tdefl_compressor *pComp = NULL;
    mz_bool store_data_uncompressed;
    mz_zip_internal_state *pState;
    mz_uint8 *pExtra_data = NULL;
    mz_uint32 extra_size = 0;
    mz_uint8 extra_data[MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE];
    mz_uint16 bit_flags = 0;

    if ((int)level_and_flags < 0)
        level_and_flags = MZ_DEFAULT_LEVEL;

    if (uncomp_size || (buf_size && !(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
        bit_flags |= MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR;

    if (!(level_and_flags & MZ_ZIP_FLAG_ASCII_FILENAME))
        bit_flags |= MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8;

    level = level_and_flags & 0xF;
    store_data_uncompressed = ((!level) || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA));

    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || ((buf_size) && (!pBuf)) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pState = pZip->m_pState;

    if (pState->m_zip64)
    {
        if (pZip->m_total_files == MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }
    else
    {
        if (pZip->m_total_files == MZ_UINT16_MAX)
        {
            pState->m_zip64 = MZ_TRUE;
            /*return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES); */
        }
        if (((mz_uint64)buf_size > 0xFFFFFFFF) || (uncomp_size > 0xFFFFFFFF))
        {
            pState->m_zip64 = MZ_TRUE;
            /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
        }
    }

    if ((!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (uncomp_size))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (!mz_zip_writer_validate_archive_name(pArchive_name))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);

#ifndef MINIZ_NO_TIME
    if (last_modified != NULL)
    {
        mz_zip_time_t_to_dos_time(*last_modified, &dos_time, &dos_date);
    }
    else
    {
        MZ_TIME_T cur_time;
        time(&cur_time);
        mz_zip_time_t_to_dos_time(cur_time, &dos_time, &dos_date);
    }
#endif /* #ifndef MINIZ_NO_TIME */

	if (!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
	{
		uncomp_crc32 = (mz_uint32)mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, buf_size);
		uncomp_size = buf_size;
		if (uncomp_size <= 3)
		{
			level = 0;
			store_data_uncompressed = MZ_TRUE;
		}
	}

    archive_name_size = strlen(pArchive_name);
    if (archive_name_size > MZ_UINT16_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);

    num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

    /* miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet */
    if (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE + comment_size) >= MZ_UINT32_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);

    if (!pState->m_zip64)
    {
        /* Bail early if the archive would obviously become too large */
        if ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + archive_name_size
			+ MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size + user_extra_data_len +
			pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE + user_extra_data_central_len
			+ MZ_ZIP_DATA_DESCRIPTER_SIZE32) > 0xFFFFFFFF)
        {
            pState->m_zip64 = MZ_TRUE;
            /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
        }
    }

    if ((archive_name_size) && (pArchive_name[archive_name_size - 1] == '/'))
    {
        /* Set DOS Subdirectory attribute bit. */
        ext_attributes |= MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG;

        /* Subdirectories cannot contain data. */
        if ((buf_size) || (uncomp_size))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
    }

    /* Try to do any allocations before writing to the archive, so if an allocation fails the file remains unmodified. (A good idea if we're doing an in-place modification.) */
    if ((!mz_zip_array_ensure_room(pZip, &pState->m_central_dir, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size + (pState->m_zip64 ? MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE : 0))) || (!mz_zip_array_ensure_room(pZip, &pState->m_central_dir_offsets, 1)))
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

    if ((!store_data_uncompressed) && (buf_size))
    {
        if (NULL == (pComp = (tdefl_compressor *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor))))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
    }

    if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes))
    {
        pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
        return MZ_FALSE;
    }

    local_dir_header_ofs += num_alignment_padding_bytes;
    if (pZip->m_file_offset_alignment)
    {
        MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
    }
    cur_archive_file_ofs += num_alignment_padding_bytes;

    MZ_CLEAR_ARR(local_dir_header);

    if (!store_data_uncompressed || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
    {
        method = MZ_DEFLATED;
    }

    if (pState->m_zip64)
    {
        if (uncomp_size >= MZ_UINT32_MAX || local_dir_header_ofs >= MZ_UINT32_MAX)
        {
            pExtra_data = extra_data;
            extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (uncomp_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
                                                               (uncomp_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
        }

        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, (mz_uint16)(extra_size + user_extra_data_len), 0, 0, 0, method, bit_flags, dos_time, dos_date))
            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_archive_file_ofs += sizeof(local_dir_header);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }
        cur_archive_file_ofs += archive_name_size;

        if (pExtra_data != NULL)
        {
            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, extra_data, extra_size) != extra_size)
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

            cur_archive_file_ofs += extra_size;
        }
    }
    else
    {
        if ((comp_size > MZ_UINT32_MAX) || (cur_archive_file_ofs > MZ_UINT32_MAX))
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, (mz_uint16)user_extra_data_len, 0, 0, 0, method, bit_flags, dos_time, dos_date))
            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_archive_file_ofs += sizeof(local_dir_header);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }
        cur_archive_file_ofs += archive_name_size;
    }

	if (user_extra_data_len > 0)
	{
		if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, user_extra_data, user_extra_data_len) != user_extra_data_len)
			return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

		cur_archive_file_ofs += user_extra_data_len;
	}

    if (store_data_uncompressed)
    {
        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pBuf, buf_size) != buf_size)
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }

        cur_archive_file_ofs += buf_size;
        comp_size = buf_size;
    }
    else if (buf_size)
    {
        mz_zip_writer_add_state state;

        state.m_pZip = pZip;
        state.m_cur_archive_file_ofs = cur_archive_file_ofs;
        state.m_comp_size = 0;

        if ((tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY) ||
            (tdefl_compress_buffer(pComp, pBuf, buf_size, TDEFL_FINISH) != TDEFL_STATUS_DONE))
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
            return mz_zip_set_error(pZip, MZ_ZIP_COMPRESSION_FAILED);
        }

        comp_size = state.m_comp_size;
        cur_archive_file_ofs = state.m_cur_archive_file_ofs;
    }

    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
    pComp = NULL;

    if (uncomp_size)
    {
        mz_uint8 local_dir_footer[MZ_ZIP_DATA_DESCRIPTER_SIZE64];
        mz_uint32 local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE32;

        MZ_ASSERT(bit_flags & MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR);

        MZ_WRITE_LE32(local_dir_footer + 0, MZ_ZIP_DATA_DESCRIPTOR_ID);
        MZ_WRITE_LE32(local_dir_footer + 4, uncomp_crc32);
        if (pExtra_data == NULL)
        {
            if (comp_size > MZ_UINT32_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);

            MZ_WRITE_LE32(local_dir_footer + 8, comp_size);
            MZ_WRITE_LE32(local_dir_footer + 12, uncomp_size);
        }
        else
        {
            MZ_WRITE_LE64(local_dir_footer + 8, comp_size);
            MZ_WRITE_LE64(local_dir_footer + 16, uncomp_size);
            local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE64;
        }

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_footer, local_dir_footer_size) != local_dir_footer_size)
            return MZ_FALSE;

        cur_archive_file_ofs += local_dir_footer_size;
    }

    if (pExtra_data != NULL)
    {
        extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (uncomp_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
                                                           (uncomp_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
    }

    if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, pExtra_data, (mz_uint16)extra_size, pComment,
                                          comment_size, uncomp_size, comp_size, uncomp_crc32, method, bit_flags, dos_time, dos_date, local_dir_header_ofs, ext_attributes,
                                          user_extra_data_central, user_extra_data_central_len))
        return MZ_FALSE;

    pZip->m_total_files++;
    pZip->m_archive_size = cur_archive_file_ofs;

    return MZ_TRUE;
}

mz_bool mz_zip_writer_add_read_buf_callback(mz_zip_archive *pZip, const char *pArchive_name, mz_file_read_func read_callback, void* callback_opaque, mz_uint64 max_size, const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
                                const char *user_extra_data, mz_uint user_extra_data_len, const char *user_extra_data_central, mz_uint user_extra_data_central_len)
{
    mz_uint16 gen_flags;
    mz_uint uncomp_crc32 = MZ_CRC32_INIT, level, num_alignment_padding_bytes;
    mz_uint16 method = 0, dos_time = 0, dos_date = 0, ext_attributes = 0;
    mz_uint64 local_dir_header_ofs, cur_archive_file_ofs = pZip->m_archive_size, uncomp_size = 0, comp_size = 0;
    size_t archive_name_size;
    mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
    mz_uint8 *pExtra_data = NULL;
    mz_uint32 extra_size = 0;
    mz_uint8 extra_data[MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE];
    mz_zip_internal_state *pState;
    mz_uint64 file_ofs = 0, cur_archive_header_file_ofs;

    if ((int)level_and_flags < 0)
        level_and_flags = MZ_DEFAULT_LEVEL;
    level = level_and_flags & 0xF;

    gen_flags = (level_and_flags & MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE) ? 0 : MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR;

    if (!(level_and_flags & MZ_ZIP_FLAG_ASCII_FILENAME))
        gen_flags |= MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8;

    /* Sanity checks */
    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pState = pZip->m_pState;

    if ((!pState->m_zip64) && (max_size > MZ_UINT32_MAX))
    {
        /* Source file is too large for non-zip64 */
        /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
        pState->m_zip64 = MZ_TRUE;
    }

    /* We could support this, but why? */
    if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (!mz_zip_writer_validate_archive_name(pArchive_name))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);

    if (pState->m_zip64)
    {
        if (pZip->m_total_files == MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }
    else
    {
        if (pZip->m_total_files == MZ_UINT16_MAX)
        {
            pState->m_zip64 = MZ_TRUE;
            /*return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES); */
        }
    }

    archive_name_size = strlen(pArchive_name);
    if (archive_name_size > MZ_UINT16_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);

    num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

    /* miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet */
    if (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE + comment_size) >= MZ_UINT32_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);

    if (!pState->m_zip64)
    {
        /* Bail early if the archive would obviously become too large */
        if ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + archive_name_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE
			+ archive_name_size + comment_size + user_extra_data_len + pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE + 1024
			+ MZ_ZIP_DATA_DESCRIPTER_SIZE32 + user_extra_data_central_len) > 0xFFFFFFFF)
        {
            pState->m_zip64 = MZ_TRUE;
            /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
        }
    }

#ifndef MINIZ_NO_TIME
    if (pFile_time)
    {
        mz_zip_time_t_to_dos_time(*pFile_time, &dos_time, &dos_date);
    }
#endif

    if (max_size <= 3)
        level = 0;

    if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes))
    {
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
    }

    cur_archive_file_ofs += num_alignment_padding_bytes;
    local_dir_header_ofs = cur_archive_file_ofs;

    if (pZip->m_file_offset_alignment)
    {
        MZ_ASSERT((cur_archive_file_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
    }

    if (max_size && level)
    {
        method = MZ_DEFLATED;
    }

    MZ_CLEAR_ARR(local_dir_header);
    if (pState->m_zip64)
    {
        if (max_size >= MZ_UINT32_MAX || local_dir_header_ofs >= MZ_UINT32_MAX)
        {
            pExtra_data = extra_data;
            if (level_and_flags & MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE)
                extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (max_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
                                                               (max_size >= MZ_UINT32_MAX) ? &comp_size : NULL,
                                                                (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
            else
                extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, NULL,
                                                                   NULL,
                                                                   (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
        }

        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, (mz_uint16)(extra_size + user_extra_data_len), 0, 0, 0, method, gen_flags, dos_time, dos_date))
            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_archive_file_ofs += sizeof(local_dir_header);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
        {
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }

        cur_archive_file_ofs += archive_name_size;

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, extra_data, extra_size) != extra_size)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_archive_file_ofs += extra_size;
    }
    else
    {
        if ((comp_size > MZ_UINT32_MAX) || (cur_archive_file_ofs > MZ_UINT32_MAX))
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, (mz_uint16)user_extra_data_len, 0, 0, 0, method, gen_flags, dos_time, dos_date))
            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_archive_file_ofs += sizeof(local_dir_header);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
        {
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }

        cur_archive_file_ofs += archive_name_size;
    }

    if (user_extra_data_len > 0)
    {
        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, user_extra_data, user_extra_data_len) != user_extra_data_len)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_archive_file_ofs += user_extra_data_len;
    }

    if (max_size)
    {
        void *pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, MZ_ZIP_MAX_IO_BUF_SIZE);
        if (!pRead_buf)
        {
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        if (!level)
        {
            while (1)
            {
                size_t n = read_callback(callback_opaque, file_ofs, pRead_buf, MZ_ZIP_MAX_IO_BUF_SIZE);
                if (n == 0)
                    break;

                if ((n > MZ_ZIP_MAX_IO_BUF_SIZE) || (file_ofs + n > max_size))
                {
                    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
                    return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                }
                if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pRead_buf, n) != n)
                {
                    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
                    return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
                }
                file_ofs += n;
                uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, n);
                cur_archive_file_ofs += n;
            }
            uncomp_size = file_ofs;
            comp_size = uncomp_size;
        }
        else
        {
            mz_bool result = MZ_FALSE;
            mz_zip_writer_add_state state;
            tdefl_compressor *pComp = (tdefl_compressor *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor));
            if (!pComp)
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            }

            state.m_pZip = pZip;
            state.m_cur_archive_file_ofs = cur_archive_file_ofs;
            state.m_comp_size = 0;

            if (tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY)
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
                pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
                return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
            }

            for (;;)
            {
                tdefl_status status;
                tdefl_flush flush = TDEFL_NO_FLUSH;

                size_t n = read_callback(callback_opaque, file_ofs, pRead_buf, MZ_ZIP_MAX_IO_BUF_SIZE);
                if ((n > MZ_ZIP_MAX_IO_BUF_SIZE) || (file_ofs + n > max_size))
                {
                    mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                    break;
                }

                file_ofs += n;
                uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, n);

                if (pZip->m_pNeeds_keepalive != NULL && pZip->m_pNeeds_keepalive(pZip->m_pIO_opaque))
                    flush = TDEFL_FULL_FLUSH;

                if (n == 0)
                    flush = TDEFL_FINISH;

                status = tdefl_compress_buffer(pComp, pRead_buf, n, flush);
                if (status == TDEFL_STATUS_DONE)
                {
                    result = MZ_TRUE;
                    break;
                }
                else if (status != TDEFL_STATUS_OKAY)
                {
                    mz_zip_set_error(pZip, MZ_ZIP_COMPRESSION_FAILED);
                    break;
                }
            }

            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);

            if (!result)
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
                return MZ_FALSE;
            }

            uncomp_size = file_ofs;
            comp_size = state.m_comp_size;
            cur_archive_file_ofs = state.m_cur_archive_file_ofs;
        }

        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
    }

    if (!(level_and_flags & MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE))
    {
        mz_uint8 local_dir_footer[MZ_ZIP_DATA_DESCRIPTER_SIZE64];
        mz_uint32 local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE32;

        MZ_WRITE_LE32(local_dir_footer + 0, MZ_ZIP_DATA_DESCRIPTOR_ID);
        MZ_WRITE_LE32(local_dir_footer + 4, uncomp_crc32);
        if (pExtra_data == NULL)
        {
            if (comp_size > MZ_UINT32_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);

            MZ_WRITE_LE32(local_dir_footer + 8, comp_size);
            MZ_WRITE_LE32(local_dir_footer + 12, uncomp_size);
        }
        else
        {
            MZ_WRITE_LE64(local_dir_footer + 8, comp_size);
            MZ_WRITE_LE64(local_dir_footer + 16, uncomp_size);
            local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE64;
        }

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_footer, local_dir_footer_size) != local_dir_footer_size)
            return MZ_FALSE;

        cur_archive_file_ofs += local_dir_footer_size;
    }

    if (level_and_flags & MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE)
    {
        if (pExtra_data != NULL)
        {
            extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (max_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
                                                               (max_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
        }

        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header,
                                                   (mz_uint16)archive_name_size, (mz_uint16)(extra_size + user_extra_data_len),
                                                   (max_size >= MZ_UINT32_MAX) ? MZ_UINT32_MAX : uncomp_size, 
                                                    (max_size >= MZ_UINT32_MAX) ? MZ_UINT32_MAX : comp_size,
                                                   uncomp_crc32, method, gen_flags, dos_time, dos_date))
            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

        cur_archive_header_file_ofs = local_dir_header_ofs;

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_header_file_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        if (pExtra_data != NULL)
        {
            cur_archive_header_file_ofs += sizeof(local_dir_header);

            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_header_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
            {
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
            }

            cur_archive_header_file_ofs += archive_name_size;

            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_header_file_ofs, extra_data, extra_size) != extra_size)
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

            cur_archive_header_file_ofs += extra_size;
        }
    }

    if (pExtra_data != NULL)
    {
        extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (uncomp_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
                                                           (uncomp_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
    }

    if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, pExtra_data, (mz_uint16)extra_size, pComment, comment_size,
                                          uncomp_size, comp_size, uncomp_crc32, method, gen_flags, dos_time, dos_date, local_dir_header_ofs, ext_attributes,
                                          user_extra_data_central, user_extra_data_central_len))
        return MZ_FALSE;

    pZip->m_total_files++;
    pZip->m_archive_size = cur_archive_file_ofs;

    return MZ_TRUE;
}

#ifndef MINIZ_NO_STDIO

static size_t mz_file_read_func_stdio(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
{
	MZ_FILE *pSrc_file = (MZ_FILE *)pOpaque;
	mz_int64 cur_ofs = MZ_FTELL64(pSrc_file);

	if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pSrc_file, (mz_int64)file_ofs, SEEK_SET))))
		return 0;

	return MZ_FREAD(pBuf, 1, n, pSrc_file);
}

mz_bool mz_zip_writer_add_cfile(mz_zip_archive *pZip, const char *pArchive_name, MZ_FILE *pSrc_file, mz_uint64 max_size, const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
	const char *user_extra_data, mz_uint user_extra_data_len, const char *user_extra_data_central, mz_uint user_extra_data_central_len)
{
	return mz_zip_writer_add_read_buf_callback(pZip, pArchive_name, mz_file_read_func_stdio, pSrc_file, max_size, pFile_time, pComment, comment_size, level_and_flags,
		user_extra_data, user_extra_data_len, user_extra_data_central, user_extra_data_central_len);
}

mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)
{
    MZ_FILE *pSrc_file = NULL;
    mz_uint64 uncomp_size = 0;
    MZ_TIME_T file_modified_time;
    MZ_TIME_T *pFile_time = NULL;
    mz_bool status;

    memset(&file_modified_time, 0, sizeof(file_modified_time));

#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_STDIO)
    pFile_time = &file_modified_time;
    if (!mz_zip_get_file_modified_time(pSrc_filename, &file_modified_time))
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_STAT_FAILED);
#endif

    pSrc_file = MZ_FOPEN(pSrc_filename, "rb");
    if (!pSrc_file)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);

    MZ_FSEEK64(pSrc_file, 0, SEEK_END);
    uncomp_size = MZ_FTELL64(pSrc_file);
    MZ_FSEEK64(pSrc_file, 0, SEEK_SET);

    status = mz_zip_writer_add_cfile(pZip, pArchive_name, pSrc_file, uncomp_size, pFile_time, pComment, comment_size, level_and_flags, NULL, 0, NULL, 0);

    MZ_FCLOSE(pSrc_file);

    return status;
}
#endif /* #ifndef MINIZ_NO_STDIO */

static mz_bool mz_zip_writer_update_zip64_extension_block(mz_zip_array *pNew_ext, mz_zip_archive *pZip, const mz_uint8 *pExt, mz_uint32 ext_len, mz_uint64 *pComp_size, mz_uint64 *pUncomp_size, mz_uint64 *pLocal_header_ofs, mz_uint32 *pDisk_start)
{
    /* + 64 should be enough for any new zip64 data */
    if (!mz_zip_array_reserve(pZip, pNew_ext, ext_len + 64, MZ_FALSE))
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

    mz_zip_array_resize(pZip, pNew_ext, 0, MZ_FALSE);

    if ((pUncomp_size) || (pComp_size) || (pLocal_header_ofs) || (pDisk_start))
    {
        mz_uint8 new_ext_block[64];
        mz_uint8 *pDst = new_ext_block;
        mz_write_le16(pDst, MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID);
        mz_write_le16(pDst + sizeof(mz_uint16), 0);
        pDst += sizeof(mz_uint16) * 2;

        if (pUncomp_size)
        {
            mz_write_le64(pDst, *pUncomp_size);
            pDst += sizeof(mz_uint64);
        }

        if (pComp_size)
        {
            mz_write_le64(pDst, *pComp_size);
            pDst += sizeof(mz_uint64);
        }

        if (pLocal_header_ofs)
        {
            mz_write_le64(pDst, *pLocal_header_ofs);
            pDst += sizeof(mz_uint64);
        }

        if (pDisk_start)
        {
            mz_write_le32(pDst, *pDisk_start);
            pDst += sizeof(mz_uint32);
        }

        mz_write_le16(new_ext_block + sizeof(mz_uint16), (mz_uint16)((pDst - new_ext_block) - sizeof(mz_uint16) * 2));

        if (!mz_zip_array_push_back(pZip, pNew_ext, new_ext_block, pDst - new_ext_block))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
    }

    if ((pExt) && (ext_len))
    {
        mz_uint32 extra_size_remaining = ext_len;
        const mz_uint8 *pExtra_data = pExt;

        do
        {
            mz_uint32 field_id, field_data_size, field_total_size;

            if (extra_size_remaining < (sizeof(mz_uint16) * 2))
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

            field_id = MZ_READ_LE16(pExtra_data);
            field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));
            field_total_size = field_data_size + sizeof(mz_uint16) * 2;

            if (field_total_size > extra_size_remaining)
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

            if (field_id != MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
            {
                if (!mz_zip_array_push_back(pZip, pNew_ext, pExtra_data, field_total_size))
                    return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            }

            pExtra_data += field_total_size;
            extra_size_remaining -= field_total_size;
        } while (extra_size_remaining);
    }

    return MZ_TRUE;
}

/* TODO: This func is now pretty freakin complex due to zip64, split it up? */
mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint src_file_index)
{
    mz_uint n, bit_flags, num_alignment_padding_bytes, src_central_dir_following_data_size;
    mz_uint64 src_archive_bytes_remaining, local_dir_header_ofs;
    mz_uint64 cur_src_file_ofs, cur_dst_file_ofs;
    mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
    mz_uint8 new_central_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];
    size_t orig_central_dir_size;
    mz_zip_internal_state *pState;
    void *pBuf;
    const mz_uint8 *pSrc_central_header;
    mz_zip_archive_file_stat src_file_stat;
    mz_uint32 src_filename_len, src_comment_len, src_ext_len;
    mz_uint32 local_header_filename_size, local_header_extra_len;
    mz_uint64 local_header_comp_size, local_header_uncomp_size;
    mz_bool found_zip64_ext_data_in_ldir = MZ_FALSE;

    /* Sanity checks */
    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pSource_zip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pState = pZip->m_pState;

    /* Don't support copying files from zip64 archives to non-zip64, even though in some cases this is possible */
    if ((pSource_zip->m_pState->m_zip64) && (!pZip->m_pState->m_zip64))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    /* Get pointer to the source central dir header and crack it */
    if (NULL == (pSrc_central_header = mz_zip_get_cdh(pSource_zip, src_file_index)))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_SIG_OFS) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    src_filename_len = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    src_comment_len = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_COMMENT_LEN_OFS);
    src_ext_len = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS);
    src_central_dir_following_data_size = src_filename_len + src_ext_len + src_comment_len;

    /* TODO: We don't support central dir's >= MZ_UINT32_MAX bytes right now (+32 fudge factor in case we need to add more extra data) */
    if ((pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_central_dir_following_data_size + 32) >= MZ_UINT32_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);

    num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

    if (!pState->m_zip64)
    {
        if (pZip->m_total_files == MZ_UINT16_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }
    else
    {
        /* TODO: Our zip64 support still has some 32-bit limits that may not be worth fixing. */
        if (pZip->m_total_files == MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }

    if (!mz_zip_file_stat_internal(pSource_zip, src_file_index, pSrc_central_header, &src_file_stat, NULL))
        return MZ_FALSE;

    cur_src_file_ofs = src_file_stat.m_local_header_ofs;
    cur_dst_file_ofs = pZip->m_archive_size;

    /* Read the source archive's local dir header */
    if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

    if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    cur_src_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;

    /* Compute the total size we need to copy (filename+extra data+compressed data) */
    local_header_filename_size = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS);
    local_header_extra_len = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
    local_header_comp_size = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS);
    local_header_uncomp_size = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS);
    src_archive_bytes_remaining = local_header_filename_size + local_header_extra_len + src_file_stat.m_comp_size;

    /* Try to find a zip64 extended information field */
    if ((local_header_extra_len) && ((local_header_comp_size == MZ_UINT32_MAX) || (local_header_uncomp_size == MZ_UINT32_MAX)))
    {
        mz_zip_array file_data_array;
        const mz_uint8 *pExtra_data;
        mz_uint32 extra_size_remaining = local_header_extra_len;

        mz_zip_array_init(&file_data_array, 1);
        if (!mz_zip_array_resize(pZip, &file_data_array, local_header_extra_len, MZ_FALSE))
        {
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, src_file_stat.m_local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + local_header_filename_size, file_data_array.m_p, local_header_extra_len) != local_header_extra_len)
        {
            mz_zip_array_clear(pZip, &file_data_array);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
        }

        pExtra_data = (const mz_uint8 *)file_data_array.m_p;

        do
        {
            mz_uint32 field_id, field_data_size, field_total_size;

            if (extra_size_remaining < (sizeof(mz_uint16) * 2))
            {
                mz_zip_array_clear(pZip, &file_data_array);
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
            }

            field_id = MZ_READ_LE16(pExtra_data);
            field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));
            field_total_size = field_data_size + sizeof(mz_uint16) * 2;

            if (field_total_size > extra_size_remaining)
            {
                mz_zip_array_clear(pZip, &file_data_array);
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
            }

            if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
            {
                const mz_uint8 *pSrc_field_data = pExtra_data + sizeof(mz_uint32);

                if (field_data_size < sizeof(mz_uint64) * 2)
                {
                    mz_zip_array_clear(pZip, &file_data_array);
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                }

                local_header_uncomp_size = MZ_READ_LE64(pSrc_field_data);
                local_header_comp_size = MZ_READ_LE64(pSrc_field_data + sizeof(mz_uint64)); /* may be 0 if there's a descriptor */

                found_zip64_ext_data_in_ldir = MZ_TRUE;
                break;
            }

            pExtra_data += field_total_size;
            extra_size_remaining -= field_total_size;
        } while (extra_size_remaining);

        mz_zip_array_clear(pZip, &file_data_array);
    }

    if (!pState->m_zip64)
    {
        /* Try to detect if the new archive will most likely wind up too big and bail early (+(sizeof(mz_uint32) * 4) is for the optional descriptor which could be present, +64 is a fudge factor). */
        /* We also check when the archive is finalized so this doesn't need to be perfect. */
        mz_uint64 approx_new_archive_size = cur_dst_file_ofs + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + src_archive_bytes_remaining + (sizeof(mz_uint32) * 4) +
                                            pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_central_dir_following_data_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE + 64;

        if (approx_new_archive_size >= MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
    }

    /* Write dest archive padding */
    if (!mz_zip_writer_write_zeros(pZip, cur_dst_file_ofs, num_alignment_padding_bytes))
        return MZ_FALSE;

    cur_dst_file_ofs += num_alignment_padding_bytes;

    local_dir_header_ofs = cur_dst_file_ofs;
    if (pZip->m_file_offset_alignment)
    {
        MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
    }

    /* The original zip's local header+ext block doesn't change, even with zip64, so we can just copy it over to the dest zip */
    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

    cur_dst_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;

    /* Copy over the source archive bytes to the dest archive, also ensure we have enough buf space to handle optional data descriptor */
    if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)MZ_MAX(32U, MZ_MIN((mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE, src_archive_bytes_remaining)))))
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

    while (src_archive_bytes_remaining)
    {
        n = (mz_uint)MZ_MIN((mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE, src_archive_bytes_remaining);
        if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, n) != n)
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
        }
        cur_src_file_ofs += n;

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n)
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }
        cur_dst_file_ofs += n;

        src_archive_bytes_remaining -= n;
    }

    /* Now deal with the optional data descriptor */
    bit_flags = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS);
    if (bit_flags & 8)
    {
        /* Copy data descriptor */
        if ((pSource_zip->m_pState->m_zip64) || (found_zip64_ext_data_in_ldir))
        {
            /* src is zip64, dest must be zip64 */

            /* name			uint32_t's */
            /* id				1 (optional in zip64?) */
            /* crc			1 */
            /* comp_size	2 */
            /* uncomp_size 2 */
            if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, (sizeof(mz_uint32) * 6)) != (sizeof(mz_uint32) * 6))
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
            }

            n = sizeof(mz_uint32) * ((MZ_READ_LE32(pBuf) == MZ_ZIP_DATA_DESCRIPTOR_ID) ? 6 : 5);
        }
        else
        {
            /* src is NOT zip64 */
            mz_bool has_id;

            if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, sizeof(mz_uint32) * 4) != sizeof(mz_uint32) * 4)
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
            }

            has_id = (MZ_READ_LE32(pBuf) == MZ_ZIP_DATA_DESCRIPTOR_ID);

            if (pZip->m_pState->m_zip64)
            {
                /* dest is zip64, so upgrade the data descriptor */
                const mz_uint8 *pSrc_descriptor = (const mz_uint8 *)pBuf + (has_id ? sizeof(mz_uint32) : 0);
                const mz_uint32 src_crc32 = MZ_READ_LE32(pSrc_descriptor);
                const mz_uint64 src_comp_size = MZ_READ_LE32(pSrc_descriptor + sizeof(mz_uint32));
                const mz_uint64 src_uncomp_size = MZ_READ_LE32(pSrc_descriptor + 2*sizeof(mz_uint32));

                mz_write_le32((mz_uint8 *)pBuf, MZ_ZIP_DATA_DESCRIPTOR_ID);
                mz_write_le32((mz_uint8 *)pBuf + sizeof(mz_uint32) * 1, src_crc32);
                mz_write_le64((mz_uint8 *)pBuf + sizeof(mz_uint32) * 2, src_comp_size);
                mz_write_le64((mz_uint8 *)pBuf + sizeof(mz_uint32) * 4, src_uncomp_size);

                n = sizeof(mz_uint32) * 6;
            }
            else
            {
                /* dest is NOT zip64, just copy it as-is */
                n = sizeof(mz_uint32) * (has_id ? 4 : 3);
            }
        }

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n)
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }

        cur_src_file_ofs += n;
        cur_dst_file_ofs += n;
    }
    pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);

    /* Finally, add the new central dir header */
    orig_central_dir_size = pState->m_central_dir.m_size;

    memcpy(new_central_header, pSrc_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);

    if (pState->m_zip64)
    {
        /* This is the painful part: We need to write a new central dir header + ext block with updated zip64 fields, and ensure the old fields (if any) are not included. */
        const mz_uint8 *pSrc_ext = pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_filename_len;
        mz_zip_array new_ext_block;

        mz_zip_array_init(&new_ext_block, sizeof(mz_uint8));

        MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, MZ_UINT32_MAX);
        MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, MZ_UINT32_MAX);
        MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS, MZ_UINT32_MAX);

        if (!mz_zip_writer_update_zip64_extension_block(&new_ext_block, pZip, pSrc_ext, src_ext_len, &src_file_stat.m_comp_size, &src_file_stat.m_uncomp_size, &local_dir_header_ofs, NULL))
        {
            mz_zip_array_clear(pZip, &new_ext_block);
            return MZ_FALSE;
        }

        MZ_WRITE_LE16(new_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS, new_ext_block.m_size);

        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, new_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))
        {
            mz_zip_array_clear(pZip, &new_ext_block);
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, src_filename_len))
        {
            mz_zip_array_clear(pZip, &new_ext_block);
            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, new_ext_block.m_p, new_ext_block.m_size))
        {
            mz_zip_array_clear(pZip, &new_ext_block);
            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_filename_len + src_ext_len, src_comment_len))
        {
            mz_zip_array_clear(pZip, &new_ext_block);
            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        mz_zip_array_clear(pZip, &new_ext_block);
    }
    else
    {
        /* sanity checks */
        if (cur_dst_file_ofs > MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);

        if (local_dir_header_ofs >= MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);

        MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_dir_header_ofs);

        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, new_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, src_central_dir_following_data_size))
        {
            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }
    }

    /* This shouldn't trigger unless we screwed up during the initial sanity checks */
    if (pState->m_central_dir.m_size >= MZ_UINT32_MAX)
    {
        /* TODO: Support central dirs >= 32-bits in size */
        mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);
    }

    n = (mz_uint32)orig_central_dir_size;
    if (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &n, 1))
    {
        mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
    }

    pZip->m_total_files++;
    pZip->m_archive_size = cur_dst_file_ofs;

    return MZ_TRUE;
}

mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip)
{
    mz_zip_internal_state *pState;
    mz_uint64 central_dir_ofs, central_dir_size;
    mz_uint8 hdr[256];

    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pState = pZip->m_pState;

    if (pState->m_zip64)
    {
        if ((mz_uint64)pState->m_central_dir.m_size >= MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }
    else
    {
        if ((pZip->m_total_files > MZ_UINT16_MAX) || ((pZip->m_archive_size + pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) > MZ_UINT32_MAX))
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }

    central_dir_ofs = 0;
    central_dir_size = 0;
    if (pZip->m_total_files)
    {
        /* Write central directory */
        central_dir_ofs = pZip->m_archive_size;
        central_dir_size = pState->m_central_dir.m_size;
        pZip->m_central_directory_file_ofs = central_dir_ofs;
        if (pZip->m_pWrite(pZip->m_pIO_opaque, central_dir_ofs, pState->m_central_dir.m_p, (size_t)central_dir_size) != central_dir_size)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        pZip->m_archive_size += central_dir_size;
    }

    if (pState->m_zip64)
    {
        /* Write zip64 end of central directory header */
        mz_uint64 rel_ofs_to_zip64_ecdr = pZip->m_archive_size;

        MZ_CLEAR_ARR(hdr);
        MZ_WRITE_LE32(hdr + MZ_ZIP64_ECDH_SIG_OFS, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG);
        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE - sizeof(mz_uint32) - sizeof(mz_uint64));
        MZ_WRITE_LE16(hdr + MZ_ZIP64_ECDH_VERSION_MADE_BY_OFS, 0x031E); /* TODO: always Unix */
        MZ_WRITE_LE16(hdr + MZ_ZIP64_ECDH_VERSION_NEEDED_OFS, 0x002D);
        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS, pZip->m_total_files);
        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS, pZip->m_total_files);
        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_SIZE_OFS, central_dir_size);
        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_OFS_OFS, central_dir_ofs);
        if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        pZip->m_archive_size += MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE;

        /* Write zip64 end of central directory locator */
        MZ_CLEAR_ARR(hdr);
        MZ_WRITE_LE32(hdr + MZ_ZIP64_ECDL_SIG_OFS, MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG);
        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS, rel_ofs_to_zip64_ecdr);
        MZ_WRITE_LE32(hdr + MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS, 1);
        if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE) != MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        pZip->m_archive_size += MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE;
    }

    /* Write end of central directory record */
    MZ_CLEAR_ARR(hdr);
    MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_SIG_OFS, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG);
    MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS, MZ_MIN(MZ_UINT16_MAX, pZip->m_total_files));
    MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS, MZ_MIN(MZ_UINT16_MAX, pZip->m_total_files));
    MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_SIZE_OFS, MZ_MIN(MZ_UINT32_MAX, central_dir_size));
    MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_OFS_OFS, MZ_MIN(MZ_UINT32_MAX, central_dir_ofs));

    if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

#ifndef MINIZ_NO_STDIO
    if ((pState->m_pFile) && (MZ_FFLUSH(pState->m_pFile) == EOF))
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_CLOSE_FAILED);
#endif /* #ifndef MINIZ_NO_STDIO */

    pZip->m_archive_size += MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE;

    pZip->m_zip_mode = MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED;
    return MZ_TRUE;
}

mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **ppBuf, size_t *pSize)
{
    if ((!ppBuf) || (!pSize))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    *ppBuf = NULL;
    *pSize = 0;

    if ((!pZip) || (!pZip->m_pState))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (pZip->m_pWrite != mz_zip_heap_write_func)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (!mz_zip_writer_finalize_archive(pZip))
        return MZ_FALSE;

    *ppBuf = pZip->m_pState->m_pMem;
    *pSize = pZip->m_pState->m_mem_size;
    pZip->m_pState->m_pMem = NULL;
    pZip->m_pState->m_mem_size = pZip->m_pState->m_mem_capacity = 0;

    return MZ_TRUE;
}

mz_bool mz_zip_writer_end(mz_zip_archive *pZip)
{
    return mz_zip_writer_end_internal(pZip, MZ_TRUE);
}

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)
{
    return mz_zip_add_mem_to_archive_file_in_place_v2(pZip_filename, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, NULL);
}

mz_bool mz_zip_add_mem_to_archive_file_in_place_v2(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_zip_error *pErr)
{
    mz_bool status, created_new_archive = MZ_FALSE;
    mz_zip_archive zip_archive;
    struct MZ_FILE_STAT_STRUCT file_stat;
    mz_zip_error actual_err = MZ_ZIP_NO_ERROR;

    mz_zip_zero_struct(&zip_archive);
    if ((int)level_and_flags < 0)
        level_and_flags = MZ_DEFAULT_LEVEL;

    if ((!pZip_filename) || (!pArchive_name) || ((buf_size) && (!pBuf)) || ((comment_size) && (!pComment)) || ((level_and_flags & 0xF) > MZ_UBER_COMPRESSION))
    {
        if (pErr)
            *pErr = MZ_ZIP_INVALID_PARAMETER;
        return MZ_FALSE;
    }

    if (!mz_zip_writer_validate_archive_name(pArchive_name))
    {
        if (pErr)
            *pErr = MZ_ZIP_INVALID_FILENAME;
        return MZ_FALSE;
    }

    /* Important: The regular non-64 bit version of stat() can fail here if the file is very large, which could cause the archive to be overwritten. */
    /* So be sure to compile with _LARGEFILE64_SOURCE 1 */
    if (MZ_FILE_STAT(pZip_filename, &file_stat) != 0)
    {
        /* Create a new archive. */
        if (!mz_zip_writer_init_file_v2(&zip_archive, pZip_filename, 0, level_and_flags))
        {
            if (pErr)
                *pErr = zip_archive.m_last_error;
            return MZ_FALSE;
        }

        created_new_archive = MZ_TRUE;
    }
    else
    {
        /* Append to an existing archive. */
        if (!mz_zip_reader_init_file_v2(&zip_archive, pZip_filename, level_and_flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY, 0, 0))
        {
            if (pErr)
                *pErr = zip_archive.m_last_error;
            return MZ_FALSE;
        }

        if (!mz_zip_writer_init_from_reader_v2(&zip_archive, pZip_filename, level_and_flags))
        {
            if (pErr)
                *pErr = zip_archive.m_last_error;

            mz_zip_reader_end_internal(&zip_archive, MZ_FALSE);

            return MZ_FALSE;
        }
    }

    status = mz_zip_writer_add_mem_ex(&zip_archive, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, 0, 0);
    actual_err = zip_archive.m_last_error;

    /* Always finalize, even if adding failed for some reason, so we have a valid central directory. (This may not always succeed, but we can try.) */
    if (!mz_zip_writer_finalize_archive(&zip_archive))
    {
        if (!actual_err)
            actual_err = zip_archive.m_last_error;

        status = MZ_FALSE;
    }

    if (!mz_zip_writer_end_internal(&zip_archive, status))
    {
        if (!actual_err)
            actual_err = zip_archive.m_last_error;

        status = MZ_FALSE;
    }

    if ((!status) && (created_new_archive))
    {
        /* It's a new archive and something went wrong, so just delete it. */
        int ignoredStatus = MZ_DELETE_FILE(pZip_filename);
        (void)ignoredStatus;
    }

    if (pErr)
        *pErr = actual_err;

    return status;
}

void *mz_zip_extract_archive_file_to_heap_v2(const char *pZip_filename, const char *pArchive_name, const char *pComment, size_t *pSize, mz_uint flags, mz_zip_error *pErr)
{
    mz_uint32 file_index;
    mz_zip_archive zip_archive;
    void *p = NULL;

    if (pSize)
        *pSize = 0;

    if ((!pZip_filename) || (!pArchive_name))
    {
        if (pErr)
            *pErr = MZ_ZIP_INVALID_PARAMETER;

        return NULL;
    }

    mz_zip_zero_struct(&zip_archive);
    if (!mz_zip_reader_init_file_v2(&zip_archive, pZip_filename, flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY, 0, 0))
    {
        if (pErr)
            *pErr = zip_archive.m_last_error;

        return NULL;
    }

    if (mz_zip_reader_locate_file_v2(&zip_archive, pArchive_name, pComment, flags, &file_index))
    {
        p = mz_zip_reader_extract_to_heap(&zip_archive, file_index, pSize, flags);
    }

    mz_zip_reader_end_internal(&zip_archive, p != NULL);

    if (pErr)
        *pErr = zip_archive.m_last_error;

    return p;
}

void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint flags)
{
    return mz_zip_extract_archive_file_to_heap_v2(pZip_filename, pArchive_name, NULL, pSize, flags, NULL);
}

#endif /* #ifndef MINIZ_NO_STDIO */

#endif /* #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS */

/* ------------------- Misc utils */

mz_zip_mode mz_zip_get_mode(mz_zip_archive *pZip)
{
    return pZip ? pZip->m_zip_mode : MZ_ZIP_MODE_INVALID;
}

mz_zip_type mz_zip_get_type(mz_zip_archive *pZip)
{
    return pZip ? pZip->m_zip_type : MZ_ZIP_TYPE_INVALID;
}

mz_zip_error mz_zip_set_last_error(mz_zip_archive *pZip, mz_zip_error err_num)
{
    mz_zip_error prev_err;

    if (!pZip)
        return MZ_ZIP_INVALID_PARAMETER;

    prev_err = pZip->m_last_error;

    pZip->m_last_error = err_num;
    return prev_err;
}

mz_zip_error mz_zip_peek_last_error(mz_zip_archive *pZip)
{
    if (!pZip)
        return MZ_ZIP_INVALID_PARAMETER;

    return pZip->m_last_error;
}

mz_zip_error mz_zip_clear_last_error(mz_zip_archive *pZip)
{
    return mz_zip_set_last_error(pZip, MZ_ZIP_NO_ERROR);
}

mz_zip_error mz_zip_get_last_error(mz_zip_archive *pZip)
{
    mz_zip_error prev_err;

    if (!pZip)
        return MZ_ZIP_INVALID_PARAMETER;

    prev_err = pZip->m_last_error;

    pZip->m_last_error = MZ_ZIP_NO_ERROR;
    return prev_err;
}

const char *mz_zip_get_error_string(mz_zip_error mz_err)
{
    switch (mz_err)
    {
        case MZ_ZIP_NO_ERROR:
            return "no error";
        case MZ_ZIP_UNDEFINED_ERROR:
            return "undefined error";
        case MZ_ZIP_TOO_MANY_FILES:
            return "too many files";
        case MZ_ZIP_FILE_TOO_LARGE:
            return "file too large";
        case MZ_ZIP_UNSUPPORTED_METHOD:
            return "unsupported method";
        case MZ_ZIP_UNSUPPORTED_ENCRYPTION:
            return "unsupported encryption";
        case MZ_ZIP_UNSUPPORTED_FEATURE:
            return "unsupported feature";
        case MZ_ZIP_FAILED_FINDING_CENTRAL_DIR:
            return "failed finding central directory";
        case MZ_ZIP_NOT_AN_ARCHIVE:
            return "not a ZIP archive";
        case MZ_ZIP_INVALID_HEADER_OR_CORRUPTED:
            return "invalid header or archive is corrupted";
        case MZ_ZIP_UNSUPPORTED_MULTIDISK:
            return "unsupported multidisk archive";
        case MZ_ZIP_DECOMPRESSION_FAILED:
            return "decompression failed or archive is corrupted";
        case MZ_ZIP_COMPRESSION_FAILED:
            return "compression failed";
        case MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE:
            return "unexpected decompressed size";
        case MZ_ZIP_CRC_CHECK_FAILED:
            return "CRC-32 check failed";
        case MZ_ZIP_UNSUPPORTED_CDIR_SIZE:
            return "unsupported central directory size";
        case MZ_ZIP_ALLOC_FAILED:
            return "allocation failed";
        case MZ_ZIP_FILE_OPEN_FAILED:
            return "file open failed";
        case MZ_ZIP_FILE_CREATE_FAILED:
            return "file create failed";
        case MZ_ZIP_FILE_WRITE_FAILED:
            return "file write failed";
        case MZ_ZIP_FILE_READ_FAILED:
            return "file read failed";
        case MZ_ZIP_FILE_CLOSE_FAILED:
            return "file close failed";
        case MZ_ZIP_FILE_SEEK_FAILED:
            return "file seek failed";
        case MZ_ZIP_FILE_STAT_FAILED:
            return "file stat failed";
        case MZ_ZIP_INVALID_PARAMETER:
            return "invalid parameter";
        case MZ_ZIP_INVALID_FILENAME:
            return "invalid filename";
        case MZ_ZIP_BUF_TOO_SMALL:
            return "buffer too small";
        case MZ_ZIP_INTERNAL_ERROR:
            return "internal error";
        case MZ_ZIP_FILE_NOT_FOUND:
            return "file not found";
        case MZ_ZIP_ARCHIVE_TOO_LARGE:
            return "archive is too large";
        case MZ_ZIP_VALIDATION_FAILED:
            return "validation failed";
        case MZ_ZIP_WRITE_CALLBACK_FAILED:
            return "write callback failed";
	case MZ_ZIP_TOTAL_ERRORS:
            return "total errors";
        default:
            break;
    }

    return "unknown error";
}

/* Note: Just because the archive is not zip64 doesn't necessarily mean it doesn't have Zip64 extended information extra field, argh. */
mz_bool mz_zip_is_zip64(mz_zip_archive *pZip)
{
    if ((!pZip) || (!pZip->m_pState))
        return MZ_FALSE;

    return pZip->m_pState->m_zip64;
}

size_t mz_zip_get_central_dir_size(mz_zip_archive *pZip)
{
    if ((!pZip) || (!pZip->m_pState))
        return 0;

    return pZip->m_pState->m_central_dir.m_size;
}

mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip)
{
    return pZip ? pZip->m_total_files : 0;
}

mz_uint64 mz_zip_get_archive_size(mz_zip_archive *pZip)
{
    if (!pZip)
        return 0;
    return pZip->m_archive_size;
}

mz_uint64 mz_zip_get_archive_file_start_offset(mz_zip_archive *pZip)
{
    if ((!pZip) || (!pZip->m_pState))
        return 0;
    return pZip->m_pState->m_file_archive_start_ofs;
}

MZ_FILE *mz_zip_get_cfile(mz_zip_archive *pZip)
{
    if ((!pZip) || (!pZip->m_pState))
        return 0;
    return pZip->m_pState->m_pFile;
}

size_t mz_zip_read_archive_data(mz_zip_archive *pZip, mz_uint64 file_ofs, void *pBuf, size_t n)
{
    if ((!pZip) || (!pZip->m_pState) || (!pBuf) || (!pZip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    return pZip->m_pRead(pZip->m_pIO_opaque, file_ofs, pBuf, n);
}

mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size)
{
    mz_uint n;
    const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
    if (!p)
    {
        if (filename_buf_size)
            pFilename[0] = '\0';
        mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        return 0;
    }
    n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    if (filename_buf_size)
    {
        n = MZ_MIN(n, filename_buf_size - 1);
        memcpy(pFilename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
        pFilename[n] = '\0';
    }
    return n + 1;
}

mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat)
{
    return mz_zip_file_stat_internal(pZip, file_index, mz_zip_get_cdh(pZip, file_index), pStat, NULL);
}

mz_bool mz_zip_end(mz_zip_archive *pZip)
{
    if (!pZip)
        return MZ_FALSE;

    if (pZip->m_zip_mode == MZ_ZIP_MODE_READING)
        return mz_zip_reader_end(pZip);
#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
    else if ((pZip->m_zip_mode == MZ_ZIP_MODE_WRITING) || (pZip->m_zip_mode == MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED))
        return mz_zip_writer_end(pZip);
#endif

    return MZ_FALSE;
}

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_ARCHIVE_APIS*/







namespace NumberDuck
{
	namespace Secret
	{
		ZipFileInfo::ZipFileInfo()
		{
			m_pFileStat = new mz_zip_archive_file_stat();
		}

		ZipFileInfo::~ZipFileInfo()
		{
			delete m_pFileStat;
		}

		const char* ZipFileInfo::GetFileName()
		{
			return m_pFileStat->m_filename;
		}

		int ZipFileInfo::GetSize()
		{
			return (int)m_pFileStat->m_uncomp_size;
		}

		/*unsigned int ZipFileInfo :: GetCrc32()
		   {
			return (unsigned int)m_pFileStat->m_crc32;
		   }*/

		Zip::Zip()
		{
			m_pBlob = NULL;
			m_pArchive = NULL;
			m_pTempFileInfo = new ZipFileInfo();
		}

		Zip::~Zip()
		{
			Cleanup();
			delete m_pTempFileInfo;
		}

		bool Zip::LoadBlobView(BlobView* pBlobView)
		{
			CleanupArchive();

			mz_bool bResult;

			m_pArchive = new mz_zip_archive();
			mz_zip_zero_struct(m_pArchive);

			bResult = mz_zip_reader_init_mem(m_pArchive, pBlobView->GetBlob()->GetData() + pBlobView->GetStart() + pBlobView->GetOffset(), pBlobView->GetSize() - pBlobView->GetOffset(), 0);

			pBlobView->SetOffset(pBlobView->GetOffset() + (int)(m_pArchive->m_archive_size));

			if (!bResult)
			{
				CleanupArchive();
				return false;
			}

			return true;
		}

		bool Zip::LoadFile(const char* szFileName)
		{
			Cleanup();
			m_pBlob = new Blob(false);

			if (!m_pBlob->Load(szFileName) || !LoadBlobView(m_pBlob->GetBlobView()))
			{
				Cleanup();
				return false;
			}

			return true;
		}

		int Zip::GetNumFile()
		{
			return mz_zip_reader_get_num_files(m_pArchive);
		}

		ZipFileInfo* Zip::GetFileInfo(int nIndex)
		{
			if (!mz_zip_reader_file_stat(m_pArchive, nIndex, m_pTempFileInfo->m_pFileStat))
				return NULL;
			return m_pTempFileInfo;
		}

		bool Zip::ExtractFileByIndex(int nIndex, BlobView* pOutBlobView)
		{
			// todo: write direct to blob instead of heap

			size_t nSize = 0;
			uint8_t* pData = (uint8_t*)mz_zip_reader_extract_to_heap(m_pArchive, nIndex, &nSize, 0);
			if (!pData)
				return false;

			pOutBlobView->PackData(pData, (int)nSize);
			pOutBlobView->SetOffset(0);

			mz_free(pData);

			return true;
		}

		bool Zip::ExtractFileByName(const char* szFileName, BlobView* pOutBlobView)
		{
			int nIndex = mz_zip_reader_locate_file(m_pArchive, szFileName, NULL, 0);
			if (nIndex == -1)
				return false;

			return ExtractFileByIndex(nIndex, pOutBlobView);
		}

		bool Zip::ExtractFileByIndexToString(int nIndex, InternalString* sOut)
		{
			size_t nSize = 0;
			uint8_t* pData = (uint8_t*)mz_zip_reader_extract_to_heap(m_pArchive, nIndex, &nSize, 0);
			if (!pData)
				return false;

			sOut->AppendStringData(pData, (int)nSize);

			mz_free(pData);

			return true;
		}

		void Zip::CleanupArchive()
		{
			if (m_pArchive)
			{
				mz_bool bResult;
				bResult = mz_zip_reader_end(m_pArchive);
				CLIFFY_ASSERT(bResult);
				delete m_pArchive;
				m_pArchive = NULL;
			}
		}

		void Zip::Cleanup()
		{
			CleanupArchive();
			if (m_pBlob)
			{
				delete m_pBlob;
				m_pBlob = NULL;
			}
		}
	}
}


#include "NumberDuck.hpp"

namespace NumberDuck
{
	namespace Secret
	{
		class OfficeArtRecord;
		class OfficeArtRecordHeaderStruct;
		class ParsedExpressionRecord;
		class BiffRecord_ContinueInfo;
		class BiffHeader;
		class BiffRecord;
		class WorksheetRange;
		class BiffWorksheetStreamSize;
		class InternalString;
		class FontRecord;
		class Format;
		class XF;
		class XFCRC;
		class XFExt;
		class Theme;
		class SstRecord;
		class BoundSheet8Record;
		class PaletteRecord;
		class MsoDrawingGroupRecord;
		class ExternSheetRecord;
		class XTIStruct;
		class Window1;
		class BiffRecordContainer;
		class Sector;
		class SectorChain;
		class SectorAllocationTable;
		class OfficeArtFOPTEStruct;
		class OfficeArtFRITStruct;
		class OfficeArtIDCLStruct;
		class OfficeArtBlipRecord;
		class Coordinate;
		class Coordinate3d;
		class Coordinate3dToken;
		class Area;
		class Area3d;
		class ExtPropStruct;
		class Hsl;
		class XmlFile;
		class Zip;
		class XmlNode;
		class XLUnicodeRichExtendedString;
		class RkRecStruct;
		class IXFCellStruct;
		class OfficeArtClientAnchorSheetRecord;
		class OfficeArtFOPTRecord;
		class OfficeArtBStoreContainerRecord;
		class OfficeArtDggContainerRecord;
		class Ref8Struct;
		class OfficeArtTertiaryFOPTRecord;
		class XLUnicodeRichExtendedString_ContinueInfo;
		class PrintGridRecord;
		class DefaultRowHeight;
		class SetupRecord;
		class ColInfoRecord;
		class RowRecord;
		class LabelSstRecord;
		class RkRecord;
		class MulRkRecord;
		class Blank;
		class MulBlank;
		class NumberRecord;
		class BoolErrRecord;
		class FormulaRecord;
		class ObjRecord;
		class MsoDrawingRecord;
		class MsoDrawingRecord_Position;
		class OfficeArtFBSERecord;
		class IHlinkStruct;
		class BofRecord;
		class LineFormatRecord;
		class AreaFormatRecord;
		class MarkerFormatRecord;
		class BarRecord;
		class LineRecord;
		class AreaRecord;
		class ScatterRecord;
		class Formula;
		class BraiRecord;
		class AxisRecord;
		class AxisLineRecord;
		class LegendRecord;
		class Window2Record;
		class MergeCellsRecord;
		class RowInfo;
		class DefColWidthRecord;
		class ColumnInfo;
		class OfficeArtSpContainerRecord;
		class OfficeArtDgContainerRecord;
		class OfficeArtSpgrContainerRecord;
		class OfficeArtDimensions;
		class Stream;
		class RedBlackTree;
		class Token;
		class SpaceToken;
		class Area3dToken;
		class AreaToken;
		class CoordinateToken;
		class ParseSpaceData;
		class ParseFunctionData;
		class RedBlackNodeImplementation;
		template <class T>
		class TableElement;
		class SharedString;
	}
	class BlobView;
	class Picture;
	class Style;
	class Line;
	class Color;
	class Worksheet;
	class Font;
	class Blob;
	class MD4;
	class MergedCell;
	class Cell;
	class Chart;
	class Series;
	class Value;
	class Workbook;
}
namespace NumberDuck
{
	namespace Secret
	{
		const char* OfficeArtRecord::GetTypeName()
		{
			switch ((Type)(m_pHeader->m_recType))
			{
				case Type::TYPE_OFFICE_ART_DGG_CONTAINER:
				{
					return "TYPE_OFFICE_ART_DGG_CONTAINER";
				}

				case Type::TYPE_OFFICE_ART_B_STORE_CONTAINER:
				{
					return "TYPE_OFFICE_ART_B_STORE_CONTAINER";
				}

				case Type::TYPE_OFFICE_ART_DG_CONTAINER:
				{
					return "TYPE_OFFICE_ART_DG_CONTAINER";
				}

				case Type::TYPE_OFFICE_ART_SPGR_CONTAINER:
				{
					return "TYPE_OFFICE_ART_SPGR_CONTAINER";
				}

				case Type::TYPE_OFFICE_ART_SP_CONTAINER:
				{
					return "TYPE_OFFICE_ART_SP_CONTAINER";
				}

				case Type::TYPE_OFFICE_ART_FDGG_BLOCK:
				{
					return "TYPE_OFFICE_ART_FDGG_BLOCK";
				}

				case Type::TYPE_OFFICE_ART_FBSE:
				{
					return "TYPE_OFFICE_ART_FBSE";
				}

				case Type::TYPE_OFFICE_ART_FDG:
				{
					return "TYPE_OFFICE_ART_FDG";
				}

				case Type::TYPE_OFFICE_ART_FSPGR:
				{
					return "TYPE_OFFICE_ART_FSPGR";
				}

				case Type::TYPE_OFFICE_ART_FSP:
				{
					return "TYPE_OFFICE_ART_FSP";
				}

				case Type::TYPE_OFFICE_ART_FOPT:
				{
					return "TYPE_OFFICE_ART_FOPT";
				}

				case Type::TYPE_OFFICE_ART_TERTIARY_FOPT:
				{
					return "TYPE_OFFICE_ART_TERTIARY_FOPT";
				}

				case Type::TYPE_OFFICE_ART_CLIENT_ANCHOR_SHEET:
				{
					return "TYPE_OFFICE_ART_CLIENT_ANCHOR_SHEET";
				}

				case Type::TYPE_OFFICE_ART_CLIENT_DATA:
				{
					return "TYPE_OFFICE_ART_CLIENT_DATA";
				}

				case Type::TYPE_OFFICE_ART_BLIP_EMF:
				{
					return "TYPE_OFFICE_ART_BLIP_EMF";
				}

				case Type::TYPE_OFFICE_ART_BLIP_WMF:
				{
					return "TYPE_OFFICE_ART_BLIP_WMF";
				}

				case Type::TYPE_OFFICE_ART_BLIP_PICT:
				{
					return "TYPE_OFFICE_ART_BLIP_PICT";
				}

				case Type::TYPE_OFFICE_ART_BLIP_JPEG:
				{
					return "TYPE_OFFICE_ART_BLIP_JPEG";
				}

				case Type::TYPE_OFFICE_ART_BLIP_PNG:
				{
					return "TYPE_OFFICE_ART_BLIP_PNG";
				}

				case Type::TYPE_OFFICE_ART_BLIP_DIB:
				{
					return "TYPE_OFFICE_ART_BLIP_DIB";
				}

				case Type::TYPE_OFFICE_ART_BLIP_TIFF:
				{
					return "TYPE_OFFICE_ART_BLIP_TIFF";
				}

				case Type::TYPE_OFFICE_ART_BLIP_JPEG_CMYK:
				{
					return "TYPE_OFFICE_ART_BLIP_JPEG_CMYK";
				}

				case Type::TYPE_OFFICE_ART_FRIT_CONTAINER:
				{
					return "TYPE_OFFICE_ART_FRIT_CONTAINER";
				}

				case Type::TYPE_OFFICE_ART_SPLIT_MENU_COLOR_CONTAINER:
				{
					return "TYPE_OFFICE_ART_SPLIT_MENU_COLOR_CONTAINER";
				}

			}
			return "???";
		}

		OfficeArtRecord::OfficeArtRecord(OfficeArtRecordHeaderStruct* pHeader, bool bIsContainer, BlobView* pBlobView)
		{
			m_pHeader = 0;
			m_bIsContainer = false;
			m_pOfficeArtRecordVector = 0;
			m_pHeader = pHeader;
			m_bIsContainer = bIsContainer;
			m_pOfficeArtRecordVector = new OwnedVector<OfficeArtRecord*>();
			if (m_bIsContainer)
			{
				nbAssert::Assert(m_pHeader->m_recVer == 0xF);
				while (pBlobView->GetOffset() < (int)(m_pHeader->m_recLen) && pBlobView->GetOffset() < pBlobView->GetSize())
				{
					OfficeArtRecord* pOfficeArtRecord = CreateOfficeArtRecord(pBlobView);
					{
						NumberDuck::Secret::OfficeArtRecord* __3533451309 = pOfficeArtRecord;
						pOfficeArtRecord = 0;
						m_pOfficeArtRecordVector->PushBack(__3533451309);
					}
					if (pOfficeArtRecord) delete pOfficeArtRecord;
				}
			}
		}

		OfficeArtRecord::OfficeArtRecord(Type nType, bool bIsContainer, unsigned int nSize, bool bHax)
		{
			m_pHeader = 0;
			m_bIsContainer = false;
			m_pOfficeArtRecordVector = 0;
			m_pHeader = new OfficeArtRecordHeaderStruct();
			m_pHeader->m_recType = (unsigned short)(nType);
			m_pHeader->m_recLen = nSize;
			m_bIsContainer = bIsContainer;
			m_pOfficeArtRecordVector = new OwnedVector<OfficeArtRecord*>();
		}

		unsigned short OfficeArtRecord::GetVersion()
		{
			return m_pHeader->m_recVer;
		}

		unsigned short OfficeArtRecord::GetInstance()
		{
			return m_pHeader->m_recInstance;
		}

		OfficeArtRecord::Type OfficeArtRecord::GetType()
		{
			return (Type)(m_pHeader->m_recType);
		}

		bool OfficeArtRecord::GetIsContainer()
		{
			return m_bIsContainer;
		}

		unsigned int OfficeArtRecord::GetSize()
		{
			return m_pHeader->m_recLen + OfficeArtRecordHeaderStruct::SIZE;
		}

		unsigned int OfficeArtRecord::GetRecursiveSize()
		{
			unsigned int nSize = OfficeArtRecordHeaderStruct::SIZE;
			if (m_bIsContainer)
			{
				for (int i = 0; i < m_pOfficeArtRecordVector->GetSize(); i++)
					nSize = nSize + m_pOfficeArtRecordVector->Get(i)->GetRecursiveSize();
			}
			else
			{
				nSize = nSize + m_pHeader->m_recLen;
			}
			return nSize;
		}

		void OfficeArtRecord::RecursiveWrite(BlobView* pBlobView)
		{
			int nBefore = pBlobView->GetOffset();
			m_pHeader->BlobWrite(pBlobView);
			nbAssert::Assert(pBlobView->GetOffset() - nBefore == OfficeArtRecordHeaderStruct::SIZE);
			if (m_bIsContainer)
			{
				for (int i = 0; i < m_pOfficeArtRecordVector->GetSize(); i++)
					m_pOfficeArtRecordVector->Get(i)->RecursiveWrite(pBlobView);
			}
			else
			{
				BlobWrite(pBlobView);
			}
			nbAssert::Assert(pBlobView->GetOffset() - nBefore == (int)(OfficeArtRecordHeaderStruct::SIZE + m_pHeader->m_recLen));
		}

		void OfficeArtRecord::BlobRead(BlobView* pBlobView)
		{
			nbAssert::Assert(false);
		}

		void OfficeArtRecord::BlobWrite(BlobView* pBlobView)
		{
			nbAssert::Assert(false);
		}

		unsigned short OfficeArtRecord::GetNumOfficeArtRecord()
		{
			nbAssert::Assert(m_bIsContainer);
			return (unsigned short)(m_pOfficeArtRecordVector->GetSize());
		}

		OfficeArtRecord* OfficeArtRecord::GetOfficeArtRecordByIndex(unsigned short nIndex)
		{
			nbAssert::Assert(m_bIsContainer);
			nbAssert::Assert(nIndex < m_pOfficeArtRecordVector->GetSize());
			return m_pOfficeArtRecordVector->Get(nIndex);
		}

		OfficeArtRecord* OfficeArtRecord::FindOfficeArtRecordByType(Type eType)
		{
			nbAssert::Assert(m_bIsContainer);
			for (int i = 0; i < m_pOfficeArtRecordVector->GetSize(); i++)
			{
				OfficeArtRecord* pOfficeArtRecord = m_pOfficeArtRecordVector->Get(i);
				if (pOfficeArtRecord->GetType() == eType)
					return pOfficeArtRecord;
				if (pOfficeArtRecord->GetIsContainer())
				{
					OfficeArtRecord* pTemp = pOfficeArtRecord->FindOfficeArtRecordByType(eType);
					if (pTemp != 0)
						return pTemp;
				}
			}
			return 0;
		}

		void OfficeArtRecord::AddOfficeArtRecord(OfficeArtRecord* pOfficeArtRecord)
		{
			nbAssert::Assert(m_bIsContainer);
			m_pHeader->m_recLen += pOfficeArtRecord->GetRecursiveSize();
			m_pOfficeArtRecordVector->PushBack(pOfficeArtRecord);
		}

		OfficeArtRecord* OfficeArtRecord::CreateOfficeArtRecord(BlobView* pBlobView)
		{
			nbAssert::Assert(pBlobView->GetOffset() < pBlobView->GetSize());
			if (pBlobView->GetSize() - pBlobView->GetOffset() < (int)(OfficeArtRecordHeaderStruct::SIZE))
				return 0;
			OfficeArtRecordHeaderStruct* pHeader = new OfficeArtRecordHeaderStruct();
			pHeader->BlobRead(pBlobView);
			if ((Type)(pHeader->m_recType) != Type::TYPE_OFFICE_ART_DG_CONTAINER && (Type)(pHeader->m_recType) != Type::TYPE_OFFICE_ART_SPGR_CONTAINER)
				if (pBlobView->GetOffset() + (int)(pHeader->m_recLen) > pBlobView->GetSize())
				{
					{
						if (pHeader) delete pHeader;
						return 0;
					}
				}
			switch ((Type)(pHeader->m_recType))
			{
				case Type::TYPE_OFFICE_ART_DGG_CONTAINER:
				{
					{
						NumberDuck::Secret::OfficeArtRecordHeaderStruct* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new OfficeArtDggContainerRecord(__1199093386, pBlobView);
						}
					}
				}

				case Type::TYPE_OFFICE_ART_B_STORE_CONTAINER:
				{
					{
						NumberDuck::Secret::OfficeArtRecordHeaderStruct* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new OfficeArtBStoreContainerRecord(__1199093386, pBlobView);
						}
					}
				}

				case Type::TYPE_OFFICE_ART_DG_CONTAINER:
				{
					{
						NumberDuck::Secret::OfficeArtRecordHeaderStruct* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new OfficeArtDgContainerRecord(__1199093386, pBlobView);
						}
					}
				}

				case Type::TYPE_OFFICE_ART_SPGR_CONTAINER:
				{
					{
						NumberDuck::Secret::OfficeArtRecordHeaderStruct* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new OfficeArtSpgrContainerRecord(__1199093386, pBlobView);
						}
					}
				}

				case Type::TYPE_OFFICE_ART_SP_CONTAINER:
				{
					{
						NumberDuck::Secret::OfficeArtRecordHeaderStruct* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new OfficeArtSpContainerRecord(__1199093386, pBlobView);
						}
					}
				}

				case Type::TYPE_OFFICE_ART_FDGG_BLOCK:
				{
					{
						NumberDuck::Secret::OfficeArtRecordHeaderStruct* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new OfficeArtFDGGBlockRecord(__1199093386, pBlobView);
						}
					}
				}

				case Type::TYPE_OFFICE_ART_FBSE:
				{
					{
						NumberDuck::Secret::OfficeArtRecordHeaderStruct* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new OfficeArtFBSERecord(__1199093386, pBlobView);
						}
					}
				}

				case Type::TYPE_OFFICE_ART_FDG:
				{
					{
						NumberDuck::Secret::OfficeArtRecordHeaderStruct* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new OfficeArtFDGRecord(__1199093386, pBlobView);
						}
					}
				}

				case Type::TYPE_OFFICE_ART_FSPGR:
				{
					{
						NumberDuck::Secret::OfficeArtRecordHeaderStruct* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new OfficeArtFSPGRRecord(__1199093386, pBlobView);
						}
					}
				}

				case Type::TYPE_OFFICE_ART_FSP:
				{
					{
						NumberDuck::Secret::OfficeArtRecordHeaderStruct* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new OfficeArtFSPRecord(__1199093386, pBlobView);
						}
					}
				}

				case Type::TYPE_OFFICE_ART_FOPT:
				{
					{
						NumberDuck::Secret::OfficeArtRecordHeaderStruct* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new OfficeArtFOPTRecord(__1199093386, pBlobView);
						}
					}
				}

				case Type::TYPE_OFFICE_ART_TERTIARY_FOPT:
				{
					{
						NumberDuck::Secret::OfficeArtRecordHeaderStruct* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new OfficeArtTertiaryFOPTRecord(__1199093386, pBlobView);
						}
					}
				}

				case Type::TYPE_OFFICE_ART_CLIENT_ANCHOR_SHEET:
				{
					{
						NumberDuck::Secret::OfficeArtRecordHeaderStruct* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new OfficeArtClientAnchorSheetRecord(__1199093386, pBlobView);
						}
					}
				}

				case Type::TYPE_OFFICE_ART_CLIENT_DATA:
				{
					{
						NumberDuck::Secret::OfficeArtRecordHeaderStruct* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new OfficeArtClientDataRecord(__1199093386, pBlobView);
						}
					}
				}

				case Type::TYPE_OFFICE_ART_BLIP_EMF:
				case Type::TYPE_OFFICE_ART_BLIP_WMF:
				case Type::TYPE_OFFICE_ART_BLIP_PICT:
				case Type::TYPE_OFFICE_ART_BLIP_JPEG:
				case Type::TYPE_OFFICE_ART_BLIP_PNG:
				case Type::TYPE_OFFICE_ART_BLIP_DIB:
				case Type::TYPE_OFFICE_ART_BLIP_TIFF:
				case Type::TYPE_OFFICE_ART_BLIP_JPEG_CMYK:
				{
					{
						NumberDuck::Secret::OfficeArtRecordHeaderStruct* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new OfficeArtBlipRecord(__1199093386, pBlobView);
						}
					}
				}

				case Type::TYPE_OFFICE_ART_FRIT_CONTAINER:
				{
					{
						NumberDuck::Secret::OfficeArtRecordHeaderStruct* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new OfficeArtFRITContainerRecord(__1199093386, pBlobView);
						}
					}
				}

				case Type::TYPE_OFFICE_ART_SPLIT_MENU_COLOR_CONTAINER:
				{
					{
						NumberDuck::Secret::OfficeArtRecordHeaderStruct* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new OfficeArtSplitMenuColorContainerRecord(__1199093386, pBlobView);
						}
					}
				}

				default:
				{
					{
						NumberDuck::Secret::OfficeArtRecordHeaderStruct* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new OfficeArtRecord(__1199093386, false, pBlobView);
						}
					}
				}

			}
			if (pHeader) delete pHeader;
		}

		OfficeArtRecord::~OfficeArtRecord()
		{
			if (m_pHeader) delete m_pHeader;
			if (m_pOfficeArtRecordVector) delete m_pOfficeArtRecordVector;
		}

		ParsedExpressionRecord::ParsedExpressionRecord(Type eType, unsigned short nSize, bool bHax)
		{
			m_eType = Type::TYPE_PtgExp;
			m_nSize = 0;
			m_nFirstByte = 0;
			m_nSecondByte = 0;
			m_eType = eType;
			m_nSize = nSize;
			m_nFirstByte = 0;
			m_nSecondByte = 0;
		}

		ParsedExpressionRecord::~ParsedExpressionRecord()
		{
		}

		Token* ParsedExpressionRecord::GetToken(WorkbookGlobals* pWorkbookGlobals)
		{
			return 0;
		}

		ParsedExpressionRecord::Type ParsedExpressionRecord::GetType()
		{
			return m_eType;
		}

		const char* ParsedExpressionRecord::GetTypeName()
		{
			switch ((Type)(m_eType))
			{
				case Type::TYPE_PtgExp:
				{
					return "TYPE_PtgExp";
				}

				case Type::TYPE_PtgAdd:
				{
					return "TYPE_PtgAdd";
				}

				case Type::TYPE_PtgSub:
				{
					return "TYPE_PtgSub";
				}

				case Type::TYPE_PtgMul:
				{
					return "TYPE_PtgMul";
				}

				case Type::TYPE_PtgDiv:
				{
					return "TYPE_PtgDiv";
				}

				case Type::TYPE_PtgPower:
				{
					return "TYPE_PtgPower";
				}

				case Type::TYPE_PtgConcat:
				{
					return "TYPE_PtgConcat";
				}

				case Type::TYPE_PtgLt:
				{
					return "TYPE_PtgLt";
				}

				case Type::TYPE_PtgLe:
				{
					return "TYPE_PtgLe";
				}

				case Type::TYPE_PtgEq:
				{
					return "TYPE_PtgEq";
				}

				case Type::TYPE_PtgGe:
				{
					return "TYPE_PtgGe";
				}

				case Type::TYPE_PtgGt:
				{
					return "TYPE_PtgGt";
				}

				case Type::TYPE_PtgNe:
				{
					return "TYPE_PtgNe";
				}

				case Type::TYPE_PtgParen:
				{
					return "TYPE_PtgParen";
				}

				case Type::TYPE_PtgMissArg:
				{
					return "TYPE_PtgMissArg";
				}

				case Type::TYPE_PtgStr:
				{
					return "TYPE_PtgStr";
				}

				case Type::TYPE_PtgAttrSemi:
				{
					return "TYPE_PtgAttrSemi";
				}

				case Type::TYPE_PtgAttrIf:
				{
					return "TYPE_PtgAttrIf";
				}

				case Type::TYPE_PtgAttrGoto:
				{
					return "TYPE_PtgAttrGoto";
				}

				case Type::TYPE_PtgAttrSum:
				{
					return "TYPE_PtgAttrSum";
				}

				case Type::TYPE_PtgAttrSpace:
				{
					return "TYPE_PtgAttrSpace";
				}

				case Type::TYPE_PtgArea:
				{
					return "TYPE_PtgArea";
				}

				case Type::TYPE_PtgBool:
				{
					return "TYPE_PtgBool";
				}

				case Type::TYPE_PtgInt:
				{
					return "TYPE_PtgInt";
				}

				case Type::TYPE_PtgNum:
				{
					return "TYPE_PtgNum";
				}

				case Type::TYPE_PtgArea3d:
				{
					return "TYPE_PtgArea3d";
				}

				case Type::TYPE_PtgFunc:
				{
					return "TYPE_PtgFunc";
				}

				case Type::TYPE_PtgFuncVar:
				{
					return "TYPE_PtgFuncVar";
				}

				case Type::TYPE_PtgRef:
				{
					return "TYPE_PtgRef";
				}

				case Type::TYPE_PtgRef3d:
				{
					return "TYPE_PtgRef3d";
				}

				case Type::TYPE_UNKNOWN:
				{
					return "TYPE_UNKNOWN";
				}

			}
			return "???";
		}

		unsigned short ParsedExpressionRecord::GetDataSize()
		{
			return m_nSize;
		}

		void ParsedExpressionRecord::BlobRead(BlobView* pBlobView)
		{
			nbAssert::Assert(false);
		}

		void ParsedExpressionRecord::BlobWrite(BlobView* pBlobView)
		{
			nbAssert::Assert(false);
		}

		ParsedExpressionRecord* ParsedExpressionRecord::CreateParsedExpressionRecord(BlobView* pBlobView)
		{
			int nInitialOffset = pBlobView->GetOffset();
			unsigned char ptg = pBlobView->UnpackUint8();
			pBlobView->SetOffset(nInitialOffset);
			ParsedExpressionRecord* pParsedExpressionRecord = 0;
			switch (ptg)
			{
				case 0x03:
				case 0x04:
				case 0x05:
				case 0x06:
				case 0x07:
				case 0x08:
				case 0x09:
				case 0x0A:
				case 0x0B:
				case 0x0C:
				case 0x0D:
				case 0x0E:
				{
					pParsedExpressionRecord = new PtgOperatorRecord(pBlobView);
					break;
				}

				case 0x15:
				{
					pParsedExpressionRecord = new PtgParenRecord(pBlobView);
					break;
				}

				case 0x16:
				{
					pParsedExpressionRecord = new PtgMissArgRecord(pBlobView);
					break;
				}

				case 0x17:
				{
					pParsedExpressionRecord = new PtgStrRecord(pBlobView);
					break;
				}

				case 0x19:
				{
					pBlobView->SetOffset(nInitialOffset + 1);
					unsigned char eptg = pBlobView->UnpackUint8();
					pBlobView->SetOffset(nInitialOffset);
					switch (eptg)
					{
						case 0x01:
						{
							pParsedExpressionRecord = new PtgAttrSemiRecord(pBlobView);
							break;
						}

						case 0x02:
						{
							pParsedExpressionRecord = new PtgAttrIfRecord(pBlobView);
							break;
						}

						case 0x08:
						{
							pParsedExpressionRecord = new PtgAttrGotoRecord(pBlobView);
							break;
						}

						case 0x10:
						{
							pParsedExpressionRecord = new PtgAttrSumRecord(pBlobView);
							break;
						}

						case 0x40:
						{
							pParsedExpressionRecord = new PtgAttrSpaceRecord(pBlobView);
							break;
						}

					}
					break;
				}

				case 0x1d:
				{
					pParsedExpressionRecord = new PtgBoolRecord(pBlobView);
					break;
				}

				case 0x1e:
				{
					pParsedExpressionRecord = new PtgIntRecord(pBlobView);
					break;
				}

				case 0x1f:
				{
					pParsedExpressionRecord = new PtgNumRecord(pBlobView);
					break;
				}

				case 0x22:
				{
					pParsedExpressionRecord = new PtgFuncVarRecord(pBlobView);
					break;
				}

				case 0x24:
				{
					pParsedExpressionRecord = new PtgRefRecord(pBlobView);
					break;
				}

				case 0x25:
				{
					pParsedExpressionRecord = new PtgAreaRecord(pBlobView);
					break;
				}

				case 0x3A:
				{
					pParsedExpressionRecord = new PtgRef3dRecord(pBlobView);
					break;
				}

				case 0x3B:
				{
					pParsedExpressionRecord = new PtgArea3dRecord(pBlobView);
					break;
				}

				case 0x41:
				{
					pParsedExpressionRecord = new PtgFuncRecord(pBlobView);
					break;
				}

				case 0x42:
				{
					pParsedExpressionRecord = new PtgFuncVarRecord(pBlobView);
					break;
				}

				case 0x44:
				{
					pParsedExpressionRecord = new PtgRefRecord(pBlobView);
					break;
				}

				case 0x5A:
				{
					pParsedExpressionRecord = new PtgRef3dRecord(pBlobView);
					break;
				}

				default:
				{
					pParsedExpressionRecord = new ParsedExpressionRecord(Type::TYPE_UNKNOWN, 0, true);
					break;
				}

			}
			{
				NumberDuck::Secret::ParsedExpressionRecord* __3596419756 = pParsedExpressionRecord;
				pParsedExpressionRecord = 0;
				return __3596419756;
			}
		}

		BiffHeader::BiffHeader()
		{
			m_nType = 0;
			m_nSize = 0;
		}

		const char* BiffRecord::GetTypeName()
		{
			switch ((Type)(m_pHeader->m_nType))
			{
				case Type::TYPE_DIMENSIONS_B2:
				{
					return "TYPE_DIMENSIONS_B2";
				}

				case Type::TYPE_BLANK_B2:
				{
					return "TYPE_BLANK_B2";
				}

				case Type::TYPE_INTEGER_B2_ONLY:
				{
					return "TYPE_INTEGER_B2_ONLY";
				}

				case Type::TYPE_NUMBER_B2:
				{
					return "TYPE_NUMBER_B2";
				}

				case Type::TYPE_LABEL_B2:
				{
					return "TYPE_LABEL_B2";
				}

				case Type::TYPE_BOOLERR_B2:
				{
					return "TYPE_BOOLERR_B2";
				}

				case Type::TYPE_FORMULA:
				{
					return "TYPE_FORMULA";
				}

				case Type::TYPE_STRING_B2:
				{
					return "TYPE_STRING_B2";
				}

				case Type::TYPE_ROW_B2:
				{
					return "TYPE_ROW_B2";
				}

				case Type::TYPE_BOF_B2:
				{
					return "TYPE_BOF_B2";
				}

				case Type::TYPE_EOF:
				{
					return "TYPE_EOF";
				}

				case Type::TYPE_INDEX_B2_ONLY:
				{
					return "TYPE_INDEX_B2_ONLY";
				}

				case Type::TYPE_CALCCOUNT:
				{
					return "TYPE_CALCCOUNT";
				}

				case Type::TYPE_CALCMODE:
				{
					return "TYPE_CALCMODE";
				}

				case Type::TYPE_CALC_PRECISION:
				{
					return "TYPE_CALC_PRECISION";
				}

				case Type::TYPE_REFMODE:
				{
					return "TYPE_REFMODE";
				}

				case Type::TYPE_DELTA:
				{
					return "TYPE_DELTA";
				}

				case Type::TYPE_ITERATION:
				{
					return "TYPE_ITERATION";
				}

				case Type::TYPE_PROTECT:
				{
					return "TYPE_PROTECT";
				}

				case Type::TYPE_PASSWORD:
				{
					return "TYPE_PASSWORD";
				}

				case Type::TYPE_HEADER:
				{
					return "TYPE_HEADER";
				}

				case Type::TYPE_FOOTER:
				{
					return "TYPE_FOOTER";
				}

				case Type::TYPE_EXTERNCOUNT:
				{
					return "TYPE_EXTERNCOUNT";
				}

				case Type::TYPE_EXTERN_SHEET:
				{
					return "TYPE_EXTERN_SHEET";
				}

				case Type::TYPE_NAME_B2:
				{
					return "TYPE_NAME_B2";
				}

				case Type::TYPE_WIN_PROTECT:
				{
					return "TYPE_WIN_PROTECT";
				}

				case Type::TYPE_VERTICALPAGEBREAKS:
				{
					return "TYPE_VERTICALPAGEBREAKS";
				}

				case Type::TYPE_HORIZONTALPAGEBREAKS:
				{
					return "TYPE_HORIZONTALPAGEBREAKS";
				}

				case Type::TYPE_NOTE:
				{
					return "TYPE_NOTE";
				}

				case Type::TYPE_SELECTION:
				{
					return "TYPE_SELECTION";
				}

				case Type::TYPE_FORMAT_B2:
				{
					return "TYPE_FORMAT_B2";
				}

				case Type::TYPE_BUILTINFMTCOUNT_B2:
				{
					return "TYPE_BUILTINFMTCOUNT_B2";
				}

				case Type::TYPE_COLUMNDEFAULT_B2_ONLY:
				{
					return "TYPE_COLUMNDEFAULT_B2_ONLY";
				}

				case Type::TYPE_ARRAY_B2_ONLY:
				{
					return "TYPE_ARRAY_B2_ONLY";
				}

				case Type::TYPE_DATE_1904:
				{
					return "TYPE_DATE_1904";
				}

				case Type::TYPE_EXTERN_NAME:
				{
					return "TYPE_EXTERN_NAME";
				}

				case Type::TYPE_COLWIDTH_B2_ONLY:
				{
					return "TYPE_COLWIDTH_B2_ONLY";
				}

				case Type::TYPE_DEFAULTROWHEIGHT_B2_ONLY:
				{
					return "TYPE_DEFAULTROWHEIGHT_B2_ONLY";
				}

				case Type::TYPE_LEFT_MARGIN:
				{
					return "TYPE_LEFT_MARGIN";
				}

				case Type::TYPE_RIGHT_MARGIN:
				{
					return "TYPE_RIGHT_MARGIN";
				}

				case Type::TYPE_TOP_MARGIN:
				{
					return "TYPE_TOP_MARGIN";
				}

				case Type::TYPE_BOTTOM_MARGIN:
				{
					return "TYPE_BOTTOM_MARGIN";
				}

				case Type::TYPE_PrintRowCol:
				{
					return "TYPE_PrintRowCol";
				}

				case Type::TYPE_PrintGrid:
				{
					return "TYPE_PrintGrid";
				}

				case Type::TYPE_FILEPASS:
				{
					return "TYPE_FILEPASS";
				}

				case Type::TYPE_FONT:
				{
					return "TYPE_FONT";
				}

				case Type::TYPE_FONT2_B2_ONLY:
				{
					return "TYPE_FONT2_B2_ONLY";
				}

				case Type::TYPE_PRINT_SIZE:
				{
					return "TYPE_PRINT_SIZE";
				}

				case Type::TYPE_TABLEOP_B2:
				{
					return "TYPE_TABLEOP_B2";
				}

				case Type::TYPE_TABLEOP2_B2:
				{
					return "TYPE_TABLEOP2_B2";
				}

				case Type::TYPE_CONTINUE:
				{
					return "TYPE_CONTINUE";
				}

				case Type::TYPE_WINDOW1:
				{
					return "TYPE_WINDOW1";
				}

				case Type::TYPE_WINDOW2_B2:
				{
					return "TYPE_WINDOW2_B2";
				}

				case Type::TYPE_BACKUP:
				{
					return "TYPE_BACKUP";
				}

				case Type::TYPE_PANE:
				{
					return "TYPE_PANE";
				}

				case Type::TYPE_CODE_PAGE:
				{
					return "TYPE_CODE_PAGE";
				}

				case Type::TYPE_XF_B2:
				{
					return "TYPE_XF_B2";
				}

				case Type::TYPE_IXFE_B2_ONLY:
				{
					return "TYPE_IXFE_B2_ONLY";
				}

				case Type::TYPE_EFONT_B2_ONLY:
				{
					return "TYPE_EFONT_B2_ONLY";
				}

				case Type::TYPE_PLS:
				{
					return "TYPE_PLS";
				}

				case Type::TYPE_DCONREF:
				{
					return "TYPE_DCONREF";
				}

				case Type::TYPE_DEFCOLWIDTH:
				{
					return "TYPE_DEFCOLWIDTH";
				}

				case Type::TYPE_BUILTINFMTCOUNT_B3:
				{
					return "TYPE_BUILTINFMTCOUNT_B3";
				}

				case Type::TYPE_XCT:
				{
					return "TYPE_XCT";
				}

				case Type::TYPE_CRN:
				{
					return "TYPE_CRN";
				}

				case Type::TYPE_FILESHARING:
				{
					return "TYPE_FILESHARING";
				}

				case Type::TYPE_WRITE_ACCESS:
				{
					return "TYPE_WRITE_ACCESS";
				}

				case Type::TYPE_OBJ:
				{
					return "TYPE_OBJ";
				}

				case Type::TYPE_UNCALCED:
				{
					return "TYPE_UNCALCED";
				}

				case Type::TYPE_SAVERECALC:
				{
					return "TYPE_SAVERECALC";
				}

				case Type::TYPE_OBJECTPROTECT:
				{
					return "TYPE_OBJECTPROTECT";
				}

				case Type::TYPE_COLINFO:
				{
					return "TYPE_COLINFO";
				}

				case Type::TYPE_RK2_mythical:
				{
					return "TYPE_RK2_mythical_";
				}

				case Type::TYPE_GUTS:
				{
					return "TYPE_GUTS";
				}

				case Type::TYPE_WSBOOL:
				{
					return "TYPE_WSBOOL";
				}

				case Type::TYPE_GRIDSET:
				{
					return "TYPE_GRIDSET";
				}

				case Type::TYPE_HCENTER:
				{
					return "TYPE_HCENTER";
				}

				case Type::TYPE_VCENTER:
				{
					return "TYPE_VCENTER";
				}

				case Type::TYPE_BOUND_SHEET_8:
				{
					return "TYPE_BOUND_SHEET_8";
				}

				case Type::TYPE_WRITEPROT:
				{
					return "TYPE_WRITEPROT";
				}

				case Type::TYPE_COUNTRY:
				{
					return "TYPE_COUNTRY";
				}

				case Type::TYPE_HIDE_OBJ:
				{
					return "TYPE_HIDE_OBJ";
				}

				case Type::TYPE_SHEETSOFFSET:
				{
					return "TYPE_SHEETSOFFSET";
				}

				case Type::TYPE_SHEETHDR:
				{
					return "TYPE_SHEETHDR";
				}

				case Type::TYPE_SORT:
				{
					return "TYPE_SORT";
				}

				case Type::TYPE_PALETTE:
				{
					return "TYPE_PALETTE";
				}

				case Type::TYPE_STANDARDWIDTH:
				{
					return "TYPE_STANDARDWIDTH";
				}

				case Type::TYPE_FILTERMODE:
				{
					return "TYPE_FILTERMODE";
				}

				case Type::TYPE_BUILT_IN_FN_GROUP_COUNT:
				{
					return "TYPE_BUILT_IN_FN_GROUP_COUNT";
				}

				case Type::TYPE_AUTOFILTERINFO:
				{
					return "TYPE_AUTOFILTERINFO";
				}

				case Type::TYPE_AUTOFILTER:
				{
					return "TYPE_AUTOFILTER";
				}

				case Type::TYPE_SCL:
				{
					return "TYPE_SCL";
				}

				case Type::TYPE_SETUP:
				{
					return "TYPE_SETUP";
				}

				case Type::TYPE_GCW:
				{
					return "TYPE_GCW";
				}

				case Type::TYPE_MULRK:
				{
					return "TYPE_MULRK";
				}

				case Type::TYPE_MULBLANK:
				{
					return "TYPE_MULBLANK";
				}

				case Type::TYPE_MMS:
				{
					return "TYPE_MMS";
				}

				case Type::TYPE_RSTRING:
				{
					return "TYPE_RSTRING";
				}

				case Type::TYPE_DBCELL:
				{
					return "TYPE_DBCELL";
				}

				case Type::TYPE_BOOK_BOOL:
				{
					return "TYPE_BOOK_BOOL";
				}

				case Type::TYPE_SCENPROTECT:
				{
					return "TYPE_SCENPROTECT";
				}

				case Type::TYPE_XF:
				{
					return "TYPE_XF";
				}

				case Type::TYPE_INTERFACE_HDR:
				{
					return "TYPE_INTERFACE_HDR";
				}

				case Type::TYPE_INTERFACE_END:
				{
					return "TYPE_INTERFACE_END";
				}

				case Type::TYPE_MergeCells:
				{
					return "TYPE_MergeCells";
				}

				case Type::TYPE_BITMAP:
				{
					return "TYPE_BITMAP";
				}

				case Type::TYPE_MSO_DRAWING_GROUP:
				{
					return "TYPE_MSO_DRAWING_GROUP";
				}

				case Type::TYPE_MSO_DRAWING:
				{
					return "TYPE_MSO_DRAWING";
				}

				case Type::TYPE_MSO_DRAWING_SELECTION:
				{
					return "TYPE_MSO_DRAWING_SELECTION";
				}

				case Type::TYPE_PHONETIC:
				{
					return "TYPE_PHONETIC";
				}

				case Type::TYPE_SST:
				{
					return "TYPE_SST";
				}

				case Type::TYPE_LABELSST:
				{
					return "TYPE_LABELSST";
				}

				case Type::TYPE_EXT_SST:
				{
					return "TYPE_EXT_SST";
				}

				case Type::TYPE_RR_TAB_ID:
				{
					return "TYPE_RR_TAB_ID";
				}

				case Type::TYPE_LABELRANGES:
				{
					return "TYPE_LABELRANGES";
				}

				case Type::TYPE_USESELFS:
				{
					return "TYPE_USESELFS";
				}

				case Type::TYPE_DSF:
				{
					return "TYPE_DSF";
				}

				case Type::TYPE_SUP_BOOK:
				{
					return "TYPE_SUP_BOOK";
				}

				case Type::TYPE_PROT_4_REV:
				{
					return "TYPE_PROT_4_REV";
				}

				case Type::TYPE_CONDFMT:
				{
					return "TYPE_CONDFMT";
				}

				case Type::TYPE_CF:
				{
					return "TYPE_CF";
				}

				case Type::TYPE_DVAL:
				{
					return "TYPE_DVAL";
				}

				case Type::TYPE_TXO:
				{
					return "TYPE_TXO";
				}

				case Type::TYPE_REFRESH_ALL:
				{
					return "TYPE_REFRESH_ALL";
				}

				case Type::TYPE_HLINK:
				{
					return "TYPE_HLINK";
				}

				case Type::TYPE_PROT_4_REV_PASS:
				{
					return "TYPE_PROT_4_REV_PASS";
				}

				case Type::TYPE_DV:
				{
					return "TYPE_DV";
				}

				case Type::TYPE_EXCEL9_FILE:
				{
					return "TYPE_EXCEL9_FILE";
				}

				case Type::TYPE_RECALCID:
				{
					return "TYPE_RECALCID";
				}

				case Type::TYPE_DIMENSION:
				{
					return "TYPE_DIMENSION";
				}

				case Type::TYPE_BLANK:
				{
					return "TYPE_BLANK";
				}

				case Type::TYPE_NUMBER:
				{
					return "TYPE_NUMBER";
				}

				case Type::TYPE_LABEL:
				{
					return "TYPE_LABEL";
				}

				case Type::TYPE_BOOLERR:
				{
					return "TYPE_BOOLERR";
				}

				case Type::TYPE_FORMULA_B3:
				{
					return "TYPE_FORMULA_B3";
				}

				case Type::TYPE_STRING:
				{
					return "TYPE_STRING";
				}

				case Type::TYPE_ROW:
				{
					return "TYPE_ROW";
				}

				case Type::TYPE_INDEX_B3:
				{
					return "TYPE_INDEX_B3";
				}

				case Type::TYPE_NAME:
				{
					return "TYPE_NAME";
				}

				case Type::TYPE_ARRAY:
				{
					return "TYPE_ARRAY";
				}

				case Type::TYPE_EXTERNNAME_B3:
				{
					return "TYPE_EXTERNNAME_B3";
				}

				case Type::TYPE_DEFAULTROWHEIGHT:
				{
					return "TYPE_DEFAULTROWHEIGHT";
				}

				case Type::TYPE_FONT_B3B4:
				{
					return "TYPE_FONT_B3B4";
				}

				case Type::TYPE_TABLEOP:
				{
					return "TYPE_TABLEOP";
				}

				case Type::TYPE_WINDOW2:
				{
					return "TYPE_WINDOW2";
				}

				case Type::TYPE_XF_B3:
				{
					return "TYPE_XF_B3";
				}

				case Type::TYPE_RK:
				{
					return "TYPE_RK";
				}

				case Type::TYPE_STYLE:
				{
					return "TYPE_STYLE";
				}

				case Type::TYPE_STYLE_EXT:
				{
					return "TYPE_STYLE_EXT";
				}

				case Type::TYPE_FORMULA_B4:
				{
					return "TYPE_FORMULA_B4";
				}

				case Type::TYPE_FORMAT:
				{
					return "TYPE_FORMAT";
				}

				case Type::TYPE_XF_B4:
				{
					return "TYPE_XF_B4";
				}

				case Type::TYPE_SHRFMLA:
				{
					return "TYPE_SHRFMLA";
				}

				case Type::TYPE_QUICKTIP:
				{
					return "TYPE_QUICKTIP";
				}

				case Type::TYPE_BOF:
				{
					return "TYPE_BOF";
				}

				case Type::TYPE_SHEETLAYOUT:
				{
					return "TYPE_SHEETLAYOUT";
				}

				case Type::TYPE_SHEETPROTECTION:
				{
					return "TYPE_SHEETPROTECTION";
				}

				case Type::TYPE_RANGEPROTECTION:
				{
					return "TYPE_RANGEPROTECTION";
				}

				case Type::TYPE_XF_CRC:
				{
					return "TYPE_XF_CRC";
				}

				case Type::TYPE_XF_EXT:
				{
					return "TYPE_XF_EXT";
				}

				case Type::TYPE_BOOK_EXT:
				{
					return "TYPE_BOOK_EXT";
				}

				case Type::TYPE_THEME:
				{
					return "TYPE_THEME";
				}

				case Type::TYPE_COMPRESS_PICTURES:
				{
					return "TYPE_COMPRESS_PICTURES";
				}

				case Type::TYPE_PLV:
				{
					return "TYPE_PLV";
				}

				case Type::TYPE_COMPAT12:
				{
					return "TYPE_COMPAT12";
				}

				case Type::TYPE_MTR_SETTINGS:
				{
					return "TYPE_MTR_SETTINGS";
				}

				case Type::TYPE_FORCE_FULL_CALCULATION:
				{
					return "TYPE_FORCE_FULL_CALCULATION";
				}

				case Type::TYPE_TABLE_STYLES:
				{
					return "TYPE_TABLE_STYLES";
				}

				case Type::TYPE_ChartColors:
				{
					return "TYPE_ChartColors";
				}

				case Type::TYPE_ChartFrtInfo:
				{
					return "TYPE_ChartFrtInfo";
				}

				case Type::TYPE_StartBlock:
				{
					return "TYPE_StartBlock";
				}

				case Type::TYPE_EndBlock:
				{
					return "TYPE_EndBlock";
				}

				case Type::TYPE_StartObject:
				{
					return "TYPE_StartObject";
				}

				case Type::TYPE_EndObject:
				{
					return "TYPE_EndObject";
				}

				case Type::TYPE_CatLab:
				{
					return "TYPE_CatLab";
				}

				case Type::TYPE_YMult:
				{
					return "TYPE_YMult";
				}

				case Type::TYPE_FrtFontList:
				{
					return "TYPE_FrtFontList";
				}

				case Type::TYPE_DataLabExt:
				{
					return "TYPE_DataLabExt";
				}

				case Type::TYPE_DataLabExtContents:
				{
					return "TYPE_DataLabExtContents";
				}

				case Type::TYPE_NamePublish:
				{
					return "TYPE_NamePublish";
				}

				case Type::TYPE_HeaderFooter:
				{
					return "TYPE_HeaderFooter";
				}

				case Type::TYPE_CrtMlFrt:
				{
					return "TYPE_CrtMlFrt";
				}

				case Type::TYPE_ShapePropsStream:
				{
					return "TYPE_ShapePropsStream";
				}

				case Type::TYPE_TextPropsStream:
				{
					return "TYPE_TextPropsStream";
				}

				case Type::TYPE_CrtLayout12A:
				{
					return "TYPE_CrtLayout12A";
				}

				case Type::TYPE_Units:
				{
					return "TYPE_Units";
				}

				case Type::TYPE_Chart:
				{
					return "TYPE_Chart";
				}

				case Type::TYPE_Series:
				{
					return "TYPE_Series";
				}

				case Type::TYPE_DataFormat:
				{
					return "TYPE_DataFormat";
				}

				case Type::TYPE_LineFormat:
				{
					return "TYPE_LineFormat";
				}

				case Type::TYPE_MarkerFormat:
				{
					return "TYPE_MarkerFormat";
				}

				case Type::TYPE_AreaFormat:
				{
					return "TYPE_AreaFormat";
				}

				case Type::TYPE_PieFormat:
				{
					return "TYPE_PieFormat";
				}

				case Type::TYPE_AttachedLabel:
				{
					return "TYPE_AttachedLabel";
				}

				case Type::TYPE_SeriesText:
				{
					return "TYPE_SeriesText";
				}

				case Type::TYPE_ChartFormat:
				{
					return "TYPE_ChartFormat";
				}

				case Type::TYPE_Legend:
				{
					return "TYPE_Legend";
				}

				case Type::TYPE_SeriesList:
				{
					return "TYPE_SeriesList";
				}

				case Type::TYPE_Bar:
				{
					return "TYPE_Bar";
				}

				case Type::TYPE_Line:
				{
					return "TYPE_Line";
				}

				case Type::TYPE_Pie:
				{
					return "TYPE_Pie";
				}

				case Type::TYPE_Area:
				{
					return "TYPE_Area";
				}

				case Type::TYPE_Scatter:
				{
					return "TYPE_Scatter";
				}

				case Type::TYPE_CrtLine:
				{
					return "TYPE_CrtLine";
				}

				case Type::TYPE_Axis:
				{
					return "TYPE_Axis";
				}

				case Type::TYPE_Tick:
				{
					return "TYPE_Tick";
				}

				case Type::TYPE_ValueRange:
				{
					return "TYPE_ValueRange";
				}

				case Type::TYPE_CatSerRange:
				{
					return "TYPE_CatSerRange";
				}

				case Type::TYPE_AxisLine:
				{
					return "TYPE_AxisLine";
				}

				case Type::TYPE_CrtLink:
				{
					return "TYPE_CrtLink";
				}

				case Type::TYPE_DefaultText:
				{
					return "TYPE_DefaultText";
				}

				case Type::TYPE_Text:
				{
					return "TYPE_Text";
				}

				case Type::TYPE_FontX:
				{
					return "TYPE_FontX";
				}

				case Type::TYPE_ObjectLink:
				{
					return "TYPE_ObjectLink";
				}

				case Type::TYPE_Frame:
				{
					return "TYPE_Frame";
				}

				case Type::TYPE_Begin:
				{
					return "TYPE_Begin";
				}

				case Type::TYPE_End:
				{
					return "TYPE_End";
				}

				case Type::TYPE_PlotArea:
				{
					return "TYPE_PlotArea";
				}

				case Type::TYPE_Chart3d:
				{
					return "TYPE_Chart3d";
				}

				case Type::TYPE_PicF:
				{
					return "TYPE_PicF";
				}

				case Type::TYPE_DropBar:
				{
					return "TYPE_DropBar";
				}

				case Type::TYPE_Radar:
				{
					return "TYPE_Radar";
				}

				case Type::TYPE_Surf:
				{
					return "TYPE_Surf";
				}

				case Type::TYPE_RadarArea:
				{
					return "TYPE_RadarArea";
				}

				case Type::TYPE_AxisParent:
				{
					return "TYPE_AxisParent";
				}

				case Type::TYPE_LegendException:
				{
					return "TYPE_LegendException";
				}

				case Type::TYPE_ShtProps:
				{
					return "TYPE_ShtProps";
				}

				case Type::TYPE_SerToCrt:
				{
					return "TYPE_SerToCrt";
				}

				case Type::TYPE_AxesUsed:
				{
					return "TYPE_AxesUsed";
				}

				case Type::TYPE_SerParent:
				{
					return "TYPE_SerParent";
				}

				case Type::TYPE_SerAuxTrend:
				{
					return "TYPE_SerAuxTrend";
				}

				case Type::TYPE_IFmtRecord:
				{
					return "TYPE_IFmtRecord";
				}

				case Type::TYPE_Pos:
				{
					return "TYPE_Pos";
				}

				case Type::TYPE_AlRuns:
				{
					return "TYPE_AlRuns";
				}

				case Type::TYPE_BRAI:
				{
					return "TYPE_BRAI";
				}

				case Type::TYPE_BOFDatasheet:
				{
					return "TYPE_BOFDatasheet";
				}

				case Type::TYPE_ExcludeRows:
				{
					return "TYPE_ExcludeRows";
				}

				case Type::TYPE_ExcludeColumns:
				{
					return "TYPE_ExcludeColumns";
				}

				case Type::TYPE_Orient:
				{
					return "TYPE_Orient";
				}

				case Type::TYPE_WinDoc:
				{
					return "TYPE_WinDoc";
				}

				case Type::TYPE_MaxStatus:
				{
					return "TYPE_MaxStatus";
				}

				case Type::TYPE_MainWindow:
				{
					return "TYPE_MainWindow";
				}

				case Type::TYPE_SerAuxErrBar:
				{
					return "TYPE_SerAuxErrBar";
				}

				case Type::TYPE_ClrtClient:
				{
					return "TYPE_ClrtClient";
				}

				case Type::TYPE_SerFmt:
				{
					return "TYPE_SerFmt";
				}

				case Type::TYPE_LinkedSelection:
				{
					return "TYPE_LinkedSelection";
				}

				case Type::TYPE_Chart3DBarShape:
				{
					return "TYPE_Chart3DBarShape";
				}

				case Type::TYPE_Fbi:
				{
					return "TYPE_Fbi";
				}

				case Type::TYPE_BopPop:
				{
					return "TYPE_BopPop";
				}

				case Type::TYPE_AxcExt:
				{
					return "TYPE_AxcExt";
				}

				case Type::TYPE_Dat:
				{
					return "TYPE_Dat";
				}

				case Type::TYPE_PlotGrowth:
				{
					return "TYPE_PlotGrowth";
				}

				case Type::TYPE_SIIndex:
				{
					return "TYPE_SIIndex";
				}

				case Type::TYPE_GelFrame:
				{
					return "TYPE_GelFrame";
				}

				case Type::TYPE_BopPopCustom:
				{
					return "TYPE_BopPopCustom";
				}

				case Type::TYPE_Fbi2:
				{
					return "TYPE_Fbi2";
				}

			}
			return "???";
		}

		BiffRecord::BiffRecord(BiffHeader* pHeader, Stream* pStream)
		{
			m_pHeader = 0;
			m_pContinueBlob = 0;
			m_pBlobView = 0;
			m_pContinueInfoVector = 0;
			m_pHeader = pHeader;
			m_pContinueBlob = 0;
			BlobView* pBlobView = pStream->GetSectorChain()->GetBlobView();
			m_pBlobView = new BlobView(pBlobView->GetBlob(), pBlobView->GetStart() + pBlobView->GetOffset(), (int)(pBlobView->GetStart() + pBlobView->GetOffset() + m_pHeader->m_nSize));
			pBlobView->SetOffset((int)(pBlobView->GetOffset() + m_pHeader->m_nSize));
			m_pContinueInfoVector = new OwnedVector<BiffRecord_ContinueInfo*>();
			if (m_pHeader->m_nType != (unsigned short)(Type::TYPE_CONTINUE))
			{
				while (pStream->GetStreamSize() - pStream->GetOffset() >= SIZEOF_HEADER)
				{
					int nOffset = pStream->GetOffset();
					BiffHeader* pSubHeader = new BiffHeader();
					pSubHeader->m_nType = pBlobView->UnpackUint16();
					pSubHeader->m_nSize = pBlobView->UnpackUint16();
					if (!(m_pHeader->m_nType == (unsigned short)(Type::TYPE_MSO_DRAWING_GROUP) && pSubHeader->m_nType == (unsigned short)(Type::TYPE_MSO_DRAWING_GROUP) || pSubHeader->m_nType == (unsigned short)(Type::TYPE_CONTINUE)))
					{
						pStream->SetOffset(nOffset);
						{
							delete pSubHeader;
							pSubHeader = 0;
						}
						{
							if (pSubHeader) delete pSubHeader;
							break;
						}
					}
					pSubHeader->m_nType = (unsigned short)(Type::TYPE_CONTINUE);
					if (m_pContinueBlob == 0)
					{
						m_pContinueBlob = new Blob(true);
						m_pContinueBlob->GetBlobView()->Pack(m_pBlobView, m_pBlobView->GetSize());
						{
							delete m_pBlobView;
							m_pBlobView = 0;
						}
						m_pBlobView = new BlobView(m_pContinueBlob, 0, m_pContinueBlob->GetSize());
					}
					unsigned short nTempType = pSubHeader->m_nType;
					BiffRecord* pBiffRecord = 0;
					{
						NumberDuck::Secret::BiffHeader* __4098344237 = pSubHeader;
						pSubHeader = 0;
						pBiffRecord = new BiffRecord(__4098344237, pStream);
					}
					Extend(pBiffRecord);
					m_pContinueInfoVector->Get(m_pContinueInfoVector->GetSize() - 1)->m_nType = nTempType;
					m_pContinueBlob->GetBlobView()->Pack(pBiffRecord->m_pBlobView, pBiffRecord->m_pBlobView->GetSize());
					{
						delete m_pBlobView;
						m_pBlobView = 0;
					}
					m_pBlobView = new BlobView(m_pContinueBlob, 0, m_pContinueBlob->GetSize());
					{
						delete pBiffRecord;
						pBiffRecord = 0;
					}
					if (pSubHeader) delete pSubHeader;
					if (pBiffRecord) delete pBiffRecord;
				}
			}
		}

		BiffRecord::BiffRecord(Type nType, unsigned int nSize)
		{
			m_pHeader = 0;
			m_pContinueBlob = 0;
			m_pBlobView = 0;
			m_pContinueInfoVector = 0;
			m_pHeader = new BiffHeader();
			m_pHeader->m_nType = (unsigned short)(nType);
			m_pHeader->m_nSize = nSize;
			m_pContinueBlob = 0;
			m_pBlobView = 0;
			m_pContinueInfoVector = new OwnedVector<BiffRecord_ContinueInfo*>();
		}

		BiffRecord::Type BiffRecord::GetType()
		{
			return (Type)(m_pHeader->m_nType);
		}

		unsigned int BiffRecord::GetSize()
		{
			return (unsigned int)(m_pHeader->m_nSize + SIZEOF_HEADER + m_pContinueInfoVector->GetSize() * SIZEOF_HEADER);
		}

		BiffRecord* BiffRecord::CreateBiffRecord(Stream* pStream)
		{
			BlobView* pBlobView = pStream->GetSectorChain()->GetBlobView();
			BiffHeader* pHeader = new BiffHeader();
			pHeader->m_nType = pBlobView->UnpackUint16();
			pHeader->m_nSize = pBlobView->UnpackUint16();
			switch ((Type)(pHeader->m_nType))
			{
				case Type::TYPE_BOF:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new BofRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_INTERFACE_HDR:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new InterfaceHdr(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_MMS:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new Mms(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_INTERFACE_END:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new InterfaceEnd(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_WRITE_ACCESS:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new WriteAccess(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_CODE_PAGE:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new CodePage(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_DSF:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new DSF(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_EXCEL9_FILE:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new Excel9File(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_RR_TAB_ID:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new RRTabId(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_BUILT_IN_FN_GROUP_COUNT:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new BuiltInFnGroupCount(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_WIN_PROTECT:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new WinProtect(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_PROTECT:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new ProtectRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_PASSWORD:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new PasswordRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_PROT_4_REV:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new Prot4RevRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_PROT_4_REV_PASS:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new Prot4RevPassRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_WINDOW1:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new Window1(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_BACKUP:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new Backup(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_HIDE_OBJ:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new HideObj(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_DATE_1904:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new Date1904(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_CALC_PRECISION:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new CalcPrecision(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_REFRESH_ALL:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new RefreshAllRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_BOOK_BOOL:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new BookBool(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_FONT:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new FontRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_FORMAT:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new Format(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_XF:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new XF(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_STYLE:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new StyleRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_MergeCells:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new MergeCellsRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_SST:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new SstRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_BOUND_SHEET_8:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new BoundSheet8Record(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_PALETTE:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new PaletteRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_PrintRowCol:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new PrintRowColRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_PrintGrid:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new PrintGridRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_CALCCOUNT:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new CalcCountRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_WSBOOL:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new WsBoolRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_DIMENSION:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new DimensionRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_DEFCOLWIDTH:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new DefColWidthRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_DEFAULTROWHEIGHT:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new DefaultRowHeight(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_COLINFO:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new ColInfoRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_ROW:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new RowRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_LABELSST:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new LabelSstRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_RK:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new RkRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_MULRK:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new MulRkRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_BLANK:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new Blank(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_MULBLANK:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new MulBlank(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_NUMBER:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new NumberRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_BOOLERR:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new BoolErrRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_FORMULA:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new FormulaRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_WINDOW2:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new Window2Record(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_SELECTION:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new SelectionRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_XF_CRC:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new XFCRC(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_XF_EXT:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new XFExt(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_BOOK_EXT:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new BookExtRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_THEME:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new Theme(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_SUP_BOOK:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new SupBookRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_EXTERN_SHEET:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new ExternSheetRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_CrtLink:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new CrtLinkRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_Units:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new UnitsRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_Chart:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new ChartRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_Begin:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new BeginRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_Frame:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new FrameRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_LineFormat:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new LineFormatRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_AreaFormat:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new AreaFormatRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_Series:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new SeriesRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_BRAI:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new BraiRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_DataFormat:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new DataFormatRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_MarkerFormat:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new MarkerFormatRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_SerToCrt:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new SerToCrtRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_ShtProps:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new ShtPropsRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_AxesUsed:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new AxesUsedRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_AxisParent:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new AxisParentRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_Pos:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new PosRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_Axis:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new AxisRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_CatSerRange:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new CatSerRangeRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_AxcExt:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new AxcExtRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_Tick:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new TickRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_FontX:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new FontXRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_AxisLine:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new AxisLineRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_ValueRange:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new ValueRangeRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_PlotArea:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new PlotAreaRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_ChartFormat:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new ChartFormatRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_Line:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new LineRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_Bar:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new BarRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_Area:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new AreaRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_Scatter:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new ScatterRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_Legend:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new LegendRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_Text:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new TextRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_SeriesText:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new SeriesTextRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_ObjectLink:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new ObjectLinkRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_HCENTER:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new HCenterRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_VCENTER:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new VCenterRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_LEFT_MARGIN:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new LeftMarginRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_RIGHT_MARGIN:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new RightMarginRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_TOP_MARGIN:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new TopMarginRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_BOTTOM_MARGIN:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new BottomMarginRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_SETUP:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new SetupRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_PRINT_SIZE:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new PrintSizeRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_SCL:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new SclRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_PlotGrowth:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new PlotGrowthRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_SIIndex:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new SIIndexRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_ChartFrtInfo:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new ChartFrtInfoRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_StartBlock:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new StartBlockRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_EndBlock:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new EndBlockRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_ShapePropsStream:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new ShapePropsStreamRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_CrtLayout12A:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new CrtLayout12ARecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_CrtMlFrt:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new CrtMlFrtRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_HeaderFooter:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new HeaderFooterRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_Chart3DBarShape:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new Chart3DBarShapeRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_PieFormat:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new PieFormatRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_CatLab:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new CatLabRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_DefaultText:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new DefaultTextRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_GelFrame:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new GelFrameRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_OBJ:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new ObjRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_MSO_DRAWING_GROUP:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new MsoDrawingGroupRecord(__1199093386, pStream);
						}
					}
				}

				case Type::TYPE_MSO_DRAWING:
				{
					{
						NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
						pHeader = 0;
						{
							if (pHeader) delete pHeader;
							return new MsoDrawingRecord(__1199093386, pStream);
						}
					}
				}

			}
			{
				NumberDuck::Secret::BiffHeader* __1199093386 = pHeader;
				pHeader = 0;
				{
					if (pHeader) delete pHeader;
					return new BiffRecord(__1199093386, pStream);
				}
			}
		}

		void BiffRecord::Write(Stream* pStream, BlobView* pTempBlobView)
		{
			BlobWrite(pTempBlobView);
			pTempBlobView->SetOffset(0);
			nbAssert::Assert(pTempBlobView->GetSize() == (int)(m_pHeader->m_nSize));
			m_pHeader->m_nSize = (unsigned int)(pTempBlobView->GetSize());
			if (m_pContinueInfoVector->GetSize() == 0)
			{
				nbAssert::Assert(pTempBlobView->GetSize() <= MAX_DATA_SIZE);
				pStream->SizeToFit(SIZEOF_HEADER + pTempBlobView->GetSize());
				BlobView* pStreamBlobView = pStream->GetSectorChain()->GetBlobView();
				pStreamBlobView->PackUint16(m_pHeader->m_nType);
				pStreamBlobView->PackUint16((unsigned short)(m_pHeader->m_nSize));
				pStreamBlobView->Pack(pTempBlobView, pTempBlobView->GetSize());
			}
			else
			{
				unsigned short nIndex = 0;
				unsigned int nOffset = 0;
				unsigned int nSize = m_pHeader->m_nSize;
				unsigned short nRecordSize;
				{
					BiffRecord_ContinueInfo* pContinueInfo = m_pContinueInfoVector->Get(nIndex);
					nbAssert::Assert(pContinueInfo->m_nOffset <= MAX_DATA_SIZE);
					nRecordSize = (unsigned short)(pContinueInfo->m_nOffset);
				}
				{
					pStream->SizeToFit(SIZEOF_HEADER + nRecordSize);
					BlobView* pStreamBlobView = pStream->GetSectorChain()->GetBlobView();
					pStreamBlobView->PackUint16(m_pHeader->m_nType);
					pStreamBlobView->PackUint16(nRecordSize);
					pStreamBlobView->Pack(pTempBlobView, nRecordSize);
				}
				nOffset += nRecordSize;
				nIndex++;
				while (nOffset != nSize)
				{
					Type eType = Type::TYPE_CONTINUE;
					if (m_pHeader->m_nType == (unsigned short)(Type::TYPE_MSO_DRAWING_GROUP) && nIndex == 1)
						eType = Type::TYPE_MSO_DRAWING_GROUP;
					if (nIndex < m_pContinueInfoVector->GetSize())
					{
						BiffRecord_ContinueInfo* pContinueInfo = m_pContinueInfoVector->Get(nIndex);
						BiffRecord_ContinueInfo* pPreviousContinueInfo = m_pContinueInfoVector->Get(nIndex - 1);
						nbAssert::Assert(pContinueInfo->m_nOffset - pPreviousContinueInfo->m_nOffset <= MAX_DATA_SIZE);
						nRecordSize = (unsigned short)(pContinueInfo->m_nOffset - pPreviousContinueInfo->m_nOffset);
					}
					else
					{
						nbAssert::Assert(nSize - nOffset <= MAX_DATA_SIZE);
						nRecordSize = (unsigned short)(nSize - nOffset);
					}
					{
						pStream->SizeToFit(SIZEOF_HEADER + nRecordSize);
						BlobView* pStreamBlobView = pStream->GetSectorChain()->GetBlobView();
						pStreamBlobView->PackUint16((unsigned short)(eType));
						pStreamBlobView->PackUint16(nRecordSize);
						pStreamBlobView->Pack(pTempBlobView, nRecordSize);
					}
					nOffset += nRecordSize;
					nIndex++;
				}
			}
		}

		void BiffRecord::BlobRead(BlobView* pBlobView)
		{
			nbAssert::Assert(false);
		}

		void BiffRecord::BlobWrite(BlobView* pBlobView)
		{
		}

		void BiffRecord::Extend(BiffRecord* pBiffRecord)
		{
			nbAssert::Assert(pBiffRecord->GetType() == Type::TYPE_CONTINUE || pBiffRecord->GetType() == Type::TYPE_MSO_DRAWING_GROUP);
			m_pContinueInfoVector->PushBack(new BiffRecord_ContinueInfo((int)(m_pHeader->m_nSize), (int)(pBiffRecord->GetType())));
			unsigned int nNewSize = m_pHeader->m_nSize + pBiffRecord->m_pHeader->m_nSize;
			m_pHeader->m_nSize = nNewSize;
		}

		BiffRecord::~BiffRecord()
		{
			if (m_pHeader) delete m_pHeader;
			if (m_pContinueBlob) delete m_pContinueBlob;
			if (m_pBlobView) delete m_pBlobView;
			if (m_pContinueInfoVector) delete m_pContinueInfoVector;
		}

		BiffWorksheetStreamSize::BiffWorksheetStreamSize()
		{
			m_nSize = 0;
		}

		WorkbookGlobals::WorkbookGlobals()
		{
			m_pSharedStringContainer = 0;
			m_pSharedPictureVector = 0;
			m_pWorksheetRangeVector = 0;
			m_pBiffWorksheetStreamSizeVector = 0;
			m_pStyleVector = 0;
			m_pHeaderFont = 0;
			m_Window1_nTabRatio = 0;
			m_pSharedStringContainer = new SharedStringContainer();
			m_pSharedPictureVector = new Vector<Picture*>();
			m_pWorksheetRangeVector = new OwnedVector<WorksheetRange*>();
			m_pBiffWorksheetStreamSizeVector = new OwnedVector<BiffWorksheetStreamSize*>();
			m_pStyleVector = new OwnedVector<Style*>();
			m_pHeaderFont = new Font();
			m_pHeaderFont->SetName("Sans");
			m_pHeaderFont->SetSize(13);
			m_pHeaderFont->SetBold(false);
			m_pHeaderFont->SetItalic(false);
			m_pHeaderFont->SetUnderline(Font::Underline::UNDERLINE_NONE);
			CreateStyle();
			m_Window1_nTabRatio = 600;
		}

		WorkbookGlobals::~WorkbookGlobals()
		{
			Clear();
			{
				delete m_pSharedStringContainer;
				m_pSharedStringContainer = 0;
			}
			{
				delete m_pSharedPictureVector;
				m_pSharedPictureVector = 0;
			}
			{
				delete m_pWorksheetRangeVector;
				m_pWorksheetRangeVector = 0;
			}
			{
				delete m_pBiffWorksheetStreamSizeVector;
				m_pBiffWorksheetStreamSizeVector = 0;
			}
			{
				delete m_pStyleVector;
				m_pStyleVector = 0;
			}
			{
				delete m_pHeaderFont;
				m_pHeaderFont = 0;
			}
			if (m_pSharedStringContainer) delete m_pSharedStringContainer;
			if (m_pSharedPictureVector) delete m_pSharedPictureVector;
			if (m_pWorksheetRangeVector) delete m_pWorksheetRangeVector;
			if (m_pBiffWorksheetStreamSizeVector) delete m_pBiffWorksheetStreamSizeVector;
			if (m_pStyleVector) delete m_pStyleVector;
			if (m_pHeaderFont) delete m_pHeaderFont;
		}

		void WorkbookGlobals::Clear()
		{
			m_pSharedStringContainer->Clear();
			m_pSharedPictureVector->Clear();
			while (m_pWorksheetRangeVector->GetSize() > 0)
			{
				WorksheetRange* pWorksheetRange = m_pWorksheetRangeVector->PopBack();
				{
					delete pWorksheetRange;
					pWorksheetRange = 0;
				}
				if (pWorksheetRange) delete pWorksheetRange;
			}
			while (m_pBiffWorksheetStreamSizeVector->GetSize() > 0)
			{
				BiffWorksheetStreamSize* pBiffWorksheetStreamSize = m_pBiffWorksheetStreamSizeVector->PopBack();
				{
					delete pBiffWorksheetStreamSize;
					pBiffWorksheetStreamSize = 0;
				}
				if (pBiffWorksheetStreamSize) delete pBiffWorksheetStreamSize;
			}
		}

		void WorkbookGlobals::PushBiffWorksheetStreamSize(unsigned int nStreamSize)
		{
			BiffWorksheetStreamSize* pStreamSize = new BiffWorksheetStreamSize();
			pStreamSize->m_nSize = nStreamSize;
			{
				NumberDuck::Secret::BiffWorksheetStreamSize* __521035195 = pStreamSize;
				pStreamSize = 0;
				m_pBiffWorksheetStreamSizeVector->PushBack(__521035195);
			}
			if (pStreamSize) delete pStreamSize;
		}

		const char* WorkbookGlobals::GetSharedStringByIndex(unsigned int nIndex)
		{
			return m_pSharedStringContainer->Get((int)(nIndex));
		}

		unsigned int WorkbookGlobals::GetSharedStringIndex(const char* szString)
		{
			return (unsigned int)(m_pSharedStringContainer->GetIndex(szString));
		}

		unsigned int WorkbookGlobals::PushSharedString(const char* szString)
		{
			return (unsigned int)(m_pSharedStringContainer->Push(szString));
		}

		unsigned int WorkbookGlobals::PushPicture(Picture* pPicture)
		{
			m_pSharedPictureVector->PushBack(pPicture);
			return (unsigned int)(m_pSharedPictureVector->GetSize());
		}

		WorksheetRange* WorkbookGlobals::GetWorksheetRangeByIndex(unsigned short nIndex)
		{
			nbAssert::Assert(nIndex <= (unsigned short)(m_pWorksheetRangeVector->GetSize()));
			return m_pWorksheetRangeVector->Get((int)(nIndex));
		}

		unsigned short WorkbookGlobals::GetWorksheetRangeIndex(unsigned short nFirst, unsigned short nLast)
		{
			for (int i = 0; i < m_pWorksheetRangeVector->GetSize(); i++)
			{
				WorksheetRange* pWorksheetRange = m_pWorksheetRangeVector->Get(i);
				if (nFirst == pWorksheetRange->m_nFirst)
					if (nLast == pWorksheetRange->m_nLast)
						return (unsigned short)(i);
			}
			{
				WorksheetRange* pWorksheetRange = new WorksheetRange(nFirst, nLast);
				{
					NumberDuck::Secret::WorksheetRange* __4286285562 = pWorksheetRange;
					pWorksheetRange = 0;
					m_pWorksheetRangeVector->PushBack(__4286285562);
				}
				if (pWorksheetRange) delete pWorksheetRange;
			}
			return (unsigned short)(m_pWorksheetRangeVector->GetSize() - 1);
		}

		Style* WorkbookGlobals::GetStyleByIndex(unsigned short nIndex)
		{
			if (nIndex >= GetNumStyle())
				return 0;
			return m_pStyleVector->Get(nIndex);
		}

		unsigned short WorkbookGlobals::GetStyleIndex(Style* pStyle)
		{
			for (int i = 0; i < m_pStyleVector->GetSize(); i++)
				if (m_pStyleVector->Get(i) == pStyle)
					return (unsigned short)(i + 15);
			nbAssert::Assert(false);
			return 0;
		}

		unsigned short WorkbookGlobals::GetNumStyle()
		{
			return (unsigned short)(m_pStyleVector->GetSize());
		}

		Style* WorkbookGlobals::CreateStyle()
		{
			Style* pStyle = new Style();
			Style* pTempStyle = pStyle;
			{
				NumberDuck::Style* __2188486757 = pStyle;
				pStyle = 0;
				m_pStyleVector->PushBack(__2188486757);
			}
			{
				if (pStyle) delete pStyle;
				return pTempStyle;
			}
		}

		const unsigned int BiffWorkbookGlobals::DEFAULT_COLOR[NUM_DEFAULT_PALETTE_ENTRY] = {0x000000, 0xFFFFFF, 0x0000FF, 0x00FF00, 0xFF0000, 0x00FFFF, 0xFF00FF, 0xFFFF00};
		const unsigned int BiffWorkbookGlobals::DEFAULT_CUSTOM_COLOR[NUM_CUSTOM_PALETTE_ENTRY] = {((unsigned int)(0)) << 0 | ((unsigned int)(0)) << 8 | ((unsigned int)(0)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(255)) << 0 | ((unsigned int)(255)) << 8 | ((unsigned int)(255)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(255)) << 0 | ((unsigned int)(0)) << 8 | ((unsigned int)(0)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(0)) << 0 | ((unsigned int)(255)) << 8 | ((unsigned int)(0)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(0)) << 0 | ((unsigned int)(0)) << 8 | ((unsigned int)(255)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(255)) << 0 | ((unsigned int)(255)) << 8 | ((unsigned int)(0)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(255)) << 0 | ((unsigned int)(0)) << 8 | ((unsigned int)(255)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(0)) << 0 | ((unsigned int)(255)) << 8 | ((unsigned int)(255)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(128)) << 0 | ((unsigned int)(0)) << 8 | ((unsigned int)(0)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(0)) << 0 | ((unsigned int)(128)) << 8 | ((unsigned int)(0)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(0)) << 0 | ((unsigned int)(0)) << 8 | ((unsigned int)(128)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(128)) << 0 | ((unsigned int)(128)) << 8 | ((unsigned int)(0)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(128)) << 0 | ((unsigned int)(0)) << 8 | ((unsigned int)(128)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(0)) << 0 | ((unsigned int)(128)) << 8 | ((unsigned int)(128)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(192)) << 0 | ((unsigned int)(192)) << 8 | ((unsigned int)(192)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(128)) << 0 | ((unsigned int)(128)) << 8 | ((unsigned int)(128)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(153)) << 0 | ((unsigned int)(153)) << 8 | ((unsigned int)(255)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(153)) << 0 | ((unsigned int)(51)) << 8 | ((unsigned int)(102)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(255)) << 0 | ((unsigned int)(255)) << 8 | ((unsigned int)(204)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(204)) << 0 | ((unsigned int)(255)) << 8 | ((unsigned int)(255)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(102)) << 0 | ((unsigned int)(0)) << 8 | ((unsigned int)(102)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(255)) << 0 | ((unsigned int)(128)) << 8 | ((unsigned int)(128)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(0)) << 0 | ((unsigned int)(102)) << 8 | ((unsigned int)(204)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(204)) << 0 | ((unsigned int)(204)) << 8 | ((unsigned int)(255)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(0)) << 0 | ((unsigned int)(0)) << 8 | ((unsigned int)(128)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(255)) << 0 | ((unsigned int)(0)) << 8 | ((unsigned int)(255)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(255)) << 0 | ((unsigned int)(255)) << 8 | ((unsigned int)(0)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(0)) << 0 | ((unsigned int)(255)) << 8 | ((unsigned int)(255)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(128)) << 0 | ((unsigned int)(0)) << 8 | ((unsigned int)(128)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(128)) << 0 | ((unsigned int)(0)) << 8 | ((unsigned int)(0)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(0)) << 0 | ((unsigned int)(128)) << 8 | ((unsigned int)(128)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(0)) << 0 | ((unsigned int)(0)) << 8 | ((unsigned int)(255)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(0)) << 0 | ((unsigned int)(204)) << 8 | ((unsigned int)(255)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(204)) << 0 | ((unsigned int)(255)) << 8 | ((unsigned int)(255)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(204)) << 0 | ((unsigned int)(255)) << 8 | ((unsigned int)(204)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(255)) << 0 | ((unsigned int)(255)) << 8 | ((unsigned int)(153)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(153)) << 0 | ((unsigned int)(204)) << 8 | ((unsigned int)(255)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(255)) << 0 | ((unsigned int)(153)) << 8 | ((unsigned int)(204)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(204)) << 0 | ((unsigned int)(153)) << 8 | ((unsigned int)(255)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(255)) << 0 | ((unsigned int)(204)) << 8 | ((unsigned int)(153)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(51)) << 0 | ((unsigned int)(102)) << 8 | ((unsigned int)(255)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(51)) << 0 | ((unsigned int)(204)) << 8 | ((unsigned int)(204)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(153)) << 0 | ((unsigned int)(204)) << 8 | ((unsigned int)(0)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(255)) << 0 | ((unsigned int)(204)) << 8 | ((unsigned int)(0)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(255)) << 0 | ((unsigned int)(153)) << 8 | ((unsigned int)(0)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(255)) << 0 | ((unsigned int)(102)) << 8 | ((unsigned int)(0)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(102)) << 0 | ((unsigned int)(102)) << 8 | ((unsigned int)(153)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(150)) << 0 | ((unsigned int)(150)) << 8 | ((unsigned int)(150)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(0)) << 0 | ((unsigned int)(51)) << 8 | ((unsigned int)(102)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(51)) << 0 | ((unsigned int)(153)) << 8 | ((unsigned int)(102)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(0)) << 0 | ((unsigned int)(51)) << 8 | ((unsigned int)(0)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(51)) << 0 | ((unsigned int)(51)) << 8 | ((unsigned int)(0)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(153)) << 0 | ((unsigned int)(51)) << 8 | ((unsigned int)(0)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(153)) << 0 | ((unsigned int)(51)) << 8 | ((unsigned int)(102)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(51)) << 0 | ((unsigned int)(51)) << 8 | ((unsigned int)(153)) << 16 | ((unsigned int)(255)) << 24, ((unsigned int)(51)) << 0 | ((unsigned int)(51)) << 8 | ((unsigned int)(51)) << 16 | ((unsigned int)(255)) << 24};
		BiffWorkbookGlobals::BiffWorkbookGlobals(BiffRecord* pInitialBiffRecord, Stream* pStream)
		{
			m_pBiffRecordContainer = 0;
			m_sWorkheetNameVector = 0;
			m_sTempWorksheetName = 0;
			m_MsoDrawingGroupRecord = 0;
			m_pPaletteRecord = 0;
			m_pBiffRecordContainer = new BiffRecordContainer(pInitialBiffRecord, pStream);
			m_sWorkheetNameVector = new OwnedVector<InternalString*>();
			m_sTempWorksheetName = 0;
			m_MsoDrawingGroupRecord = 0;
			m_pPaletteRecord = 0;
			Vector<FontRecord*>* pFontRecordVector = new Vector<FontRecord*>();
			Vector<Format*>* pFormatRecordVector = new Vector<Format*>();
			Vector<XF*>* pXFVector = new Vector<XF*>();
			XFCRC* pXFCRC = 0;
			Vector<XFExt*>* pXFExtVector = new Vector<XFExt*>();
			Theme* pTheme = 0;
			for (int i = 0; i < m_pBiffRecordContainer->m_pBiffRecordVector->GetSize(); i++)
			{
				BiffRecord* pBiffRecord = m_pBiffRecordContainer->m_pBiffRecordVector->Get(i);
				if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_SST)
				{
					SstRecord* pSstRecord = (SstRecord*)(pBiffRecord);
					for (int j = 0; j < pSstRecord->GetNumString(); j++)
						m_pSharedStringContainer->Push(pSstRecord->GetString(j));
				}
				if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_BOUND_SHEET_8)
				{
					BoundSheet8Record* pBoundSheet8Record = (BoundSheet8Record*)(pBiffRecord);
					m_sWorkheetNameVector->PushBack(new InternalString(pBoundSheet8Record->GetName()));
				}
				if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_FONT)
					pFontRecordVector->PushBack((FontRecord*)(pBiffRecord));
				if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_FORMAT)
					pFormatRecordVector->PushBack((Format*)(pBiffRecord));
				if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_XF)
					pXFVector->PushBack((XF*)(pBiffRecord));
				if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_XF_CRC)
					pXFCRC = (XFCRC*)(pBiffRecord);
				if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_XF_EXT)
					pXFExtVector->PushBack((XFExt*)(pBiffRecord));
				if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_PALETTE)
					m_pPaletteRecord = (PaletteRecord*)(pBiffRecord);
				if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_MSO_DRAWING_GROUP)
					m_MsoDrawingGroupRecord = (MsoDrawingGroupRecord*)(pBiffRecord);
				if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_EXTERN_SHEET)
				{
					while (m_pWorksheetRangeVector->GetSize() > 0)
					{
						WorksheetRange* pWorksheetRange = m_pWorksheetRangeVector->PopBack();
						{
							delete pWorksheetRange;
							pWorksheetRange = 0;
						}
						if (pWorksheetRange) delete pWorksheetRange;
					}
					ExternSheetRecord* pExternSheetRecord = (ExternSheetRecord*)(pBiffRecord);
					for (unsigned short j = 0; j < pExternSheetRecord->GetNumXTI(); j++)
					{
						XTIStruct* pXTI = pExternSheetRecord->GetXTIByIndex(j);
						WorksheetRange* pWorksheetRange = new WorksheetRange((unsigned short)(pXTI->m_itabFirst), (unsigned short)(pXTI->m_itabLast));
						{
							NumberDuck::Secret::WorksheetRange* __4286285562 = pWorksheetRange;
							pWorksheetRange = 0;
							m_pWorksheetRangeVector->PushBack(__4286285562);
						}
						if (pWorksheetRange) delete pWorksheetRange;
					}
				}
				if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_THEME)
					pTheme = (Theme*)(pBiffRecord);
				if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_WINDOW1)
				{
					m_Window1_nTabRatio = ((Window1*)(pBiffRecord))->GetTabRatio();
				}
			}
			bool bXFExtValid = false;
			if (pXFCRC != 0)
				bXFExtValid = pXFCRC->ValidateCrc(pXFVector);
			for (int i = 15; i < pXFVector->GetSize(); i++)
			{
				XF* pXF = pXFVector->Get(i);
				{
					Style* pStyle = 0;
					if (i == 15)
						pStyle = this->GetStyleByIndex(0);
					else
						pStyle = this->CreateStyle();
					unsigned short nFontIndex = pXF->GetFontIndex();
					if (nFontIndex > 4)
						nFontIndex -= 1;
					FontRecord* pFontRecord = pFontRecordVector->Get(nFontIndex);
					pStyle->GetFont()->SetName(pFontRecord->GetName());
					pStyle->GetFont()->m_pImpl->m_nSizeTwips = pFontRecord->GetSizeTwips();
					pStyle->GetFont()->SetBold(pFontRecord->GetBold());
					pStyle->GetFont()->SetItalic(pFontRecord->GetItalic());
					pStyle->GetFont()->SetUnderline(pFontRecord->GetUnderline());
					unsigned short nFormatIndex = pXF->GetFormatIndex();
					switch (nFormatIndex)
					{
						case 0:
						{
							pStyle->SetFormat("General");
							break;
						}

						case 1:
						{
							pStyle->SetFormat("0");
							break;
						}

						case 2:
						{
							pStyle->SetFormat("0.00");
							break;
						}

						case 3:
						{
							pStyle->SetFormat("#,##0");
							break;
						}

						case 4:
						{
							pStyle->SetFormat("#,##0.00");
							break;
						}

						case 9:
						{
							pStyle->SetFormat("0%");
							break;
						}

						case 10:
						{
							pStyle->SetFormat("0.00%");
							break;
						}

						case 11:
						{
							pStyle->SetFormat("0.00E+00");
							break;
						}

						case 12:
						{
							pStyle->SetFormat("# \\?/\\?");
							break;
						}

						case 13:
						{
							pStyle->SetFormat("# \\?\\?/\\?\\?");
							break;
						}

						case 14:
						{
							pStyle->SetFormat("mm-dd-yy");
							break;
						}

						case 15:
						{
							pStyle->SetFormat("d-mmm-yy");
							break;
						}

						case 16:
						{
							pStyle->SetFormat("d-mmm");
							break;
						}

						case 17:
						{
							pStyle->SetFormat("mmm-yy");
							break;
						}

						case 18:
						{
							pStyle->SetFormat("h:mm AM/PM");
							break;
						}

						case 19:
						{
							pStyle->SetFormat("h:mm:ss AM/PM");
							break;
						}

						case 20:
						{
							pStyle->SetFormat("h:mm");
							break;
						}

						case 21:
						{
							pStyle->SetFormat("h:mm:ss");
							break;
						}

						case 22:
						{
							pStyle->SetFormat("m/d/yy h:mm");
							break;
						}

						case 37:
						{
							pStyle->SetFormat("#,##0 ;(#,##0)");
							break;
						}

						case 38:
						{
							pStyle->SetFormat("#,##0 ;[Red](#,##0)");
							break;
						}

						case 39:
						{
							pStyle->SetFormat("#,##0.00;-#,##0.00");
							break;
						}

						case 40:
						{
							pStyle->SetFormat("#,##0.00;[Red](#,##0.00)");
							break;
						}

						case 45:
						{
							pStyle->SetFormat("mm:ss");
							break;
						}

						case 46:
						{
							pStyle->SetFormat("[h]:mm:ss");
							break;
						}

						case 47:
						{
							pStyle->SetFormat("mmss.0");
							break;
						}

						case 48:
						{
							pStyle->SetFormat("##0.0E+0");
							break;
						}

						case 49:
						{
							pStyle->SetFormat("@");
							break;
						}

					}
					for (int j = 0; j < pFormatRecordVector->GetSize(); j++)
					{
						Format* pFormatRecord = pFormatRecordVector->Get(j);
						if (pFormatRecord->GetFormatIndex() == nFormatIndex)
						{
							pStyle->SetFormat(pFormatRecord->GetFormat());
						}
					}
					unsigned short nBackgroundPaletteIndex = pXF->GetBackgroundPaletteIndex();
					if (nBackgroundPaletteIndex != PALETTE_INDEX_DEFAULT && nBackgroundPaletteIndex < NUM_DEFAULT_PALETTE_ENTRY + NUM_CUSTOM_PALETTE_ENTRY)
						pStyle->GetBackgroundColor(true)->SetFromRgba(GetPaletteColorByIndex(nBackgroundPaletteIndex));
					pStyle->SetFillPattern(pXF->GetFillPattern());
					unsigned short nForegroundPaletteIndex = pXF->GetForegroundPaletteIndex();
					if (nForegroundPaletteIndex != PALETTE_INDEX_DEFAULT && nForegroundPaletteIndex < NUM_DEFAULT_PALETTE_ENTRY + NUM_CUSTOM_PALETTE_ENTRY)
						pStyle->GetFillPatternColor(true)->SetFromRgba(GetPaletteColorByIndex(nForegroundPaletteIndex));
					unsigned short nPaletteIndex = pFontRecord->GetColourIndex();
					if (nPaletteIndex != PALETTE_INDEX_DEFAULT && nPaletteIndex != PALETTE_INDEX_DEFAULT_FONT_AUTOMATIC)
						pStyle->GetFont()->GetColor(true)->SetFromRgba(GetPaletteColorByIndex(nPaletteIndex));
					pStyle->SetHorizontalAlign((Style::HorizontalAlign)(pXF->GetHorizontalAlign()));
					pStyle->SetVerticalAlign((Style::VerticalAlign)(pXF->GetVerticalAlign()));
					pStyle->GetTopBorderLine()->SetType(pXF->GetTopBorderType());
					nPaletteIndex = pXF->GetTopBorderPaletteIndex();
					if (nPaletteIndex < NUM_DEFAULT_PALETTE_ENTRY + NUM_CUSTOM_PALETTE_ENTRY)
					{
						Line* pLine = pStyle->GetTopBorderLine();
						pLine->GetColor()->SetFromRgba(GetPaletteColorByIndex(nPaletteIndex));
					}
					if (nPaletteIndex == PALETTE_INDEX_DEFAULT_FOREGROUND)
					{
						Line* pLine = pStyle->GetTopBorderLine();
						pLine->GetColor()->Set(0x00, 0x00, 0x00);
					}
					pStyle->GetRightBorderLine()->SetType(pXF->GetRightBorderType());
					nPaletteIndex = pXF->GetRightBorderPaletteIndex();
					if (nPaletteIndex < NUM_DEFAULT_PALETTE_ENTRY + NUM_CUSTOM_PALETTE_ENTRY)
					{
						Line* pLine = pStyle->GetRightBorderLine();
						pLine->GetColor()->SetFromRgba(GetPaletteColorByIndex(nPaletteIndex));
					}
					if (nPaletteIndex == PALETTE_INDEX_DEFAULT_FOREGROUND)
					{
						Line* pLine = pStyle->GetRightBorderLine();
						pLine->GetColor()->Set(0x00, 0x00, 0x00);
					}
					pStyle->GetBottomBorderLine()->SetType(pXF->GetBottomBorderType());
					nPaletteIndex = pXF->GetBottomBorderPaletteIndex();
					if (nPaletteIndex < NUM_DEFAULT_PALETTE_ENTRY + NUM_CUSTOM_PALETTE_ENTRY)
					{
						Line* pLine = pStyle->GetBottomBorderLine();
						pLine->GetColor()->SetFromRgba(GetPaletteColorByIndex(nPaletteIndex));
					}
					if (nPaletteIndex == PALETTE_INDEX_DEFAULT_FOREGROUND)
					{
						Line* pLine = pStyle->GetBottomBorderLine();
						pLine->GetColor()->Set(0x00, 0x00, 0x00);
					}
					pStyle->GetLeftBorderLine()->SetType(pXF->GetLeftBorderType());
					nPaletteIndex = pXF->GetLeftBorderPaletteIndex();
					if (nPaletteIndex < NUM_DEFAULT_PALETTE_ENTRY + NUM_CUSTOM_PALETTE_ENTRY)
					{
						Line* pLine = pStyle->GetLeftBorderLine();
						pLine->GetColor()->SetFromRgba(GetPaletteColorByIndex(nPaletteIndex));
					}
					if (nPaletteIndex == PALETTE_INDEX_DEFAULT_FOREGROUND)
					{
						Line* pLine = pStyle->GetLeftBorderLine();
						pLine->GetColor()->Set(0x00, 0x00, 0x00);
					}
					if (bXFExtValid && pXF->GetHasXFExt())
					{
						for (int j = 0; j < pXFExtVector->GetSize(); j++)
						{
							XFExt* pXFExt = pXFExtVector->Get(j);
							if (pXFExt->GetXFIndex() == i)
							{
								{
									const Color* pColor = pXFExt->GetTextColor(pTheme);
									if (pColor != 0)
										pStyle->GetFont()->GetColor(true)->SetFromColor(pColor);
								}
								{
									const Color* pColor = pXFExt->GetForegroundColor(pTheme);
									if (pColor != 0)
										pStyle->GetBackgroundColor(true)->SetFromColor(pColor);
								}
								break;
							}
						}
					}
				}
			}
			{
				FontRecord* pFontRecord = pFontRecordVector->Get(0);
				m_pHeaderFont->SetName(pFontRecord->GetName());
				m_pHeaderFont->m_pImpl->m_nSizeTwips = pFontRecord->GetSizeTwips();
				m_pHeaderFont->SetBold(pFontRecord->GetBold());
				m_pHeaderFont->SetItalic(pFontRecord->GetItalic());
				m_pHeaderFont->SetUnderline(pFontRecord->GetUnderline());
			}
			{
				delete pFontRecordVector;
				pFontRecordVector = 0;
			}
			{
				delete pFormatRecordVector;
				pFormatRecordVector = 0;
			}
			{
				delete pXFVector;
				pXFVector = 0;
			}
			{
				delete pXFExtVector;
				pXFExtVector = 0;
			}
			if (pFontRecordVector) delete pFontRecordVector;
			if (pFormatRecordVector) delete pFormatRecordVector;
			if (pXFVector) delete pXFVector;
			if (pXFExtVector) delete pXFExtVector;
		}

		void BiffWorkbookGlobals::Write(WorkbookGlobals* pWorkbookGlobals, OwnedVector<Worksheet*>* pWorksheetVector, Stream* pStream)
		{
			Vector<BoundSheet8Record*>* pBoundSheet8RecordVector = new Vector<BoundSheet8Record*>();
			BiffRecordContainer* pBiffRecordContainer = new BiffRecordContainer();
			OwnedVector<XF*>* pXFVector = new OwnedVector<XF*>();
			pBiffRecordContainer->AddBiffRecord(new BofRecord(BofRecord::BofType::BOF_TYPE_WORKBOOK_GLOBALS));
			pBiffRecordContainer->AddBiffRecord(new InterfaceHdr());
			pBiffRecordContainer->AddBiffRecord(new Mms());
			pBiffRecordContainer->AddBiffRecord(new InterfaceEnd());
			pBiffRecordContainer->AddBiffRecord(new WriteAccess());
			pBiffRecordContainer->AddBiffRecord(new CodePage());
			pBiffRecordContainer->AddBiffRecord(new DSF());
			pBiffRecordContainer->AddBiffRecord(new Excel9File());
			pBiffRecordContainer->AddBiffRecord(new RRTabId((unsigned short)(pWorksheetVector->GetSize())));
			pBiffRecordContainer->AddBiffRecord(new BuiltInFnGroupCount());
			pBiffRecordContainer->AddBiffRecord(new WinProtect());
			pBiffRecordContainer->AddBiffRecord(new ProtectRecord());
			pBiffRecordContainer->AddBiffRecord(new PasswordRecord());
			pBiffRecordContainer->AddBiffRecord(new Prot4RevRecord());
			pBiffRecordContainer->AddBiffRecord(new Prot4RevPassRecord());
			pBiffRecordContainer->AddBiffRecord(new Window1(pWorkbookGlobals->m_Window1_nTabRatio));
			pBiffRecordContainer->AddBiffRecord(new Backup());
			pBiffRecordContainer->AddBiffRecord(new HideObj());
			pBiffRecordContainer->AddBiffRecord(new Date1904());
			pBiffRecordContainer->AddBiffRecord(new CalcPrecision());
			pBiffRecordContainer->AddBiffRecord(new RefreshAllRecord());
			pBiffRecordContainer->AddBiffRecord(new BookBool());
			{
				Font* pHeaderFont = pWorkbookGlobals->m_pHeaderFont;
				pBiffRecordContainer->AddBiffRecord(new FontRecord(pHeaderFont->GetName(), (unsigned short)(pHeaderFont->m_pImpl->m_nSizeTwips), PALETTE_INDEX_DEFAULT_FONT_AUTOMATIC, pHeaderFont->GetBold(), pHeaderFont->GetItalic(), pHeaderFont->GetUnderline()));
			}
			for (int i = 0; i < pWorkbookGlobals->m_pStyleVector->GetSize(); i++)
			{
				Style* pStyle = pWorkbookGlobals->m_pStyleVector->Get(i);
				unsigned short nPaletteIndex = SnapToPalette(pStyle->GetFont()->GetColor(false));
				if (nPaletteIndex == PALETTE_INDEX_DEFAULT)
					nPaletteIndex = PALETTE_INDEX_DEFAULT_FONT_AUTOMATIC;
				pBiffRecordContainer->AddBiffRecord(new FontRecord(pStyle->GetFont()->GetName(), (unsigned short)(pStyle->GetFont()->m_pImpl->m_nSizeTwips), nPaletteIndex, pStyle->GetFont()->GetBold(), pStyle->GetFont()->GetItalic(), pStyle->GetFont()->GetUnderline()));
			}
			unsigned short nFormatIndex = 164;
			for (int i = 0; i < pWorkbookGlobals->m_pStyleVector->GetSize(); i++)
			{
				Style* pStyle = pWorkbookGlobals->m_pStyleVector->Get(i);
				pStyle->m_pImplementation->m_nFormatIndex = 0;
				for (int j = 0; j < i; j++)
				{
					Style* pTestStyle = pWorkbookGlobals->m_pStyleVector->Get(j);
					if (ExternalString::Equal(pTestStyle->GetFormat(), pStyle->GetFormat()))
					{
						pStyle->m_pImplementation->m_nFormatIndex = pTestStyle->m_pImplementation->m_nFormatIndex;
						break;
					}
				}
				if (pStyle->m_pImplementation->m_nFormatIndex == 0 && nFormatIndex < 382)
				{
					pStyle->m_pImplementation->m_nFormatIndex = nFormatIndex;
					pBiffRecordContainer->AddBiffRecord(new Format(nFormatIndex, pStyle->GetFormat()));
					nFormatIndex++;
				}
			}
			for (int i = 0; i < 15; i++)
			{
				pXFVector->PushBack(new XF(0, 43, 1, 0xFFF, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, PALETTE_INDEX_DEFAULT_FOREGROUND, PALETTE_INDEX_DEFAULT_BACKGROUND));
			}
			for (unsigned short i = 0; i < (unsigned short)(pWorkbookGlobals->m_pStyleVector->GetSize()); i++)
			{
				Style* pStyle = pWorkbookGlobals->m_pStyleVector->Get(i);
				pXFVector->PushBack(new XF((unsigned short)(i + 1), (unsigned short)(pStyle->m_pImplementation->m_nFormatIndex), pStyle, true));
			}
			XFCRC* pXFCRC = new XFCRC(pXFVector);
			while (pXFVector->GetSize() > 0)
			{
				pBiffRecordContainer->AddBiffRecord(pXFVector->PopFront());
			}
			{
				NumberDuck::Secret::XFCRC* __241720877 = pXFCRC;
				pXFCRC = 0;
				pBiffRecordContainer->AddBiffRecord(__241720877);
			}
			for (unsigned short i = 0; i < (unsigned short)(pWorkbookGlobals->m_pStyleVector->GetSize()); i++)
			{
				Style* pStyle = pWorkbookGlobals->m_pStyleVector->Get(i);
				pBiffRecordContainer->AddBiffRecord(new XFExt((unsigned short)(i + 15), pStyle->GetBackgroundColor(false), pStyle->GetFillPatternColor(false), pStyle->GetFont()->GetColor(false)));
			}
			pBiffRecordContainer->AddBiffRecord(new PaletteRecord());
			for (int i = 0; i < pWorksheetVector->GetSize(); i++)
			{
				Worksheet* pWorksheet = pWorksheetVector->Get(i);
				BoundSheet8Record* pBoundSheet8Record = new BoundSheet8Record(pWorksheet->GetName());
				pBoundSheet8RecordVector->PushBack(pBoundSheet8Record);
				{
					NumberDuck::Secret::BoundSheet8Record* __3176075103 = pBoundSheet8Record;
					pBoundSheet8Record = 0;
					pBiffRecordContainer->AddBiffRecord(__3176075103);
				}
				if (pBoundSheet8Record) delete pBoundSheet8Record;
			}
			if (pWorkbookGlobals->m_pWorksheetRangeVector->GetSize() > 0)
			{
				pBiffRecordContainer->AddBiffRecord(new SupBookRecord((unsigned short)(pWorksheetVector->GetSize())));
				pBiffRecordContainer->AddBiffRecord(new ExternSheetRecord(pWorkbookGlobals->m_pWorksheetRangeVector));
			}
			{
				MsoDrawingGroupRecord* pMsoDrawingGroupRecord = new MsoDrawingGroupRecord(pWorkbookGlobals->m_pSharedPictureVector);
				{
					NumberDuck::Secret::MsoDrawingGroupRecord* __355026241 = pMsoDrawingGroupRecord;
					pMsoDrawingGroupRecord = 0;
					pBiffRecordContainer->AddBiffRecord(__355026241);
				}
				if (pMsoDrawingGroupRecord) delete pMsoDrawingGroupRecord;
			}
			if (pWorkbookGlobals->m_pSharedStringContainer->GetSize() > 0)
			{
				SstRecord* pSstRecord = new SstRecord(pWorkbookGlobals->m_pSharedStringContainer);
				{
					NumberDuck::Secret::SstRecord* __1557921119 = pSstRecord;
					pSstRecord = 0;
					pBiffRecordContainer->AddBiffRecord(__1557921119);
				}
				if (pSstRecord) delete pSstRecord;
			}
			pBiffRecordContainer->AddBiffRecord(new BookExtRecord());
			pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_EOF, 0));
			unsigned int nStreamOffset = pBiffRecordContainer->GetSize();
			for (int i = 0; i < pBoundSheet8RecordVector->GetSize(); i++)
			{
				pBoundSheet8RecordVector->Get(i)->SetStreamOffset(nStreamOffset);
				nStreamOffset += pWorkbookGlobals->m_pBiffWorksheetStreamSizeVector->Get(i)->m_nSize;
			}
			pBiffRecordContainer->Write(pStream);
			{
				delete pBiffRecordContainer;
				pBiffRecordContainer = 0;
			}
			{
				delete pBoundSheet8RecordVector;
				pBoundSheet8RecordVector = 0;
			}
			if (pBoundSheet8RecordVector) delete pBoundSheet8RecordVector;
			if (pBiffRecordContainer) delete pBiffRecordContainer;
			if (pXFVector) delete pXFVector;
			if (pXFCRC) delete pXFCRC;
		}

		const char* BiffWorkbookGlobals::GetNextWorksheetName()
		{
			if (m_sTempWorksheetName != 0)
				{
					delete m_sTempWorksheetName;
					m_sTempWorksheetName = 0;
				}
			m_sTempWorksheetName = m_sWorkheetNameVector->PopFront();
			return m_sTempWorksheetName->GetExternalString();
		}

		Style* BiffWorkbookGlobals::GetStyleByXfIndex(unsigned short nXfIndex)
		{
			nbAssert::Assert(nXfIndex >= 15);
			Style* pStyle = GetStyleByIndex((unsigned short)(nXfIndex - 15));
			return pStyle;
		}

		MsoDrawingGroupRecord* BiffWorkbookGlobals::GetMsoDrawingGroupRecord()
		{
			return m_MsoDrawingGroupRecord;
		}

		unsigned char BiffWorkbookGlobals::SnapToPalette(Color* pColor)
		{
			unsigned char nIndex = 0;
			int nDiff = 2147483647;
			if (pColor != 0)
			{
				for (unsigned char i = 0; i < NUM_CUSTOM_PALETTE_ENTRY; i++)
				{
					unsigned int nTestColor = DEFAULT_CUSTOM_COLOR[i];
					int nRedDiff = ((int)(nTestColor & 0xFF)) - ((int)(pColor->GetRed()));
					int nGreenDiff = ((int)((nTestColor >> 8) & 0xFF)) - ((int)(pColor->GetGreen()));
					int nBlueDiff = ((int)((nTestColor >> 16) & 0xFF)) - ((int)(pColor->GetBlue()));
					int nTestDiff = nRedDiff * nRedDiff + nGreenDiff * nGreenDiff + nBlueDiff * nBlueDiff;
					if (nTestDiff < nDiff)
					{
						nIndex = i;
						nDiff = nTestDiff;
					}
				}
				return (unsigned char)(nIndex + NUM_DEFAULT_PALETTE_ENTRY);
			}
			return (unsigned char)(PALETTE_INDEX_DEFAULT);
		}

		unsigned int BiffWorkbookGlobals::GetDefaultPaletteColorByIndex(unsigned short nIndex)
		{
			nbAssert::Assert(nIndex < NUM_DEFAULT_PALETTE_ENTRY + NUM_CUSTOM_PALETTE_ENTRY);
			unsigned int nColor = 0;
			if (nIndex < NUM_DEFAULT_PALETTE_ENTRY)
				nColor = DEFAULT_COLOR[nIndex];
			else
				nColor = DEFAULT_CUSTOM_COLOR[nIndex - NUM_DEFAULT_PALETTE_ENTRY];
			return nColor;
		}

		unsigned int BiffWorkbookGlobals::GetPaletteColorByIndex(unsigned short nIndex)
		{
			nbAssert::Assert(nIndex < NUM_DEFAULT_PALETTE_ENTRY + NUM_CUSTOM_PALETTE_ENTRY);
			if (m_pPaletteRecord != 0 && nIndex >= NUM_DEFAULT_PALETTE_ENTRY)
				return m_pPaletteRecord->GetColorByIndex((unsigned short)(nIndex - NUM_DEFAULT_PALETTE_ENTRY));
			return GetDefaultPaletteColorByIndex(nIndex);
		}

		BiffWorkbookGlobals::~BiffWorkbookGlobals()
		{
			if (m_pBiffRecordContainer) delete m_pBiffRecordContainer;
			if (m_sWorkheetNameVector) delete m_sWorkheetNameVector;
			if (m_sTempWorksheetName) delete m_sTempWorksheetName;
		}

		void BiffStruct::BlobRead(BlobView* pBlobView)
		{
		}

		void BiffStruct::BlobWrite(BlobView* pBlobView)
		{
		}

		FtCmoStruct::FtCmoStruct()
		{
			m_ft = 0;
			m_cb = 0;
			m_ot = 0;
			m_id = 0;
			m_fLocked = 0;
			m_reserved = 0;
			m_fDefaultSize = 0;
			m_fPublished = 0;
			m_fPrint = 0;
			m_unused1 = 0;
			m_unused2 = 0;
			m_fDisabled = 0;
			m_fUIObj = 0;
			m_fRecalcObj = 0;
			m_unused3 = 0;
			m_unused4 = 0;
			m_fRecalcObjAlways = 0;
			m_unused5 = 0;
			m_unused6 = 0;
			m_unused7 = 0;
			m_unused8 = 0;
			m_unused9 = 0;
			m_unused10 = 0;
			SetDefaults();
		}

		void FtCmoStruct::BlobRead(BlobView* pBlobView)
		{
			m_ft = pBlobView->UnpackUint16();
			m_cb = pBlobView->UnpackUint16();
			m_ot = pBlobView->UnpackUint16();
			m_id = pBlobView->UnpackUint16();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fLocked = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_reserved = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fDefaultSize = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_fPublished = (unsigned short)((nBitmask0 >> 3) & 0x1);
			m_fPrint = (unsigned short)((nBitmask0 >> 4) & 0x1);
			m_unused1 = (unsigned short)((nBitmask0 >> 5) & 0x1);
			m_unused2 = (unsigned short)((nBitmask0 >> 6) & 0x1);
			m_fDisabled = (unsigned short)((nBitmask0 >> 7) & 0x1);
			m_fUIObj = (unsigned short)((nBitmask0 >> 8) & 0x1);
			m_fRecalcObj = (unsigned short)((nBitmask0 >> 9) & 0x1);
			m_unused3 = (unsigned short)((nBitmask0 >> 10) & 0x1);
			m_unused4 = (unsigned short)((nBitmask0 >> 11) & 0x1);
			m_fRecalcObjAlways = (unsigned short)((nBitmask0 >> 12) & 0x1);
			m_unused5 = (unsigned short)((nBitmask0 >> 13) & 0x1);
			m_unused6 = (unsigned short)((nBitmask0 >> 14) & 0x1);
			m_unused7 = (unsigned short)((nBitmask0 >> 15) & 0x1);
			m_unused8 = pBlobView->UnpackUint32();
			m_unused9 = pBlobView->UnpackUint32();
			m_unused10 = pBlobView->UnpackUint32();
		}

		void FtCmoStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_ft);
			pBlobView->PackUint16(m_cb);
			pBlobView->PackUint16(m_ot);
			pBlobView->PackUint16(m_id);
			int nBitmask0 = 0;
			nBitmask0 += m_fLocked << 0;
			nBitmask0 += m_reserved << 1;
			nBitmask0 += m_fDefaultSize << 2;
			nBitmask0 += m_fPublished << 3;
			nBitmask0 += m_fPrint << 4;
			nBitmask0 += m_unused1 << 5;
			nBitmask0 += m_unused2 << 6;
			nBitmask0 += m_fDisabled << 7;
			nBitmask0 += m_fUIObj << 8;
			nBitmask0 += m_fRecalcObj << 9;
			nBitmask0 += m_unused3 << 10;
			nBitmask0 += m_unused4 << 11;
			nBitmask0 += m_fRecalcObjAlways << 12;
			nBitmask0 += m_unused5 << 13;
			nBitmask0 += m_unused6 << 14;
			nBitmask0 += m_unused7 << 15;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			pBlobView->PackUint32(m_unused8);
			pBlobView->PackUint32(m_unused9);
			pBlobView->PackUint32(m_unused10);
		}

		void FtCmoStruct::SetDefaults()
		{
			m_ft = 0;
			m_cb = 0;
			m_ot = 0;
			m_id = 0;
			m_fLocked = 0;
			m_reserved = 0;
			m_fDefaultSize = 0;
			m_fPublished = 0;
			m_fPrint = 0;
			m_unused1 = 0;
			m_unused2 = 0;
			m_fDisabled = 0;
			m_fUIObj = 0;
			m_fRecalcObj = 0;
			m_unused3 = 0;
			m_unused4 = 0;
			m_fRecalcObjAlways = 0;
			m_unused5 = 0;
			m_unused6 = 0;
			m_unused7 = 0;
			m_unused8 = 0;
			m_unused9 = 0;
			m_unused10 = 0;
		}

		SectorChain::SectorChain(int nSectorSize)
		{
			m_nSectorSize = 0;
			m_pSectorVector = 0;
			m_pBlob = 0;
			nbAssert::Assert((nSectorSize & (nSectorSize - 1)) == 0);
			m_nSectorSize = nSectorSize;
			m_pBlob = new Blob(false);
			m_pSectorVector = new Vector<Sector*>();
		}

		int SectorChain::GetNumSector()
		{
			return m_pSectorVector->GetSize();
		}

		Sector* SectorChain::GetSectorByIndex(int nIndex)
		{
			nbAssert::Assert(nIndex < m_pSectorVector->GetSize());
			return m_pSectorVector->Get(nIndex);
		}

		int SectorChain::GetSectorSize()
		{
			return m_nSectorSize;
		}

		int SectorChain::GetDataSize()
		{
			return m_pSectorVector->GetSize() * m_nSectorSize;
		}

		void SectorChain::Read(int nSize, BlobView* pBlobView)
		{
			m_pBlob->GetBlobView()->Unpack(pBlobView, nSize);
		}

		void SectorChain::ReadAt(int nOffset, int nSize, BlobView* pBlobView)
		{
			m_pBlob->GetBlobView()->UnpackAt(nOffset, pBlobView, nSize);
		}

		void SectorChain::Write(int nSize, BlobView* pBlobView)
		{
			m_pBlob->GetBlobView()->Pack(pBlobView, nSize);
		}

		void SectorChain::WriteAt(int nOffset, int nSize, BlobView* pBlobView)
		{
			m_pBlob->GetBlobView()->PackAt(nOffset, pBlobView, nSize);
		}

		int SectorChain::GetOffset()
		{
			return m_pBlob->GetBlobView()->GetOffset();
		}

		void SectorChain::SetOffset(int nOffset)
		{
			m_pBlob->GetBlobView()->SetOffset(nOffset);
		}

		void SectorChain::AppendSector(Sector* pSector)
		{
			BlobView* pBlobView = pSector->GetBlobView();
			m_pSectorVector->PushBack(pSector);
			int nSize = m_pSectorVector->GetSize() * m_nSectorSize;
			m_pBlob->Resize(nSize, false);
			pBlobView->SetOffset(0);
			m_pBlob->GetBlobView()->PackAt(nSize - m_nSectorSize, pBlobView, m_nSectorSize);
		}

		void SectorChain::Extend(Sector* pSector)
		{
			AppendSector(pSector);
		}

		BlobView* SectorChain::GetBlobView()
		{
			return m_pBlob->GetBlobView();
		}

		void SectorChain::WriteToSectors()
		{
			BlobView* pBlobView = m_pBlob->GetBlobView();
			pBlobView->SetOffset(0);
			for (int i = 0; i < m_pSectorVector->GetSize(); i++)
				m_pSectorVector->Get(i)->GetBlobView()->PackAt(0, pBlobView, m_nSectorSize);
		}

		SectorChain::~SectorChain()
		{
			if (m_pSectorVector) delete m_pSectorVector;
			if (m_pBlob) delete m_pBlob;
		}

		StreamDataStruct::StreamDataStruct()
		{
			m_nNameDataSize = 0;
			m_nType = 0;
			m_nNodeColour = 0;
			m_nLeftChildNodeStreamId = 0;
			m_nRightChildNodeStreamId = 0;
			m_nRootNodeStreamId = 0;
			m_nSectorId = 0;
			m_nStreamSize = 0;
		}

		Stream::Stream(int nStreamId, int nMinimumStandardStreamSize, Blob* pBlob, int nOffset, CompoundFile* pCompoundFile)
		{
			m_nStreamId = 0;
			m_nMinimumStandardStreamSize = 0;
			m_pDataStruct = 0;
			m_pBlobView = 0;
			m_pSectorChain = 0;
			m_sNameTemp = 0;
			m_pCompoundFile = 0;
			int i;
			nbAssert::Assert(pCompoundFile != 0);
			m_pDataStruct = new StreamDataStruct();
			m_pCompoundFile = pCompoundFile;
			m_nStreamId = nStreamId;
			m_nMinimumStandardStreamSize = nMinimumStandardStreamSize;
			m_sNameTemp = new InternalString("");
			m_pBlobView = new BlobView(pBlob, nOffset, nOffset + DATA_SIZE);
			for (i = 0; i < StreamDataStruct::MAX_NAME_LENGTH; i++)
				m_pDataStruct->m_pName[i] = m_pBlobView->UnpackUint16();
			m_pDataStruct->m_nNameDataSize = m_pBlobView->UnpackUint16();
			m_pDataStruct->m_nType = m_pBlobView->UnpackUint8();
			m_pDataStruct->m_nNodeColour = m_pBlobView->UnpackUint8();
			m_pDataStruct->m_nLeftChildNodeStreamId = m_pBlobView->UnpackInt32();
			m_pDataStruct->m_nRightChildNodeStreamId = m_pBlobView->UnpackInt32();
			m_pDataStruct->m_nRootNodeStreamId = m_pBlobView->UnpackInt32();
			for (i = 0; i < 16; i++)
				m_pDataStruct->m_pUniqueIdentifier[i] = m_pBlobView->UnpackUint8();
			for (i = 0; i < 4; i++)
				m_pDataStruct->m_pUserFlags[i] = m_pBlobView->UnpackUint8();
			for (i = 0; i < 8; i++)
				m_pDataStruct->m_pCreationDate[i] = m_pBlobView->UnpackUint8();
			for (i = 0; i < 8; i++)
				m_pDataStruct->m_pModificationDate[i] = m_pBlobView->UnpackUint8();
			m_pDataStruct->m_nSectorId = m_pBlobView->UnpackInt32();
			m_pDataStruct->m_nStreamSize = m_pBlobView->UnpackUint32();
			for (i = 0; i < 4; i++)
				m_pDataStruct->m_pUnused[i] = m_pBlobView->UnpackUint8();
			nbAssert::Assert(m_pBlobView->GetOffset() == m_pBlobView->GetSize());
			nbAssert::Assert(m_pBlobView->GetOffset() == DATA_SIZE);
			if (m_nStreamId == 0)
			{
				m_pDataStruct->m_nType = (unsigned char)(Type::TYPE_ROOT_STORAGE);
			}
			m_pSectorChain = 0;
			if (m_pDataStruct->m_nType != (unsigned char)(Type::TYPE_EMPTY))
				m_pSectorChain = new SectorChain(m_pCompoundFile->GetSectorSize(GetShortSector()));
		}

		void Stream::Allocate(Type eType, int nStreamSize)
		{
			nbAssert::Assert(m_pSectorChain == 0);
			nbAssert::Assert(m_pDataStruct->m_nType == (unsigned char)(Type::TYPE_EMPTY));
			nbAssert::Assert(eType != Type::TYPE_ROOT_STORAGE);
			m_pDataStruct->m_nType = (unsigned char)(eType);
			m_pSectorChain = new SectorChain(m_pCompoundFile->GetSectorSize(GetShortSector()));
			Resize(nStreamSize);
		}

		void Stream::FillSectorChain()
		{
			m_pCompoundFile->FillSectorChain(m_pSectorChain, GetSectorId(), GetShortSector());
		}

		void Stream::WriteToSectors()
		{
			int i;
			if (m_pSectorChain != 0)
				m_pSectorChain->WriteToSectors();
			m_pBlobView->SetOffset(0);
			for (i = 0; i < StreamDataStruct::MAX_NAME_LENGTH; i++)
				m_pBlobView->PackUint16(m_pDataStruct->m_pName[i]);
			m_pBlobView->PackUint16(m_pDataStruct->m_nNameDataSize);
			m_pBlobView->PackUint8(m_pDataStruct->m_nType);
			m_pBlobView->PackUint8(m_pDataStruct->m_nNodeColour);
			m_pBlobView->PackInt32(m_pDataStruct->m_nLeftChildNodeStreamId);
			m_pBlobView->PackInt32(m_pDataStruct->m_nRightChildNodeStreamId);
			m_pBlobView->PackInt32(m_pDataStruct->m_nRootNodeStreamId);
			for (i = 0; i < 16; i++)
				m_pBlobView->PackUint8(m_pDataStruct->m_pUniqueIdentifier[i]);
			for (i = 0; i < 4; i++)
				m_pBlobView->PackUint8(m_pDataStruct->m_pUserFlags[i]);
			for (i = 0; i < 8; i++)
				m_pBlobView->PackUint8(m_pDataStruct->m_pCreationDate[i]);
			for (i = 0; i < 8; i++)
				m_pBlobView->PackUint8(m_pDataStruct->m_pModificationDate[i]);
			m_pBlobView->PackInt32(m_pDataStruct->m_nSectorId);
			m_pBlobView->PackUint32(m_pDataStruct->m_nStreamSize);
			for (i = 0; i < 4; i++)
				m_pBlobView->PackUint8(m_pDataStruct->m_pUnused[i]);
			nbAssert::Assert(m_pBlobView->GetOffset() == m_pBlobView->GetSize());
			nbAssert::Assert(m_pBlobView->GetOffset() == DATA_SIZE);
		}

		int Stream::GetStreamId()
		{
			return m_nStreamId;
		}

		const char* Stream::GetName()
		{
			unsigned short i = 0;
			m_sNameTemp->Set("");
			while (i << 1 < m_pDataStruct->m_nNameDataSize)
			{
				unsigned short nTemp = m_pDataStruct->m_pName[i];
				if (nTemp == 0)
					break;
				m_sNameTemp->AppendChar((unsigned short)(nTemp));
				i++;
			}
			return m_sNameTemp->GetExternalString();
		}

		void Stream::SetName(const char* sxName)
		{
			int i;
			m_sNameTemp->Set(sxName);
			int nLength = m_sNameTemp->GetLength();
			nbAssert::Assert(nLength < StreamDataStruct::MAX_NAME_LENGTH);
			m_pDataStruct->m_nNameDataSize = (unsigned short)((nLength + 1) << 1);
			for (i = 0; i < nLength; i++)
				m_pDataStruct->m_pName[i] = m_sNameTemp->GetChar(i);
			m_pDataStruct->m_pName[nLength] = 0;
		}

		Stream::Type Stream::GetType()
		{
			return (Type)(m_pDataStruct->m_nType);
		}

		int Stream::GetSectorId()
		{
			return m_pDataStruct->m_nSectorId;
		}

		bool Stream::GetShortSector()
		{
			if (GetType() == Type::TYPE_ROOT_STORAGE || (int)(m_pDataStruct->m_nStreamSize) >= m_nMinimumStandardStreamSize)
				return false;
			return true;
		}

		int Stream::GetStreamSize()
		{
			return (int)(m_pDataStruct->m_nStreamSize);
		}

		int Stream::GetSize()
		{
			return m_pSectorChain->GetDataSize();
		}

		SectorChain* Stream::GetSectorChain()
		{
			return m_pSectorChain;
		}

		int Stream::GetOffset()
		{
			return m_pSectorChain->GetOffset();
		}

		void Stream::SetOffset(int nOffset)
		{
			m_pSectorChain->SetOffset(nOffset);
		}

		void Stream::SizeToFit(int nSize)
		{
			if (GetStreamSize() < m_pSectorChain->GetOffset() + nSize)
				Resize(m_pSectorChain->GetOffset() + nSize);
		}

		bool Stream::Resize(int nSize)
		{
			if (GetType() == Type::TYPE_EMPTY)
				return false;
			int nOldSize = GetStreamSize();
			m_pDataStruct->m_nStreamSize = (unsigned int)(nSize);
			bool bShortSector = GetShortSector();
			int nSectorSize = m_pCompoundFile->GetSectorSize(bShortSector);
			int nNumSector = nSize / nSectorSize + 1;
			if (m_pSectorChain == 0)
				m_pSectorChain = new SectorChain(nSectorSize);
			if (nSectorSize != m_pSectorChain->GetSectorSize())
			{
				SectorChain* pSectorChain = new SectorChain(nSectorSize);
				while (pSectorChain->GetNumSector() < nNumSector)
				{
					m_pCompoundFile->SectorChainExtend(pSectorChain);
				}
				BlobView* pBlobView = m_pSectorChain->GetBlobView();
				pBlobView->SetOffset(0);
				int nDataSize = nOldSize;
				if (nSize < nOldSize)
					nDataSize = nSize;
				pSectorChain->Write(nDataSize, pBlobView);
				SectorAllocationTable* pSectorAllocationTable = m_pCompoundFile->GetSectorAllocationTable(!bShortSector);
				for (int i = 0; i < m_pSectorChain->GetNumSector(); i++)
					pSectorAllocationTable->SetSectorId(m_pSectorChain->GetSectorByIndex(i)->GetSectorId(), (int)(Sector::SectorId::FREE_SECTOR_SECTOR_ID));
				pSectorAllocationTable = m_pCompoundFile->GetSectorAllocationTable(bShortSector);
				for (int i = 0; i < pSectorChain->GetNumSector() - 1; i++)
					pSectorAllocationTable->SetSectorId(pSectorChain->GetSectorByIndex(i)->GetSectorId(), pSectorChain->GetSectorByIndex(i + 1)->GetSectorId());
				pSectorAllocationTable->SetSectorId(pSectorChain->GetSectorByIndex(pSectorChain->GetNumSector() - 1)->GetSectorId(), (int)(Sector::SectorId::END_OF_CHAIN_SECTOR_ID));
				{
					delete m_pSectorChain;
					m_pSectorChain = 0;
				}
				{
					NumberDuck::Secret::SectorChain* __175211134 = pSectorChain;
					pSectorChain = 0;
					m_pSectorChain = __175211134;
				}
				if (pSectorChain) delete pSectorChain;
			}
			else
			{
				while (m_pSectorChain->GetNumSector() < nNumSector)
				{
					m_pCompoundFile->SectorChainExtend(m_pSectorChain);
				}
			}
			m_pDataStruct->m_nSectorId = m_pSectorChain->GetSectorByIndex(0)->GetSectorId();
			return true;
		}

		void Stream::SetNodeColour(unsigned char nColour)
		{
			m_pDataStruct->m_nNodeColour = nColour;
		}

		void Stream::SetLeftChildNodeStreamId(int nStreamId)
		{
			m_pDataStruct->m_nLeftChildNodeStreamId = nStreamId;
		}

		void Stream::SetRightChildNodeStreamId(int nStreamId)
		{
			m_pDataStruct->m_nRightChildNodeStreamId = nStreamId;
		}

		void Stream::SetRootNodeStreamId(int nStreamId)
		{
			m_pDataStruct->m_nRootNodeStreamId = nStreamId;
		}

		unsigned short Stream::GetNameLengthUtf16()
		{
			if (m_pDataStruct->m_nNameDataSize == 0)
				return 0;
			return (unsigned short)((m_pDataStruct->m_nNameDataSize >> 1) - 1);
		}

		unsigned short Stream::GetNameUtf16(unsigned short nIndex)
		{
			nbAssert::Assert(nIndex < StreamDataStruct::MAX_NAME_LENGTH);
			return m_pDataStruct->m_pName[nIndex];
		}

		Stream::~Stream()
		{
			if (m_pDataStruct) delete m_pDataStruct;
			if (m_pBlobView) delete m_pBlobView;
			if (m_pSectorChain) delete m_pSectorChain;
			if (m_sNameTemp) delete m_sNameTemp;
		}

		OfficeArtTertiaryFOPTRecord::OfficeArtTertiaryFOPTRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView) : OfficeArtRecord(pHeader, IS_CONTAINER, pBlobView)
		{
			m_pFoptVector = 0;
			nbAssert::Assert((OfficeArtRecord::Type)(pHeader->m_recType) == OfficeArtRecord::Type::TYPE_OFFICE_ART_TERTIARY_FOPT);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void OfficeArtTertiaryFOPTRecord::BlobRead(BlobView* pBlobView)
		{
			PostBlobRead(pBlobView);
		}

		void OfficeArtTertiaryFOPTRecord::BlobWrite(BlobView* pBlobView)
		{
			PostBlobWrite(pBlobView);
		}

		void OfficeArtTertiaryFOPTRecord::SetDefaults()
		{
			PostSetDefaults();
		}

		OfficeArtTertiaryFOPTRecord::OfficeArtTertiaryFOPTRecord() : OfficeArtRecord(TYPE, IS_CONTAINER, SIZE, true)
		{
			m_pFoptVector = 0;
			SetDefaults();
			m_pHeader->m_recVer = 0x3;
		}

		void OfficeArtTertiaryFOPTRecord::PostSetDefaults()
		{
			m_pFoptVector = new OwnedVector<OfficeArtFOPTEStruct*>();
		}

		void OfficeArtTertiaryFOPTRecord::PostBlobWrite(BlobView* pBlobView)
		{
			int i;
			for (i = 0; i < m_pFoptVector->GetSize(); i++)
				m_pFoptVector->Get(i)->BlobWrite(pBlobView);
			for (i = 0; i < m_pFoptVector->GetSize(); i++)
			{
				OfficeArtFOPTEStruct* pFOPTE = m_pFoptVector->Get(i);
				if (pFOPTE->m_pComplexData != 0)
				{
					BlobView* pComplexDataBlobView = pFOPTE->m_pComplexData->GetBlobView();
					pComplexDataBlobView->SetOffset(0);
					pBlobView->Pack(pComplexDataBlobView, pComplexDataBlobView->GetSize());
				}
			}
		}

		void OfficeArtTertiaryFOPTRecord::PostBlobRead(BlobView* pBlobView)
		{
			unsigned short i;
			for (i = 0; i < m_pHeader->m_recInstance; i++)
			{
				OfficeArtFOPTEStruct* pFOPTE = new OfficeArtFOPTEStruct();
				pFOPTE->BlobRead(pBlobView);
				{
					NumberDuck::Secret::OfficeArtFOPTEStruct* __3616310584 = pFOPTE;
					pFOPTE = 0;
					m_pFoptVector->PushBack(__3616310584);
				}
				if (pFOPTE) delete pFOPTE;
			}
			for (i = 0; i < m_pFoptVector->GetSize(); i++)
			{
				OfficeArtFOPTEStruct* pFOPTE = m_pFoptVector->Get(i);
				if (pFOPTE->m_opid->m_fComplex == 0x1)
				{
					pFOPTE->m_pComplexData = new Blob(false);
					pFOPTE->m_pComplexData->Resize(pFOPTE->m_op, false);
					pFOPTE->m_pComplexData->GetBlobView()->Pack(pBlobView, pFOPTE->m_op);
				}
			}
		}

		void OfficeArtTertiaryFOPTRecord::AddProperty(unsigned short opid, unsigned char fBid, int op)
		{
			nbAssert::Assert(opid <= 0x3FFF);
			nbAssert::Assert(fBid <= 0x1);
			OfficeArtFOPTEStruct* pFOPTE = new OfficeArtFOPTEStruct();
			pFOPTE->m_opid->m_opid = opid;
			pFOPTE->m_opid->m_fBid = fBid;
			pFOPTE->m_opid->m_fComplex = 0x0;
			pFOPTE->m_op = op;
			{
				NumberDuck::Secret::OfficeArtFOPTEStruct* __3616310584 = pFOPTE;
				pFOPTE = 0;
				m_pFoptVector->PushBack(__3616310584);
			}
			m_pHeader->m_recInstance++;
			m_pHeader->m_recLen += OfficeArtFOPTEStruct::SIZE;
			if (pFOPTE) delete pFOPTE;
		}

		OfficeArtFOPTEStruct* OfficeArtTertiaryFOPTRecord::GetProperty(OfficeArtRecord::OPIDType eType)
		{
			unsigned short i;
			for (i = 0; i < m_pHeader->m_recInstance; i++)
			{
				OfficeArtFOPTEStruct* pFOPTE = m_pFoptVector->Get(i);
				if ((OfficeArtRecord::OPIDType)(pFOPTE->m_opid->m_opid) == eType)
					return pFOPTE;
			}
			return 0;
		}

		OfficeArtTertiaryFOPTRecord::~OfficeArtTertiaryFOPTRecord()
		{
			if (m_pFoptVector) delete m_pFoptVector;
		}

		OfficeArtSplitMenuColorContainerRecord::OfficeArtSplitMenuColorContainerRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView) : OfficeArtRecord(pHeader, IS_CONTAINER, pBlobView)
		{
			m_smca0 = 0;
			m_smca1 = 0;
			m_smca2 = 0;
			m_smca3 = 0;
			nbAssert::Assert((OfficeArtRecord::Type)(pHeader->m_recType) == OfficeArtRecord::Type::TYPE_OFFICE_ART_SPLIT_MENU_COLOR_CONTAINER);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void OfficeArtSplitMenuColorContainerRecord::BlobRead(BlobView* pBlobView)
		{
			m_smca0->BlobRead(pBlobView);
			m_smca1->BlobRead(pBlobView);
			m_smca2->BlobRead(pBlobView);
			m_smca3->BlobRead(pBlobView);
		}

		void OfficeArtSplitMenuColorContainerRecord::BlobWrite(BlobView* pBlobView)
		{
			m_smca0->BlobWrite(pBlobView);
			m_smca1->BlobWrite(pBlobView);
			m_smca2->BlobWrite(pBlobView);
			m_smca3->BlobWrite(pBlobView);
		}

		void OfficeArtSplitMenuColorContainerRecord::SetDefaults()
		{
			m_smca0 = new MSOCRStruct();
			m_smca1 = new MSOCRStruct();
			m_smca2 = new MSOCRStruct();
			m_smca3 = new MSOCRStruct();
		}

		OfficeArtSplitMenuColorContainerRecord::OfficeArtSplitMenuColorContainerRecord() : OfficeArtRecord(TYPE, IS_CONTAINER, SIZE, true)
		{
			m_smca0 = 0;
			m_smca1 = 0;
			m_smca2 = 0;
			m_smca3 = 0;
			SetDefaults();
			m_pHeader->m_recVer = 0x0;
			m_pHeader->m_recInstance = 4;
			m_smca0->m_red = 13;
			m_smca0->m_green = 0;
			m_smca0->m_blue = 0;
			m_smca0->m_fSchemeIndex = 1;
			m_smca1->m_red = 12;
			m_smca1->m_green = 0;
			m_smca1->m_blue = 0;
			m_smca1->m_fSchemeIndex = 1;
			m_smca2->m_red = 23;
			m_smca2->m_green = 0;
			m_smca2->m_blue = 0;
			m_smca2->m_fSchemeIndex = 1;
			m_smca3->m_red = 247;
			m_smca3->m_green = 0;
			m_smca3->m_blue = 0;
			m_smca3->m_unused2 = 1;
		}

		OfficeArtSplitMenuColorContainerRecord::~OfficeArtSplitMenuColorContainerRecord()
		{
			if (m_smca0) delete m_smca0;
			if (m_smca1) delete m_smca1;
			if (m_smca2) delete m_smca2;
			if (m_smca3) delete m_smca3;
		}

		OfficeArtSpgrContainerRecord::OfficeArtSpgrContainerRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView) : OfficeArtRecord(pHeader, IS_CONTAINER, pBlobView)
		{
			nbAssert::Assert((OfficeArtRecord::Type)(pHeader->m_recType) == OfficeArtRecord::Type::TYPE_OFFICE_ART_SPGR_CONTAINER);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void OfficeArtSpgrContainerRecord::BlobRead(BlobView* pBlobView)
		{
		}

		void OfficeArtSpgrContainerRecord::BlobWrite(BlobView* pBlobView)
		{
		}

		void OfficeArtSpgrContainerRecord::SetDefaults()
		{
		}

		OfficeArtSpgrContainerRecord::OfficeArtSpgrContainerRecord() : OfficeArtRecord(TYPE, IS_CONTAINER, SIZE, true)
		{
			SetDefaults();
			m_pHeader->m_recVer = 0xF;
		}

		OfficeArtSpContainerRecord::OfficeArtSpContainerRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView) : OfficeArtRecord(pHeader, IS_CONTAINER, pBlobView)
		{
			nbAssert::Assert((OfficeArtRecord::Type)(pHeader->m_recType) == OfficeArtRecord::Type::TYPE_OFFICE_ART_SP_CONTAINER);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void OfficeArtSpContainerRecord::BlobRead(BlobView* pBlobView)
		{
		}

		void OfficeArtSpContainerRecord::BlobWrite(BlobView* pBlobView)
		{
		}

		void OfficeArtSpContainerRecord::SetDefaults()
		{
		}

		OfficeArtSpContainerRecord::OfficeArtSpContainerRecord() : OfficeArtRecord(TYPE, IS_CONTAINER, SIZE, true)
		{
			SetDefaults();
			m_pHeader->m_recVer = 0xF;
		}

		OfficeArtFSPRecord::OfficeArtFSPRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView) : OfficeArtRecord(pHeader, IS_CONTAINER, pBlobView)
		{
			m_spid = 0;
			m_fGroup = 0;
			m_fChild = 0;
			m_fPatriarch = 0;
			m_fDeleted = 0;
			m_fOleShape = 0;
			m_fHaveMaster = 0;
			m_fFlipH = 0;
			m_fFlipV = 0;
			m_fConnector = 0;
			m_fHaveAnchor = 0;
			m_fBackground = 0;
			m_fHaveSpt = 0;
			m_unused1 = 0;
			nbAssert::Assert((OfficeArtRecord::Type)(pHeader->m_recType) == OfficeArtRecord::Type::TYPE_OFFICE_ART_FSP);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void OfficeArtFSPRecord::BlobRead(BlobView* pBlobView)
		{
			m_spid = pBlobView->UnpackUint32();
			unsigned int nBitmask0 = pBlobView->UnpackUint32();
			m_fGroup = (unsigned int)((nBitmask0 >> 0) & 0x1);
			m_fChild = (unsigned int)((nBitmask0 >> 1) & 0x1);
			m_fPatriarch = (unsigned int)((nBitmask0 >> 2) & 0x1);
			m_fDeleted = (unsigned int)((nBitmask0 >> 3) & 0x1);
			m_fOleShape = (unsigned int)((nBitmask0 >> 4) & 0x1);
			m_fHaveMaster = (unsigned int)((nBitmask0 >> 5) & 0x1);
			m_fFlipH = (unsigned int)((nBitmask0 >> 6) & 0x1);
			m_fFlipV = (unsigned int)((nBitmask0 >> 7) & 0x1);
			m_fConnector = (unsigned int)((nBitmask0 >> 8) & 0x1);
			m_fHaveAnchor = (unsigned int)((nBitmask0 >> 9) & 0x1);
			m_fBackground = (unsigned int)((nBitmask0 >> 10) & 0x1);
			m_fHaveSpt = (unsigned int)((nBitmask0 >> 11) & 0x1);
			m_unused1 = (unsigned int)((nBitmask0 >> 12) & 0xfffff);
		}

		void OfficeArtFSPRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint32(m_spid);
			unsigned int nBitmask0 = 0;
			nBitmask0 += m_fGroup << 0;
			nBitmask0 += m_fChild << 1;
			nBitmask0 += m_fPatriarch << 2;
			nBitmask0 += m_fDeleted << 3;
			nBitmask0 += m_fOleShape << 4;
			nBitmask0 += m_fHaveMaster << 5;
			nBitmask0 += m_fFlipH << 6;
			nBitmask0 += m_fFlipV << 7;
			nBitmask0 += m_fConnector << 8;
			nBitmask0 += m_fHaveAnchor << 9;
			nBitmask0 += m_fBackground << 10;
			nBitmask0 += m_fHaveSpt << 11;
			nBitmask0 += m_unused1 << 12;
			pBlobView->PackUint32((unsigned int)(nBitmask0));
		}

		void OfficeArtFSPRecord::SetDefaults()
		{
			m_spid = 0;
			m_fGroup = 0;
			m_fChild = 0;
			m_fPatriarch = 0;
			m_fDeleted = 0;
			m_fOleShape = 0;
			m_fHaveMaster = 0;
			m_fFlipH = 0;
			m_fFlipV = 0;
			m_fConnector = 0;
			m_fHaveAnchor = 0;
			m_fBackground = 0;
			m_fHaveSpt = 0;
			m_unused1 = 0;
		}

		OfficeArtFSPRecord::OfficeArtFSPRecord(unsigned short recInstance, unsigned int spid, unsigned char fGroup, unsigned char fPatriarch, unsigned char fHaveAnchor, unsigned char fHaveSpt) : OfficeArtRecord(TYPE, IS_CONTAINER, SIZE, true)
		{
			m_spid = 0;
			m_fGroup = 0;
			m_fChild = 0;
			m_fPatriarch = 0;
			m_fDeleted = 0;
			m_fOleShape = 0;
			m_fHaveMaster = 0;
			m_fFlipH = 0;
			m_fFlipV = 0;
			m_fConnector = 0;
			m_fHaveAnchor = 0;
			m_fBackground = 0;
			m_fHaveSpt = 0;
			m_unused1 = 0;
			SetDefaults();
			m_pHeader->m_recVer = 0x2;
			m_pHeader->m_recInstance = recInstance;
			m_fGroup = fGroup;
			m_fPatriarch = fPatriarch;
			m_fHaveAnchor = fHaveAnchor;
			m_fHaveSpt = fHaveSpt;
		}

		OfficeArtFSPGRRecord::OfficeArtFSPGRRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView) : OfficeArtRecord(pHeader, IS_CONTAINER, pBlobView)
		{
			m_xLeft = 0;
			m_yTop = 0;
			m_xRight = 0;
			m_yBottom = 0;
			nbAssert::Assert((OfficeArtRecord::Type)(pHeader->m_recType) == OfficeArtRecord::Type::TYPE_OFFICE_ART_FSPGR);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void OfficeArtFSPGRRecord::BlobRead(BlobView* pBlobView)
		{
			m_xLeft = pBlobView->UnpackUint32();
			m_yTop = pBlobView->UnpackUint32();
			m_xRight = pBlobView->UnpackUint32();
			m_yBottom = pBlobView->UnpackUint32();
		}

		void OfficeArtFSPGRRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint32(m_xLeft);
			pBlobView->PackUint32(m_yTop);
			pBlobView->PackUint32(m_xRight);
			pBlobView->PackUint32(m_yBottom);
		}

		void OfficeArtFSPGRRecord::SetDefaults()
		{
			m_xLeft = 0;
			m_yTop = 0;
			m_xRight = 0;
			m_yBottom = 0;
		}

		OfficeArtFSPGRRecord::OfficeArtFSPGRRecord() : OfficeArtRecord(TYPE, IS_CONTAINER, SIZE, true)
		{
			m_xLeft = 0;
			m_yTop = 0;
			m_xRight = 0;
			m_yBottom = 0;
			SetDefaults();
			m_pHeader->m_recVer = 0x1;
			m_pHeader->m_recInstance = 0x0000;
		}

		OfficeArtFRITContainerRecord::OfficeArtFRITContainerRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView) : OfficeArtRecord(pHeader, IS_CONTAINER, pBlobView)
		{
			m_pRgfritVector = 0;
			nbAssert::Assert((OfficeArtRecord::Type)(pHeader->m_recType) == OfficeArtRecord::Type::TYPE_OFFICE_ART_FRIT_CONTAINER);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void OfficeArtFRITContainerRecord::BlobRead(BlobView* pBlobView)
		{
			PostBlobRead(pBlobView);
		}

		void OfficeArtFRITContainerRecord::BlobWrite(BlobView* pBlobView)
		{
			PostBlobWrite(pBlobView);
		}

		void OfficeArtFRITContainerRecord::SetDefaults()
		{
			PostSetDefaults();
		}

		void OfficeArtFRITContainerRecord::PostSetDefaults()
		{
			m_pRgfritVector = new OwnedVector<OfficeArtFRITStruct*>();
		}

		void OfficeArtFRITContainerRecord::PostBlobWrite(BlobView* pBlobView)
		{
			int i;
			for (i = 0; i < m_pRgfritVector->GetSize(); i++)
			{
				m_pRgfritVector->Get(i)->BlobWrite(pBlobView);
			}
		}

		void OfficeArtFRITContainerRecord::PostBlobRead(BlobView* pBlobView)
		{
			unsigned short i;
			nbAssert::Assert(GetNumFRIT() == GetSize() / OfficeArtFRITStruct::SIZE);
			for (i = 0; i < m_pHeader->m_recInstance; i++)
			{
				OfficeArtFRITStruct* pFRIT = new OfficeArtFRITStruct();
				pFRIT->BlobRead(pBlobView);
				{
					NumberDuck::Secret::OfficeArtFRITStruct* __2212815663 = pFRIT;
					pFRIT = 0;
					m_pRgfritVector->PushBack(__2212815663);
				}
				if (pFRIT) delete pFRIT;
			}
		}

		unsigned short OfficeArtFRITContainerRecord::GetNumFRIT()
		{
			return GetInstance();
		}

		OfficeArtFRITStruct* OfficeArtFRITContainerRecord::GetFRITByIndex(unsigned short nIndex)
		{
			nbAssert::Assert(nIndex >= GetNumFRIT());
			return m_pRgfritVector->Get(nIndex);
		}

		OfficeArtFRITContainerRecord::~OfficeArtFRITContainerRecord()
		{
			if (m_pRgfritVector) delete m_pRgfritVector;
		}

		OfficeArtFOPTRecord::OfficeArtFOPTRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView) : OfficeArtRecord(pHeader, IS_CONTAINER, pBlobView)
		{
			m_pFoptVector = 0;
			nbAssert::Assert((OfficeArtRecord::Type)(pHeader->m_recType) == OfficeArtRecord::Type::TYPE_OFFICE_ART_FOPT);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void OfficeArtFOPTRecord::BlobRead(BlobView* pBlobView)
		{
			PostBlobRead(pBlobView);
		}

		void OfficeArtFOPTRecord::BlobWrite(BlobView* pBlobView)
		{
			PostBlobWrite(pBlobView);
		}

		void OfficeArtFOPTRecord::SetDefaults()
		{
			PostSetDefaults();
		}

		OfficeArtFOPTRecord::OfficeArtFOPTRecord() : OfficeArtRecord(TYPE, IS_CONTAINER, SIZE, true)
		{
			m_pFoptVector = 0;
			SetDefaults();
			m_pHeader->m_recVer = 0x3;
		}

		void OfficeArtFOPTRecord::PostSetDefaults()
		{
			m_pFoptVector = new OwnedVector<OfficeArtFOPTEStruct*>();
		}

		void OfficeArtFOPTRecord::PostBlobWrite(BlobView* pBlobView)
		{
			int i;
			for (i = 0; i < m_pFoptVector->GetSize(); i++)
				m_pFoptVector->Get(i)->BlobWrite(pBlobView);
			for (i = 0; i < m_pFoptVector->GetSize(); i++)
			{
				OfficeArtFOPTEStruct* pFOPTE = m_pFoptVector->Get(i);
				if (pFOPTE->m_pComplexData != 0)
				{
					BlobView* pComplexDataBlobView = pFOPTE->m_pComplexData->GetBlobView();
					pComplexDataBlobView->SetOffset(0);
					pBlobView->Pack(pComplexDataBlobView, pComplexDataBlobView->GetSize());
				}
			}
		}

		void OfficeArtFOPTRecord::PostBlobRead(BlobView* pBlobView)
		{
			unsigned short i;
			for (i = 0; i < m_pHeader->m_recInstance; i++)
			{
				OfficeArtFOPTEStruct* pFOPTE = new OfficeArtFOPTEStruct();
				pFOPTE->BlobRead(pBlobView);
				{
					NumberDuck::Secret::OfficeArtFOPTEStruct* __3616310584 = pFOPTE;
					pFOPTE = 0;
					m_pFoptVector->PushBack(__3616310584);
				}
				if (pFOPTE) delete pFOPTE;
			}
			for (i = 0; i < m_pFoptVector->GetSize(); i++)
			{
				OfficeArtFOPTEStruct* pFOPTE = m_pFoptVector->Get(i);
				if (pFOPTE->m_opid->m_fComplex == 0x1)
				{
					pFOPTE->m_pComplexData = new Blob(false);
					pFOPTE->m_pComplexData->Resize(pFOPTE->m_op, false);
					pFOPTE->m_pComplexData->GetBlobView()->Pack(pBlobView, pFOPTE->m_op);
				}
			}
		}

		void OfficeArtFOPTRecord::AddProperty(unsigned short opid, unsigned char fBid, int op)
		{
			nbAssert::Assert(opid <= 0x3FFF);
			nbAssert::Assert(fBid <= 0x1);
			OfficeArtFOPTEStruct* pFOPTE = new OfficeArtFOPTEStruct();
			pFOPTE->m_opid->m_opid = opid;
			pFOPTE->m_opid->m_fBid = fBid;
			pFOPTE->m_opid->m_fComplex = 0x0;
			pFOPTE->m_op = op;
			{
				NumberDuck::Secret::OfficeArtFOPTEStruct* __3616310584 = pFOPTE;
				pFOPTE = 0;
				m_pFoptVector->PushBack(__3616310584);
			}
			m_pHeader->m_recInstance++;
			m_pHeader->m_recLen += OfficeArtFOPTEStruct::SIZE;
			if (pFOPTE) delete pFOPTE;
		}

		void OfficeArtFOPTRecord::AddStringProperty(unsigned short opid, const char* szString)
		{
			nbAssert::Assert((OfficeArtRecord::OPIDType)(opid) == OfficeArtRecord::OPIDType::OPID_WZ_NAME);
			InternalString* sTemp = new InternalString(szString);
			Blob* pBlob = new Blob(true);
			BlobView* pBlobView = pBlob->GetBlobView();
			sTemp->BlobWrite16Bit(pBlobView, true);
			AddBlobProperty(opid, 1, pBlob);
			if (sTemp) delete sTemp;
			if (pBlob) delete pBlob;
		}

		void OfficeArtFOPTRecord::AddBlobProperty(unsigned short opid, unsigned char fBid, Blob* pBlob)
		{
			nbAssert::Assert(opid <= 0x3FFF);
			nbAssert::Assert(fBid <= 0x1);
			BlobView* pBlobView = pBlob->GetBlobView();
			pBlobView->SetOffset(0);
			OfficeArtFOPTEStruct* pFOPTE = new OfficeArtFOPTEStruct();
			pFOPTE->m_opid->m_opid = opid;
			pFOPTE->m_opid->m_fBid = fBid;
			pFOPTE->m_opid->m_fComplex = 0x1;
			pFOPTE->m_op = (int)(pBlob->GetSize());
			pFOPTE->m_pComplexData = new Blob(false);
			pFOPTE->m_pComplexData->Resize(pFOPTE->m_op, false);
			pFOPTE->m_pComplexData->GetBlobView()->Pack(pBlobView, pBlobView->GetSize());
			m_pHeader->m_recInstance++;
			m_pHeader->m_recLen += (unsigned int)(OfficeArtFOPTEStruct::SIZE + pFOPTE->m_op);
			{
				NumberDuck::Secret::OfficeArtFOPTEStruct* __3616310584 = pFOPTE;
				pFOPTE = 0;
				m_pFoptVector->PushBack(__3616310584);
			}
			if (pFOPTE) delete pFOPTE;
		}

		OfficeArtFOPTEStruct* OfficeArtFOPTRecord::GetProperty(OfficeArtRecord::OPIDType eType)
		{
			unsigned short i;
			for (i = 0; i < m_pHeader->m_recInstance; i++)
			{
				OfficeArtFOPTEStruct* pFOPTE = m_pFoptVector->Get(i);
				if ((OfficeArtRecord::OPIDType)(pFOPTE->m_opid->m_opid) == eType)
					return pFOPTE;
			}
			return 0;
		}

		OfficeArtFOPTRecord::~OfficeArtFOPTRecord()
		{
			if (m_pFoptVector) delete m_pFoptVector;
		}

		OfficeArtFDGRecord::OfficeArtFDGRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView) : OfficeArtRecord(pHeader, IS_CONTAINER, pBlobView)
		{
			m_csp = 0;
			m_spidCur = 0;
			nbAssert::Assert((OfficeArtRecord::Type)(pHeader->m_recType) == OfficeArtRecord::Type::TYPE_OFFICE_ART_FDG);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void OfficeArtFDGRecord::BlobRead(BlobView* pBlobView)
		{
			m_csp = pBlobView->UnpackUint32();
			m_spidCur = pBlobView->UnpackUint32();
		}

		void OfficeArtFDGRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint32(m_csp);
			pBlobView->PackUint32(m_spidCur);
		}

		void OfficeArtFDGRecord::SetDefaults()
		{
			m_csp = 0;
			m_spidCur = 0;
		}

		OfficeArtFDGRecord::OfficeArtFDGRecord(unsigned short recInstance, unsigned int csp, unsigned int spidCur) : OfficeArtRecord(TYPE, IS_CONTAINER, SIZE, true)
		{
			m_csp = 0;
			m_spidCur = 0;
			SetDefaults();
			m_pHeader->m_recVer = 0x0;
			m_pHeader->m_recInstance = recInstance;
			m_csp = csp;
			m_spidCur = spidCur;
		}

		OfficeArtFDGGBlockRecord::OfficeArtFDGGBlockRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView) : OfficeArtRecord(pHeader, IS_CONTAINER, pBlobView)
		{
			m_spidMax = 0;
			m_cidcl = 0;
			m_cspSaved = 0;
			m_cdgSaved = 0;
			m_pRgidclVector = 0;
			nbAssert::Assert((OfficeArtRecord::Type)(pHeader->m_recType) == OfficeArtRecord::Type::TYPE_OFFICE_ART_FDGG_BLOCK);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void OfficeArtFDGGBlockRecord::BlobRead(BlobView* pBlobView)
		{
			m_spidMax = pBlobView->UnpackUint32();
			m_cidcl = pBlobView->UnpackUint32();
			m_cspSaved = pBlobView->UnpackUint32();
			m_cdgSaved = pBlobView->UnpackUint32();
			PostBlobRead(pBlobView);
		}

		void OfficeArtFDGGBlockRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint32(m_spidMax);
			pBlobView->PackUint32(m_cidcl);
			pBlobView->PackUint32(m_cspSaved);
			pBlobView->PackUint32(m_cdgSaved);
			PostBlobWrite(pBlobView);
		}

		void OfficeArtFDGGBlockRecord::SetDefaults()
		{
			m_spidMax = 0;
			m_cidcl = 0;
			m_cspSaved = 0;
			m_cdgSaved = 0;
			PostSetDefaults();
		}

		OfficeArtFDGGBlockRecord::OfficeArtFDGGBlockRecord(unsigned int nNumPicture) : OfficeArtRecord(TYPE, IS_CONTAINER, SIZE + OfficeArtIDCLStruct::SIZE, true)
		{
			m_spidMax = 0;
			m_cidcl = 0;
			m_cspSaved = 0;
			m_cdgSaved = 0;
			m_pRgidclVector = 0;
			SetDefaults();
			m_spidMax = 2049;
			m_cidcl = 2;
			m_cspSaved = nNumPicture + 1;
			m_cdgSaved = 1;
			OfficeArtIDCLStruct* pIdcl = new OfficeArtIDCLStruct();
			pIdcl->m_dgid = 1;
			pIdcl->m_cspidCur = nNumPicture * 2;
			{
				NumberDuck::Secret::OfficeArtIDCLStruct* __1286637680 = pIdcl;
				pIdcl = 0;
				m_pRgidclVector->PushBack(__1286637680);
			}
			if (pIdcl) delete pIdcl;
		}

		void OfficeArtFDGGBlockRecord::PostSetDefaults()
		{
			m_pRgidclVector = new OwnedVector<OfficeArtIDCLStruct*>();
		}

		void OfficeArtFDGGBlockRecord::PostBlobWrite(BlobView* pBlobView)
		{
			int i;
			for (i = 0; i < m_pRgidclVector->GetSize(); i++)
			{
				m_pRgidclVector->Get(i)->BlobWrite(pBlobView);
			}
		}

		void OfficeArtFDGGBlockRecord::PostBlobRead(BlobView* pBlobView)
		{
			int i;
			for (i = 0; i < (int)(m_cidcl) - 1; i++)
			{
				OfficeArtIDCLStruct* pIdcl = new OfficeArtIDCLStruct();
				pIdcl->BlobRead(pBlobView);
				{
					NumberDuck::Secret::OfficeArtIDCLStruct* __1286637680 = pIdcl;
					pIdcl = 0;
					m_pRgidclVector->PushBack(__1286637680);
				}
				if (pIdcl) delete pIdcl;
			}
		}

		OfficeArtFDGGBlockRecord::~OfficeArtFDGGBlockRecord()
		{
			if (m_pRgidclVector) delete m_pRgidclVector;
		}

		OfficeArtFBSERecord::OfficeArtFBSERecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView) : OfficeArtRecord(pHeader, IS_CONTAINER, pBlobView)
		{
			m_btWin32 = 0;
			m_btMacOS = 0;
			m_rgbUid = 0;
			m_tag = 0;
			m_size = 0;
			m_cRef = 0;
			m_foDelay = 0;
			m_unused1 = 0;
			m_cbName = 0;
			m_unused2 = 0;
			m_unused3 = 0;
			m_pEmbeddedBlip = 0;
			nbAssert::Assert((OfficeArtRecord::Type)(pHeader->m_recType) == OfficeArtRecord::Type::TYPE_OFFICE_ART_FBSE);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void OfficeArtFBSERecord::BlobRead(BlobView* pBlobView)
		{
			m_btWin32 = pBlobView->UnpackUint8();
			m_btMacOS = pBlobView->UnpackUint8();
			m_rgbUid->BlobRead(pBlobView);
			m_tag = pBlobView->UnpackUint16();
			m_size = pBlobView->UnpackUint32();
			m_cRef = pBlobView->UnpackUint32();
			m_foDelay = pBlobView->UnpackUint32();
			m_unused1 = pBlobView->UnpackUint8();
			m_cbName = pBlobView->UnpackUint8();
			m_unused2 = pBlobView->UnpackUint8();
			m_unused3 = pBlobView->UnpackUint8();
			PostBlobRead(pBlobView);
		}

		void OfficeArtFBSERecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint8(m_btWin32);
			pBlobView->PackUint8(m_btMacOS);
			m_rgbUid->BlobWrite(pBlobView);
			pBlobView->PackUint16(m_tag);
			pBlobView->PackUint32(m_size);
			pBlobView->PackUint32(m_cRef);
			pBlobView->PackUint32(m_foDelay);
			pBlobView->PackUint8(m_unused1);
			pBlobView->PackUint8(m_cbName);
			pBlobView->PackUint8(m_unused2);
			pBlobView->PackUint8(m_unused3);
			PostBlobWrite(pBlobView);
		}

		void OfficeArtFBSERecord::SetDefaults()
		{
			m_btWin32 = 0;
			m_btMacOS = 0;
			m_rgbUid = new MD4DigestStruct();
			m_tag = 0;
			m_size = 0;
			m_cRef = 0;
			m_foDelay = 0;
			m_unused1 = 0;
			m_cbName = 0;
			m_unused2 = 0;
			m_unused3 = 0;
			PostSetDefaults();
		}

		OfficeArtFBSERecord::OfficeArtFBSERecord(Picture* pPicture) : OfficeArtRecord(TYPE, IS_CONTAINER, SIZE, true)
		{
			m_btWin32 = 0;
			m_btMacOS = 0;
			m_rgbUid = 0;
			m_tag = 0;
			m_size = 0;
			m_cRef = 0;
			m_foDelay = 0;
			m_unused1 = 0;
			m_cbName = 0;
			m_unused2 = 0;
			m_unused3 = 0;
			m_pEmbeddedBlip = 0;
			SetDefaults();
			m_pEmbeddedBlip = new OfficeArtBlipRecord(pPicture);
			unsigned int nBlipSize = m_pEmbeddedBlip->GetRecursiveSize();
			m_pHeader->m_recLen = SIZE + nBlipSize;
			m_pHeader->m_recVer = 0x2;
			{
				BlobView* pPictureBlobView = pPicture->GetBlob()->GetBlobView();
				Blob* pBlob = new Blob(true);
				BlobView* pBlobView = pBlob->GetBlobView();
				MD4* pMd4 = new MD4();
				pPictureBlobView->SetOffset(0);
				pMd4->Process(pPictureBlobView);
				pMd4->BlobWrite(pBlobView);
				pBlobView->SetOffset(0);
				m_rgbUid->BlobRead(pBlobView);
				if (pBlob) delete pBlob;
				if (pMd4) delete pMd4;
			}
			m_tag = 0xFF;
			m_size = nBlipSize;
			m_cRef = 1;
			if (pPicture->GetFormat() == Picture::Format::PNG)
			{
				m_pHeader->m_recInstance = 0x006;
				m_btWin32 = 6;
				m_btMacOS = 6;
				m_unused2 = 6;
			}
			else if (pPicture->GetFormat() == Picture::Format::JPEG)
			{
				m_pHeader->m_recInstance = 0x005;
				m_btWin32 = 5;
				m_btMacOS = 5;
				m_unused2 = 2;
			}
			else if (pPicture->GetFormat() == Picture::Format::WMF)
			{
				m_pHeader->m_recInstance = 0x003;
				m_btWin32 = 3;
				m_btMacOS = 4;
				m_unused2 = 0;
			}
			else
			{
				nbAssert::Assert(false);
			}
		}

		void OfficeArtFBSERecord::PostSetDefaults()
		{
			m_pEmbeddedBlip = 0;
		}

		void OfficeArtFBSERecord::PostBlobWrite(BlobView* pBlobView)
		{
			m_pEmbeddedBlip->RecursiveWrite(pBlobView);
		}

		void OfficeArtFBSERecord::PostBlobRead(BlobView* pBlobView)
		{
			pBlobView->SetOffset(pBlobView->GetOffset() + m_cbName);
			OfficeArtRecord* pOfficeArtRecord = OfficeArtRecord::CreateOfficeArtRecord(pBlobView);
			{
				NumberDuck::Secret::OfficeArtRecord* __3533451309 = pOfficeArtRecord;
				pOfficeArtRecord = 0;
				m_pEmbeddedBlip = (OfficeArtBlipRecord*)(__3533451309);
			}
			if (pOfficeArtRecord) delete pOfficeArtRecord;
		}

		OfficeArtBlipRecord* OfficeArtFBSERecord::GetEmbeddedBlip()
		{
			return m_pEmbeddedBlip;
		}

		OfficeArtFBSERecord::~OfficeArtFBSERecord()
		{
			if (m_rgbUid) delete m_rgbUid;
			if (m_pEmbeddedBlip) delete m_pEmbeddedBlip;
		}

		OfficeArtDggContainerRecord::OfficeArtDggContainerRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView) : OfficeArtRecord(pHeader, IS_CONTAINER, pBlobView)
		{
			nbAssert::Assert((OfficeArtRecord::Type)(pHeader->m_recType) == OfficeArtRecord::Type::TYPE_OFFICE_ART_DGG_CONTAINER);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void OfficeArtDggContainerRecord::BlobRead(BlobView* pBlobView)
		{
		}

		void OfficeArtDggContainerRecord::BlobWrite(BlobView* pBlobView)
		{
		}

		void OfficeArtDggContainerRecord::SetDefaults()
		{
		}

		OfficeArtDggContainerRecord::OfficeArtDggContainerRecord() : OfficeArtRecord(TYPE, IS_CONTAINER, SIZE, true)
		{
			SetDefaults();
			m_pHeader->m_recVer = 0xF;
		}

		OfficeArtDgContainerRecord::OfficeArtDgContainerRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView) : OfficeArtRecord(pHeader, IS_CONTAINER, pBlobView)
		{
			nbAssert::Assert((OfficeArtRecord::Type)(pHeader->m_recType) == OfficeArtRecord::Type::TYPE_OFFICE_ART_DG_CONTAINER);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void OfficeArtDgContainerRecord::BlobRead(BlobView* pBlobView)
		{
		}

		void OfficeArtDgContainerRecord::BlobWrite(BlobView* pBlobView)
		{
		}

		void OfficeArtDgContainerRecord::SetDefaults()
		{
		}

		OfficeArtDgContainerRecord::OfficeArtDgContainerRecord() : OfficeArtRecord(TYPE, IS_CONTAINER, SIZE, true)
		{
			SetDefaults();
			m_pHeader->m_recVer = 0xF;
		}

		OfficeArtClientDataRecord::OfficeArtClientDataRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView) : OfficeArtRecord(pHeader, IS_CONTAINER, pBlobView)
		{
			nbAssert::Assert((OfficeArtRecord::Type)(pHeader->m_recType) == OfficeArtRecord::Type::TYPE_OFFICE_ART_CLIENT_DATA);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void OfficeArtClientDataRecord::BlobRead(BlobView* pBlobView)
		{
		}

		void OfficeArtClientDataRecord::BlobWrite(BlobView* pBlobView)
		{
		}

		void OfficeArtClientDataRecord::SetDefaults()
		{
		}

		OfficeArtClientDataRecord::OfficeArtClientDataRecord() : OfficeArtRecord(TYPE, IS_CONTAINER, SIZE, true)
		{
			SetDefaults();
			m_pHeader->m_recVer = 0x0;
			m_pHeader->m_recInstance = 0x0000;
		}

		OfficeArtClientAnchorSheetRecord::OfficeArtClientAnchorSheetRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView) : OfficeArtRecord(pHeader, IS_CONTAINER, pBlobView)
		{
			m_fMove = 0;
			m_fSize = 0;
			m_reserved1 = 0;
			m_reserved2 = 0;
			m_reserved3 = 0;
			m_unused = 0;
			m_colL = 0;
			m_dxL = 0;
			m_rwT = 0;
			m_dyT = 0;
			m_colR = 0;
			m_dxR = 0;
			m_rwB = 0;
			m_dyB = 0;
			nbAssert::Assert((OfficeArtRecord::Type)(pHeader->m_recType) == OfficeArtRecord::Type::TYPE_OFFICE_ART_CLIENT_ANCHOR_SHEET);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void OfficeArtClientAnchorSheetRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fMove = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fSize = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_reserved1 = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_reserved2 = (unsigned short)((nBitmask0 >> 3) & 0x1);
			m_reserved3 = (unsigned short)((nBitmask0 >> 4) & 0x1);
			m_unused = (unsigned short)((nBitmask0 >> 5) & 0x7ff);
			m_colL = pBlobView->UnpackUint16();
			m_dxL = pBlobView->UnpackUint16();
			m_rwT = pBlobView->UnpackUint16();
			m_dyT = pBlobView->UnpackUint16();
			m_colR = pBlobView->UnpackUint16();
			m_dxR = pBlobView->UnpackUint16();
			m_rwB = pBlobView->UnpackUint16();
			m_dyB = pBlobView->UnpackUint16();
		}

		void OfficeArtClientAnchorSheetRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_fMove << 0;
			nBitmask0 += m_fSize << 1;
			nBitmask0 += m_reserved1 << 2;
			nBitmask0 += m_reserved2 << 3;
			nBitmask0 += m_reserved3 << 4;
			nBitmask0 += m_unused << 5;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			pBlobView->PackUint16(m_colL);
			pBlobView->PackUint16(m_dxL);
			pBlobView->PackUint16(m_rwT);
			pBlobView->PackUint16(m_dyT);
			pBlobView->PackUint16(m_colR);
			pBlobView->PackUint16(m_dxR);
			pBlobView->PackUint16(m_rwB);
			pBlobView->PackUint16(m_dyB);
		}

		void OfficeArtClientAnchorSheetRecord::SetDefaults()
		{
			m_fMove = 0;
			m_fSize = 0;
			m_reserved1 = 0;
			m_reserved2 = 0;
			m_reserved3 = 0;
			m_unused = 0;
			m_colL = 0;
			m_dxL = 0;
			m_rwT = 0;
			m_dyT = 0;
			m_colR = 0;
			m_dxR = 0;
			m_rwB = 0;
			m_dyB = 0;
		}

		OfficeArtClientAnchorSheetRecord::OfficeArtClientAnchorSheetRecord(unsigned short colL, unsigned short dxL, unsigned short rwT, unsigned short dyT, unsigned short colR, unsigned short dxR, unsigned short rwB, unsigned short dyB) : OfficeArtRecord(TYPE, IS_CONTAINER, SIZE, true)
		{
			m_fMove = 0;
			m_fSize = 0;
			m_reserved1 = 0;
			m_reserved2 = 0;
			m_reserved3 = 0;
			m_unused = 0;
			m_colL = 0;
			m_dxL = 0;
			m_rwT = 0;
			m_dyT = 0;
			m_colR = 0;
			m_dxR = 0;
			m_rwB = 0;
			m_dyB = 0;
			SetDefaults();
			m_pHeader->m_recVer = 0x0;
			m_pHeader->m_recInstance = 0x0000;
			m_colL = colL;
			m_dxL = dxL;
			m_rwT = rwT;
			m_dyT = dyT;
			m_colR = colR;
			m_dxR = dxR;
			m_rwB = rwB;
			m_dyB = dyB;
		}

		unsigned short OfficeArtClientAnchorSheetRecord::GetCellX1()
		{
			return m_colL;
		}

		unsigned short OfficeArtClientAnchorSheetRecord::GetSubCellX1()
		{
			return m_dxL;
		}

		unsigned short OfficeArtClientAnchorSheetRecord::GetCellY1()
		{
			return m_rwT;
		}

		unsigned short OfficeArtClientAnchorSheetRecord::GetSubCellY1()
		{
			return m_dyT;
		}

		unsigned short OfficeArtClientAnchorSheetRecord::GetCellX2()
		{
			return m_colR;
		}

		unsigned short OfficeArtClientAnchorSheetRecord::GetSubCellX2()
		{
			return m_dxR;
		}

		unsigned short OfficeArtClientAnchorSheetRecord::GetCellY2()
		{
			return m_rwB;
		}

		unsigned short OfficeArtClientAnchorSheetRecord::GetSubCellY2()
		{
			return m_dyB;
		}

		OfficeArtBlipRecord::OfficeArtBlipRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView) : OfficeArtRecord(pHeader, IS_CONTAINER, pBlobView)
		{
			m_rgbUid1 = 0;
			m_rgbUid2 = 0;
			m_tag = 0;
			m_BLIPFileData_ = 0;
			m_OwnedBLIPFileData = 0;
			SetDefaults();
			BlobRead(pBlobView);
		}

		void OfficeArtBlipRecord::BlobRead(BlobView* pBlobView)
		{
			m_rgbUid1->BlobRead(pBlobView);
			PostBlobRead(pBlobView);
		}

		void OfficeArtBlipRecord::BlobWrite(BlobView* pBlobView)
		{
			m_rgbUid1->BlobWrite(pBlobView);
			PostBlobWrite(pBlobView);
		}

		void OfficeArtBlipRecord::SetDefaults()
		{
			m_rgbUid1 = new MD4DigestStruct();
			PostSetDefaults();
		}

		OfficeArtBlipRecord::OfficeArtBlipRecord(Picture* pPicture) : OfficeArtRecord(TYPE, IS_CONTAINER, (unsigned int)(SIZE + 1 + pPicture->GetBlob()->GetSize()), true)
		{
			m_rgbUid1 = 0;
			m_rgbUid2 = 0;
			m_tag = 0;
			m_BLIPFileData_ = 0;
			m_OwnedBLIPFileData = 0;
			SetDefaults();
			if (pPicture->GetFormat() == Picture::Format::PNG)
			{
				m_pHeader->m_recType = (unsigned short)(OfficeArtRecord::Type::TYPE_OFFICE_ART_BLIP_PNG);
				m_pHeader->m_recVer = 0x0;
				m_pHeader->m_recInstance = 0x6E0;
			}
			else if (pPicture->GetFormat() == Picture::Format::JPEG)
			{
				m_pHeader->m_recType = (unsigned short)(OfficeArtRecord::Type::TYPE_OFFICE_ART_BLIP_JPEG);
				m_pHeader->m_recVer = 0x0;
				m_pHeader->m_recInstance = 0x46A;
			}
			else if (pPicture->GetFormat() == Picture::Format::WMF)
			{
				m_pHeader->m_recType = (unsigned short)(OfficeArtRecord::Type::TYPE_OFFICE_ART_BLIP_WMF);
				m_pHeader->m_recVer = 0x0;
				m_pHeader->m_recInstance = 0x216;
			}
			else
			{
				nbAssert::Assert(false);
			}
			{
				BlobView* pPictureBlobView = pPicture->GetBlob()->GetBlobView();
				Blob* pBlob = new Blob(true);
				BlobView* pBlobView = pBlob->GetBlobView();
				MD4* pMd4 = new MD4();
				pPictureBlobView->SetOffset(0);
				pMd4->Process(pPictureBlobView);
				pMd4->BlobWrite(pBlobView);
				pBlobView->SetOffset(0);
				m_rgbUid1->BlobRead(pBlobView);
				if (pBlob) delete pBlob;
				if (pMd4) delete pMd4;
			}
			m_tag = 0xFF;
			m_BLIPFileData_ = pPicture->GetBlob();
		}

		void OfficeArtBlipRecord::PostSetDefaults()
		{
			m_tag = 0;
			m_rgbUid2 = 0;
			m_BLIPFileData_ = 0;
			m_OwnedBLIPFileData = 0;
		}

		void OfficeArtBlipRecord::PostBlobWrite(BlobView* pBlobView)
		{
			if (m_rgbUid2 != 0)
				m_rgbUid2->BlobWrite(pBlobView);
			pBlobView->PackUint8(m_tag);
			if (m_BLIPFileData_ != 0)
			{
				BlobView* pBLIPBlobView = m_BLIPFileData_->GetBlobView();
				pBLIPBlobView->SetOffset(0);
				pBlobView->Pack(pBLIPBlobView, pBLIPBlobView->GetSize());
			}
			if (m_OwnedBLIPFileData != 0)
			{
				BlobView* pBLIPBlobView = m_OwnedBLIPFileData->GetBlobView();
				pBLIPBlobView->SetOffset(0);
				pBlobView->Pack(pBLIPBlobView, pBLIPBlobView->GetSize());
			}
		}

		void OfficeArtBlipRecord::PostBlobRead(BlobView* pBlobView)
		{
			nbAssert::Assert((Type)(m_pHeader->m_recType) == Type::TYPE_OFFICE_ART_BLIP_EMF || (Type)(m_pHeader->m_recType) == Type::TYPE_OFFICE_ART_BLIP_WMF || (Type)(m_pHeader->m_recType) == Type::TYPE_OFFICE_ART_BLIP_PICT || (Type)(m_pHeader->m_recType) == Type::TYPE_OFFICE_ART_BLIP_JPEG || (Type)(m_pHeader->m_recType) == Type::TYPE_OFFICE_ART_BLIP_PNG || (Type)(m_pHeader->m_recType) == Type::TYPE_OFFICE_ART_BLIP_DIB || (Type)(m_pHeader->m_recType) == Type::TYPE_OFFICE_ART_BLIP_TIFF || (Type)(m_pHeader->m_recType) == Type::TYPE_OFFICE_ART_BLIP_JPEG_CMYK);
			unsigned int nSize = m_pHeader->m_recLen - SIZE;
			if (m_pHeader->m_recInstance == 0x46B || m_pHeader->m_recInstance == 0x6E3)
			{
				m_rgbUid2 = new MD4DigestStruct();
				m_rgbUid2->BlobRead(pBlobView);
				nSize -= 16;
			}
			m_tag = pBlobView->UnpackUint8();
			nSize--;
			m_OwnedBLIPFileData = new Blob(true);
			m_OwnedBLIPFileData->GetBlobView()->Pack(pBlobView, (int)(nSize));
		}

		Blob* OfficeArtBlipRecord::GetBlob()
		{
			if (m_BLIPFileData_ != 0)
				return m_BLIPFileData_;
			else
				return m_OwnedBLIPFileData;
		}

		OfficeArtBlipRecord::~OfficeArtBlipRecord()
		{
			if (m_rgbUid1) delete m_rgbUid1;
			if (m_rgbUid2) delete m_rgbUid2;
			if (m_OwnedBLIPFileData) delete m_OwnedBLIPFileData;
		}

		OfficeArtBStoreContainerRecord::OfficeArtBStoreContainerRecord(OfficeArtRecordHeaderStruct* pHeader, BlobView* pBlobView) : OfficeArtRecord(pHeader, IS_CONTAINER, pBlobView)
		{
			nbAssert::Assert((OfficeArtRecord::Type)(pHeader->m_recType) == OfficeArtRecord::Type::TYPE_OFFICE_ART_B_STORE_CONTAINER);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void OfficeArtBStoreContainerRecord::BlobRead(BlobView* pBlobView)
		{
		}

		void OfficeArtBStoreContainerRecord::BlobWrite(BlobView* pBlobView)
		{
			PreBlobWrite(pBlobView);
		}

		void OfficeArtBStoreContainerRecord::SetDefaults()
		{
		}

		OfficeArtBStoreContainerRecord::OfficeArtBStoreContainerRecord() : OfficeArtRecord(TYPE, IS_CONTAINER, SIZE, true)
		{
			SetDefaults();
			m_pHeader->m_recVer = 0xF;
		}

		void OfficeArtBStoreContainerRecord::PreBlobWrite(BlobView* pBlobView)
		{
			m_pHeader->m_recInstance = (unsigned short)(m_pOfficeArtRecordVector->GetSize());
		}

		void OfficeArtBStoreContainerRecord::AddOfficeArtRecord(OfficeArtRecord* pOfficeArtRecord)
		{
			nbAssert::Assert(pOfficeArtRecord->GetType() == OfficeArtRecord::Type::TYPE_OFFICE_ART_FBSE);
			OfficeArtRecord::AddOfficeArtRecord(pOfficeArtRecord);
		}

		PtgStrRecord::PtgStrRecord(BlobView* pBlobView) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			m_string = 0;
			nbAssert::Assert((ParsedExpressionRecord::Type)(m_eType) == ParsedExpressionRecord::Type::TYPE_PtgStr);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void PtgStrRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_ptg = (unsigned char)((nBitmask0 >> 0) & 0x7f);
			m_reserved0 = (unsigned char)((nBitmask0 >> 7) & 0x1);
			PostBlobRead(pBlobView);
		}

		void PtgStrRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_ptg << 0;
			nBitmask0 += m_reserved0 << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
			PostBlobWrite(pBlobView);
		}

		void PtgStrRecord::SetDefaults()
		{
			m_ptg = 0x17;
			m_reserved0 = 0;
			PostSetDefaults();
		}

		PtgStrRecord::PtgStrRecord(const char* szString) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			m_string = 0;
			SetDefaults();
			m_string->m_rgb->Set(szString);
			m_nSize = (unsigned short)(m_nSize + ShortXLUnicodeStringStruct::SIZE + m_string->GetDynamicSize());
		}

		void PtgStrRecord::PostSetDefaults()
		{
			m_string = new ShortXLUnicodeStringStruct();
		}

		void PtgStrRecord::PostBlobRead(BlobView* pBlobView)
		{
			m_string->BlobRead(pBlobView);
		}

		void PtgStrRecord::PostBlobWrite(BlobView* pBlobView)
		{
			m_string->BlobWrite(pBlobView);
		}

		Token* PtgStrRecord::GetToken(WorkbookGlobals* pWorkbookGlobals)
		{
			return new StringToken(m_string->m_rgb->GetExternalString());
		}

		PtgStrRecord::~PtgStrRecord()
		{
			if (m_string) delete m_string;
		}

		PtgRefRecord::PtgRefRecord(BlobView* pBlobView) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_type = 0;
			m_reserved = 0;
			m_loc = 0;
			nbAssert::Assert((ParsedExpressionRecord::Type)(m_eType) == ParsedExpressionRecord::Type::TYPE_PtgRef);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void PtgRefRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_ptg = (unsigned char)((nBitmask0 >> 0) & 0x1f);
			m_type = (unsigned char)((nBitmask0 >> 5) & 0x3);
			m_reserved = (unsigned char)((nBitmask0 >> 7) & 0x1);
			m_loc->BlobRead(pBlobView);
		}

		void PtgRefRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_ptg << 0;
			nBitmask0 += m_type << 5;
			nBitmask0 += m_reserved << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
			m_loc->BlobWrite(pBlobView);
		}

		void PtgRefRecord::SetDefaults()
		{
			m_ptg = 0x04;
			m_type = 0x2;
			m_reserved = 0;
			m_loc = new RgceLocStruct();
		}

		PtgRefRecord::PtgRefRecord(Coordinate* pCoordinate) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_type = 0;
			m_reserved = 0;
			m_loc = 0;
			SetDefaults();
			m_loc->m_column->m_col = pCoordinate->m_nX;
			if (pCoordinate->m_bXRelative)
				m_loc->m_column->m_colRelative = 0x1;
			m_loc->m_row->m_rw = pCoordinate->m_nY;
			if (pCoordinate->m_bYRelative)
				m_loc->m_column->m_rowRelative = 0x1;
		}

		Token* PtgRefRecord::GetToken(WorkbookGlobals* pWorkbookGlobals)
		{
			Coordinate* pCoordinate = new Coordinate(m_loc->m_column->m_col, m_loc->m_row->m_rw, m_loc->m_column->m_colRelative == 0x1, m_loc->m_column->m_rowRelative == 0x1);
			{
				NumberDuck::Secret::Coordinate* __3642692973 = pCoordinate;
				pCoordinate = 0;
				{
					if (pCoordinate) delete pCoordinate;
					return new CoordinateToken(__3642692973);
				}
			}
		}

		PtgRefRecord::~PtgRefRecord()
		{
			if (m_loc) delete m_loc;
		}

		PtgRef3dRecord::PtgRef3dRecord(BlobView* pBlobView) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_type = 0;
			m_reserved = 0;
			m_ixti = 0;
			m_loc = 0;
			nbAssert::Assert((ParsedExpressionRecord::Type)(m_eType) == ParsedExpressionRecord::Type::TYPE_PtgRef3d);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void PtgRef3dRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_ptg = (unsigned char)((nBitmask0 >> 0) & 0x1f);
			m_type = (unsigned char)((nBitmask0 >> 5) & 0x3);
			m_reserved = (unsigned char)((nBitmask0 >> 7) & 0x1);
			m_ixti = pBlobView->UnpackUint16();
			m_loc->BlobRead(pBlobView);
		}

		void PtgRef3dRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_ptg << 0;
			nBitmask0 += m_type << 5;
			nBitmask0 += m_reserved << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
			pBlobView->PackUint16(m_ixti);
			m_loc->BlobWrite(pBlobView);
		}

		void PtgRef3dRecord::SetDefaults()
		{
			m_ptg = 0x1A;
			m_type = 0x2;
			m_reserved = 0;
			m_ixti = 0;
			m_loc = new RgceLocStruct();
		}

		PtgRef3dRecord::PtgRef3dRecord(Coordinate3d* pCoordinate3d, WorkbookGlobals* pWorkbookGlobals) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_type = 0;
			m_reserved = 0;
			m_ixti = 0;
			m_loc = 0;
			SetDefaults();
			m_type = 0x2;
			if (pCoordinate3d->m_nWorksheetFirst != pCoordinate3d->m_nWorksheetLast)
				m_type = 0x1;
			m_loc->m_column->m_col = pCoordinate3d->m_pCoordinate->m_nX;
			if (pCoordinate3d->m_pCoordinate->m_bXRelative)
				m_loc->m_column->m_colRelative = 0x1;
			m_loc->m_row->m_rw = pCoordinate3d->m_pCoordinate->m_nY;
			if (pCoordinate3d->m_pCoordinate->m_bYRelative)
				m_loc->m_column->m_rowRelative = 0x1;
			m_ixti = pWorkbookGlobals->GetWorksheetRangeIndex(pCoordinate3d->m_nWorksheetFirst, pCoordinate3d->m_nWorksheetLast);
		}

		Token* PtgRef3dRecord::GetToken(WorkbookGlobals* pWorkbookGlobals)
		{
			WorksheetRange* pWorksheetRange = pWorkbookGlobals->GetWorksheetRangeByIndex(m_ixti);
			Coordinate* pCoordinate = new Coordinate(m_loc->m_column->m_col, m_loc->m_row->m_rw, m_loc->m_column->m_colRelative == 0x1, m_loc->m_column->m_rowRelative == 0x1);
			Coordinate3d* pCoordinate3d = 0;
			{
				NumberDuck::Secret::Coordinate* __3642692973 = pCoordinate;
				pCoordinate = 0;
				pCoordinate3d = new Coordinate3d(pWorksheetRange->m_nFirst, pWorksheetRange->m_nLast, __3642692973);
			}
			Coordinate3dToken* pCoordinate3dToken = 0;
			{
				NumberDuck::Secret::Coordinate3d* __1094936853 = pCoordinate3d;
				pCoordinate3d = 0;
				pCoordinate3dToken = new Coordinate3dToken(__1094936853);
			}
			{
				NumberDuck::Secret::Coordinate3dToken* __3867610451 = pCoordinate3dToken;
				pCoordinate3dToken = 0;
				{
					if (pCoordinate) delete pCoordinate;
					if (pCoordinate3d) delete pCoordinate3d;
					return __3867610451;
				}
			}
		}

		PtgRef3dRecord::~PtgRef3dRecord()
		{
			if (m_loc) delete m_loc;
		}

		PtgParenRecord::PtgParenRecord() : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			SetDefaults();
		}

		PtgParenRecord::PtgParenRecord(BlobView* pBlobView) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			nbAssert::Assert((ParsedExpressionRecord::Type)(m_eType) == ParsedExpressionRecord::Type::TYPE_PtgParen);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void PtgParenRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_ptg = (unsigned char)((nBitmask0 >> 0) & 0x7f);
			m_reserved0 = (unsigned char)((nBitmask0 >> 7) & 0x1);
		}

		void PtgParenRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_ptg << 0;
			nBitmask0 += m_reserved0 << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
		}

		void PtgParenRecord::SetDefaults()
		{
			m_ptg = 0x15;
			m_reserved0 = 0;
		}

		PtgParenRecord::PtgParenRecord(unsigned char ptg) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			SetDefaults();
			switch (ptg)
			{
				case 0x03:
				{
					m_eType = Type::TYPE_PtgAdd;
					break;
				}

				case 0x04:
				{
					m_eType = Type::TYPE_PtgSub;
					break;
				}

				case 0x05:
				{
					m_eType = Type::TYPE_PtgMul;
					break;
				}

				case 0x06:
				{
					m_eType = Type::TYPE_PtgDiv;
					break;
				}

				case 0x07:
				{
					m_eType = Type::TYPE_PtgPower;
					break;
				}

				case 0x08:
				{
					m_eType = Type::TYPE_PtgConcat;
					break;
				}

				case 0x09:
				{
					m_eType = Type::TYPE_PtgLt;
					break;
				}

				case 0x0A:
				{
					m_eType = Type::TYPE_PtgLe;
					break;
				}

				case 0x0B:
				{
					m_eType = Type::TYPE_PtgEq;
					break;
				}

				case 0x0C:
				{
					m_eType = Type::TYPE_PtgGe;
					break;
				}

				case 0x0D:
				{
					m_eType = Type::TYPE_PtgGt;
					break;
				}

				case 0x0E:
				{
					m_eType = Type::TYPE_PtgNe;
					break;
				}

				default:
				{
					nbAssert::Assert(false);
					break;
				}

			}
			m_ptg = ptg;
		}

		void PtgParenRecord::PostBlobRead(BlobView* pBlobView)
		{
			switch (m_ptg)
			{
				case 0x03:
				{
					m_eType = Type::TYPE_PtgAdd;
					break;
				}

				case 0x04:
				{
					m_eType = Type::TYPE_PtgSub;
					break;
				}

				case 0x05:
				{
					m_eType = Type::TYPE_PtgMul;
					break;
				}

				case 0x06:
				{
					m_eType = Type::TYPE_PtgDiv;
					break;
				}

				case 0x07:
				{
					m_eType = Type::TYPE_PtgPower;
					break;
				}

				case 0x08:
				{
					m_eType = Type::TYPE_PtgConcat;
					break;
				}

				case 0x09:
				{
					m_eType = Type::TYPE_PtgLt;
					break;
				}

				case 0x0A:
				{
					m_eType = Type::TYPE_PtgLe;
					break;
				}

				case 0x0B:
				{
					m_eType = Type::TYPE_PtgEq;
					break;
				}

				case 0x0C:
				{
					m_eType = Type::TYPE_PtgGe;
					break;
				}

				case 0x0D:
				{
					m_eType = Type::TYPE_PtgGt;
					break;
				}

				case 0x0E:
				{
					m_eType = Type::TYPE_PtgNe;
					break;
				}

				default:
				{
					nbAssert::Assert(false);
					break;
				}

			}
		}

		Token* PtgParenRecord::GetToken(WorkbookGlobals* pWorkbookGlobals)
		{
			return new Token(Token::Type::TYPE_PAREN, Token::SubType::SUB_TYPE_FUNCTION, 1);
		}

		PtgOperatorRecord::PtgOperatorRecord(BlobView* pBlobView) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			SetDefaults();
			BlobRead(pBlobView);
		}

		void PtgOperatorRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_ptg = (unsigned char)((nBitmask0 >> 0) & 0x7f);
			m_reserved0 = (unsigned char)((nBitmask0 >> 7) & 0x1);
			PostBlobRead(pBlobView);
		}

		void PtgOperatorRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_ptg << 0;
			nBitmask0 += m_reserved0 << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
		}

		void PtgOperatorRecord::SetDefaults()
		{
			m_ptg = 0;
			m_reserved0 = 0;
		}

		PtgOperatorRecord::PtgOperatorRecord(unsigned char ptg) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			SetDefaults();
			switch (ptg)
			{
				case 0x03:
				{
					m_eType = Type::TYPE_PtgAdd;
					break;
				}

				case 0x04:
				{
					m_eType = Type::TYPE_PtgSub;
					break;
				}

				case 0x05:
				{
					m_eType = Type::TYPE_PtgMul;
					break;
				}

				case 0x06:
				{
					m_eType = Type::TYPE_PtgDiv;
					break;
				}

				case 0x07:
				{
					m_eType = Type::TYPE_PtgPower;
					break;
				}

				case 0x08:
				{
					m_eType = Type::TYPE_PtgConcat;
					break;
				}

				case 0x09:
				{
					m_eType = Type::TYPE_PtgLt;
					break;
				}

				case 0x0A:
				{
					m_eType = Type::TYPE_PtgLe;
					break;
				}

				case 0x0B:
				{
					m_eType = Type::TYPE_PtgEq;
					break;
				}

				case 0x0C:
				{
					m_eType = Type::TYPE_PtgGe;
					break;
				}

				case 0x0D:
				{
					m_eType = Type::TYPE_PtgGt;
					break;
				}

				case 0x0E:
				{
					m_eType = Type::TYPE_PtgNe;
					break;
				}

				default:
				{
					nbAssert::Assert(false);
					break;
				}

			}
			m_ptg = ptg;
		}

		void PtgOperatorRecord::PostBlobRead(BlobView* pBlobView)
		{
			switch (m_ptg)
			{
				case 0x03:
				{
					m_eType = Type::TYPE_PtgAdd;
					break;
				}

				case 0x04:
				{
					m_eType = Type::TYPE_PtgSub;
					break;
				}

				case 0x05:
				{
					m_eType = Type::TYPE_PtgMul;
					break;
				}

				case 0x06:
				{
					m_eType = Type::TYPE_PtgDiv;
					break;
				}

				case 0x07:
				{
					m_eType = Type::TYPE_PtgPower;
					break;
				}

				case 0x08:
				{
					m_eType = Type::TYPE_PtgConcat;
					break;
				}

				case 0x09:
				{
					m_eType = Type::TYPE_PtgLt;
					break;
				}

				case 0x0A:
				{
					m_eType = Type::TYPE_PtgLe;
					break;
				}

				case 0x0B:
				{
					m_eType = Type::TYPE_PtgEq;
					break;
				}

				case 0x0C:
				{
					m_eType = Type::TYPE_PtgGe;
					break;
				}

				case 0x0D:
				{
					m_eType = Type::TYPE_PtgGt;
					break;
				}

				case 0x0E:
				{
					m_eType = Type::TYPE_PtgNe;
					break;
				}

				default:
				{
					nbAssert::Assert(false);
					break;
				}

			}
		}

		Token* PtgOperatorRecord::GetToken(WorkbookGlobals* pWorkbookGlobals)
		{
			switch ((Type)(m_eType))
			{
				case Type::TYPE_PtgAdd:
				{
					return new OperatorToken("+");
				}

				case Type::TYPE_PtgSub:
				{
					return new OperatorToken("-");
				}

				case Type::TYPE_PtgMul:
				{
					return new OperatorToken("*");
				}

				case Type::TYPE_PtgDiv:
				{
					return new OperatorToken("/");
				}

				case Type::TYPE_PtgPower:
				{
					return new OperatorToken("^");
				}

				case Type::TYPE_PtgConcat:
				{
					return new OperatorToken("&");
				}

				case Type::TYPE_PtgLt:
				{
					return new OperatorToken("<");
				}

				case Type::TYPE_PtgLe:
				{
					return new OperatorToken("<=");
				}

				case Type::TYPE_PtgEq:
				{
					return new OperatorToken("=");
				}

				case Type::TYPE_PtgGe:
				{
					return new OperatorToken(">=");
				}

				case Type::TYPE_PtgGt:
				{
					return new OperatorToken(">");
				}

				case Type::TYPE_PtgNe:
				{
					return new OperatorToken("<>");
				}

				default:
				{
					break;
				}

			}
			nbAssert::Assert(false);
			return 0;
		}

		PtgNumRecord::PtgNumRecord(BlobView* pBlobView) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			m_value = 0;
			nbAssert::Assert((ParsedExpressionRecord::Type)(m_eType) == ParsedExpressionRecord::Type::TYPE_PtgNum);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void PtgNumRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_ptg = (unsigned char)((nBitmask0 >> 0) & 0x7f);
			m_reserved0 = (unsigned char)((nBitmask0 >> 7) & 0x1);
			m_value = pBlobView->UnpackDouble();
		}

		void PtgNumRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_ptg << 0;
			nBitmask0 += m_reserved0 << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
			pBlobView->PackDouble(m_value);
		}

		void PtgNumRecord::SetDefaults()
		{
			m_ptg = 0x1F;
			m_reserved0 = 0;
			m_value = 0.0;
		}

		PtgNumRecord::PtgNumRecord(double value) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			m_value = 0;
			SetDefaults();
			m_value = value;
		}

		Token* PtgNumRecord::GetToken(WorkbookGlobals* pWorkbookGlobals)
		{
			return new NumToken(m_value);
		}

		PtgMissArgRecord::PtgMissArgRecord() : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			SetDefaults();
		}

		PtgMissArgRecord::PtgMissArgRecord(BlobView* pBlobView) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			nbAssert::Assert((ParsedExpressionRecord::Type)(m_eType) == ParsedExpressionRecord::Type::TYPE_PtgMissArg);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void PtgMissArgRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_ptg = (unsigned char)((nBitmask0 >> 0) & 0x7f);
			m_reserved0 = (unsigned char)((nBitmask0 >> 7) & 0x1);
		}

		void PtgMissArgRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_ptg << 0;
			nBitmask0 += m_reserved0 << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
		}

		void PtgMissArgRecord::SetDefaults()
		{
			m_ptg = 0x16;
			m_reserved0 = 0;
		}

		Token* PtgMissArgRecord::GetToken(WorkbookGlobals* pWorkbookGlobals)
		{
			return new MissArgToken();
		}

		PtgIntRecord::PtgIntRecord(BlobView* pBlobView) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			m_integer = 0;
			nbAssert::Assert((ParsedExpressionRecord::Type)(m_eType) == ParsedExpressionRecord::Type::TYPE_PtgInt);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void PtgIntRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_ptg = (unsigned char)((nBitmask0 >> 0) & 0x7f);
			m_reserved0 = (unsigned char)((nBitmask0 >> 7) & 0x1);
			m_integer = pBlobView->UnpackUint16();
		}

		void PtgIntRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_ptg << 0;
			nBitmask0 += m_reserved0 << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
			pBlobView->PackUint16(m_integer);
		}

		void PtgIntRecord::SetDefaults()
		{
			m_ptg = 0x1E;
			m_reserved0 = 0;
			m_integer = 0;
		}

		PtgIntRecord::PtgIntRecord(unsigned short nInt) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			m_integer = 0;
			SetDefaults();
			m_integer = nInt;
		}

		Token* PtgIntRecord::GetToken(WorkbookGlobals* pWorkbookGlobals)
		{
			return new IntToken(m_integer);
		}

		PtgFuncVarRecord::PtgFuncVarRecord(BlobView* pBlobView) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_type = 0;
			m_reserved0 = 0;
			m_cparams = 0;
			m_tab = 0;
			m_fCeFunc = 0;
			nbAssert::Assert((ParsedExpressionRecord::Type)(m_eType) == ParsedExpressionRecord::Type::TYPE_PtgFuncVar);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void PtgFuncVarRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_ptg = (unsigned char)((nBitmask0 >> 0) & 0x1f);
			m_type = (unsigned char)((nBitmask0 >> 5) & 0x3);
			m_reserved0 = (unsigned char)((nBitmask0 >> 7) & 0x1);
			m_cparams = pBlobView->UnpackUint8();
			unsigned short nBitmask1 = pBlobView->UnpackUint16();
			m_tab = (unsigned short)((nBitmask1 >> 0) & 0x7fff);
			m_fCeFunc = (unsigned short)((nBitmask1 >> 15) & 0x1);
		}

		void PtgFuncVarRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_ptg << 0;
			nBitmask0 += m_type << 5;
			nBitmask0 += m_reserved0 << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
			pBlobView->PackUint8(m_cparams);
			int nBitmask1 = 0;
			nBitmask1 += m_tab << 0;
			nBitmask1 += m_fCeFunc << 15;
			pBlobView->PackUint16((unsigned short)(nBitmask1));
		}

		void PtgFuncVarRecord::SetDefaults()
		{
			m_ptg = 0x02;
			m_type = 1;
			m_reserved0 = 0;
			m_cparams = 0;
			m_tab = 0;
			m_fCeFunc = 0;
		}

		PtgFuncVarRecord::PtgFuncVarRecord(unsigned short iftab, unsigned char cparams) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_type = 0;
			m_reserved0 = 0;
			m_cparams = 0;
			m_tab = 0;
			m_fCeFunc = 0;
			SetDefaults();
			m_tab = iftab;
			m_cparams = cparams;
		}

		Token* PtgFuncVarRecord::GetToken(WorkbookGlobals* pWorkbookGlobals)
		{
			switch ((Token::Type)(m_tab))
			{
				case Token::Type::TYPE_FUNC_SUM:
				{
					return new SumToken(m_cparams);
				}

				case Token::Type::TYPE_FUNC_TRUE:
				{
					return new BoolToken(true, true);
				}

				case Token::Type::TYPE_FUNC_FALSE:
				{
					return new BoolToken(false, true);
				}

			}
			return new Token((Token::Type)(m_tab), Token::SubType::SUB_TYPE_FUNCTION, m_cparams);
		}

		PtgFuncRecord::PtgFuncRecord(BlobView* pBlobView) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_type = 0;
			m_reserved0 = 0;
			m_iftab = 0;
			nbAssert::Assert((ParsedExpressionRecord::Type)(m_eType) == ParsedExpressionRecord::Type::TYPE_PtgFunc);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void PtgFuncRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_ptg = (unsigned char)((nBitmask0 >> 0) & 0x1f);
			m_type = (unsigned char)((nBitmask0 >> 5) & 0x3);
			m_reserved0 = (unsigned char)((nBitmask0 >> 7) & 0x1);
			m_iftab = pBlobView->UnpackUint16();
		}

		void PtgFuncRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_ptg << 0;
			nBitmask0 += m_type << 5;
			nBitmask0 += m_reserved0 << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
			pBlobView->PackUint16(m_iftab);
		}

		void PtgFuncRecord::SetDefaults()
		{
			m_ptg = 0x01;
			m_type = 1;
			m_reserved0 = 0;
			m_iftab = 0;
		}

		Token* PtgFuncRecord::GetToken(WorkbookGlobals* pWorkbookGlobals)
		{
			switch ((Token::Type)(m_iftab))
			{
				case Token::Type::TYPE_FUNC_SUM:
				{
					return new SumToken(1);
				}

				case Token::Type::TYPE_FUNC_TRUE:
				{
					return new BoolToken(true, true);
				}

				case Token::Type::TYPE_FUNC_FALSE:
				{
					return new BoolToken(false, true);
				}

				case Token::Type::TYPE_FUNC_PI:
				case Token::Type::TYPE_FUNC_NOW:
				case Token::Type::TYPE_FUNC_TODAY:
				{
					return new Token((Token::Type)(m_iftab), Token::SubType::SUB_TYPE_FUNCTION, 0);
				}

				case Token::Type::TYPE_FUNC_INT:
				case Token::Type::TYPE_FUNC_DAY:
				case Token::Type::TYPE_FUNC_MONTH:
				case Token::Type::TYPE_FUNC_YEAR:
				case Token::Type::TYPE_FUNC_WEEKDAY:
				case Token::Type::TYPE_FUNC_HOUR:
				case Token::Type::TYPE_FUNC_MINUTE:
				case Token::Type::TYPE_FUNC_SECOND:
				case Token::Type::TYPE_FUNC_DATEVALUE:
				case Token::Type::TYPE_FUNC_TIMEVALUE:
				{
					return new Token((Token::Type)(m_iftab), Token::SubType::SUB_TYPE_FUNCTION, 1);
				}

				case Token::Type::TYPE_FUNC_ROUND:
				{
					return new Token((Token::Type)(m_iftab), Token::SubType::SUB_TYPE_FUNCTION, 2);
				}

			}
			return new Token((Token::Type)(m_iftab), Token::SubType::SUB_TYPE_FUNCTION, 3);
		}

		PtgBoolRecord::PtgBoolRecord(BlobView* pBlobView) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			m_boolean = 0;
			nbAssert::Assert((ParsedExpressionRecord::Type)(m_eType) == ParsedExpressionRecord::Type::TYPE_PtgBool);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void PtgBoolRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_ptg = (unsigned char)((nBitmask0 >> 0) & 0x7f);
			m_reserved0 = (unsigned char)((nBitmask0 >> 7) & 0x1);
			m_boolean = pBlobView->UnpackUint8();
		}

		void PtgBoolRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_ptg << 0;
			nBitmask0 += m_reserved0 << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
			pBlobView->PackUint8(m_boolean);
		}

		void PtgBoolRecord::SetDefaults()
		{
			m_ptg = 0x1D;
			m_reserved0 = 0;
			m_boolean = 0;
		}

		PtgBoolRecord::PtgBoolRecord(bool bBool) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			m_boolean = 0;
			SetDefaults();
			m_boolean = bBool ? (unsigned char)(0x1) : (unsigned char)(0x0);
		}

		Token* PtgBoolRecord::GetToken(WorkbookGlobals* pWorkbookGlobals)
		{
			return new BoolToken(m_boolean == 0x1, false);
		}

		PtgAttrSumRecord::PtgAttrSumRecord() : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			m_reserved2 = 0;
			m_bitIf = 0;
			m_reserved3 = 0;
			m_unused = 0;
			SetDefaults();
		}

		PtgAttrSumRecord::PtgAttrSumRecord(BlobView* pBlobView) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			m_reserved2 = 0;
			m_bitIf = 0;
			m_reserved3 = 0;
			m_unused = 0;
			nbAssert::Assert((ParsedExpressionRecord::Type)(m_eType) == ParsedExpressionRecord::Type::TYPE_PtgAttrSum);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void PtgAttrSumRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_ptg = (unsigned char)((nBitmask0 >> 0) & 0x7f);
			m_reserved0 = (unsigned char)((nBitmask0 >> 7) & 0x1);
			unsigned char nBitmask1 = pBlobView->UnpackUint8();
			m_reserved2 = (unsigned char)((nBitmask1 >> 0) & 0xf);
			m_bitIf = (unsigned char)((nBitmask1 >> 4) & 0x1);
			m_reserved3 = (unsigned char)((nBitmask1 >> 5) & 0x7);
			m_unused = pBlobView->UnpackUint16();
		}

		void PtgAttrSumRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_ptg << 0;
			nBitmask0 += m_reserved0 << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
			int nBitmask1 = 0;
			nBitmask1 += m_reserved2 << 0;
			nBitmask1 += m_bitIf << 4;
			nBitmask1 += m_reserved3 << 5;
			pBlobView->PackUint8((unsigned char)(nBitmask1));
			pBlobView->PackUint16(m_unused);
		}

		void PtgAttrSumRecord::SetDefaults()
		{
			m_ptg = 0x19;
			m_reserved0 = 0;
			m_reserved2 = 0;
			m_bitIf = 1;
			m_reserved3 = 0;
			m_unused = 0;
		}

		Token* PtgAttrSumRecord::GetToken(WorkbookGlobals* pWorkbookGlobals)
		{
			return new SumToken(1);
		}

		PtgAttrSpaceRecord::PtgAttrSpaceRecord(BlobView* pBlobView) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			m_reserved2 = 0;
			m_bitSpace = 0;
			m_reserved3 = 0;
			m_type = 0;
			nbAssert::Assert((ParsedExpressionRecord::Type)(m_eType) == ParsedExpressionRecord::Type::TYPE_PtgAttrSpace);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void PtgAttrSpaceRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_ptg = (unsigned char)((nBitmask0 >> 0) & 0x7f);
			m_reserved0 = (unsigned char)((nBitmask0 >> 7) & 0x1);
			unsigned char nBitmask1 = pBlobView->UnpackUint8();
			m_reserved2 = (unsigned char)((nBitmask1 >> 0) & 0x3f);
			m_bitSpace = (unsigned char)((nBitmask1 >> 6) & 0x1);
			m_reserved3 = (unsigned char)((nBitmask1 >> 7) & 0x1);
			m_type->BlobRead(pBlobView);
		}

		void PtgAttrSpaceRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_ptg << 0;
			nBitmask0 += m_reserved0 << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
			int nBitmask1 = 0;
			nBitmask1 += m_reserved2 << 0;
			nBitmask1 += m_bitSpace << 6;
			nBitmask1 += m_reserved3 << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask1));
			m_type->BlobWrite(pBlobView);
		}

		void PtgAttrSpaceRecord::SetDefaults()
		{
			m_ptg = 0x19;
			m_reserved0 = 0;
			m_reserved2 = 0;
			m_bitSpace = 1;
			m_reserved3 = 0;
			m_type = new PtgAttrSpaceTypeStruct();
		}

		PtgAttrSpaceRecord::PtgAttrSpaceRecord(unsigned char nType, unsigned char nCount) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			m_reserved2 = 0;
			m_bitSpace = 0;
			m_reserved3 = 0;
			m_type = 0;
			SetDefaults();
			m_type->m_type = nType;
			m_type->m_cch = nCount;
		}

		Token* PtgAttrSpaceRecord::GetToken(WorkbookGlobals* pWorkbookGlobals)
		{
			return new SpaceToken((SpaceToken::SpaceType)(m_type->m_type), m_type->m_cch);
		}

		PtgAttrSpaceRecord::~PtgAttrSpaceRecord()
		{
			if (m_type) delete m_type;
		}

		PtgAttrSemiRecord::PtgAttrSemiRecord() : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			m_bitSemi = 0;
			m_reserved2 = 0;
			m_unused = 0;
			SetDefaults();
		}

		PtgAttrSemiRecord::PtgAttrSemiRecord(BlobView* pBlobView) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			m_bitSemi = 0;
			m_reserved2 = 0;
			m_unused = 0;
			nbAssert::Assert((ParsedExpressionRecord::Type)(m_eType) == ParsedExpressionRecord::Type::TYPE_PtgAttrSemi);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void PtgAttrSemiRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_ptg = (unsigned char)((nBitmask0 >> 0) & 0x7f);
			m_reserved0 = (unsigned char)((nBitmask0 >> 7) & 0x1);
			unsigned char nBitmask1 = pBlobView->UnpackUint8();
			m_bitSemi = (unsigned char)((nBitmask1 >> 0) & 0x1);
			m_reserved2 = (unsigned char)((nBitmask1 >> 1) & 0x7f);
			m_unused = pBlobView->UnpackUint16();
		}

		void PtgAttrSemiRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_ptg << 0;
			nBitmask0 += m_reserved0 << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
			int nBitmask1 = 0;
			nBitmask1 += m_bitSemi << 0;
			nBitmask1 += m_reserved2 << 1;
			pBlobView->PackUint8((unsigned char)(nBitmask1));
			pBlobView->PackUint16(m_unused);
		}

		void PtgAttrSemiRecord::SetDefaults()
		{
			m_ptg = 0x19;
			m_reserved0 = 0;
			m_bitSemi = 1;
			m_reserved2 = 0;
			m_unused = 0;
		}

		PtgAttrIfRecord::PtgAttrIfRecord() : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			m_reserved2 = 0;
			m_bitIf = 0;
			m_reserved3 = 0;
			m_offset = 0;
			SetDefaults();
		}

		PtgAttrIfRecord::PtgAttrIfRecord(BlobView* pBlobView) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			m_reserved2 = 0;
			m_bitIf = 0;
			m_reserved3 = 0;
			m_offset = 0;
			nbAssert::Assert((ParsedExpressionRecord::Type)(m_eType) == ParsedExpressionRecord::Type::TYPE_PtgAttrIf);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void PtgAttrIfRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_ptg = (unsigned char)((nBitmask0 >> 0) & 0x7f);
			m_reserved0 = (unsigned char)((nBitmask0 >> 7) & 0x1);
			unsigned char nBitmask1 = pBlobView->UnpackUint8();
			m_reserved2 = (unsigned char)((nBitmask1 >> 0) & 0x1);
			m_bitIf = (unsigned char)((nBitmask1 >> 1) & 0x1);
			m_reserved3 = (unsigned char)((nBitmask1 >> 2) & 0x3f);
			m_offset = pBlobView->UnpackUint16();
		}

		void PtgAttrIfRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_ptg << 0;
			nBitmask0 += m_reserved0 << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
			int nBitmask1 = 0;
			nBitmask1 += m_reserved2 << 0;
			nBitmask1 += m_bitIf << 1;
			nBitmask1 += m_reserved3 << 2;
			pBlobView->PackUint8((unsigned char)(nBitmask1));
			pBlobView->PackUint16(m_offset);
		}

		void PtgAttrIfRecord::SetDefaults()
		{
			m_ptg = 0x19;
			m_reserved0 = 0;
			m_reserved2 = 0;
			m_bitIf = 1;
			m_reserved3 = 0;
			m_offset = 0;
		}

		Token* PtgAttrIfRecord::GetToken(WorkbookGlobals* pWorkbookGlobals)
		{
			return 0;
		}

		PtgAttrGotoRecord::PtgAttrGotoRecord() : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			m_reserved2 = 0;
			m_bitGoto = 0;
			m_reserved3 = 0;
			m_unused = 0;
			SetDefaults();
		}

		PtgAttrGotoRecord::PtgAttrGotoRecord(BlobView* pBlobView) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_reserved0 = 0;
			m_reserved2 = 0;
			m_bitGoto = 0;
			m_reserved3 = 0;
			m_unused = 0;
			nbAssert::Assert((ParsedExpressionRecord::Type)(m_eType) == ParsedExpressionRecord::Type::TYPE_PtgAttrGoto);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void PtgAttrGotoRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_ptg = (unsigned char)((nBitmask0 >> 0) & 0x7f);
			m_reserved0 = (unsigned char)((nBitmask0 >> 7) & 0x1);
			unsigned char nBitmask1 = pBlobView->UnpackUint8();
			m_reserved2 = (unsigned char)((nBitmask1 >> 0) & 0x7);
			m_bitGoto = (unsigned char)((nBitmask1 >> 3) & 0x1);
			m_reserved3 = (unsigned char)((nBitmask1 >> 4) & 0xf);
			m_unused = pBlobView->UnpackUint16();
		}

		void PtgAttrGotoRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_ptg << 0;
			nBitmask0 += m_reserved0 << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
			int nBitmask1 = 0;
			nBitmask1 += m_reserved2 << 0;
			nBitmask1 += m_bitGoto << 3;
			nBitmask1 += m_reserved3 << 4;
			pBlobView->PackUint8((unsigned char)(nBitmask1));
			pBlobView->PackUint16(m_unused);
		}

		void PtgAttrGotoRecord::SetDefaults()
		{
			m_ptg = 0x19;
			m_reserved0 = 0;
			m_reserved2 = 0;
			m_bitGoto = 1;
			m_reserved3 = 0;
			m_unused = 0;
		}

		PtgAreaRecord::PtgAreaRecord(BlobView* pBlobView) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_type = 0;
			m_reserved = 0;
			m_area = 0;
			nbAssert::Assert((ParsedExpressionRecord::Type)(m_eType) == ParsedExpressionRecord::Type::TYPE_PtgArea);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void PtgAreaRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_ptg = (unsigned char)((nBitmask0 >> 0) & 0x1f);
			m_type = (unsigned char)((nBitmask0 >> 5) & 0x3);
			m_reserved = (unsigned char)((nBitmask0 >> 7) & 0x1);
			m_area->BlobRead(pBlobView);
		}

		void PtgAreaRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_ptg << 0;
			nBitmask0 += m_type << 5;
			nBitmask0 += m_reserved << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
			m_area->BlobWrite(pBlobView);
		}

		void PtgAreaRecord::SetDefaults()
		{
			m_ptg = 0x05;
			m_type = 0x1;
			m_reserved = 0;
			m_area = new RgceAreaStruct();
		}

		PtgAreaRecord::PtgAreaRecord(Area* pArea) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_type = 0;
			m_reserved = 0;
			m_area = 0;
			SetDefaults();
			m_area->m_columnFirst->m_col = pArea->m_pTopLeft->m_nX;
			if (pArea->m_pTopLeft->m_bXRelative)
				m_area->m_columnFirst->m_colRelative = 0x1;
			m_area->m_rowFirst->m_rw = pArea->m_pTopLeft->m_nY;
			if (pArea->m_pTopLeft->m_bYRelative)
				m_area->m_columnFirst->m_rowRelative = 0x1;
			m_area->m_columnLast->m_col = pArea->m_pBottomRight->m_nX;
			if (pArea->m_pTopLeft->m_bXRelative)
				m_area->m_columnLast->m_colRelative = 0x1;
			m_area->m_rowLast->m_rw = pArea->m_pBottomRight->m_nY;
			if (pArea->m_pTopLeft->m_bYRelative)
				m_area->m_columnLast->m_rowRelative = 0x1;
		}

		Token* PtgAreaRecord::GetToken(WorkbookGlobals* pWorkbookGlobals)
		{
			Coordinate* pTopLeft = new Coordinate(m_area->m_columnFirst->m_col, m_area->m_rowFirst->m_rw, m_area->m_columnFirst->m_colRelative == 0x1, m_area->m_columnFirst->m_rowRelative == 0x1);
			Coordinate* pBottomRight = new Coordinate(m_area->m_columnLast->m_col, m_area->m_rowLast->m_rw, m_area->m_columnLast->m_colRelative == 0x1, m_area->m_columnLast->m_rowRelative == 0x1);
			Area* pArea = 0;
			{
				NumberDuck::Secret::Coordinate* __2706830545 = pTopLeft;
				pTopLeft = 0;
				{
					NumberDuck::Secret::Coordinate* __2652773404 = pBottomRight;
					pBottomRight = 0;
					pArea = new Area(__2706830545, __2652773404);
				}
			}
			{
				NumberDuck::Secret::Area* __4245081970 = pArea;
				pArea = 0;
				{
					if (pTopLeft) delete pTopLeft;
					if (pBottomRight) delete pBottomRight;
					if (pArea) delete pArea;
					return new AreaToken(__4245081970);
				}
			}
		}

		PtgAreaRecord::~PtgAreaRecord()
		{
			if (m_area) delete m_area;
		}

		PtgArea3dRecord::PtgArea3dRecord(BlobView* pBlobView) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_type = 0;
			m_reserved = 0;
			m_ixti = 0;
			m_area = 0;
			nbAssert::Assert((ParsedExpressionRecord::Type)(m_eType) == ParsedExpressionRecord::Type::TYPE_PtgArea3d);
			SetDefaults();
			BlobRead(pBlobView);
		}

		void PtgArea3dRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_ptg = (unsigned char)((nBitmask0 >> 0) & 0x1f);
			m_type = (unsigned char)((nBitmask0 >> 5) & 0x3);
			m_reserved = (unsigned char)((nBitmask0 >> 7) & 0x1);
			m_ixti = pBlobView->UnpackUint16();
			m_area->BlobRead(pBlobView);
		}

		void PtgArea3dRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_ptg << 0;
			nBitmask0 += m_type << 5;
			nBitmask0 += m_reserved << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
			pBlobView->PackUint16(m_ixti);
			m_area->BlobWrite(pBlobView);
		}

		void PtgArea3dRecord::SetDefaults()
		{
			m_ptg = 0x1B;
			m_type = 0x1;
			m_reserved = 0;
			m_ixti = 0;
			m_area = new RgceAreaStruct();
		}

		PtgArea3dRecord::PtgArea3dRecord(Area3d* pArea3d, WorkbookGlobals* pWorkbookGlobals) : ParsedExpressionRecord(TYPE, SIZE, true)
		{
			m_ptg = 0;
			m_type = 0;
			m_reserved = 0;
			m_ixti = 0;
			m_area = 0;
			SetDefaults();
			Area* pArea = pArea3d->m_pArea;
			m_area->m_columnFirst->m_col = pArea->m_pTopLeft->m_nX;
			if (pArea->m_pTopLeft->m_bXRelative)
				m_area->m_columnFirst->m_colRelative = 0x1;
			m_area->m_rowFirst->m_rw = pArea->m_pTopLeft->m_nY;
			if (pArea->m_pTopLeft->m_bYRelative)
				m_area->m_columnFirst->m_rowRelative = 0x1;
			m_area->m_columnLast->m_col = pArea->m_pBottomRight->m_nX;
			if (pArea->m_pTopLeft->m_bXRelative)
				m_area->m_columnLast->m_colRelative = 0x1;
			m_area->m_rowLast->m_rw = pArea->m_pBottomRight->m_nY;
			if (pArea->m_pTopLeft->m_bYRelative)
				m_area->m_columnLast->m_rowRelative = 0x1;
			m_ixti = pWorkbookGlobals->GetWorksheetRangeIndex(pArea3d->m_pWorksheetRange->m_nFirst, pArea3d->m_pWorksheetRange->m_nLast);
		}

		Token* PtgArea3dRecord::GetToken(WorkbookGlobals* pWorkbookGlobals)
		{
			WorksheetRange* pWorksheetRange = pWorkbookGlobals->GetWorksheetRangeByIndex(m_ixti);
			Coordinate* pTopLeft = new Coordinate(m_area->m_columnFirst->m_col, m_area->m_rowFirst->m_rw, m_area->m_columnFirst->m_colRelative == 0x1, m_area->m_columnFirst->m_rowRelative == 0x1);
			Coordinate* pBottomRight = new Coordinate(m_area->m_columnLast->m_col, m_area->m_rowLast->m_rw, m_area->m_columnLast->m_colRelative == 0x1, m_area->m_columnLast->m_rowRelative == 0x1);
			Area* pArea = 0;
			{
				NumberDuck::Secret::Coordinate* __2706830545 = pTopLeft;
				pTopLeft = 0;
				{
					NumberDuck::Secret::Coordinate* __2652773404 = pBottomRight;
					pBottomRight = 0;
					pArea = new Area(__2706830545, __2652773404);
				}
			}
			Area3d* pArea3d = 0;
			{
				NumberDuck::Secret::Area* __4245081970 = pArea;
				pArea = 0;
				pArea3d = new Area3d(pWorksheetRange->m_nFirst, pWorksheetRange->m_nLast, __4245081970);
			}
			{
				NumberDuck::Secret::Area3d* __2738670685 = pArea3d;
				pArea3d = 0;
				{
					if (pTopLeft) delete pTopLeft;
					if (pBottomRight) delete pBottomRight;
					if (pArea) delete pArea;
					if (pArea3d) delete pArea3d;
					return new Area3dToken(__2738670685);
				}
			}
		}

		PtgArea3dRecord::~PtgArea3dRecord()
		{
			if (m_area) delete m_area;
		}

		void Hsl::ToColor(Color* pColor)
		{
			double fR = 0.0;
			double fG = 0.0;
			double fB = 0.0;
			if (m_fS == 0.0)
			{
				fR = m_fL;
				fG = m_fL;
				fB = m_fL;
			}
			else
			{
				double q = m_fL < 0.5 ? m_fL * (1.0 + m_fS) : m_fL + m_fS - m_fL * m_fS;
				double p = 2 * m_fL - q;
				fR = hue2rgb(p, q, m_fH + 1 / 3.0);
				fG = hue2rgb(p, q, m_fH);
				fB = hue2rgb(p, q, m_fH - 1 / 3.0);
			}
			pColor->Set((unsigned char)(fR * 255.0 + 0.5), (unsigned char)(fG * 255.0 + 0.5), (unsigned char)(fB * 255.0 + 0.5));
		}

		void Hsl::Set(const Color* pColor)
		{
			double fR = pColor->GetRed() / 255.0;
			double fG = pColor->GetGreen() / 255.0;
			double fB = pColor->GetBlue() / 255.0;
			double fMin = haxmin(fR, haxmin(fG, fB));
			double fMax = haxmax(fR, haxmax(fG, fB));
			m_fH = (fMin + fMax) / 2.0;
			m_fS = m_fH;
			m_fL = m_fH;
			if (fMin == fMax)
			{
				m_fH = 0.0;
				m_fS = 0.0;
			}
			else
			{
				double fDiff = fMax - fMin;
				m_fS = m_fL > 0.5 ? fDiff / (2.0 - fMax - fMin) : fDiff / (fMax + fMin);
				if (fMax == fR)
					m_fH = (fG - fB) / fDiff + (fG < fB ? 6 : 0);
				else if (fMax == fG)
					m_fH = (fB - fR) / fDiff + 2;
				else
					m_fH = (fR - fG) / fDiff + 4;
				m_fH = m_fH / 6.0;
			}
		}

		double Hsl::haxmax(double a, double b)
		{
			return a > b ? a : b;
		}

		double Hsl::haxmin(double a, double b)
		{
			return a < b ? a : b;
		}

		double Hsl::hue2rgb(double p, double q, double t)
		{
			if (t < 0.0)
				t += 1.0;
			if (t > 1.0)
				t -= 1.0;
			if (t < 1.0 / 6.0)
				return p + (q - p) * 6.0 * t;
			if (t < 1.0 / 2.0)
				return q;
			if (t < 2.0 / 3.0)
				return p + (q - p) * (2.0 / 3.0 - t) * 6.0;
			return p;
		}

		Hsl::Hsl()
		{
			m_fH = 0;
			m_fS = 0;
			m_fL = 0;
		}

		XFExt::XFExt(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_frtHeader = 0;
			m_reserved1 = 0;
			m_ixfe = 0;
			m_reserved2 = 0;
			m_cexts = 0;
			m_pTempColor = 0;
			m_pExtPropVector = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_XF_EXT);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void XFExt::BlobRead(BlobView* pBlobView)
		{
			m_frtHeader->BlobRead(pBlobView);
			m_reserved1 = pBlobView->UnpackUint16();
			m_ixfe = pBlobView->UnpackUint16();
			m_reserved2 = pBlobView->UnpackUint16();
			m_cexts = pBlobView->UnpackUint16();
			PostBlobRead(pBlobView);
		}

		void XFExt::BlobWrite(BlobView* pBlobView)
		{
			m_frtHeader->BlobWrite(pBlobView);
			pBlobView->PackUint16(m_reserved1);
			pBlobView->PackUint16(m_ixfe);
			pBlobView->PackUint16(m_reserved2);
			pBlobView->PackUint16(m_cexts);
			PostBlobWrite(pBlobView);
		}

		void XFExt::SetDefaults()
		{
			m_frtHeader = new FrtHeaderStruct();
			m_reserved1 = 0;
			m_ixfe = 0;
			m_reserved2 = 0;
			m_cexts = 0;
			PostSetDefaults();
		}

		XFExt::XFExt(unsigned short nXFIndex, const Color* pForegroundColor, const Color* pBackgroundColor, const Color* pTextColor) : BiffRecord(TYPE, SIZE + 3 * (ExtPropStruct::SIZE + FullColorExtStruct::SIZE))
		{
			m_frtHeader = 0;
			m_reserved1 = 0;
			m_ixfe = 0;
			m_reserved2 = 0;
			m_cexts = 0;
			m_pTempColor = 0;
			m_pExtPropVector = 0;
			SetDefaults();
			m_frtHeader->m_rt = (unsigned short)(BiffRecord::Type::TYPE_XF_EXT);
			m_ixfe = nXFIndex;
			m_cexts = 3;
			m_pExtPropVector = new OwnedVector<ExtPropStruct*>();
			{
				ExtPropStruct* pExtProp = new ExtPropStruct();
				pExtProp->m_extType = 0x000D;
				pExtProp->m_pFullColorExt = new FullColorExtStruct();
				pExtProp->m_pFullColorExt->m_xclrType = (unsigned short)(BiffStruct::XColorType::XCLRAUTO);
				if (pTextColor != 0)
				{
					pExtProp->m_pFullColorExt->m_xclrType = (unsigned short)(BiffStruct::XColorType::XCLRRGB);
					pExtProp->m_pFullColorExt->m_xclrValue = pTextColor->GetRgba();
				}
				pExtProp->m_pFullColorExt->m_unusedA = 95;
				pExtProp->m_pFullColorExt->m_unusedB = 45;
				pExtProp->m_pFullColorExt->m_unusedC = 59;
				pExtProp->m_pFullColorExt->m_unusedD = 95;
				pExtProp->m_pFullColorExt->m_unusedE = 45;
				pExtProp->m_pFullColorExt->m_unusedF = 42;
				pExtProp->m_pFullColorExt->m_unusedG = 32;
				pExtProp->m_pFullColorExt->m_unusedH = 34;
				{
					NumberDuck::Secret::ExtPropStruct* __1075823487 = pExtProp;
					pExtProp = 0;
					m_pExtPropVector->PushBack(__1075823487);
				}
				if (pExtProp) delete pExtProp;
			}
			{
				ExtPropStruct* pExtProp = new ExtPropStruct();
				pExtProp->m_extType = 0x0004;
				pExtProp->m_pFullColorExt = new FullColorExtStruct();
				pExtProp->m_pFullColorExt->m_xclrType = (unsigned short)(BiffStruct::XColorType::XCLRAUTO);
				if (pForegroundColor != 0)
				{
					pExtProp->m_pFullColorExt->m_xclrType = (unsigned short)(BiffStruct::XColorType::XCLRRGB);
					pExtProp->m_pFullColorExt->m_xclrValue = pForegroundColor->GetRgba();
				}
				pExtProp->m_pFullColorExt->m_unusedA = 45;
				pExtProp->m_pFullColorExt->m_unusedB = 64;
				pExtProp->m_pFullColorExt->m_unusedC = 95;
				pExtProp->m_pFullColorExt->m_unusedD = 8;
				pExtProp->m_pFullColorExt->m_unusedE = 0;
				pExtProp->m_pFullColorExt->m_unusedF = 20;
				pExtProp->m_pFullColorExt->m_unusedG = 0;
				pExtProp->m_pFullColorExt->m_unusedH = 2;
				{
					NumberDuck::Secret::ExtPropStruct* __1075823487 = pExtProp;
					pExtProp = 0;
					m_pExtPropVector->PushBack(__1075823487);
				}
				if (pExtProp) delete pExtProp;
			}
			{
				ExtPropStruct* pExtProp = new ExtPropStruct();
				pExtProp->m_extType = 0x0005;
				pExtProp->m_pFullColorExt = new FullColorExtStruct();
				pExtProp->m_pFullColorExt->m_xclrType = (unsigned short)(BiffStruct::XColorType::XCLRAUTO);
				if (pBackgroundColor != 0)
				{
					pExtProp->m_pFullColorExt->m_xclrType = (unsigned short)(BiffStruct::XColorType::XCLRRGB);
					pExtProp->m_pFullColorExt->m_xclrValue = pBackgroundColor->GetRgba();
				}
				pExtProp->m_pFullColorExt->m_unusedA = 32;
				pExtProp->m_pFullColorExt->m_unusedB = 32;
				pExtProp->m_pFullColorExt->m_unusedC = 32;
				pExtProp->m_pFullColorExt->m_unusedD = 32;
				pExtProp->m_pFullColorExt->m_unusedE = 32;
				pExtProp->m_pFullColorExt->m_unusedF = 32;
				pExtProp->m_pFullColorExt->m_unusedG = 32;
				pExtProp->m_pFullColorExt->m_unusedH = 32;
				{
					NumberDuck::Secret::ExtPropStruct* __1075823487 = pExtProp;
					pExtProp = 0;
					m_pExtPropVector->PushBack(__1075823487);
				}
				if (pExtProp) delete pExtProp;
			}
		}

		void XFExt::PostSetDefaults()
		{
			m_pTempColor = new Color(0, 0, 0);
			m_pExtPropVector = 0;
		}

		void XFExt::PostBlobRead(BlobView* pBlobView)
		{
			unsigned short i;
			nbAssert::Assert(m_pExtPropVector == 0);
			m_pExtPropVector = new OwnedVector<ExtPropStruct*>();
			for (i = 0; i < m_cexts; i++)
			{
				ExtPropStruct* pExtProp = new ExtPropStruct();
				pExtProp->BlobRead(pBlobView);
				{
					NumberDuck::Secret::ExtPropStruct* __1075823487 = pExtProp;
					pExtProp = 0;
					m_pExtPropVector->PushBack(__1075823487);
				}
				if (pExtProp) delete pExtProp;
			}
		}

		void XFExt::PostBlobWrite(BlobView* pBlobView)
		{
			nbAssert::Assert(m_cexts == m_pExtPropVector->GetSize());
			int i;
			for (i = 0; i < m_pExtPropVector->GetSize(); i++)
			{
				ExtPropStruct* pExtProp = m_pExtPropVector->Get(i);
				pExtProp->BlobWrite(pBlobView);
			}
		}

		unsigned short XFExt::GetXFIndex()
		{
			return m_ixfe;
		}

		const Color* XFExt::GetForegroundColor(Theme* pTheme)
		{
			return GetColorByType(0x0004, pTheme);
		}

		const Color* XFExt::GetTextColor(Theme* pTheme)
		{
			return GetColorByType(0x000D, pTheme);
		}

		ExtPropStruct* XFExt::GetExtPropByType(unsigned short nType)
		{
			int i;
			for (i = 0; i < m_pExtPropVector->GetSize(); i++)
			{
				ExtPropStruct* pExtProp = m_pExtPropVector->Get(i);
				if (pExtProp->m_extType == nType)
					return pExtProp;
			}
			return 0;
		}

		const Color* XFExt::GetColorByType(unsigned short nType, Theme* pTheme)
		{
			ExtPropStruct* pExtProp = GetExtPropByType(nType);
			if (pExtProp != 0)
			{
				switch ((BiffStruct::XColorType)(pExtProp->m_pFullColorExt->m_xclrType))
				{
					case BiffStruct::XColorType::XCLRINDEXED:
					{
						break;
					}

					case BiffStruct::XColorType::XCLRRGB:
					{
						unsigned int nColor = pExtProp->m_pFullColorExt->m_xclrValue;
						m_pTempColor->Set((unsigned char)(nColor & 0xFF), (unsigned char)((nColor >> 8) & 0xFF), (unsigned char)((nColor >> 16) & 0xFF));
						return m_pTempColor;
					}

					case BiffStruct::XColorType::XCLRTHEMED:
					{
						nbAssert::Assert(pTheme != 0);
						unsigned int nColor = pTheme->GetColorByIndex((int)(pExtProp->m_pFullColorExt->m_xclrValue));
						unsigned int nR = (nColor >> 16) & 0xFF;
						unsigned int nG = (nColor >> 8) & 0xFF;
						unsigned int nB = nColor & 0xFF;
						{
							m_pTempColor->Set((unsigned char)(nR), (unsigned char)(nG), (unsigned char)(nB));
							Hsl* pHsl = new Hsl();
							pHsl->Set(m_pTempColor);
							double fTint = pExtProp->m_pFullColorExt->m_nTintShade / 32767.0;
							if (fTint < 0)
								pHsl->m_fL = pHsl->m_fL * (1.0 + fTint);
							if (fTint > 0)
								pHsl->m_fL = pHsl->m_fL * (1.0 - fTint) + (1.0 - 1.0 * (1.0 - fTint));
							pHsl->ToColor(m_pTempColor);
							if (pHsl) delete pHsl;
						}
						return m_pTempColor;
					}

				}
			}
			return 0;
		}

		XFExt::~XFExt()
		{
			if (m_frtHeader) delete m_frtHeader;
			if (m_pTempColor) delete m_pTempColor;
			if (m_pExtPropVector) delete m_pExtPropVector;
		}

		XFCRC::XFCRC(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_frtHeader = 0;
			m_reserved = 0;
			m_cxfs = 0;
			m_crc = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_XF_CRC);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void XFCRC::BlobRead(BlobView* pBlobView)
		{
			m_frtHeader->BlobRead(pBlobView);
			m_reserved = pBlobView->UnpackUint16();
			m_cxfs = pBlobView->UnpackUint16();
			m_crc = pBlobView->UnpackUint32();
		}

		void XFCRC::BlobWrite(BlobView* pBlobView)
		{
			m_frtHeader->BlobWrite(pBlobView);
			pBlobView->PackUint16(m_reserved);
			pBlobView->PackUint16(m_cxfs);
			pBlobView->PackUint32(m_crc);
		}

		void XFCRC::SetDefaults()
		{
			m_frtHeader = new FrtHeaderStruct();
			m_reserved = 0;
			m_cxfs = 0;
			m_crc = 0;
		}

		XFCRC::XFCRC(OwnedVector<XF*>* pXFVector) : BiffRecord(TYPE, SIZE)
		{
			m_frtHeader = 0;
			m_reserved = 0;
			m_cxfs = 0;
			m_crc = 0;
			SetDefaults();
			m_frtHeader->m_rt = (unsigned short)(BiffRecord::Type::TYPE_XF_CRC);
			m_reserved = 0;
			m_cxfs = (unsigned short)(pXFVector->GetSize());
			m_crc = ComputateCrc(pXFVector);
		}

		bool XFCRC::ValidateCrc(Vector<XF*>* pXFVector)
		{
			if (m_cxfs == pXFVector->GetSize())
			{
				return ComputateCrc(pXFVector) == m_crc;
			}
			return false;
		}

		unsigned int XFCRC::ComputateCrc(OwnedVector<XF*>* pXFVector)
		{
			Blob* pBlob = new Blob(true);
			BlobView* pBlobView = pBlob->GetBlobView();
			unsigned int nCrcValue = 0;
			for (int i = 0; i < pXFVector->GetSize(); i++)
				pXFVector->Get(i)->BlobWrite(pBlobView);
			pBlobView->SetOffset(0);
			while (pBlobView->GetOffset() < pBlobView->GetSize())
			{
				unsigned int nTemp = pBlobView->UnpackUint8();
				nCrcValue = nCrcValue ^ (nTemp << 24);
				for (int k = 0; k < 8; k++)
				{
					if ((nCrcValue & 0x80000000) > 0)
						nCrcValue = (nCrcValue << 1) ^ 0xAF;
					else
						nCrcValue = nCrcValue << 1;
				}
			}
			{
				if (pBlob) delete pBlob;
				return nCrcValue;
			}
		}

		unsigned int XFCRC::ComputateCrc(Vector<XF*>* pXFVector)
		{
			Blob* pBlob = new Blob(true);
			BlobView* pBlobView = pBlob->GetBlobView();
			unsigned int nCrcValue = 0;
			for (int i = 0; i < pXFVector->GetSize(); i++)
				pXFVector->Get(i)->BlobWrite(pBlobView);
			pBlobView->SetOffset(0);
			while (pBlobView->GetOffset() < pBlobView->GetSize())
			{
				unsigned int nTemp = pBlobView->UnpackUint8();
				nCrcValue = nCrcValue ^ (nTemp << 24);
				for (int k = 0; k < 8; k++)
				{
					if ((nCrcValue & 0x80000000) > 0)
						nCrcValue = (nCrcValue << 1) ^ 0xAF;
					else
						nCrcValue = nCrcValue << 1;
				}
			}
			{
				if (pBlob) delete pBlob;
				return nCrcValue;
			}
		}

		XFCRC::~XFCRC()
		{
			if (m_frtHeader) delete m_frtHeader;
		}

		XF::XF(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_ifnt = 0;
			m_ifmt = 0;
			m_fLocked = 0;
			m_fHidden = 0;
			m_fStyle = 0;
			m_f123Prefix = 0;
			m_ixfParent = 0;
			m_alc = 0;
			m_fWrap = 0;
			m_alcV = 0;
			m_fJustLast = 0;
			m_trot = 0;
			m_cIndent = 0;
			m_fShrinkToFit = 0;
			m_reserved1 = 0;
			m_iReadOrder = 0;
			m_reserved2 = 0;
			m_fAtrNum = 0;
			m_fAtrFnt = 0;
			m_fAtrAlc = 0;
			m_fAtrBdr = 0;
			m_fAtrPat = 0;
			m_fAtrProt = 0;
			m_dgLeft = 0;
			m_dgRight = 0;
			m_dgTop = 0;
			m_dgBottom = 0;
			m_icvLeft = 0;
			m_icvRight = 0;
			m_grbitDiag = 0;
			m_icvTop = 0;
			m_icvBottom = 0;
			m_icvDiag = 0;
			m_dgDiag = 0;
			m_fHasXFExt = 0;
			m_fls = 0;
			m_icvFore = 0;
			m_icvBack = 0;
			m_fsxButton = 0;
			m_reserved3 = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_XF);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void XF::BlobRead(BlobView* pBlobView)
		{
			m_ifnt = pBlobView->UnpackUint16();
			m_ifmt = pBlobView->UnpackUint16();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fLocked = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fHidden = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fStyle = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_f123Prefix = (unsigned short)((nBitmask0 >> 3) & 0x1);
			m_ixfParent = (unsigned short)((nBitmask0 >> 4) & 0xfff);
			unsigned char nBitmask1 = pBlobView->UnpackUint8();
			m_alc = (unsigned char)((nBitmask1 >> 0) & 0x7);
			m_fWrap = (unsigned char)((nBitmask1 >> 3) & 0x1);
			m_alcV = (unsigned char)((nBitmask1 >> 4) & 0x7);
			m_fJustLast = (unsigned char)((nBitmask1 >> 7) & 0x1);
			m_trot = pBlobView->UnpackUint8();
			unsigned char nBitmask2 = pBlobView->UnpackUint8();
			m_cIndent = (unsigned char)((nBitmask2 >> 0) & 0xf);
			m_fShrinkToFit = (unsigned char)((nBitmask2 >> 4) & 0x1);
			m_reserved1 = (unsigned char)((nBitmask2 >> 5) & 0x1);
			m_iReadOrder = (unsigned char)((nBitmask2 >> 6) & 0x3);
			unsigned char nBitmask3 = pBlobView->UnpackUint8();
			m_reserved2 = (unsigned char)((nBitmask3 >> 0) & 0x3);
			m_fAtrNum = (unsigned char)((nBitmask3 >> 2) & 0x1);
			m_fAtrFnt = (unsigned char)((nBitmask3 >> 3) & 0x1);
			m_fAtrAlc = (unsigned char)((nBitmask3 >> 4) & 0x1);
			m_fAtrBdr = (unsigned char)((nBitmask3 >> 5) & 0x1);
			m_fAtrPat = (unsigned char)((nBitmask3 >> 6) & 0x1);
			m_fAtrProt = (unsigned char)((nBitmask3 >> 7) & 0x1);
			unsigned int nBitmask4 = pBlobView->UnpackUint32();
			m_dgLeft = (unsigned int)((nBitmask4 >> 0) & 0xf);
			m_dgRight = (unsigned int)((nBitmask4 >> 4) & 0xf);
			m_dgTop = (unsigned int)((nBitmask4 >> 8) & 0xf);
			m_dgBottom = (unsigned int)((nBitmask4 >> 12) & 0xf);
			m_icvLeft = (unsigned int)((nBitmask4 >> 16) & 0x7f);
			m_icvRight = (unsigned int)((nBitmask4 >> 23) & 0x7f);
			m_grbitDiag = (unsigned int)((nBitmask4 >> 30) & 0x3);
			unsigned int nBitmask5 = pBlobView->UnpackUint32();
			m_icvTop = (unsigned int)((nBitmask5 >> 0) & 0x7f);
			m_icvBottom = (unsigned int)((nBitmask5 >> 7) & 0x7f);
			m_icvDiag = (unsigned int)((nBitmask5 >> 14) & 0x7f);
			m_dgDiag = (unsigned int)((nBitmask5 >> 21) & 0xf);
			m_fHasXFExt = (unsigned int)((nBitmask5 >> 25) & 0x1);
			m_fls = (unsigned int)((nBitmask5 >> 26) & 0x3f);
			unsigned short nBitmask6 = pBlobView->UnpackUint16();
			m_icvFore = (unsigned short)((nBitmask6 >> 0) & 0x7f);
			m_icvBack = (unsigned short)((nBitmask6 >> 7) & 0x7f);
			m_fsxButton = (unsigned short)((nBitmask6 >> 14) & 0x1);
			m_reserved3 = (unsigned short)((nBitmask6 >> 15) & 0x1);
		}

		void XF::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_ifnt);
			pBlobView->PackUint16(m_ifmt);
			int nBitmask0 = 0;
			nBitmask0 += m_fLocked << 0;
			nBitmask0 += m_fHidden << 1;
			nBitmask0 += m_fStyle << 2;
			nBitmask0 += m_f123Prefix << 3;
			nBitmask0 += m_ixfParent << 4;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			int nBitmask1 = 0;
			nBitmask1 += m_alc << 0;
			nBitmask1 += m_fWrap << 3;
			nBitmask1 += m_alcV << 4;
			nBitmask1 += m_fJustLast << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask1));
			pBlobView->PackUint8(m_trot);
			int nBitmask2 = 0;
			nBitmask2 += m_cIndent << 0;
			nBitmask2 += m_fShrinkToFit << 4;
			nBitmask2 += m_reserved1 << 5;
			nBitmask2 += m_iReadOrder << 6;
			pBlobView->PackUint8((unsigned char)(nBitmask2));
			int nBitmask3 = 0;
			nBitmask3 += m_reserved2 << 0;
			nBitmask3 += m_fAtrNum << 2;
			nBitmask3 += m_fAtrFnt << 3;
			nBitmask3 += m_fAtrAlc << 4;
			nBitmask3 += m_fAtrBdr << 5;
			nBitmask3 += m_fAtrPat << 6;
			nBitmask3 += m_fAtrProt << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask3));
			unsigned int nBitmask4 = 0;
			nBitmask4 += m_dgLeft << 0;
			nBitmask4 += m_dgRight << 4;
			nBitmask4 += m_dgTop << 8;
			nBitmask4 += m_dgBottom << 12;
			nBitmask4 += m_icvLeft << 16;
			nBitmask4 += m_icvRight << 23;
			nBitmask4 += m_grbitDiag << 30;
			pBlobView->PackUint32((unsigned int)(nBitmask4));
			unsigned int nBitmask5 = 0;
			nBitmask5 += m_icvTop << 0;
			nBitmask5 += m_icvBottom << 7;
			nBitmask5 += m_icvDiag << 14;
			nBitmask5 += m_dgDiag << 21;
			nBitmask5 += m_fHasXFExt << 25;
			nBitmask5 += m_fls << 26;
			pBlobView->PackUint32((unsigned int)(nBitmask5));
			int nBitmask6 = 0;
			nBitmask6 += m_icvFore << 0;
			nBitmask6 += m_icvBack << 7;
			nBitmask6 += m_fsxButton << 14;
			nBitmask6 += m_reserved3 << 15;
			pBlobView->PackUint16((unsigned short)(nBitmask6));
		}

		void XF::SetDefaults()
		{
			m_ifnt = 0;
			m_ifmt = 0;
			m_fLocked = 0;
			m_fHidden = 0;
			m_fStyle = 0;
			m_f123Prefix = 0;
			m_ixfParent = 0;
			m_alc = 0;
			m_fWrap = 0;
			m_alcV = 0;
			m_fJustLast = 0;
			m_trot = 0;
			m_cIndent = 0;
			m_fShrinkToFit = 0;
			m_reserved1 = 0;
			m_iReadOrder = 0;
			m_reserved2 = 0;
			m_fAtrNum = 0;
			m_fAtrFnt = 0;
			m_fAtrAlc = 0;
			m_fAtrBdr = 0;
			m_fAtrPat = 0;
			m_fAtrProt = 0;
			m_dgLeft = 0;
			m_dgRight = 0;
			m_dgTop = 0;
			m_dgBottom = 0;
			m_icvLeft = 0;
			m_icvRight = 0;
			m_grbitDiag = 0;
			m_icvTop = 0;
			m_icvBottom = 0;
			m_icvDiag = 0;
			m_dgDiag = 0;
			m_fHasXFExt = 0;
			m_fls = 0;
			m_icvFore = 0;
			m_icvBack = 0;
			m_fsxButton = 0;
			m_reserved3 = 0;
		}

		XF::XF(unsigned short ifnt, unsigned short ifmt, unsigned char fStyle, unsigned short ixfParent, unsigned char fAtrNum, unsigned char fAtrFnt, unsigned char fAtrAlc, unsigned char fAtrBdr, unsigned char fAtrPat, unsigned char fAtrProt, unsigned char dgLeft, unsigned char dgRight, unsigned char dgTop, unsigned char dgBottom, unsigned char icvLeft, unsigned char icvRight, unsigned char icvTop, unsigned char icvBottom, unsigned char fHasXFExt, unsigned char fls, unsigned char icvFore, unsigned char icvBack) : BiffRecord(TYPE, SIZE)
		{
			m_ifnt = 0;
			m_ifmt = 0;
			m_fLocked = 0;
			m_fHidden = 0;
			m_fStyle = 0;
			m_f123Prefix = 0;
			m_ixfParent = 0;
			m_alc = 0;
			m_fWrap = 0;
			m_alcV = 0;
			m_fJustLast = 0;
			m_trot = 0;
			m_cIndent = 0;
			m_fShrinkToFit = 0;
			m_reserved1 = 0;
			m_iReadOrder = 0;
			m_reserved2 = 0;
			m_fAtrNum = 0;
			m_fAtrFnt = 0;
			m_fAtrAlc = 0;
			m_fAtrBdr = 0;
			m_fAtrPat = 0;
			m_fAtrProt = 0;
			m_dgLeft = 0;
			m_dgRight = 0;
			m_dgTop = 0;
			m_dgBottom = 0;
			m_icvLeft = 0;
			m_icvRight = 0;
			m_grbitDiag = 0;
			m_icvTop = 0;
			m_icvBottom = 0;
			m_icvDiag = 0;
			m_dgDiag = 0;
			m_fHasXFExt = 0;
			m_fls = 0;
			m_icvFore = 0;
			m_icvBack = 0;
			m_fsxButton = 0;
			m_reserved3 = 0;
			SetDefaults();
			m_ifnt = ifnt;
			m_ifmt = ifmt;
			m_fLocked = 0x1;
			m_fStyle = (unsigned short)(fStyle & 0x1);
			m_ixfParent = (unsigned short)(ixfParent & 0xFFF);
			m_alcV = 2;
			m_fJustLast = 0;
			m_fAtrNum = (unsigned char)(fAtrNum & 0x1);
			m_fAtrFnt = (unsigned char)(fAtrFnt & 0x1);
			m_fAtrAlc = (unsigned char)(fAtrAlc & 0x1);
			m_fAtrBdr = (unsigned char)(fAtrBdr & 0x1);
			m_fAtrPat = (unsigned char)(fAtrPat & 0x1);
			m_fAtrProt = (unsigned char)(fAtrProt & 0x1);
			m_dgLeft = (unsigned int)(dgLeft & 0xF);
			m_dgRight = (unsigned int)(dgRight & 0xF);
			m_dgTop = (unsigned int)(dgTop & 0xF);
			m_dgBottom = (unsigned int)(dgBottom & 0xF);
			m_icvLeft = (unsigned int)(icvLeft & 0x7F);
			m_icvRight = (unsigned int)(icvRight & 0x7F);
			m_icvTop = (unsigned int)(icvTop & 0x7F);
			m_icvBottom = (unsigned int)(icvBottom & 0x7F);
			m_fHasXFExt = (unsigned int)(fHasXFExt & 0x1);
			m_fls = (unsigned int)(fls & 0x3F);
			m_icvFore = (unsigned short)(icvFore & 0x7F);
			m_icvBack = (unsigned short)(icvBack & 0x7F);
		}

		XF::XF(unsigned short nFontIndex, unsigned short nFormatIndex, Style* pStyle, bool bHasXFExt) : BiffRecord(TYPE, SIZE)
		{
			m_ifnt = 0;
			m_ifmt = 0;
			m_fLocked = 0;
			m_fHidden = 0;
			m_fStyle = 0;
			m_f123Prefix = 0;
			m_ixfParent = 0;
			m_alc = 0;
			m_fWrap = 0;
			m_alcV = 0;
			m_fJustLast = 0;
			m_trot = 0;
			m_cIndent = 0;
			m_fShrinkToFit = 0;
			m_reserved1 = 0;
			m_iReadOrder = 0;
			m_reserved2 = 0;
			m_fAtrNum = 0;
			m_fAtrFnt = 0;
			m_fAtrAlc = 0;
			m_fAtrBdr = 0;
			m_fAtrPat = 0;
			m_fAtrProt = 0;
			m_dgLeft = 0;
			m_dgRight = 0;
			m_dgTop = 0;
			m_dgBottom = 0;
			m_icvLeft = 0;
			m_icvRight = 0;
			m_grbitDiag = 0;
			m_icvTop = 0;
			m_icvBottom = 0;
			m_icvDiag = 0;
			m_dgDiag = 0;
			m_fHasXFExt = 0;
			m_fls = 0;
			m_icvFore = 0;
			m_icvBack = 0;
			m_fsxButton = 0;
			m_reserved3 = 0;
			SetDefaults();
			if (nFontIndex >= 4)
				nFontIndex++;
			m_ifnt = nFontIndex;
			m_ifmt = nFormatIndex;
			unsigned char nBackgroundColourIndex = BiffWorkbookGlobals::SnapToPalette(pStyle->GetBackgroundColor(false));
			if (nBackgroundColourIndex == BiffWorkbookGlobals::PALETTE_INDEX_DEFAULT)
				nBackgroundColourIndex = BiffWorkbookGlobals::PALETTE_INDEX_DEFAULT_FOREGROUND;
			unsigned char nFillPatternColourIndex = BiffWorkbookGlobals::SnapToPalette(pStyle->GetFillPatternColor(false));
			if (nFillPatternColourIndex == BiffWorkbookGlobals::PALETTE_INDEX_DEFAULT)
				nFillPatternColourIndex = BiffWorkbookGlobals::PALETTE_INDEX_DEFAULT_BACKGROUND;
			unsigned char nTopBorderType = LineTypeToBorderStyle(pStyle->GetTopBorderLine()->GetType());
			unsigned short nTopBorderPaletteIndex = BiffWorkbookGlobals::SnapToPalette(pStyle->GetTopBorderLine()->GetColor());
			unsigned char nRightBorderType = LineTypeToBorderStyle(pStyle->GetRightBorderLine()->GetType());
			unsigned short nRightBorderPaletteIndex = BiffWorkbookGlobals::SnapToPalette(pStyle->GetRightBorderLine()->GetColor());
			unsigned char nBottomBorderType = LineTypeToBorderStyle(pStyle->GetBottomBorderLine()->GetType());
			unsigned short nBottomBorderPaletteIndex = BiffWorkbookGlobals::SnapToPalette(pStyle->GetBottomBorderLine()->GetColor());
			unsigned char nLeftBorderType = LineTypeToBorderStyle(pStyle->GetLeftBorderLine()->GetType());
			unsigned short nLeftBorderPaletteIndex = BiffWorkbookGlobals::SnapToPalette(pStyle->GetLeftBorderLine()->GetColor());
			unsigned char nHorizontalAlign = (unsigned char)(pStyle->GetHorizontalAlign());
			unsigned char nVerticalAlign = (unsigned char)(pStyle->GetVerticalAlign());
			m_fLocked = 0x1;
			unsigned short fls = 0x00;
			switch (pStyle->GetFillPattern())
			{
				case Style::FillPattern::FILL_PATTERN_NONE:
				{
					if (nBackgroundColourIndex == BiffWorkbookGlobals::PALETTE_INDEX_DEFAULT_FOREGROUND)
						fls = 0x00;
					else
						fls = 0x01;
					break;
				}

				case Style::FillPattern::FILL_PATTERN_50:
				{
					fls = 0x02;
					break;
				}

				case Style::FillPattern::FILL_PATTERN_75:
				{
					fls = 0x03;
					break;
				}

				case Style::FillPattern::FILL_PATTERN_25:
				{
					fls = 0x04;
					break;
				}

				case Style::FillPattern::FILL_PATTERN_HORIZONTAL_STRIPE:
				{
					fls = 0x05;
					break;
				}

				case Style::FillPattern::FILL_PATTERN_VARTICAL_STRIPE:
				{
					fls = 0x06;
					break;
				}

				case Style::FillPattern::FILL_PATTERN_REVERSE_DIAGONAL_STRIPE:
				{
					fls = 0x07;
					break;
				}

				case Style::FillPattern::FILL_PATTERN_DIAGONAL_STRIPE:
				{
					fls = 0x08;
					break;
				}

				case Style::FillPattern::FILL_PATTERN_DIAGONAL_CROSSHATCH:
				{
					fls = 0x09;
					break;
				}

				case Style::FillPattern::FILL_PATTERN_THICK_DIAGONAL_CROSSHATCH:
				{
					fls = 0x0A;
					break;
				}

				case Style::FillPattern::FILL_PATTERN_THIN_HORIZONTAL_STRIPE:
				{
					fls = 0x0B;
					break;
				}

				case Style::FillPattern::FILL_PATTERN_THIN_VERTICAL_STRIPE:
				{
					fls = 0x0C;
					break;
				}

				case Style::FillPattern::FILL_PATTERN_THIN_REVERSE_VERTICAL_STRIPE:
				{
					fls = 0x0D;
					break;
				}

				case Style::FillPattern::FILL_PATTERN_THIN_DIAGONAL_STRIPE:
				{
					fls = 0x0E;
					break;
				}

				case Style::FillPattern::FILL_PATTERN_THIN_HORIZONTAL_CROSSHATCH:
				{
					fls = 0x0F;
					break;
				}

				case Style::FillPattern::FILL_PATTERN_THIN_DIAGONAL_CROSSHATCH:
				{
					fls = 0x10;
					break;
				}

				case Style::FillPattern::FILL_PATTERN_125:
				{
					fls = 0x11;
					break;
				}

				case Style::FillPattern::FILL_PATTERN_625:
				{
					fls = 0x12;
					break;
				}

			}
			nbAssert::Assert(nBackgroundColourIndex >= BiffWorkbookGlobals::NUM_DEFAULT_PALETTE_ENTRY && nBackgroundColourIndex < BiffWorkbookGlobals::NUM_DEFAULT_PALETTE_ENTRY + BiffWorkbookGlobals::NUM_CUSTOM_PALETTE_ENTRY || nBackgroundColourIndex == BiffWorkbookGlobals::PALETTE_INDEX_DEFAULT_FOREGROUND);
			nbAssert::Assert(nFillPatternColourIndex >= BiffWorkbookGlobals::NUM_DEFAULT_PALETTE_ENTRY && nFillPatternColourIndex < BiffWorkbookGlobals::NUM_DEFAULT_PALETTE_ENTRY + BiffWorkbookGlobals::NUM_CUSTOM_PALETTE_ENTRY || nFillPatternColourIndex == BiffWorkbookGlobals::PALETTE_INDEX_DEFAULT_BACKGROUND);
			{
				m_fls = fls;
				m_icvFore = nBackgroundColourIndex;
				m_icvBack = nFillPatternColourIndex;
			}
			m_alc = (unsigned char)(nHorizontalAlign & 0x7);
			m_alcV = (unsigned char)(nVerticalAlign & 0x7);
			m_dgLeft = (unsigned int)(nLeftBorderType & 0xF);
			m_dgRight = (unsigned int)(nRightBorderType & 0xF);
			m_dgTop = (unsigned int)(nTopBorderType & 0xF);
			m_dgBottom = (unsigned int)(nBottomBorderType & 0xF);
			m_icvLeft = (unsigned int)(nLeftBorderPaletteIndex & 0x7F);
			m_icvRight = (unsigned int)(nRightBorderPaletteIndex & 0x7F);
			m_icvTop = (unsigned int)(nTopBorderPaletteIndex & 0x7F);
			m_icvBottom = (unsigned int)(nBottomBorderPaletteIndex & 0x7F);
			if (bHasXFExt)
				m_fHasXFExt = 0x1;
		}

		unsigned short XF::GetFontIndex()
		{
			return m_ifnt;
		}

		unsigned short XF::GetFormatIndex()
		{
			return m_ifmt;
		}

		unsigned short XF::GetBackgroundPaletteIndex()
		{
			if (m_fls > 0)
				return m_icvFore;
			return BiffWorkbookGlobals::PALETTE_INDEX_DEFAULT;
		}

		Style::FillPattern XF::GetFillPattern()
		{
			switch (m_fls)
			{
				case 0x02:
				{
					return Style::FillPattern::FILL_PATTERN_50;
				}

				case 0x03:
				{
					return Style::FillPattern::FILL_PATTERN_75;
				}

				case 0x04:
				{
					return Style::FillPattern::FILL_PATTERN_25;
				}

				case 0x05:
				{
					return Style::FillPattern::FILL_PATTERN_HORIZONTAL_STRIPE;
				}

				case 0x06:
				{
					return Style::FillPattern::FILL_PATTERN_VARTICAL_STRIPE;
				}

				case 0x07:
				{
					return Style::FillPattern::FILL_PATTERN_REVERSE_DIAGONAL_STRIPE;
				}

				case 0x08:
				{
					return Style::FillPattern::FILL_PATTERN_DIAGONAL_STRIPE;
				}

				case 0x09:
				{
					return Style::FillPattern::FILL_PATTERN_DIAGONAL_CROSSHATCH;
				}

				case 0x0A:
				{
					return Style::FillPattern::FILL_PATTERN_THICK_DIAGONAL_CROSSHATCH;
				}

				case 0x0B:
				{
					return Style::FillPattern::FILL_PATTERN_THIN_HORIZONTAL_STRIPE;
				}

				case 0x0C:
				{
					return Style::FillPattern::FILL_PATTERN_THIN_VERTICAL_STRIPE;
				}

				case 0x0D:
				{
					return Style::FillPattern::FILL_PATTERN_THIN_REVERSE_VERTICAL_STRIPE;
				}

				case 0x0E:
				{
					return Style::FillPattern::FILL_PATTERN_THIN_DIAGONAL_STRIPE;
				}

				case 0x0F:
				{
					return Style::FillPattern::FILL_PATTERN_THIN_HORIZONTAL_CROSSHATCH;
				}

				case 0x10:
				{
					return Style::FillPattern::FILL_PATTERN_THIN_DIAGONAL_CROSSHATCH;
				}

				case 0x11:
				{
					return Style::FillPattern::FILL_PATTERN_125;
				}

				case 0x12:
				{
					return Style::FillPattern::FILL_PATTERN_625;
				}

			}
			return Style::FillPattern::FILL_PATTERN_NONE;
		}

		unsigned short XF::GetForegroundPaletteIndex()
		{
			if (m_fls > 0)
				return m_icvBack;
			return BiffWorkbookGlobals::PALETTE_INDEX_DEFAULT;
		}

		unsigned char XF::GetHorizontalAlign()
		{
			return m_alc;
		}

		unsigned char XF::GetVerticalAlign()
		{
			return m_alcV;
		}

		Line::Type XF::BorderStyleToLineType(unsigned char nBorderStyle)
		{
			switch (nBorderStyle)
			{
				case 0x0000:
				{
					return Line::Type::TYPE_NONE;
				}

				case 0x0001:
				{
					return Line::Type::TYPE_THIN;
				}

				case 0x0002:
				{
					return Line::Type::TYPE_MEDIUM;
				}

				case 0x0003:
				{
					return Line::Type::TYPE_DASHED;
				}

				case 0x0004:
				{
					return Line::Type::TYPE_DOTTED;
				}

				case 0x0005:
				{
					return Line::Type::TYPE_THICK;
				}

				case 0x0006:
				{
					return Line::Type::TYPE_DOUBLE;
				}

				case 0x0007:
				{
					return Line::Type::TYPE_HAIR;
				}

				case 0x0008:
				{
					return Line::Type::TYPE_MEDIUM_DASHED;
				}

				case 0x0009:
				{
					return Line::Type::TYPE_DASH_DOT;
				}

				case 0x000A:
				{
					return Line::Type::TYPE_MEDIUM_DASH_DOT;
				}

				case 0x000B:
				{
					return Line::Type::TYPE_DASH_DOT_DOT;
				}

				case 0x000C:
				{
					return Line::Type::TYPE_MEDIUM_DASH_DOT_DOT;
				}

				case 0x000D:
				{
					return Line::Type::TYPE_SLANT_DASH_DOT_DOT;
				}

			}
			return Line::Type::TYPE_NONE;
		}

		unsigned char XF::LineTypeToBorderStyle(Line::Type eLineType)
		{
			switch (eLineType)
			{
				case Line::Type::TYPE_NONE:
				{
					return 0x0000;
				}

				case Line::Type::TYPE_THIN:
				{
					return 0x0001;
				}

				case Line::Type::TYPE_MEDIUM:
				{
					return 0x0002;
				}

				case Line::Type::TYPE_DASHED:
				{
					return 0x0003;
				}

				case Line::Type::TYPE_DOTTED:
				{
					return 0x0004;
				}

				case Line::Type::TYPE_THICK:
				{
					return 0x0005;
				}

				case Line::Type::TYPE_DOUBLE:
				{
					return 0x0006;
				}

				case Line::Type::TYPE_HAIR:
				{
					return 0x0007;
				}

				case Line::Type::TYPE_MEDIUM_DASHED:
				{
					return 0x0008;
				}

				case Line::Type::TYPE_DASH_DOT:
				{
					return 0x0009;
				}

				case Line::Type::TYPE_MEDIUM_DASH_DOT:
				{
					return 0x000A;
				}

				case Line::Type::TYPE_DASH_DOT_DOT:
				{
					return 0x000B;
				}

				case Line::Type::TYPE_MEDIUM_DASH_DOT_DOT:
				{
					return 0x000C;
				}

				case Line::Type::TYPE_SLANT_DASH_DOT_DOT:
				{
					return 0x000D;
				}

			}
			return 0x0000;
		}

		Line::Type XF::GetTopBorderType()
		{
			return BorderStyleToLineType((unsigned char)(m_dgTop));
		}

		Line::Type XF::GetRightBorderType()
		{
			return BorderStyleToLineType((unsigned char)(m_dgRight));
		}

		Line::Type XF::GetBottomBorderType()
		{
			return BorderStyleToLineType((unsigned char)(m_dgBottom));
		}

		Line::Type XF::GetLeftBorderType()
		{
			return BorderStyleToLineType((unsigned char)(m_dgLeft));
		}

		unsigned short XF::GetTopBorderPaletteIndex()
		{
			return (unsigned short)(m_icvTop);
		}

		unsigned short XF::GetRightBorderPaletteIndex()
		{
			return (unsigned short)(m_icvRight);
		}

		unsigned short XF::GetBottomBorderPaletteIndex()
		{
			return (unsigned short)(m_icvBottom);
		}

		unsigned short XF::GetLeftBorderPaletteIndex()
		{
			return (unsigned short)(m_icvLeft);
		}

		bool XF::GetHasXFExt()
		{
			return m_fHasXFExt == 0x1;
		}

		WsBoolRecord::WsBoolRecord() : BiffRecord(TYPE, SIZE)
		{
			m_haxFlags = 0;
			SetDefaults();
		}

		WsBoolRecord::WsBoolRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_haxFlags = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_WSBOOL);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void WsBoolRecord::BlobRead(BlobView* pBlobView)
		{
			m_haxFlags = pBlobView->UnpackUint16();
		}

		void WsBoolRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_haxFlags);
		}

		void WsBoolRecord::SetDefaults()
		{
			m_haxFlags = 1217;
		}

		WriteAccess::WriteAccess(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_userName = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_WRITE_ACCESS);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void WriteAccess::BlobRead(BlobView* pBlobView)
		{
			m_userName->BlobRead(pBlobView);
		}

		void WriteAccess::BlobWrite(BlobView* pBlobView)
		{
			m_userName->BlobWrite(pBlobView);
			PostBlobWrite(pBlobView);
		}

		void WriteAccess::SetDefaults()
		{
			m_userName = new XLUnicodeStringStruct();
		}

		WriteAccess::WriteAccess() : BiffRecord(TYPE, SIZE)
		{
			m_userName = 0;
			SetDefaults();
			m_userName->m_rgb->Set("Number Duck");
			m_pHeader->m_nSize = FORCE_SIZE;
		}

		void WriteAccess::PostBlobWrite(BlobView* pBlobView)
		{
			while (pBlobView->GetSize() < (int)(FORCE_SIZE))
			{
				pBlobView->PackUint8(0);
			}
		}

		WriteAccess::~WriteAccess()
		{
			if (m_userName) delete m_userName;
		}

		Window2Record::Window2Record(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_fDspFmlaRt = 0;
			m_fDspGridRt = 0;
			m_fDspRwColRt = 0;
			m_fFrozenRt = 0;
			m_fDspZerosRt = 0;
			m_fDefaultHdr = 0;
			m_fRightToLeft = 0;
			m_fDspGuts = 0;
			m_fFrozenNoSplit = 0;
			m_fSelected = 0;
			m_fPaged = 0;
			m_fSLV = 0;
			m_reserved1 = 0;
			m_rwTop = 0;
			m_colLeft = 0;
			m_icvHdr = 0;
			m_reserved2 = 0;
			m_wScaleSLV = 0;
			m_wScaleNormal = 0;
			m_unused = 0;
			m_reserved3 = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_WINDOW2);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void Window2Record::BlobRead(BlobView* pBlobView)
		{
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fDspFmlaRt = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fDspGridRt = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fDspRwColRt = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_fFrozenRt = (unsigned short)((nBitmask0 >> 3) & 0x1);
			m_fDspZerosRt = (unsigned short)((nBitmask0 >> 4) & 0x1);
			m_fDefaultHdr = (unsigned short)((nBitmask0 >> 5) & 0x1);
			m_fRightToLeft = (unsigned short)((nBitmask0 >> 6) & 0x1);
			m_fDspGuts = (unsigned short)((nBitmask0 >> 7) & 0x1);
			m_fFrozenNoSplit = (unsigned short)((nBitmask0 >> 8) & 0x1);
			m_fSelected = (unsigned short)((nBitmask0 >> 9) & 0x1);
			m_fPaged = (unsigned short)((nBitmask0 >> 10) & 0x1);
			m_fSLV = (unsigned short)((nBitmask0 >> 11) & 0x1);
			m_reserved1 = (unsigned short)((nBitmask0 >> 12) & 0xf);
			m_rwTop = pBlobView->UnpackUint16();
			m_colLeft = pBlobView->UnpackUint16();
			m_icvHdr = pBlobView->UnpackUint16();
			m_reserved2 = pBlobView->UnpackUint16();
			m_wScaleSLV = pBlobView->UnpackUint16();
			m_wScaleNormal = pBlobView->UnpackUint16();
			m_unused = pBlobView->UnpackUint16();
			m_reserved3 = pBlobView->UnpackUint16();
		}

		void Window2Record::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_fDspFmlaRt << 0;
			nBitmask0 += m_fDspGridRt << 1;
			nBitmask0 += m_fDspRwColRt << 2;
			nBitmask0 += m_fFrozenRt << 3;
			nBitmask0 += m_fDspZerosRt << 4;
			nBitmask0 += m_fDefaultHdr << 5;
			nBitmask0 += m_fRightToLeft << 6;
			nBitmask0 += m_fDspGuts << 7;
			nBitmask0 += m_fFrozenNoSplit << 8;
			nBitmask0 += m_fSelected << 9;
			nBitmask0 += m_fPaged << 10;
			nBitmask0 += m_fSLV << 11;
			nBitmask0 += m_reserved1 << 12;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			pBlobView->PackUint16(m_rwTop);
			pBlobView->PackUint16(m_colLeft);
			pBlobView->PackUint16(m_icvHdr);
			pBlobView->PackUint16(m_reserved2);
			pBlobView->PackUint16(m_wScaleSLV);
			pBlobView->PackUint16(m_wScaleNormal);
			pBlobView->PackUint16(m_unused);
			pBlobView->PackUint16(m_reserved3);
		}

		void Window2Record::SetDefaults()
		{
			m_fDspFmlaRt = 0;
			m_fDspGridRt = 0;
			m_fDspRwColRt = 1;
			m_fFrozenRt = 0;
			m_fDspZerosRt = 1;
			m_fDefaultHdr = 1;
			m_fRightToLeft = 0;
			m_fDspGuts = 1;
			m_fFrozenNoSplit = 0;
			m_fSelected = 0;
			m_fPaged = 0;
			m_fSLV = 0;
			m_reserved1 = 0;
			m_rwTop = 0;
			m_colLeft = 0;
			m_icvHdr = 64;
			m_reserved2 = 0;
			m_wScaleSLV = 0;
			m_wScaleNormal = 0;
			m_unused = 0;
			m_reserved3 = 0;
		}

		Window2Record::Window2Record(bool fSelected, bool fPaged, bool bShowGridlines) : BiffRecord(TYPE, SIZE)
		{
			m_fDspFmlaRt = 0;
			m_fDspGridRt = 0;
			m_fDspRwColRt = 0;
			m_fFrozenRt = 0;
			m_fDspZerosRt = 0;
			m_fDefaultHdr = 0;
			m_fRightToLeft = 0;
			m_fDspGuts = 0;
			m_fFrozenNoSplit = 0;
			m_fSelected = 0;
			m_fPaged = 0;
			m_fSLV = 0;
			m_reserved1 = 0;
			m_rwTop = 0;
			m_colLeft = 0;
			m_icvHdr = 0;
			m_reserved2 = 0;
			m_wScaleSLV = 0;
			m_wScaleNormal = 0;
			m_unused = 0;
			m_reserved3 = 0;
			SetDefaults();
			m_fSelected = fSelected ? (unsigned short)(0x1) : (unsigned short)(0x0);
			m_fPaged = fPaged ? (unsigned short)(0x1) : (unsigned short)(0x0);
			m_fDspGridRt = bShowGridlines ? (unsigned short)(0x1) : (unsigned short)(0x0);
		}

		bool Window2Record::GetShowGridlines()
		{
			return m_fDspGridRt == 0x1;
		}

		Window1::Window1(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_xWn = 0;
			m_yWn = 0;
			m_dxWn = 0;
			m_dyWn = 0;
			m_fHidden = 0;
			m_fIconic = 0;
			m_fVeryHidden = 0;
			m_fDspHScroll = 0;
			m_fDspVScroll = 0;
			m_fBotAdornment = 0;
			m_fNoAFDateGroup = 0;
			m_reserved = 0;
			m_itabCur = 0;
			m_itabFirst = 0;
			m_ctabSel = 0;
			m_wTabRatio = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_WINDOW1);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void Window1::BlobRead(BlobView* pBlobView)
		{
			m_xWn = pBlobView->UnpackInt16();
			m_yWn = pBlobView->UnpackInt16();
			m_dxWn = pBlobView->UnpackInt16();
			m_dyWn = pBlobView->UnpackInt16();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fHidden = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fIconic = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fVeryHidden = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_fDspHScroll = (unsigned short)((nBitmask0 >> 3) & 0x1);
			m_fDspVScroll = (unsigned short)((nBitmask0 >> 4) & 0x1);
			m_fBotAdornment = (unsigned short)((nBitmask0 >> 5) & 0x1);
			m_fNoAFDateGroup = (unsigned short)((nBitmask0 >> 6) & 0x1);
			m_reserved = (unsigned short)((nBitmask0 >> 7) & 0x1ff);
			m_itabCur = pBlobView->UnpackUint16();
			m_itabFirst = pBlobView->UnpackUint16();
			m_ctabSel = pBlobView->UnpackUint16();
			m_wTabRatio = pBlobView->UnpackUint16();
		}

		void Window1::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackInt16(m_xWn);
			pBlobView->PackInt16(m_yWn);
			pBlobView->PackInt16(m_dxWn);
			pBlobView->PackInt16(m_dyWn);
			int nBitmask0 = 0;
			nBitmask0 += m_fHidden << 0;
			nBitmask0 += m_fIconic << 1;
			nBitmask0 += m_fVeryHidden << 2;
			nBitmask0 += m_fDspHScroll << 3;
			nBitmask0 += m_fDspVScroll << 4;
			nBitmask0 += m_fBotAdornment << 5;
			nBitmask0 += m_fNoAFDateGroup << 6;
			nBitmask0 += m_reserved << 7;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			pBlobView->PackUint16(m_itabCur);
			pBlobView->PackUint16(m_itabFirst);
			pBlobView->PackUint16(m_ctabSel);
			pBlobView->PackUint16(m_wTabRatio);
		}

		void Window1::SetDefaults()
		{
			m_xWn = 0;
			m_yWn = 0;
			m_dxWn = 0;
			m_dyWn = 0;
			m_fHidden = 0;
			m_fIconic = 0;
			m_fVeryHidden = 0;
			m_fDspHScroll = 0;
			m_fDspVScroll = 0;
			m_fBotAdornment = 0;
			m_fNoAFDateGroup = 0;
			m_reserved = 0;
			m_itabCur = 0;
			m_itabFirst = 0;
			m_ctabSel = 0;
			m_wTabRatio = 0;
		}

		Window1::Window1(unsigned short nTabRatio) : BiffRecord(TYPE, SIZE)
		{
			m_xWn = 0;
			m_yWn = 0;
			m_dxWn = 0;
			m_dyWn = 0;
			m_fHidden = 0;
			m_fIconic = 0;
			m_fVeryHidden = 0;
			m_fDspHScroll = 0;
			m_fDspVScroll = 0;
			m_fBotAdornment = 0;
			m_fNoAFDateGroup = 0;
			m_reserved = 0;
			m_itabCur = 0;
			m_itabFirst = 0;
			m_ctabSel = 0;
			m_wTabRatio = 0;
			SetDefaults();
			m_xWn = 480;
			m_yWn = 105;
			m_dxWn = 11475;
			m_dyWn = 7740;
			m_fDspHScroll = 0x1;
			m_fDspVScroll = 0x1;
			m_fBotAdornment = 0x1;
			m_ctabSel = 1;
			m_wTabRatio = nTabRatio;
		}

		unsigned short Window1::GetTabRatio()
		{
			return m_wTabRatio;
		}

		WinProtect::WinProtect() : BiffRecord(TYPE, SIZE)
		{
			m_fLockWn = 0;
			SetDefaults();
		}

		WinProtect::WinProtect(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_fLockWn = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_WIN_PROTECT);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void WinProtect::BlobRead(BlobView* pBlobView)
		{
			m_fLockWn = pBlobView->UnpackUint16();
		}

		void WinProtect::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_fLockWn);
		}

		void WinProtect::SetDefaults()
		{
			m_fLockWn = 0;
		}

		ValueRangeRecord::ValueRangeRecord() : BiffRecord(TYPE, SIZE)
		{
			m_numMin = 0;
			m_numMax = 0;
			m_numMajor = 0;
			m_numMinor = 0;
			m_numCross = 0;
			m_fAutoMin = 0;
			m_fAutoMax = 0;
			m_fAutoMajor = 0;
			m_fAutoMinor = 0;
			m_fAutoCross = 0;
			m_fLog = 0;
			m_fReversed = 0;
			m_fMaxCross = 0;
			m_unused = 0;
			SetDefaults();
		}

		ValueRangeRecord::ValueRangeRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_numMin = 0;
			m_numMax = 0;
			m_numMajor = 0;
			m_numMinor = 0;
			m_numCross = 0;
			m_fAutoMin = 0;
			m_fAutoMax = 0;
			m_fAutoMajor = 0;
			m_fAutoMinor = 0;
			m_fAutoCross = 0;
			m_fLog = 0;
			m_fReversed = 0;
			m_fMaxCross = 0;
			m_unused = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_ValueRange);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void ValueRangeRecord::BlobRead(BlobView* pBlobView)
		{
			m_numMin = pBlobView->UnpackDouble();
			m_numMax = pBlobView->UnpackDouble();
			m_numMajor = pBlobView->UnpackDouble();
			m_numMinor = pBlobView->UnpackDouble();
			m_numCross = pBlobView->UnpackDouble();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fAutoMin = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fAutoMax = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fAutoMajor = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_fAutoMinor = (unsigned short)((nBitmask0 >> 3) & 0x1);
			m_fAutoCross = (unsigned short)((nBitmask0 >> 4) & 0x1);
			m_fLog = (unsigned short)((nBitmask0 >> 5) & 0x1);
			m_fReversed = (unsigned short)((nBitmask0 >> 6) & 0x1);
			m_fMaxCross = (unsigned short)((nBitmask0 >> 7) & 0x1);
			m_unused = (unsigned short)((nBitmask0 >> 8) & 0xff);
		}

		void ValueRangeRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackDouble(m_numMin);
			pBlobView->PackDouble(m_numMax);
			pBlobView->PackDouble(m_numMajor);
			pBlobView->PackDouble(m_numMinor);
			pBlobView->PackDouble(m_numCross);
			int nBitmask0 = 0;
			nBitmask0 += m_fAutoMin << 0;
			nBitmask0 += m_fAutoMax << 1;
			nBitmask0 += m_fAutoMajor << 2;
			nBitmask0 += m_fAutoMinor << 3;
			nBitmask0 += m_fAutoCross << 4;
			nBitmask0 += m_fLog << 5;
			nBitmask0 += m_fReversed << 6;
			nBitmask0 += m_fMaxCross << 7;
			nBitmask0 += m_unused << 8;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
		}

		void ValueRangeRecord::SetDefaults()
		{
			m_numMin = 0.0;
			m_numMax = 0.0;
			m_numMajor = 0.0;
			m_numMinor = 0.0;
			m_numCross = 0.0;
			m_fAutoMin = 1;
			m_fAutoMax = 1;
			m_fAutoMajor = 1;
			m_fAutoMinor = 1;
			m_fAutoCross = 1;
			m_fLog = 0;
			m_fReversed = 0;
			m_fMaxCross = 0;
			m_unused = 0;
		}

		VCenterRecord::VCenterRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_vcenter = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_VCENTER);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void VCenterRecord::BlobRead(BlobView* pBlobView)
		{
			m_vcenter = pBlobView->UnpackUint16();
		}

		void VCenterRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_vcenter);
		}

		void VCenterRecord::SetDefaults()
		{
			m_vcenter = 0;
		}

		VCenterRecord::VCenterRecord(bool bCenter) : BiffRecord(TYPE, SIZE)
		{
			m_vcenter = 0;
			SetDefaults();
			m_vcenter = bCenter ? (unsigned short)(0x1) : (unsigned short)(0x0);
		}

		UnitsRecord::UnitsRecord() : BiffRecord(TYPE, SIZE)
		{
			m_unused = 0;
			SetDefaults();
		}

		UnitsRecord::UnitsRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_unused = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_Units);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void UnitsRecord::BlobRead(BlobView* pBlobView)
		{
			m_unused = pBlobView->UnpackUint16();
		}

		void UnitsRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_unused);
		}

		void UnitsRecord::SetDefaults()
		{
			m_unused = 0;
		}

		TopMarginRecord::TopMarginRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_num = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_TOP_MARGIN);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void TopMarginRecord::BlobRead(BlobView* pBlobView)
		{
			m_num = pBlobView->UnpackDouble();
		}

		void TopMarginRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackDouble(m_num);
		}

		void TopMarginRecord::SetDefaults()
		{
			m_num = 0.0;
		}

		TopMarginRecord::TopMarginRecord(double num) : BiffRecord(TYPE, SIZE)
		{
			m_num = 0;
			SetDefaults();
			m_num = num;
		}

		TickRecord::TickRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_tktMajor = 0;
			m_tktMinor = 0;
			m_tlt = 0;
			m_wBkgMode = 0;
			m_rgb = 0;
			m_reserved1 = 0;
			m_reserved2 = 0;
			m_reserved3 = 0;
			m_reserved4 = 0;
			m_fAutoCo = 0;
			m_fAutoMode = 0;
			m_rot = 0;
			m_fAutoRot = 0;
			m_unused = 0;
			m_iReadingOrder = 0;
			m_icv = 0;
			m_trot = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_Tick);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void TickRecord::BlobRead(BlobView* pBlobView)
		{
			m_tktMajor = pBlobView->UnpackUint8();
			m_tktMinor = pBlobView->UnpackUint8();
			m_tlt = pBlobView->UnpackUint8();
			m_wBkgMode = pBlobView->UnpackUint8();
			m_rgb = pBlobView->UnpackUint32();
			m_reserved1 = pBlobView->UnpackUint32();
			m_reserved2 = pBlobView->UnpackUint32();
			m_reserved3 = pBlobView->UnpackUint32();
			m_reserved4 = pBlobView->UnpackUint32();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fAutoCo = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fAutoMode = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_rot = (unsigned short)((nBitmask0 >> 2) & 0x7);
			m_fAutoRot = (unsigned short)((nBitmask0 >> 5) & 0x1);
			m_unused = (unsigned short)((nBitmask0 >> 6) & 0xff);
			m_iReadingOrder = (unsigned short)((nBitmask0 >> 14) & 0x3);
			m_icv = pBlobView->UnpackUint16();
			m_trot = pBlobView->UnpackUint16();
		}

		void TickRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint8(m_tktMajor);
			pBlobView->PackUint8(m_tktMinor);
			pBlobView->PackUint8(m_tlt);
			pBlobView->PackUint8(m_wBkgMode);
			pBlobView->PackUint32(m_rgb);
			pBlobView->PackUint32(m_reserved1);
			pBlobView->PackUint32(m_reserved2);
			pBlobView->PackUint32(m_reserved3);
			pBlobView->PackUint32(m_reserved4);
			int nBitmask0 = 0;
			nBitmask0 += m_fAutoCo << 0;
			nBitmask0 += m_fAutoMode << 1;
			nBitmask0 += m_rot << 2;
			nBitmask0 += m_fAutoRot << 5;
			nBitmask0 += m_unused << 6;
			nBitmask0 += m_iReadingOrder << 14;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			pBlobView->PackUint16(m_icv);
			pBlobView->PackUint16(m_trot);
		}

		void TickRecord::SetDefaults()
		{
			m_tktMajor = 0;
			m_tktMinor = 0;
			m_tlt = 0;
			m_wBkgMode = 0;
			m_rgb = 0;
			m_reserved1 = 0;
			m_reserved2 = 0;
			m_reserved3 = 0;
			m_reserved4 = 0;
			m_fAutoCo = 0;
			m_fAutoMode = 0;
			m_rot = 0;
			m_fAutoRot = 0;
			m_unused = 0;
			m_iReadingOrder = 0;
			m_icv = 0;
			m_trot = 0;
		}

		TickRecord::TickRecord(bool fAutoRot) : BiffRecord(TYPE, SIZE)
		{
			m_tktMajor = 0;
			m_tktMinor = 0;
			m_tlt = 0;
			m_wBkgMode = 0;
			m_rgb = 0;
			m_reserved1 = 0;
			m_reserved2 = 0;
			m_reserved3 = 0;
			m_reserved4 = 0;
			m_fAutoCo = 0;
			m_fAutoMode = 0;
			m_rot = 0;
			m_fAutoRot = 0;
			m_unused = 0;
			m_iReadingOrder = 0;
			m_icv = 0;
			m_trot = 0;
			SetDefaults();
			m_tktMajor = 0x0002;
			m_tlt = 0x0003;
			m_wBkgMode = 0x0001;
			if (fAutoRot)
				m_fAutoRot = 0x1;
			m_icv = 0x08;
		}

		Theme::Theme(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_frtHeader = 0;
			m_dwThemeVersion = 0;
			m_nColorVector = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_THEME);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void Theme::BlobRead(BlobView* pBlobView)
		{
			m_frtHeader->BlobRead(pBlobView);
			m_dwThemeVersion = pBlobView->UnpackUint32();
			PostBlobRead(pBlobView);
		}

		void Theme::BlobWrite(BlobView* pBlobView)
		{
			m_frtHeader->BlobWrite(pBlobView);
			pBlobView->PackUint32(m_dwThemeVersion);
			PostBlobWrite(pBlobView);
		}

		void Theme::SetDefaults()
		{
			m_frtHeader = new FrtHeaderStruct();
			m_dwThemeVersion = 124226;
			PostSetDefaults();
		}

		void Theme::PostSetDefaults()
		{
			m_nColorVector = new Vector<unsigned int>();
		}

		void Theme::PostBlobRead(BlobView* pBlobView)
		{
			if (m_dwThemeVersion == 0)
			{
				XmlFile* pXmlFile = new XmlFile();
				Blob* pXmlBlob = new Blob(true);
				BlobView* pXmlBlobView = pXmlBlob->GetBlobView();
				bool bContinue = true;
				Zip* pZip = new Zip();
				if (!pZip->LoadBlobView(pBlobView))
					bContinue = false;
				if (bContinue)
				{
					if (!pZip->ExtractFileByName("theme/theme/theme1.xml", pXmlBlobView))
						bContinue = false;
				}
				if (bContinue)
				{
					pXmlBlobView->SetOffset(0);
					if (!pXmlFile->Load(pXmlBlobView))
						bContinue = false;
				}
				XmlNode* pTheme = 0;
				XmlNode* pThemeElements = 0;
				XmlNode* pClrScheme = 0;
				XmlNode* pChild = 0;
				XmlNode* pClr = 0;
				if (bContinue)
				{
					pTheme = pXmlFile->GetFirstChildElement("a:theme");
					if (pTheme == 0)
						bContinue = false;
				}
				if (bContinue)
				{
					pThemeElements = pTheme->GetFirstChildElement("a:themeElements");
					if (pThemeElements == 0)
						bContinue = false;
				}
				if (bContinue)
				{
					pClrScheme = pThemeElements->GetFirstChildElement("a:clrScheme");
					if (pThemeElements == 0)
						bContinue = false;
				}
				if (bContinue)
				{
					pChild = pClrScheme->GetFirstChildElement(0);
					while (pChild != 0)
					{
						const char* szName;
						const char* szValue;
						unsigned int nColor;
						pClr = pChild->GetFirstChildElement(0);
						if (pClr == 0)
						{
							bContinue = false;
							break;
						}
						szName = pClr->GetValue();
						if (ExternalString::Equal(szName, "a:sysClr"))
							szValue = pClr->GetAttribute("lastClr");
						else
							szValue = pClr->GetAttribute("val");
						nColor = (unsigned int)(ExternalString::hextol(szValue)) + ((unsigned int)(0xFF) << 24);
						m_nColorVector->PushBack(nColor);
						pChild = pChild->GetNextSiblingElement(0);
					}
				}
				if (pXmlFile) delete pXmlFile;
				if (pXmlBlob) delete pXmlBlob;
				if (pZip) delete pZip;
			}
		}

		void Theme::PostBlobWrite(BlobView* pBlobView)
		{
			nbAssert::Assert(false);
		}

		unsigned int Theme::GetColorByIndex(int nIndex)
		{
			if (m_dwThemeVersion == 0)
			{
				nbAssert::Assert(nIndex < m_nColorVector->GetSize());
				return m_nColorVector->Get(nIndex);
			}
			else
			{
				nbAssert::Assert(nIndex < 12);
				unsigned int nDefaultArray[12] = {0xFFFFFF, 0x000000, 0xEEECE1, 0x1F497D, 0x4F81BD, 0xC0504D, 0x9BBB59, 0x8064A2, 0x4BACC6, 0xF79646, 0x0000FF, 0x800080};
				return nDefaultArray[nIndex];
			}
		}

		Theme::~Theme()
		{
			if (m_frtHeader) delete m_frtHeader;
			if (m_nColorVector) delete m_nColorVector;
		}

		TextRecord::TextRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_at = 0;
			m_vat = 0;
			m_wBkgMode = 0;
			m_rgbText = 0;
			m_x = 0;
			m_y = 0;
			m_dx = 0;
			m_dy = 0;
			m_fAutoColor = 0;
			m_fShowKey = 0;
			m_fShowValue = 0;
			m_unused1 = 0;
			m_fAutoText = 0;
			m_fGenerated = 0;
			m_fDeleted = 0;
			m_fAutoMode = 0;
			m_unused2 = 0;
			m_fShowLabelAndPerc = 0;
			m_fShowPercent = 0;
			m_fShowBubbleSizes = 0;
			m_fShowLabel = 0;
			m_reserved = 0;
			m_icvText = 0;
			m_dlp = 0;
			m_unused3 = 0;
			m_iReadingOrder = 0;
			m_trot = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_Text);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void TextRecord::BlobRead(BlobView* pBlobView)
		{
			m_at = pBlobView->UnpackUint8();
			m_vat = pBlobView->UnpackUint8();
			m_wBkgMode = pBlobView->UnpackUint16();
			m_rgbText = pBlobView->UnpackUint32();
			m_x = pBlobView->UnpackInt32();
			m_y = pBlobView->UnpackInt32();
			m_dx = pBlobView->UnpackInt32();
			m_dy = pBlobView->UnpackInt32();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fAutoColor = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fShowKey = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fShowValue = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_unused1 = (unsigned short)((nBitmask0 >> 3) & 0x1);
			m_fAutoText = (unsigned short)((nBitmask0 >> 4) & 0x1);
			m_fGenerated = (unsigned short)((nBitmask0 >> 5) & 0x1);
			m_fDeleted = (unsigned short)((nBitmask0 >> 6) & 0x1);
			m_fAutoMode = (unsigned short)((nBitmask0 >> 7) & 0x1);
			m_unused2 = (unsigned short)((nBitmask0 >> 8) & 0x7);
			m_fShowLabelAndPerc = (unsigned short)((nBitmask0 >> 11) & 0x1);
			m_fShowPercent = (unsigned short)((nBitmask0 >> 12) & 0x1);
			m_fShowBubbleSizes = (unsigned short)((nBitmask0 >> 13) & 0x1);
			m_fShowLabel = (unsigned short)((nBitmask0 >> 14) & 0x1);
			m_reserved = (unsigned short)((nBitmask0 >> 15) & 0x1);
			m_icvText = pBlobView->UnpackUint16();
			unsigned short nBitmask1 = pBlobView->UnpackUint16();
			m_dlp = (unsigned short)((nBitmask1 >> 0) & 0xf);
			m_unused3 = (unsigned short)((nBitmask1 >> 4) & 0x3ff);
			m_iReadingOrder = (unsigned short)((nBitmask1 >> 14) & 0x3);
			m_trot = pBlobView->UnpackUint16();
		}

		void TextRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint8(m_at);
			pBlobView->PackUint8(m_vat);
			pBlobView->PackUint16(m_wBkgMode);
			pBlobView->PackUint32(m_rgbText);
			pBlobView->PackInt32(m_x);
			pBlobView->PackInt32(m_y);
			pBlobView->PackInt32(m_dx);
			pBlobView->PackInt32(m_dy);
			int nBitmask0 = 0;
			nBitmask0 += m_fAutoColor << 0;
			nBitmask0 += m_fShowKey << 1;
			nBitmask0 += m_fShowValue << 2;
			nBitmask0 += m_unused1 << 3;
			nBitmask0 += m_fAutoText << 4;
			nBitmask0 += m_fGenerated << 5;
			nBitmask0 += m_fDeleted << 6;
			nBitmask0 += m_fAutoMode << 7;
			nBitmask0 += m_unused2 << 8;
			nBitmask0 += m_fShowLabelAndPerc << 11;
			nBitmask0 += m_fShowPercent << 12;
			nBitmask0 += m_fShowBubbleSizes << 13;
			nBitmask0 += m_fShowLabel << 14;
			nBitmask0 += m_reserved << 15;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			pBlobView->PackUint16(m_icvText);
			int nBitmask1 = 0;
			nBitmask1 += m_dlp << 0;
			nBitmask1 += m_unused3 << 4;
			nBitmask1 += m_iReadingOrder << 14;
			pBlobView->PackUint16((unsigned short)(nBitmask1));
			pBlobView->PackUint16(m_trot);
		}

		void TextRecord::SetDefaults()
		{
			m_at = 0;
			m_vat = 0;
			m_wBkgMode = 0;
			m_rgbText = 0;
			m_x = 0;
			m_y = 0;
			m_dx = 0;
			m_dy = 0;
			m_fAutoColor = 0;
			m_fShowKey = 0;
			m_fShowValue = 0;
			m_unused1 = 0;
			m_fAutoText = 0;
			m_fGenerated = 0;
			m_fDeleted = 0;
			m_fAutoMode = 0;
			m_unused2 = 0;
			m_fShowLabelAndPerc = 0;
			m_fShowPercent = 0;
			m_fShowBubbleSizes = 0;
			m_fShowLabel = 0;
			m_reserved = 0;
			m_icvText = 0;
			m_dlp = 0;
			m_unused3 = 0;
			m_iReadingOrder = 0;
			m_trot = 0;
		}

		TextRecord::TextRecord(int x, int y, unsigned int rgbText, bool fAutoColor, bool fAutoText, bool fGenerated, bool fAutoMode, unsigned short icvText, unsigned short trot) : BiffRecord(TYPE, SIZE)
		{
			m_at = 0;
			m_vat = 0;
			m_wBkgMode = 0;
			m_rgbText = 0;
			m_x = 0;
			m_y = 0;
			m_dx = 0;
			m_dy = 0;
			m_fAutoColor = 0;
			m_fShowKey = 0;
			m_fShowValue = 0;
			m_unused1 = 0;
			m_fAutoText = 0;
			m_fGenerated = 0;
			m_fDeleted = 0;
			m_fAutoMode = 0;
			m_unused2 = 0;
			m_fShowLabelAndPerc = 0;
			m_fShowPercent = 0;
			m_fShowBubbleSizes = 0;
			m_fShowLabel = 0;
			m_reserved = 0;
			m_icvText = 0;
			m_dlp = 0;
			m_unused3 = 0;
			m_iReadingOrder = 0;
			m_trot = 0;
			SetDefaults();
			m_at = 0x02;
			m_vat = 0x02;
			m_wBkgMode = 0x0001;
			m_x = x;
			m_y = y;
			m_rgbText = rgbText;
			if (fAutoColor)
				m_fAutoColor = 0x1;
			if (fAutoText)
				m_fAutoText = 0x1;
			if (fGenerated)
				m_fGenerated = 0x1;
			if (fAutoMode)
				m_fAutoMode = 0x1;
			m_icvText = icvText;
			m_trot = trot;
		}

		SupBookRecord::SupBookRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_ctab = 0;
			m_cch = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_SUP_BOOK);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void SupBookRecord::BlobRead(BlobView* pBlobView)
		{
			m_ctab = pBlobView->UnpackUint16();
			m_cch = pBlobView->UnpackUint16();
		}

		void SupBookRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_ctab);
			pBlobView->PackUint16(m_cch);
		}

		void SupBookRecord::SetDefaults()
		{
			m_ctab = 0;
			m_cch = 0;
		}

		SupBookRecord::SupBookRecord(unsigned short nNumWorksheet) : BiffRecord(TYPE, SIZE)
		{
			m_ctab = 0;
			m_cch = 0;
			SetDefaults();
			m_ctab = nNumWorksheet;
			m_cch = 0x0401;
		}

		StyleRecord::StyleRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_ixfe = 0;
			m_unused = 0;
			m_fBuiltIn = 0;
			m_builtInData = 0;
			m_user = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_STYLE);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void StyleRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_ixfe = (unsigned short)((nBitmask0 >> 0) & 0xfff);
			m_unused = (unsigned short)((nBitmask0 >> 12) & 0x7);
			m_fBuiltIn = (unsigned short)((nBitmask0 >> 15) & 0x1);
			PostBlobRead(pBlobView);
		}

		void StyleRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_ixfe << 0;
			nBitmask0 += m_unused << 12;
			nBitmask0 += m_fBuiltIn << 15;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			PostBlobWrite(pBlobView);
		}

		void StyleRecord::SetDefaults()
		{
			m_ixfe = 0;
			m_unused = 0;
			m_fBuiltIn = 0;
			PostSetDefaults();
		}

		StyleRecord::StyleRecord(unsigned short nXFIndex, const char* szName) : BiffRecord(TYPE, SIZE)
		{
			m_ixfe = 0;
			m_unused = 0;
			m_fBuiltIn = 0;
			m_builtInData = 0;
			m_user = 0;
			SetDefaults();
			m_ixfe = nXFIndex;
			m_user->m_rgb->Set(szName);
			m_builtInData->m_istyBuiltIn = 0;
			m_builtInData->m_iLevel = 0xFF;
			if (m_user->m_rgb->GetLength() == 0)
			{
				m_fBuiltIn = 0x1;
				m_pHeader->m_nSize += BuiltInStyleStruct::SIZE;
			}
			else
			{
				m_fBuiltIn = 0x0;
				m_pHeader->m_nSize += (unsigned int)(XLUnicodeStringStruct::SIZE + m_user->GetDynamicSize());
			}
		}

		void StyleRecord::PostSetDefaults()
		{
			m_builtInData = new BuiltInStyleStruct();
			m_user = new XLUnicodeStringStruct();
		}

		void StyleRecord::PostBlobRead(BlobView* pBlobView)
		{
			if (m_fBuiltIn != 0)
				m_builtInData->BlobRead(pBlobView);
			else
				m_user->BlobRead(pBlobView);
		}

		void StyleRecord::PostBlobWrite(BlobView* pBlobView)
		{
			if (m_fBuiltIn != 0)
				m_builtInData->BlobWrite(pBlobView);
			else
				m_user->BlobWrite(pBlobView);
		}

		StyleRecord::~StyleRecord()
		{
			if (m_builtInData) delete m_builtInData;
			if (m_user) delete m_user;
		}

		StartBlockRecord::StartBlockRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_frtHeaderOld = 0;
			m_iObjectKind = 0;
			m_iObjectContext = 0;
			m_iObjectInstance1 = 0;
			m_iObjectInstance2 = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_StartBlock);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void StartBlockRecord::BlobRead(BlobView* pBlobView)
		{
			m_frtHeaderOld->BlobRead(pBlobView);
			m_iObjectKind = pBlobView->UnpackUint16();
			m_iObjectContext = pBlobView->UnpackUint16();
			m_iObjectInstance1 = pBlobView->UnpackUint16();
			m_iObjectInstance2 = pBlobView->UnpackUint16();
		}

		void StartBlockRecord::BlobWrite(BlobView* pBlobView)
		{
			m_frtHeaderOld->BlobWrite(pBlobView);
			pBlobView->PackUint16(m_iObjectKind);
			pBlobView->PackUint16(m_iObjectContext);
			pBlobView->PackUint16(m_iObjectInstance1);
			pBlobView->PackUint16(m_iObjectInstance2);
		}

		void StartBlockRecord::SetDefaults()
		{
			m_frtHeaderOld = new FrtHeaderOldStruct();
			m_iObjectKind = 0;
			m_iObjectContext = 0;
			m_iObjectInstance1 = 0;
			m_iObjectInstance2 = 0;
			PostSetDefaults();
		}

		StartBlockRecord::StartBlockRecord(unsigned short iObjectKind, unsigned short iObjectContext, unsigned short iObjectInstance1, unsigned short iObjectInstance2) : BiffRecord(TYPE, SIZE)
		{
			m_frtHeaderOld = 0;
			m_iObjectKind = 0;
			m_iObjectContext = 0;
			m_iObjectInstance1 = 0;
			m_iObjectInstance2 = 0;
			SetDefaults();
			m_iObjectKind = iObjectKind;
			m_iObjectContext = iObjectContext;
			m_iObjectInstance1 = iObjectInstance1;
			m_iObjectInstance2 = iObjectInstance2;
		}

		void StartBlockRecord::PostSetDefaults()
		{
			m_frtHeaderOld->m_rt = 2130;
		}

		StartBlockRecord::~StartBlockRecord()
		{
			if (m_frtHeaderOld) delete m_frtHeaderOld;
		}

		SstRecord::SstRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_cstTotal = 0;
			m_cstUnique = 0;
			m_pHaxBlob = 0;
			m_pRgb = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_SST);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void SstRecord::BlobRead(BlobView* pBlobView)
		{
			m_cstTotal = pBlobView->UnpackInt32();
			m_cstUnique = pBlobView->UnpackInt32();
			PostBlobRead(pBlobView);
		}

		void SstRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackInt32(m_cstTotal);
			pBlobView->PackInt32(m_cstUnique);
			PostBlobWrite(pBlobView);
		}

		void SstRecord::SetDefaults()
		{
			m_cstTotal = 0;
			m_cstUnique = 0;
			PostSetDefaults();
		}

		SstRecord::SstRecord(SharedStringContainer* pSharedStringContainer) : BiffRecord(TYPE, SIZE)
		{
			m_cstTotal = 0;
			m_cstUnique = 0;
			m_pHaxBlob = 0;
			m_pRgb = 0;
			SetDefaults();
			m_cstTotal = pSharedStringContainer->GetSize();
			m_cstUnique = pSharedStringContainer->GetSize();
			m_pHaxBlob = new Blob(true);
			BlobView* pHaxBlobView = m_pHaxBlob->GetBlobView();
			for (int i = 0; i < pSharedStringContainer->GetSize(); i++)
			{
				XLUnicodeRichExtendedString* pXLUnicodeRichExtendedString = new XLUnicodeRichExtendedString(pSharedStringContainer->Get(i));
				pXLUnicodeRichExtendedString->ContinueAwareBlobWrite(pHaxBlobView, m_pContinueInfoVector);
				{
					NumberDuck::Secret::XLUnicodeRichExtendedString* __555132520 = pXLUnicodeRichExtendedString;
					pXLUnicodeRichExtendedString = 0;
					m_pRgb->PushBack(__555132520);
				}
				if (pXLUnicodeRichExtendedString) delete pXLUnicodeRichExtendedString;
			}
			m_pHeader->m_nSize += (unsigned int)(pHaxBlobView->GetSize());
		}

		void SstRecord::PostSetDefaults()
		{
			m_pHaxBlob = 0;
			m_pRgb = new OwnedVector<XLUnicodeRichExtendedString*>();
		}

		void SstRecord::PostBlobRead(BlobView* pBlobView)
		{
			for (unsigned short i = 0; i < m_cstUnique; i++)
			{
				XLUnicodeRichExtendedString* pXLUnicodeRichExtendedString = new XLUnicodeRichExtendedString();
				pXLUnicodeRichExtendedString->ContinueAwareBlobRead(pBlobView, m_pContinueInfoVector);
				{
					NumberDuck::Secret::XLUnicodeRichExtendedString* __555132520 = pXLUnicodeRichExtendedString;
					pXLUnicodeRichExtendedString = 0;
					m_pRgb->PushBack(__555132520);
				}
				if (pXLUnicodeRichExtendedString) delete pXLUnicodeRichExtendedString;
			}
		}

		void SstRecord::PostBlobWrite(BlobView* pBlobView)
		{
			m_pHaxBlob->GetBlobView()->SetOffset(0);
			pBlobView->Pack(m_pHaxBlob->GetBlobView(), m_pHaxBlob->GetSize());
		}

		int SstRecord::GetNumString()
		{
			return m_cstUnique;
		}

		const char* SstRecord::GetString(int nIndex)
		{
			return m_pRgb->Get(nIndex)->m_rgb->GetExternalString();
		}

		SstRecord::~SstRecord()
		{
			if (m_pHaxBlob) delete m_pHaxBlob;
			if (m_pRgb) delete m_pRgb;
		}

		ShtPropsRecord::ShtPropsRecord() : BiffRecord(TYPE, SIZE)
		{
			m_fManSerAlloc = 0;
			m_fPlotVisOnly = 0;
			m_fNotSizeWith = 0;
			m_fManPlotArea = 0;
			m_fAlwaysAutoPlotArea = 0;
			m_reserved1 = 0;
			m_mdBlank = 0;
			m_reserved2 = 0;
			SetDefaults();
		}

		ShtPropsRecord::ShtPropsRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_fManSerAlloc = 0;
			m_fPlotVisOnly = 0;
			m_fNotSizeWith = 0;
			m_fManPlotArea = 0;
			m_fAlwaysAutoPlotArea = 0;
			m_reserved1 = 0;
			m_mdBlank = 0;
			m_reserved2 = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_ShtProps);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void ShtPropsRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fManSerAlloc = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fPlotVisOnly = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fNotSizeWith = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_fManPlotArea = (unsigned short)((nBitmask0 >> 3) & 0x1);
			m_fAlwaysAutoPlotArea = (unsigned short)((nBitmask0 >> 4) & 0x1);
			m_reserved1 = (unsigned short)((nBitmask0 >> 5) & 0x7ff);
			m_mdBlank = pBlobView->UnpackUint8();
			m_reserved2 = pBlobView->UnpackUint8();
		}

		void ShtPropsRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_fManSerAlloc << 0;
			nBitmask0 += m_fPlotVisOnly << 1;
			nBitmask0 += m_fNotSizeWith << 2;
			nBitmask0 += m_fManPlotArea << 3;
			nBitmask0 += m_fAlwaysAutoPlotArea << 4;
			nBitmask0 += m_reserved1 << 5;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			pBlobView->PackUint8(m_mdBlank);
			pBlobView->PackUint8(m_reserved2);
		}

		void ShtPropsRecord::SetDefaults()
		{
			m_fManSerAlloc = 1;
			m_fPlotVisOnly = 1;
			m_fNotSizeWith = 0;
			m_fManPlotArea = 1;
			m_fAlwaysAutoPlotArea = 1;
			m_reserved1 = 0;
			m_mdBlank = 0;
			m_reserved2 = 0;
		}

		ShapePropsStreamRecord::ShapePropsStreamRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_frtHeader = 0;
			m_wObjContext = 0;
			m_unused = 0;
			m_dwChecksum = 0;
			m_cb = 0;
			m_rgb = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_ShapePropsStream);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void ShapePropsStreamRecord::BlobRead(BlobView* pBlobView)
		{
			m_frtHeader->BlobRead(pBlobView);
			m_wObjContext = pBlobView->UnpackUint16();
			m_unused = pBlobView->UnpackUint16();
			m_dwChecksum = pBlobView->UnpackUint32();
			m_cb = pBlobView->UnpackUint32();
			PostBlobRead(pBlobView);
		}

		void ShapePropsStreamRecord::BlobWrite(BlobView* pBlobView)
		{
			m_frtHeader->BlobWrite(pBlobView);
			pBlobView->PackUint16(m_wObjContext);
			pBlobView->PackUint16(m_unused);
			pBlobView->PackUint32(m_dwChecksum);
			pBlobView->PackUint32(m_cb);
		}

		void ShapePropsStreamRecord::SetDefaults()
		{
			m_frtHeader = new FrtHeaderStruct();
			m_wObjContext = 0;
			m_unused = 0;
			m_dwChecksum = 0;
			m_cb = 0;
			PostSetDefaults();
		}

		ShapePropsStreamRecord::ShapePropsStreamRecord(unsigned short wObjContext, unsigned short unused, unsigned int dwChecksum) : BiffRecord(TYPE, SIZE)
		{
			m_frtHeader = 0;
			m_wObjContext = 0;
			m_unused = 0;
			m_dwChecksum = 0;
			m_cb = 0;
			m_rgb = 0;
			SetDefaults();
			m_wObjContext = wObjContext;
			m_unused = unused;
			m_dwChecksum = dwChecksum;
		}

		void ShapePropsStreamRecord::PostSetDefaults()
		{
			m_rgb = new InternalString("");
			m_frtHeader->m_rt = 2212;
		}

		void ShapePropsStreamRecord::PostBlobRead(BlobView* pBlobView)
		{
			unsigned int i;
			for (i = 0; i < m_cb; i++)
				m_rgb->AppendChar((unsigned short)(pBlobView->UnpackUint8()));
		}

		ShapePropsStreamRecord::~ShapePropsStreamRecord()
		{
			if (m_frtHeader) delete m_frtHeader;
			if (m_rgb) delete m_rgb;
		}

		SetupRecord::SetupRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_iPaperSize = 0;
			m_iScale = 0;
			m_iPageStart = 0;
			m_iFitWidth = 0;
			m_iFitHeight = 0;
			m_fLeftToRight = 0;
			m_fPortrait = 0;
			m_fNoPls = 0;
			m_fNoColor = 0;
			m_fDraft = 0;
			m_fNotes = 0;
			m_fNoOrient = 0;
			m_fUsePage = 0;
			m_unused1 = 0;
			m_fEndNotes = 0;
			m_iErrors = 0;
			m_reserved = 0;
			m_iRes = 0;
			m_iVRes = 0;
			m_numHdr = 0;
			m_numFtr = 0;
			m_iCopies = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_SETUP);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void SetupRecord::BlobRead(BlobView* pBlobView)
		{
			m_iPaperSize = pBlobView->UnpackUint16();
			m_iScale = pBlobView->UnpackUint16();
			m_iPageStart = pBlobView->UnpackInt16();
			m_iFitWidth = pBlobView->UnpackUint16();
			m_iFitHeight = pBlobView->UnpackUint16();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fLeftToRight = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fPortrait = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fNoPls = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_fNoColor = (unsigned short)((nBitmask0 >> 3) & 0x1);
			m_fDraft = (unsigned short)((nBitmask0 >> 4) & 0x1);
			m_fNotes = (unsigned short)((nBitmask0 >> 5) & 0x1);
			m_fNoOrient = (unsigned short)((nBitmask0 >> 6) & 0x1);
			m_fUsePage = (unsigned short)((nBitmask0 >> 7) & 0x1);
			m_unused1 = (unsigned short)((nBitmask0 >> 8) & 0x1);
			m_fEndNotes = (unsigned short)((nBitmask0 >> 9) & 0x1);
			m_iErrors = (unsigned short)((nBitmask0 >> 10) & 0x3);
			m_reserved = (unsigned short)((nBitmask0 >> 12) & 0xf);
			m_iRes = pBlobView->UnpackUint16();
			m_iVRes = pBlobView->UnpackUint16();
			m_numHdr = pBlobView->UnpackDouble();
			m_numFtr = pBlobView->UnpackDouble();
			m_iCopies = pBlobView->UnpackUint16();
		}

		void SetupRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_iPaperSize);
			pBlobView->PackUint16(m_iScale);
			pBlobView->PackInt16(m_iPageStart);
			pBlobView->PackUint16(m_iFitWidth);
			pBlobView->PackUint16(m_iFitHeight);
			int nBitmask0 = 0;
			nBitmask0 += m_fLeftToRight << 0;
			nBitmask0 += m_fPortrait << 1;
			nBitmask0 += m_fNoPls << 2;
			nBitmask0 += m_fNoColor << 3;
			nBitmask0 += m_fDraft << 4;
			nBitmask0 += m_fNotes << 5;
			nBitmask0 += m_fNoOrient << 6;
			nBitmask0 += m_fUsePage << 7;
			nBitmask0 += m_unused1 << 8;
			nBitmask0 += m_fEndNotes << 9;
			nBitmask0 += m_iErrors << 10;
			nBitmask0 += m_reserved << 12;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			pBlobView->PackUint16(m_iRes);
			pBlobView->PackUint16(m_iVRes);
			pBlobView->PackDouble(m_numHdr);
			pBlobView->PackDouble(m_numFtr);
			pBlobView->PackUint16(m_iCopies);
		}

		void SetupRecord::SetDefaults()
		{
			m_iPaperSize = 1;
			m_iScale = 100;
			m_iPageStart = 1;
			m_iFitWidth = 1;
			m_iFitHeight = 1;
			m_fLeftToRight = 0;
			m_fPortrait = 0;
			m_fNoPls = 0;
			m_fNoColor = 0;
			m_fDraft = 0;
			m_fNotes = 0;
			m_fNoOrient = 0;
			m_fUsePage = 0;
			m_unused1 = 0;
			m_fEndNotes = 0;
			m_iErrors = 0;
			m_reserved = 0;
			m_iRes = 600;
			m_iVRes = 600;
			m_numHdr = 0.3;
			m_numFtr = 0.3;
			m_iCopies = 1;
		}

		SetupRecord::SetupRecord(bool bPortrait) : BiffRecord(TYPE, SIZE)
		{
			m_iPaperSize = 0;
			m_iScale = 0;
			m_iPageStart = 0;
			m_iFitWidth = 0;
			m_iFitHeight = 0;
			m_fLeftToRight = 0;
			m_fPortrait = 0;
			m_fNoPls = 0;
			m_fNoColor = 0;
			m_fDraft = 0;
			m_fNotes = 0;
			m_fNoOrient = 0;
			m_fUsePage = 0;
			m_unused1 = 0;
			m_fEndNotes = 0;
			m_iErrors = 0;
			m_reserved = 0;
			m_iRes = 0;
			m_iVRes = 0;
			m_numHdr = 0;
			m_numFtr = 0;
			m_iCopies = 0;
			SetDefaults();
			if (bPortrait)
				m_fPortrait = 0x1;
		}

		bool SetupRecord::GetPortrait()
		{
			return m_fPortrait == 0x1;
		}

		SeriesTextRecord::SeriesTextRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_reserved = 0;
			m_stText = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_SeriesText);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void SeriesTextRecord::BlobRead(BlobView* pBlobView)
		{
			m_reserved = pBlobView->UnpackUint16();
			m_stText->BlobRead(pBlobView);
		}

		void SeriesTextRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_reserved);
			m_stText->BlobWrite(pBlobView);
		}

		void SeriesTextRecord::SetDefaults()
		{
			m_reserved = 0;
			m_stText = new ShortXLUnicodeStringStruct();
		}

		SeriesTextRecord::SeriesTextRecord(const char* szText) : BiffRecord(TYPE, SIZE)
		{
			m_reserved = 0;
			m_stText = 0;
			SetDefaults();
			m_stText->m_rgb->Set(szText);
			m_pHeader->m_nSize += (unsigned int)(m_stText->GetDynamicSize());
		}

		SeriesTextRecord::~SeriesTextRecord()
		{
			if (m_stText) delete m_stText;
		}

		SeriesRecord::SeriesRecord() : BiffRecord(TYPE, SIZE)
		{
			m_sdtX = 0;
			m_sdtY = 0;
			m_cValx = 0;
			m_cValy = 0;
			m_sdtBSize = 0;
			m_cValBSize = 0;
			SetDefaults();
		}

		SeriesRecord::SeriesRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_sdtX = 0;
			m_sdtY = 0;
			m_cValx = 0;
			m_cValy = 0;
			m_sdtBSize = 0;
			m_cValBSize = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_Series);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void SeriesRecord::BlobRead(BlobView* pBlobView)
		{
			m_sdtX = pBlobView->UnpackUint16();
			m_sdtY = pBlobView->UnpackUint16();
			m_cValx = pBlobView->UnpackUint16();
			m_cValy = pBlobView->UnpackUint16();
			m_sdtBSize = pBlobView->UnpackUint16();
			m_cValBSize = pBlobView->UnpackUint16();
		}

		void SeriesRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_sdtX);
			pBlobView->PackUint16(m_sdtY);
			pBlobView->PackUint16(m_cValx);
			pBlobView->PackUint16(m_cValy);
			pBlobView->PackUint16(m_sdtBSize);
			pBlobView->PackUint16(m_cValBSize);
		}

		void SeriesRecord::SetDefaults()
		{
			m_sdtX = 0x0001;
			m_sdtY = 0x0001;
			m_cValx = 10;
			m_cValy = 10;
			m_sdtBSize = 0x0001;
			m_cValBSize = 0;
		}

		SerToCrtRecord::SerToCrtRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_id = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_SerToCrt);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void SerToCrtRecord::BlobRead(BlobView* pBlobView)
		{
			m_id = pBlobView->UnpackUint16();
		}

		void SerToCrtRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_id);
		}

		void SerToCrtRecord::SetDefaults()
		{
			m_id = 0;
		}

		SerToCrtRecord::SerToCrtRecord(unsigned short id) : BiffRecord(TYPE, SIZE)
		{
			m_id = 0;
			SetDefaults();
			m_id = id;
		}

		SelectionRecord::SelectionRecord() : BiffRecord(TYPE, SIZE)
		{
			m_pnn = 0;
			m_rwAct = 0;
			m_colAct = 0;
			m_irefAct = 0;
			m_cref = 0;
			m_rwFirst = 0;
			m_rwLast = 0;
			m_colFirst = 0;
			m_colLast = 0;
			SetDefaults();
		}

		SelectionRecord::SelectionRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_pnn = 0;
			m_rwAct = 0;
			m_colAct = 0;
			m_irefAct = 0;
			m_cref = 0;
			m_rwFirst = 0;
			m_rwLast = 0;
			m_colFirst = 0;
			m_colLast = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_SELECTION);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void SelectionRecord::BlobRead(BlobView* pBlobView)
		{
			m_pnn = pBlobView->UnpackUint8();
			m_rwAct = pBlobView->UnpackUint16();
			m_colAct = pBlobView->UnpackUint16();
			m_irefAct = pBlobView->UnpackUint16();
			m_cref = pBlobView->UnpackUint16();
			m_rwFirst = pBlobView->UnpackUint16();
			m_rwLast = pBlobView->UnpackUint16();
			m_colFirst = pBlobView->UnpackUint8();
			m_colLast = pBlobView->UnpackUint8();
		}

		void SelectionRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint8(m_pnn);
			pBlobView->PackUint16(m_rwAct);
			pBlobView->PackUint16(m_colAct);
			pBlobView->PackUint16(m_irefAct);
			pBlobView->PackUint16(m_cref);
			pBlobView->PackUint16(m_rwFirst);
			pBlobView->PackUint16(m_rwLast);
			pBlobView->PackUint8(m_colFirst);
			pBlobView->PackUint8(m_colLast);
		}

		void SelectionRecord::SetDefaults()
		{
			m_pnn = 3;
			m_rwAct = 0;
			m_colAct = 0;
			m_irefAct = 0;
			m_cref = 1;
			m_rwFirst = 0;
			m_rwLast = 0;
			m_colFirst = 0;
			m_colLast = 0;
		}

		SclRecord::SclRecord() : BiffRecord(TYPE, SIZE)
		{
			m_nscl = 0;
			m_dscl = 0;
			SetDefaults();
		}

		SclRecord::SclRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_nscl = 0;
			m_dscl = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_SCL);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void SclRecord::BlobRead(BlobView* pBlobView)
		{
			m_nscl = pBlobView->UnpackInt16();
			m_dscl = pBlobView->UnpackInt16();
		}

		void SclRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackInt16(m_nscl);
			pBlobView->PackInt16(m_dscl);
		}

		void SclRecord::SetDefaults()
		{
			m_nscl = 1;
			m_dscl = 1;
		}

		ScatterRecord::ScatterRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_pcBubbleSizeRatio = 0;
			m_wBubbleSize = 0;
			m_fBubbles = 0;
			m_fShowNegBubbles = 0;
			m_fHasShadow = 0;
			m_reserved = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_Scatter);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void ScatterRecord::BlobRead(BlobView* pBlobView)
		{
			m_pcBubbleSizeRatio = pBlobView->UnpackUint16();
			m_wBubbleSize = pBlobView->UnpackUint16();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fBubbles = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fShowNegBubbles = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fHasShadow = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_reserved = (unsigned short)((nBitmask0 >> 3) & 0x1fff);
		}

		void ScatterRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_pcBubbleSizeRatio);
			pBlobView->PackUint16(m_wBubbleSize);
			int nBitmask0 = 0;
			nBitmask0 += m_fBubbles << 0;
			nBitmask0 += m_fShowNegBubbles << 1;
			nBitmask0 += m_fHasShadow << 2;
			nBitmask0 += m_reserved << 3;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
		}

		void ScatterRecord::SetDefaults()
		{
			m_pcBubbleSizeRatio = 100;
			m_wBubbleSize = 0x0001;
			m_fBubbles = 0;
			m_fShowNegBubbles = 0;
			m_fHasShadow = 0;
			m_reserved = 0;
		}

		ScatterRecord::ScatterRecord(Chart::Type eType) : BiffRecord(TYPE, SIZE)
		{
			m_pcBubbleSizeRatio = 0;
			m_wBubbleSize = 0;
			m_fBubbles = 0;
			m_fShowNegBubbles = 0;
			m_fHasShadow = 0;
			m_reserved = 0;
			SetDefaults();
			nbAssert::Assert(eType == Chart::Type::TYPE_SCATTER);
		}

		Chart::Type ScatterRecord::GetChartType()
		{
			return Chart::Type::TYPE_SCATTER;
		}

		SIIndexRecord::SIIndexRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_numIndex = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_SIIndex);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void SIIndexRecord::BlobRead(BlobView* pBlobView)
		{
			m_numIndex = pBlobView->UnpackUint16();
		}

		void SIIndexRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_numIndex);
		}

		void SIIndexRecord::SetDefaults()
		{
			m_numIndex = 0;
		}

		SIIndexRecord::SIIndexRecord(unsigned short numIndex) : BiffRecord(TYPE, SIZE)
		{
			m_numIndex = 0;
			SetDefaults();
			m_numIndex = numIndex;
		}

		RowRecord::RowRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_rw = 0;
			m_colMic = 0;
			m_colMac = 0;
			m_miyRw = 0;
			m_reserved1 = 0;
			m_unused1 = 0;
			m_iOutLevel = 0;
			m_reserved2 = 0;
			m_fCollapsed = 0;
			m_fDyZero = 0;
			m_fUnsynced = 0;
			m_fGhostDirty = 0;
			m_reserved3 = 0;
			m_ixfe_val = 0;
			m_fExAsc = 0;
			m_fExDes = 0;
			m_fPhonetic = 0;
			m_unused2 = 0;
			m_bTopMedium = false;
			m_bTopThick = false;
			m_bBottomMedium = false;
			m_bBottomThick = false;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_ROW);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void RowRecord::BlobRead(BlobView* pBlobView)
		{
			m_rw->BlobRead(pBlobView);
			m_colMic = pBlobView->UnpackUint16();
			m_colMac = pBlobView->UnpackUint16();
			m_miyRw = pBlobView->UnpackUint16();
			m_reserved1 = pBlobView->UnpackUint16();
			m_unused1 = pBlobView->UnpackUint16();
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_iOutLevel = (unsigned char)((nBitmask0 >> 0) & 0x7);
			m_reserved2 = (unsigned char)((nBitmask0 >> 3) & 0x1);
			m_fCollapsed = (unsigned char)((nBitmask0 >> 4) & 0x1);
			m_fDyZero = (unsigned char)((nBitmask0 >> 5) & 0x1);
			m_fUnsynced = (unsigned char)((nBitmask0 >> 6) & 0x1);
			m_fGhostDirty = (unsigned char)((nBitmask0 >> 7) & 0x1);
			m_reserved3 = pBlobView->UnpackUint8();
			unsigned short nBitmask1 = pBlobView->UnpackUint16();
			m_ixfe_val = (unsigned short)((nBitmask1 >> 0) & 0xfff);
			m_fExAsc = (unsigned short)((nBitmask1 >> 12) & 0x1);
			m_fExDes = (unsigned short)((nBitmask1 >> 13) & 0x1);
			m_fPhonetic = (unsigned short)((nBitmask1 >> 14) & 0x1);
			m_unused2 = (unsigned short)((nBitmask1 >> 15) & 0x1);
		}

		void RowRecord::BlobWrite(BlobView* pBlobView)
		{
			m_rw->BlobWrite(pBlobView);
			pBlobView->PackUint16(m_colMic);
			pBlobView->PackUint16(m_colMac);
			pBlobView->PackUint16(m_miyRw);
			pBlobView->PackUint16(m_reserved1);
			pBlobView->PackUint16(m_unused1);
			int nBitmask0 = 0;
			nBitmask0 += m_iOutLevel << 0;
			nBitmask0 += m_reserved2 << 3;
			nBitmask0 += m_fCollapsed << 4;
			nBitmask0 += m_fDyZero << 5;
			nBitmask0 += m_fUnsynced << 6;
			nBitmask0 += m_fGhostDirty << 7;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
			pBlobView->PackUint8(m_reserved3);
			int nBitmask1 = 0;
			nBitmask1 += m_ixfe_val << 0;
			nBitmask1 += m_fExAsc << 12;
			nBitmask1 += m_fExDes << 13;
			nBitmask1 += m_fPhonetic << 14;
			nBitmask1 += m_unused2 << 15;
			pBlobView->PackUint16((unsigned short)(nBitmask1));
		}

		void RowRecord::SetDefaults()
		{
			m_rw = new RwStruct();
			m_colMic = 0;
			m_colMac = 0;
			m_miyRw = 0;
			m_reserved1 = 0;
			m_unused1 = 0;
			m_iOutLevel = 0;
			m_reserved2 = 0;
			m_fCollapsed = 0;
			m_fDyZero = 0;
			m_fUnsynced = 1;
			m_fGhostDirty = 0;
			m_reserved3 = 1;
			m_ixfe_val = 15;
			m_fExAsc = 0;
			m_fExDes = 0;
			m_fPhonetic = 0;
			m_unused2 = 0;
			PostSetDefaults();
		}

		RowRecord::RowRecord(unsigned short nRow, unsigned short nHeight) : BiffRecord(TYPE, SIZE)
		{
			m_rw = 0;
			m_colMic = 0;
			m_colMac = 0;
			m_miyRw = 0;
			m_reserved1 = 0;
			m_unused1 = 0;
			m_iOutLevel = 0;
			m_reserved2 = 0;
			m_fCollapsed = 0;
			m_fDyZero = 0;
			m_fUnsynced = 0;
			m_fGhostDirty = 0;
			m_reserved3 = 0;
			m_ixfe_val = 0;
			m_fExAsc = 0;
			m_fExDes = 0;
			m_fPhonetic = 0;
			m_unused2 = 0;
			m_bTopMedium = false;
			m_bTopThick = false;
			m_bBottomMedium = false;
			m_bBottomThick = false;
			SetDefaults();
			m_rw->m_rw = nRow;
			m_miyRw = nHeight;
		}

		void RowRecord::PostSetDefaults()
		{
			m_bTopMedium = false;
			m_bTopThick = false;
			m_bBottomMedium = false;
			m_bBottomThick = false;
		}

		unsigned short RowRecord::GetRow()
		{
			return m_rw->m_rw;
		}

		unsigned short RowRecord::GetHeight()
		{
			return m_miyRw;
		}

		void RowRecord::SetHeight(unsigned short nHeight)
		{
			m_miyRw = nHeight;
		}

		void RowRecord::SetTopMedium()
		{
			m_bTopMedium = true;
		}

		void RowRecord::SetTopThick()
		{
			m_fExAsc = 0x1;
			m_bTopThick = true;
		}

		void RowRecord::SetBottomMedium()
		{
			m_fExDes = 0x1;
			m_bBottomMedium = true;
		}

		void RowRecord::SetBottomThick()
		{
			m_fExDes = 0x1;
			m_bBottomThick = true;
		}

		bool RowRecord::GetBottomThick()
		{
			return m_bBottomThick;
		}

		RowRecord::~RowRecord()
		{
			if (m_rw) delete m_rw;
		}

		RkRecord::RkRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_nRowIndex = 0;
			m_nColumnIndex = 0;
			m_nXfIndex = 0;
			m_nRkValue = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_RK);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void RkRecord::BlobRead(BlobView* pBlobView)
		{
			m_nRowIndex = pBlobView->UnpackUint16();
			m_nColumnIndex = pBlobView->UnpackUint16();
			m_nXfIndex = pBlobView->UnpackUint16();
			m_nRkValue = pBlobView->UnpackUint32();
		}

		void RkRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_nRowIndex);
			pBlobView->PackUint16(m_nColumnIndex);
			pBlobView->PackUint16(m_nXfIndex);
			pBlobView->PackUint32(m_nRkValue);
		}

		void RkRecord::SetDefaults()
		{
			m_nRowIndex = 0;
			m_nColumnIndex = 0;
			m_nXfIndex = 0;
			m_nRkValue = 0;
		}

		unsigned short RkRecord::GetX()
		{
			return m_nColumnIndex;
		}

		unsigned short RkRecord::GetY()
		{
			return m_nRowIndex;
		}

		unsigned short RkRecord::GetXfIndex()
		{
			return m_nXfIndex;
		}

		unsigned int RkRecord::GetRkValue()
		{
			return m_nRkValue;
		}

		RightMarginRecord::RightMarginRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_num = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_RIGHT_MARGIN);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void RightMarginRecord::BlobRead(BlobView* pBlobView)
		{
			m_num = pBlobView->UnpackDouble();
		}

		void RightMarginRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackDouble(m_num);
		}

		void RightMarginRecord::SetDefaults()
		{
			m_num = 0.0;
		}

		RightMarginRecord::RightMarginRecord(double num) : BiffRecord(TYPE, SIZE)
		{
			m_num = 0;
			m_num = num;
		}

		RefreshAllRecord::RefreshAllRecord() : BiffRecord(TYPE, SIZE)
		{
			m_refreshAll = 0;
			SetDefaults();
		}

		RefreshAllRecord::RefreshAllRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_refreshAll = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_REFRESH_ALL);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void RefreshAllRecord::BlobRead(BlobView* pBlobView)
		{
			m_refreshAll = pBlobView->UnpackUint16();
		}

		void RefreshAllRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_refreshAll);
		}

		void RefreshAllRecord::SetDefaults()
		{
			m_refreshAll = 0;
		}

		RRTabId::RRTabId(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_nNumWorksheet = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_RR_TAB_ID);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void RRTabId::BlobRead(BlobView* pBlobView)
		{
			PostBlobRead(pBlobView);
		}

		void RRTabId::BlobWrite(BlobView* pBlobView)
		{
			PostBlobWrite(pBlobView);
		}

		void RRTabId::SetDefaults()
		{
		}

		RRTabId::RRTabId(unsigned short nNumWorksheet) : BiffRecord(TYPE, (unsigned short)(SIZE + 2 * nNumWorksheet))
		{
			m_nNumWorksheet = 0;
			SetDefaults();
			m_nNumWorksheet = nNumWorksheet;
		}

		void RRTabId::PostBlobRead(BlobView* pBlobView)
		{
			m_nNumWorksheet = (unsigned short)((pBlobView->GetSize() - pBlobView->GetOffset()) >> 1);
		}

		void RRTabId::PostBlobWrite(BlobView* pBlobView)
		{
			unsigned short i;
			for (i = 0; i < m_nNumWorksheet; i++)
				pBlobView->PackUint16(i);
		}

		ProtectRecord::ProtectRecord() : BiffRecord(TYPE, SIZE)
		{
			m_fLock = 0;
			SetDefaults();
		}

		ProtectRecord::ProtectRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_fLock = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_PROTECT);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void ProtectRecord::BlobRead(BlobView* pBlobView)
		{
			m_fLock = pBlobView->UnpackUint16();
		}

		void ProtectRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_fLock);
		}

		void ProtectRecord::SetDefaults()
		{
			m_fLock = 0;
		}

		Prot4RevRecord::Prot4RevRecord() : BiffRecord(TYPE, SIZE)
		{
			m_fRevLock = 0;
			SetDefaults();
		}

		Prot4RevRecord::Prot4RevRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_fRevLock = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_PROT_4_REV);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void Prot4RevRecord::BlobRead(BlobView* pBlobView)
		{
			m_fRevLock = pBlobView->UnpackUint16();
		}

		void Prot4RevRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_fRevLock);
		}

		void Prot4RevRecord::SetDefaults()
		{
			m_fRevLock = 0;
		}

		Prot4RevPassRecord::Prot4RevPassRecord() : BiffRecord(TYPE, SIZE)
		{
			m_protPwdRev = 0;
			SetDefaults();
		}

		Prot4RevPassRecord::Prot4RevPassRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_protPwdRev = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_PROT_4_REV_PASS);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void Prot4RevPassRecord::BlobRead(BlobView* pBlobView)
		{
			m_protPwdRev = pBlobView->UnpackUint16();
		}

		void Prot4RevPassRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_protPwdRev);
		}

		void Prot4RevPassRecord::SetDefaults()
		{
			m_protPwdRev = 0;
		}

		PrintSizeRecord::PrintSizeRecord() : BiffRecord(TYPE, SIZE)
		{
			m_printSize = 0;
			SetDefaults();
		}

		PrintSizeRecord::PrintSizeRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_printSize = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_PRINT_SIZE);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void PrintSizeRecord::BlobRead(BlobView* pBlobView)
		{
			m_printSize = pBlobView->UnpackUint16();
		}

		void PrintSizeRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_printSize);
		}

		void PrintSizeRecord::SetDefaults()
		{
			m_printSize = 0x0003;
		}

		PrintRowColRecord::PrintRowColRecord() : BiffRecord(TYPE, SIZE)
		{
			m_printRwCol = 0;
			SetDefaults();
		}

		PrintRowColRecord::PrintRowColRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_printRwCol = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_PrintRowCol);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void PrintRowColRecord::BlobRead(BlobView* pBlobView)
		{
			m_printRwCol = pBlobView->UnpackUint16();
		}

		void PrintRowColRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_printRwCol);
		}

		void PrintRowColRecord::SetDefaults()
		{
			m_printRwCol = 0;
		}

		PrintGridRecord::PrintGridRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_fPrintGrid = 0;
			m_unused = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_PrintGrid);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void PrintGridRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fPrintGrid = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_unused = (unsigned short)((nBitmask0 >> 1) & 0x7fff);
		}

		void PrintGridRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_fPrintGrid << 0;
			nBitmask0 += m_unused << 1;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
		}

		void PrintGridRecord::SetDefaults()
		{
			m_fPrintGrid = 0;
			m_unused = 0;
		}

		PrintGridRecord::PrintGridRecord(bool bPrintGridlines) : BiffRecord(TYPE, SIZE)
		{
			m_fPrintGrid = 0;
			m_unused = 0;
			SetDefaults();
			if (bPrintGridlines)
				m_fPrintGrid = 0x1;
		}

		bool PrintGridRecord::GetPrintGridlines()
		{
			return m_fPrintGrid == 0x1;
		}

		PosRecord::PosRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_mdTopLt = 0;
			m_mdBotRt = 0;
			m_x1 = 0;
			m_unused1 = 0;
			m_y1 = 0;
			m_unused2 = 0;
			m_x2 = 0;
			m_unused3 = 0;
			m_y2 = 0;
			m_unused4 = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_Pos);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void PosRecord::BlobRead(BlobView* pBlobView)
		{
			m_mdTopLt = pBlobView->UnpackUint16();
			m_mdBotRt = pBlobView->UnpackUint16();
			m_x1 = pBlobView->UnpackInt16();
			m_unused1 = pBlobView->UnpackUint16();
			m_y1 = pBlobView->UnpackInt16();
			m_unused2 = pBlobView->UnpackUint16();
			m_x2 = pBlobView->UnpackInt16();
			m_unused3 = pBlobView->UnpackUint16();
			m_y2 = pBlobView->UnpackInt16();
			m_unused4 = pBlobView->UnpackUint16();
		}

		void PosRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_mdTopLt);
			pBlobView->PackUint16(m_mdBotRt);
			pBlobView->PackInt16(m_x1);
			pBlobView->PackUint16(m_unused1);
			pBlobView->PackInt16(m_y1);
			pBlobView->PackUint16(m_unused2);
			pBlobView->PackInt16(m_x2);
			pBlobView->PackUint16(m_unused3);
			pBlobView->PackInt16(m_y2);
			pBlobView->PackUint16(m_unused4);
		}

		void PosRecord::SetDefaults()
		{
			m_mdTopLt = 0x0002;
			m_mdBotRt = 0x0002;
			m_x1 = 0;
			m_unused1 = 0;
			m_y1 = 0;
			m_unused2 = 0;
			m_x2 = 0;
			m_unused3 = 0;
			m_y2 = 0;
			m_unused4 = 0;
		}

		PosRecord::PosRecord(short x1, short y1, unsigned short unused2, short x2, short y2) : BiffRecord(TYPE, SIZE)
		{
			m_mdTopLt = 0;
			m_mdBotRt = 0;
			m_x1 = 0;
			m_unused1 = 0;
			m_y1 = 0;
			m_unused2 = 0;
			m_x2 = 0;
			m_unused3 = 0;
			m_y2 = 0;
			m_unused4 = 0;
			SetDefaults();
			m_x1 = x1;
			m_y1 = y1;
			m_unused2 = unused2;
			m_x2 = x2;
			m_y2 = y2;
		}

		PlotGrowthRecord::PlotGrowthRecord() : BiffRecord(TYPE, SIZE)
		{
			m_dxPlotGrowth = 0;
			m_dyPlotGrowth = 0;
			SetDefaults();
		}

		PlotGrowthRecord::PlotGrowthRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_dxPlotGrowth = 0;
			m_dyPlotGrowth = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_PlotGrowth);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void PlotGrowthRecord::BlobRead(BlobView* pBlobView)
		{
			m_dxPlotGrowth = pBlobView->UnpackInt32();
			m_dyPlotGrowth = pBlobView->UnpackInt32();
		}

		void PlotGrowthRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackInt32(m_dxPlotGrowth);
			pBlobView->PackInt32(m_dyPlotGrowth);
		}

		void PlotGrowthRecord::SetDefaults()
		{
			m_dxPlotGrowth = 65536;
			m_dyPlotGrowth = 65536;
		}

		PlotAreaRecord::PlotAreaRecord() : BiffRecord(TYPE, SIZE)
		{
			SetDefaults();
		}

		PlotAreaRecord::PlotAreaRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_PlotArea);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void PlotAreaRecord::BlobRead(BlobView* pBlobView)
		{
		}

		void PlotAreaRecord::BlobWrite(BlobView* pBlobView)
		{
		}

		void PlotAreaRecord::SetDefaults()
		{
		}

		PieFormatRecord::PieFormatRecord() : BiffRecord(TYPE, SIZE)
		{
			m_pcExplode = 0;
			SetDefaults();
		}

		PieFormatRecord::PieFormatRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_pcExplode = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_PieFormat);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void PieFormatRecord::BlobRead(BlobView* pBlobView)
		{
			m_pcExplode = pBlobView->UnpackUint16();
		}

		void PieFormatRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_pcExplode);
		}

		void PieFormatRecord::SetDefaults()
		{
			m_pcExplode = 0;
		}

		PasswordRecord::PasswordRecord() : BiffRecord(TYPE, SIZE)
		{
			m_wPassword = 0;
			SetDefaults();
		}

		PasswordRecord::PasswordRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_wPassword = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_PASSWORD);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void PasswordRecord::BlobRead(BlobView* pBlobView)
		{
			m_wPassword = pBlobView->UnpackUint16();
		}

		void PasswordRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_wPassword);
		}

		void PasswordRecord::SetDefaults()
		{
			m_wPassword = 0;
		}

		PaletteRecord::PaletteRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_ccv = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_PALETTE);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void PaletteRecord::BlobRead(BlobView* pBlobView)
		{
			m_ccv = pBlobView->UnpackUint16();
			PostBlobRead(pBlobView);
		}

		void PaletteRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_ccv);
			PostBlobWrite(pBlobView);
		}

		void PaletteRecord::SetDefaults()
		{
			m_ccv = 0;
			PostSetDefaults();
		}

		PaletteRecord::PaletteRecord() : BiffRecord(TYPE, SIZE + BiffWorkbookGlobals::NUM_CUSTOM_PALETTE_ENTRY * 4)
		{
			m_ccv = 0;
			SetDefaults();
		}

		void PaletteRecord::PostBlobRead(BlobView* pBlobView)
		{
			for (unsigned short i = 0; i < m_ccv; i++)
				m_rgColor[i] = pBlobView->UnpackUint32();
		}

		void PaletteRecord::PostBlobWrite(BlobView* pBlobView)
		{
			for (unsigned short i = 0; i < m_ccv; i++)
				pBlobView->PackUint32(m_rgColor[i]);
		}

		void PaletteRecord::PostSetDefaults()
		{
			m_ccv = BiffWorkbookGlobals::NUM_CUSTOM_PALETTE_ENTRY;
			for (unsigned short i = 0; i < m_ccv; i++)
				m_rgColor[i] = BiffWorkbookGlobals::DEFAULT_CUSTOM_COLOR[i] & 0xFFFFFF;
		}

		unsigned int PaletteRecord::GetColorByIndex(unsigned short nIndex)
		{
			nbAssert::Assert(nIndex <= m_ccv);
			return m_rgColor[nIndex];
		}

		ObjectLinkRecord::ObjectLinkRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_wLinkObj = 0;
			m_wLinkVar1 = 0;
			m_wLinkVar2 = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_ObjectLink);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void ObjectLinkRecord::BlobRead(BlobView* pBlobView)
		{
			m_wLinkObj = pBlobView->UnpackUint16();
			m_wLinkVar1 = pBlobView->UnpackUint16();
			m_wLinkVar2 = pBlobView->UnpackUint16();
		}

		void ObjectLinkRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_wLinkObj);
			pBlobView->PackUint16(m_wLinkVar1);
			pBlobView->PackUint16(m_wLinkVar2);
		}

		void ObjectLinkRecord::SetDefaults()
		{
			m_wLinkObj = 0;
			m_wLinkVar1 = 0;
			m_wLinkVar2 = 0;
		}

		ObjectLinkRecord::ObjectLinkRecord(unsigned short nLinkObject, unsigned short nSeriesIndex, unsigned short nCategoryIndex) : BiffRecord(TYPE, SIZE)
		{
			m_wLinkObj = 0;
			m_wLinkVar1 = 0;
			m_wLinkVar2 = 0;
			SetDefaults();
			m_wLinkObj = nLinkObject;
			m_wLinkVar1 = nSeriesIndex;
			m_wLinkVar2 = nSeriesIndex;
		}

		ObjRecord::ObjRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_cmo = 0;
			m_pictFormat = 0;
			m_pictFlags = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_OBJ);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void ObjRecord::BlobRead(BlobView* pBlobView)
		{
			m_cmo->BlobRead(pBlobView);
			PostBlobRead(pBlobView);
		}

		void ObjRecord::BlobWrite(BlobView* pBlobView)
		{
			m_cmo->BlobWrite(pBlobView);
			PostBlobWrite(pBlobView);
		}

		void ObjRecord::SetDefaults()
		{
			m_cmo = new FtCmoStruct();
			PostSetDefaults();
		}

		ObjRecord::ObjRecord(unsigned short nIndex, FtCmoStruct::ObjType eType) : BiffRecord(TYPE, (unsigned short)(SIZE + (eType == (FtCmoStruct::ObjType::OBJ_TYPE_PICTURE) ? (FtCfStruct::SIZE + FtPioGrbitStruct::SIZE) : 0) + 4))
		{
			m_cmo = 0;
			m_pictFormat = 0;
			m_pictFlags = 0;
			SetDefaults();
			nbAssert::Assert(eType == FtCmoStruct::ObjType::OBJ_TYPE_PICTURE || eType == FtCmoStruct::ObjType::OBJ_TYPE_CHART);
			m_cmo->m_ft = 0x15;
			m_cmo->m_cb = 0x12;
			m_cmo->m_ot = (unsigned short)(eType);
			m_cmo->m_id = nIndex;
			m_cmo->m_fLocked = 1;
			m_cmo->m_fPrint = 1;
			m_cmo->m_unused6 = 1;
			if (eType == FtCmoStruct::ObjType::OBJ_TYPE_PICTURE)
			{
				m_pictFormat = new FtCfStruct();
				m_pictFormat->m_cf = 0xffff;
				m_pictFlags = new FtPioGrbitStruct();
				m_pictFlags->m_fAutoPict = 0x1;
			}
		}

		void ObjRecord::PostBlobRead(BlobView* pBlobView)
		{
			if ((FtCmoStruct::ObjType)(m_cmo->m_ot) == FtCmoStruct::ObjType::OBJ_TYPE_PICTURE)
			{
				m_pictFormat = new FtCfStruct();
				m_pictFormat->BlobRead(pBlobView);
				m_pictFlags = new FtPioGrbitStruct();
				m_pictFlags->BlobRead(pBlobView);
			}
		}

		void ObjRecord::PostBlobWrite(BlobView* pBlobView)
		{
			if ((FtCmoStruct::ObjType)(m_cmo->m_ot) == FtCmoStruct::ObjType::OBJ_TYPE_PICTURE)
			{
				m_pictFormat->BlobWrite(pBlobView);
				m_pictFlags->BlobWrite(pBlobView);
			}
			pBlobView->PackUint32(0);
		}

		void ObjRecord::PostSetDefaults()
		{
			m_pictFormat = 0;
			m_pictFlags = 0;
		}

		FtCmoStruct::ObjType ObjRecord::GetType()
		{
			return (FtCmoStruct::ObjType)(m_cmo->m_ot);
		}

		ObjRecord::~ObjRecord()
		{
			if (m_cmo) delete m_cmo;
			if (m_pictFormat) delete m_pictFormat;
			if (m_pictFlags) delete m_pictFlags;
		}

		NumberRecord::NumberRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_cell = 0;
			m_num = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_NUMBER);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void NumberRecord::BlobRead(BlobView* pBlobView)
		{
			m_cell->BlobRead(pBlobView);
			m_num = pBlobView->UnpackDouble();
		}

		void NumberRecord::BlobWrite(BlobView* pBlobView)
		{
			m_cell->BlobWrite(pBlobView);
			pBlobView->PackDouble(m_num);
		}

		void NumberRecord::SetDefaults()
		{
			m_cell = new CellStruct();
			m_num = 0.0;
		}

		NumberRecord::NumberRecord(unsigned short nX, unsigned short nY, unsigned short nXfIndex, double fNumber) : BiffRecord(TYPE, SIZE)
		{
			m_cell = 0;
			m_num = 0;
			SetDefaults();
			m_cell->m_rw->m_rw = nY;
			m_cell->m_col->m_col = nX;
			m_cell->m_ixfe->m_ixfe = nXfIndex;
			m_num = fNumber;
		}

		unsigned short NumberRecord::GetX()
		{
			return m_cell->m_col->m_col;
		}

		unsigned short NumberRecord::GetY()
		{
			return m_cell->m_rw->m_rw;
		}

		unsigned short NumberRecord::GetXfIndex()
		{
			return m_cell->m_ixfe->m_ixfe;
		}

		double NumberRecord::GetNumber()
		{
			return m_num;
		}

		NumberRecord::~NumberRecord()
		{
			if (m_cell) delete m_cell;
		}

		MulRkRecord::MulRkRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_rw = 0;
			m_col = 0;
			m_pRkRecVector = 0;
			m_colLast = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_MULRK);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void MulRkRecord::BlobRead(BlobView* pBlobView)
		{
			m_rw->BlobRead(pBlobView);
			m_col->BlobRead(pBlobView);
			PostBlobRead(pBlobView);
		}

		void MulRkRecord::BlobWrite(BlobView* pBlobView)
		{
			m_rw->BlobWrite(pBlobView);
			m_col->BlobWrite(pBlobView);
			PostBlobWrite(pBlobView);
		}

		void MulRkRecord::SetDefaults()
		{
			m_rw = new RwStruct();
			m_col = new ColStruct();
			PostSetDefaults();
		}

		void MulRkRecord::PostSetDefaults()
		{
			m_pRkRecVector = new OwnedVector<RkRecStruct*>();
			m_colLast = 0;
		}

		void MulRkRecord::PostBlobRead(BlobView* pBlobView)
		{
			unsigned int nNumColumn = (m_pHeader->m_nSize - SIZE - 2) / RkRecStruct::SIZE;
			for (unsigned int i = 0; i < nNumColumn; i++)
			{
				RkRecStruct* pRkRec = new RkRecStruct();
				pRkRec->BlobRead(pBlobView);
				{
					NumberDuck::Secret::RkRecStruct* __3209674599 = pRkRec;
					pRkRec = 0;
					m_pRkRecVector->PushBack(__3209674599);
				}
				if (pRkRec) delete pRkRec;
			}
			m_colLast = pBlobView->UnpackUint16();
		}

		void MulRkRecord::PostBlobWrite(BlobView* pBlobView)
		{
			for (int i = 0; i < m_pRkRecVector->GetSize(); i++)
				m_pRkRecVector->Get(i)->BlobWrite(pBlobView);
			pBlobView->PackUint16(m_colLast);
		}

		unsigned short MulRkRecord::GetX()
		{
			return m_col->m_col;
		}

		unsigned short MulRkRecord::GetY()
		{
			return m_rw->m_rw;
		}

		unsigned short MulRkRecord::GetNumRk()
		{
			return (unsigned short)(m_pRkRecVector->GetSize());
		}

		unsigned short MulRkRecord::GetXfIndexByIndex(unsigned short nIndex)
		{
			return m_pRkRecVector->Get(nIndex)->m_ixfe;
		}

		unsigned int MulRkRecord::GetRkValueByIndex(unsigned short nIndex)
		{
			return m_pRkRecVector->Get(nIndex)->m_RK;
		}

		MulRkRecord::~MulRkRecord()
		{
			if (m_rw) delete m_rw;
			if (m_col) delete m_col;
			if (m_pRkRecVector) delete m_pRkRecVector;
		}

		MulBlank::MulBlank(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_rw = 0;
			m_col = 0;
			m_pIXFCellVector = 0;
			m_colLast = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_MULBLANK);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void MulBlank::BlobRead(BlobView* pBlobView)
		{
			m_rw->BlobRead(pBlobView);
			m_col->BlobRead(pBlobView);
			PostBlobRead(pBlobView);
		}

		void MulBlank::BlobWrite(BlobView* pBlobView)
		{
			m_rw->BlobWrite(pBlobView);
			m_col->BlobWrite(pBlobView);
			PostBlobWrite(pBlobView);
		}

		void MulBlank::SetDefaults()
		{
			m_rw = new RwStruct();
			m_col = new ColStruct();
			PostSetDefaults();
		}

		MulBlank::MulBlank(unsigned short nX, unsigned short nY, Vector<int>* pXfIndexVector) : BiffRecord(TYPE, SIZE + IXFCellStruct::SIZE * (unsigned int)(pXfIndexVector->GetSize()) + 2)
		{
			m_rw = 0;
			m_col = 0;
			m_pIXFCellVector = 0;
			m_colLast = 0;
			SetDefaults();
			nbAssert::Assert(pXfIndexVector->GetSize() > 1);
			m_rw->m_rw = nY;
			m_col->m_col = nX;
			for (int i = 0; i < pXfIndexVector->GetSize(); i++)
			{
				IXFCellStruct* pIXFCell = new IXFCellStruct();
				pIXFCell->m_ixfe = (unsigned short)(pXfIndexVector->Get(i));
				{
					NumberDuck::Secret::IXFCellStruct* __62881043 = pIXFCell;
					pIXFCell = 0;
					m_pIXFCellVector->PushBack(__62881043);
				}
				if (pIXFCell) delete pIXFCell;
			}
			m_colLast = (unsigned short)(m_col->m_col + pXfIndexVector->GetSize() - 1);
		}

		void MulBlank::PostSetDefaults()
		{
			m_pIXFCellVector = new OwnedVector<IXFCellStruct*>();
			m_colLast = 0;
		}

		void MulBlank::PostBlobRead(BlobView* pBlobView)
		{
			unsigned int nNumColumn = (m_pHeader->m_nSize - SIZE - 2) / IXFCellStruct::SIZE;
			for (unsigned int i = 0; i < nNumColumn; i++)
			{
				IXFCellStruct* pIXFCell = new IXFCellStruct();
				pIXFCell->BlobRead(pBlobView);
				{
					NumberDuck::Secret::IXFCellStruct* __62881043 = pIXFCell;
					pIXFCell = 0;
					m_pIXFCellVector->PushBack(__62881043);
				}
				if (pIXFCell) delete pIXFCell;
			}
			m_colLast = pBlobView->UnpackUint16();
		}

		void MulBlank::PostBlobWrite(BlobView* pBlobView)
		{
			for (int i = 0; i < m_pIXFCellVector->GetSize(); i++)
				m_pIXFCellVector->Get(i)->BlobWrite(pBlobView);
			pBlobView->PackUint16(m_colLast);
		}

		unsigned short MulBlank::GetX()
		{
			return m_col->m_col;
		}

		unsigned short MulBlank::GetY()
		{
			return m_rw->m_rw;
		}

		unsigned short MulBlank::GetNumColumn()
		{
			return (unsigned short)(m_pIXFCellVector->GetSize());
		}

		unsigned short MulBlank::GetXfIndexByIndex(unsigned short nIndex)
		{
			IXFCellStruct* pIXFCell = m_pIXFCellVector->Get(nIndex);
			return pIXFCell->m_ixfe;
		}

		MulBlank::~MulBlank()
		{
			if (m_rw) delete m_rw;
			if (m_col) delete m_col;
			if (m_pIXFCellVector) delete m_pIXFCellVector;
		}

		MsoDrawingRecord_Position::MsoDrawingRecord_Position()
		{
			m_nCellX1 = 0;
			m_nSubCellX1 = 0;
			m_nCellY1 = 0;
			m_nSubCellY1 = 0;
			m_nCellX2 = 0;
			m_nSubCellX2 = 0;
			m_nCellY2 = 0;
			m_nSubCellY2 = 0;
		}

		MsoDrawingRecord::MsoDrawingRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_pOfficeArtRecord = 0;
			m_pPosition = 0;
			m_pBlob = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_MSO_DRAWING);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void MsoDrawingRecord::BlobRead(BlobView* pBlobView)
		{
			PostBlobRead(pBlobView);
		}

		void MsoDrawingRecord::BlobWrite(BlobView* pBlobView)
		{
			PostBlobWrite(pBlobView);
		}

		void MsoDrawingRecord::SetDefaults()
		{
			PostSetDefaults();
		}

		MsoDrawingRecord::MsoDrawingRecord(OfficeArtDgContainerRecord* pOfficeArtDgContainerRecord, unsigned int nWriteSize) : BiffRecord(TYPE, SIZE)
		{
			m_pOfficeArtRecord = 0;
			m_pPosition = 0;
			m_pBlob = 0;
			SetDefaults();
			m_pBlob = new Blob(true);
			pOfficeArtDgContainerRecord->RecursiveWrite(m_pBlob->GetBlobView());
			m_pBlob->GetBlobView()->SetOffset(0);
			m_pHeader->m_nSize = nWriteSize;
			m_pBlob->Resize((int)(nWriteSize), true);
		}

		MsoDrawingRecord::MsoDrawingRecord(OfficeArtSpContainerRecord* pOfficeArtSpContainerRecord) : BiffRecord(TYPE, SIZE)
		{
			m_pOfficeArtRecord = 0;
			m_pPosition = 0;
			m_pBlob = 0;
			SetDefaults();
			m_pBlob = new Blob(true);
			pOfficeArtSpContainerRecord->RecursiveWrite(m_pBlob->GetBlobView());
			m_pHeader->m_nSize = (unsigned int)(m_pBlob->GetSize());
		}

		void MsoDrawingRecord::PostSetDefaults()
		{
			m_pOfficeArtRecord = 0;
			m_pBlob = 0;
			m_pPosition = new MsoDrawingRecord_Position();
		}

		void MsoDrawingRecord::PostBlobRead(BlobView* pBlobView)
		{
			nbAssert::Assert(m_pOfficeArtRecord == 0);
			m_pOfficeArtRecord = OfficeArtRecord::CreateOfficeArtRecord(pBlobView);
		}

		void MsoDrawingRecord::PostBlobWrite(BlobView* pBlobView)
		{
			m_pBlob->GetBlobView()->SetOffset(0);
			pBlobView->Pack(m_pBlob->GetBlobView(), m_pBlob->GetSize());
		}

		const MsoDrawingRecord_Position* MsoDrawingRecord::GetPosition()
		{
			if (m_pOfficeArtRecord != 0)
			{
				if (m_pOfficeArtRecord->GetType() == OfficeArtRecord::Type::TYPE_OFFICE_ART_DG_CONTAINER || m_pOfficeArtRecord->GetType() == OfficeArtRecord::Type::TYPE_OFFICE_ART_SP_CONTAINER)
				{
					OfficeArtClientAnchorSheetRecord* pOfficeArtClientAnchorSheetRecord = (OfficeArtClientAnchorSheetRecord*)(m_pOfficeArtRecord->FindOfficeArtRecordByType(OfficeArtRecord::Type::TYPE_OFFICE_ART_CLIENT_ANCHOR_SHEET));
					if (pOfficeArtClientAnchorSheetRecord != 0)
					{
						m_pPosition->m_nCellX1 = pOfficeArtClientAnchorSheetRecord->GetCellX1();
						m_pPosition->m_nSubCellX1 = pOfficeArtClientAnchorSheetRecord->GetSubCellX1();
						m_pPosition->m_nCellY1 = pOfficeArtClientAnchorSheetRecord->GetCellY1();
						m_pPosition->m_nSubCellY1 = pOfficeArtClientAnchorSheetRecord->GetSubCellY1();
						m_pPosition->m_nCellX2 = pOfficeArtClientAnchorSheetRecord->GetCellX2();
						m_pPosition->m_nSubCellX2 = pOfficeArtClientAnchorSheetRecord->GetSubCellX2();
						m_pPosition->m_nCellY2 = pOfficeArtClientAnchorSheetRecord->GetCellY2();
						m_pPosition->m_nSubCellY2 = pOfficeArtClientAnchorSheetRecord->GetSubCellY2();
						return m_pPosition;
					}
				}
			}
			return 0;
		}

		OfficeArtFOPTEStruct* MsoDrawingRecord::GetProperty(OfficeArtRecord::OPIDType eType)
		{
			if (m_pOfficeArtRecord->GetType() == OfficeArtRecord::Type::TYPE_OFFICE_ART_DG_CONTAINER || m_pOfficeArtRecord->GetType() == OfficeArtRecord::Type::TYPE_OFFICE_ART_SP_CONTAINER)
			{
				OfficeArtFOPTRecord* pOfficeArtFOPTRecord = (OfficeArtFOPTRecord*)(m_pOfficeArtRecord->FindOfficeArtRecordByType(OfficeArtRecord::Type::TYPE_OFFICE_ART_FOPT));
				if (pOfficeArtFOPTRecord != 0)
					return pOfficeArtFOPTRecord->GetProperty(eType);
			}
			return 0;
		}

		MsoDrawingRecord::~MsoDrawingRecord()
		{
			if (m_pOfficeArtRecord) delete m_pOfficeArtRecord;
			if (m_pPosition) delete m_pPosition;
			if (m_pBlob) delete m_pBlob;
		}

		MsoDrawingGroupRecord::MsoDrawingGroupRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_pOfficeArtDggContainerRecord = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_MSO_DRAWING_GROUP);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void MsoDrawingGroupRecord::BlobRead(BlobView* pBlobView)
		{
			PostBlobRead(pBlobView);
		}

		void MsoDrawingGroupRecord::BlobWrite(BlobView* pBlobView)
		{
			PostBlobWrite(pBlobView);
		}

		void MsoDrawingGroupRecord::SetDefaults()
		{
			PostSetDefaults();
		}

		MsoDrawingGroupRecord::MsoDrawingGroupRecord(Vector<Picture*>* pPictureVector) : BiffRecord(TYPE, SIZE)
		{
			m_pOfficeArtDggContainerRecord = 0;
			SetDefaults();
			m_pOfficeArtDggContainerRecord = new OfficeArtDggContainerRecord();
			m_pOfficeArtDggContainerRecord->AddOfficeArtRecord(new OfficeArtFDGGBlockRecord((unsigned int)(pPictureVector->GetSize())));
			OfficeArtBStoreContainerRecord* pOfficeArtBStoreContainerRecord = new OfficeArtBStoreContainerRecord();
			for (int i = 0; i < pPictureVector->GetSize(); i++)
				pOfficeArtBStoreContainerRecord->AddOfficeArtRecord(new OfficeArtFBSERecord(pPictureVector->Get(i)));
			{
				NumberDuck::Secret::OfficeArtBStoreContainerRecord* __3451512242 = pOfficeArtBStoreContainerRecord;
				pOfficeArtBStoreContainerRecord = 0;
				m_pOfficeArtDggContainerRecord->AddOfficeArtRecord(__3451512242);
			}
			OfficeArtFOPTRecord* pOfficeArtFOPTRecord = new OfficeArtFOPTRecord();
			pOfficeArtFOPTRecord->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_TEXT_BOOLEAN_PROPERTIES), 0, 524296);
			pOfficeArtFOPTRecord->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_FILL_COLOR), 0, 134217793);
			pOfficeArtFOPTRecord->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_LINE_COLOR), 0, 134217792);
			{
				NumberDuck::Secret::OfficeArtFOPTRecord* __1214438724 = pOfficeArtFOPTRecord;
				pOfficeArtFOPTRecord = 0;
				m_pOfficeArtDggContainerRecord->AddOfficeArtRecord(__1214438724);
			}
			m_pOfficeArtDggContainerRecord->AddOfficeArtRecord(new OfficeArtSplitMenuColorContainerRecord());
			m_pHeader->m_nSize = m_pOfficeArtDggContainerRecord->GetRecursiveSize();
			unsigned int nOffset = MAX_DATA_SIZE;
			while (nOffset < m_pHeader->m_nSize)
			{
				m_pContinueInfoVector->PushBack(new BiffRecord_ContinueInfo((int)(nOffset), 0));
				nOffset += MAX_DATA_SIZE;
			}
			if (pOfficeArtBStoreContainerRecord) delete pOfficeArtBStoreContainerRecord;
			if (pOfficeArtFOPTRecord) delete pOfficeArtFOPTRecord;
		}

		void MsoDrawingGroupRecord::PostSetDefaults()
		{
			m_pOfficeArtDggContainerRecord = 0;
		}

		void MsoDrawingGroupRecord::PostBlobRead(BlobView* pBlobView)
		{
			nbAssert::Assert(m_pOfficeArtDggContainerRecord == 0);
			OfficeArtRecord* pOfficeArtRecord = OfficeArtRecord::CreateOfficeArtRecord(pBlobView);
			nbAssert::Assert(pOfficeArtRecord->GetType() == OfficeArtRecord::Type::TYPE_OFFICE_ART_DGG_CONTAINER);
			{
				NumberDuck::Secret::OfficeArtRecord* __3533451309 = pOfficeArtRecord;
				pOfficeArtRecord = 0;
				m_pOfficeArtDggContainerRecord = (OfficeArtDggContainerRecord*)(__3533451309);
			}
			if (pOfficeArtRecord) delete pOfficeArtRecord;
		}

		void MsoDrawingGroupRecord::PostBlobWrite(BlobView* pBlobView)
		{
			m_pOfficeArtDggContainerRecord->RecursiveWrite(pBlobView);
		}

		OfficeArtDggContainerRecord* MsoDrawingGroupRecord::GetOfficeArtDggContainerRecord()
		{
			return m_pOfficeArtDggContainerRecord;
		}

		MsoDrawingGroupRecord::~MsoDrawingGroupRecord()
		{
			if (m_pOfficeArtDggContainerRecord) delete m_pOfficeArtDggContainerRecord;
		}

		Mms::Mms() : BiffRecord(TYPE, SIZE)
		{
			m_reserved1 = 0;
			m_reserved2 = 0;
			SetDefaults();
		}

		Mms::Mms(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_reserved1 = 0;
			m_reserved2 = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_MMS);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void Mms::BlobRead(BlobView* pBlobView)
		{
			m_reserved1 = pBlobView->UnpackUint8();
			m_reserved2 = pBlobView->UnpackUint8();
		}

		void Mms::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint8(m_reserved1);
			pBlobView->PackUint8(m_reserved2);
		}

		void Mms::SetDefaults()
		{
			m_reserved1 = 0;
			m_reserved2 = 0;
		}

		MergeCellsRecord::MergeCellsRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_cmcs = 0;
			m_pRef8Vector = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_MergeCells);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void MergeCellsRecord::BlobRead(BlobView* pBlobView)
		{
			m_cmcs = pBlobView->UnpackUint16();
			PostBlobRead(pBlobView);
		}

		void MergeCellsRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_cmcs);
			PostBlobWrite(pBlobView);
		}

		void MergeCellsRecord::SetDefaults()
		{
			m_cmcs = 0;
			PostSetDefaults();
		}

		MergeCellsRecord::MergeCellsRecord(OwnedVector<MergedCell*>* pMergedCellVector, int nOffset, int nSize) : BiffRecord(TYPE, SIZE + Ref8Struct::SIZE * (unsigned int)(nSize))
		{
			m_cmcs = 0;
			m_pRef8Vector = 0;
			SetDefaults();
			m_cmcs = (unsigned short)(nSize);
			for (unsigned short i = 0; i < m_cmcs; i++)
			{
				MergedCell* pMergedCell = pMergedCellVector->Get(nOffset + i);
				Ref8Struct* pRef8 = new Ref8Struct();
				pRef8->m_rwFirst = (unsigned short)(pMergedCell->GetY());
				unsigned int nTemp = (unsigned int)(pRef8->m_rwFirst) + (unsigned int)(pMergedCell->GetHeight()) - 1;
				if (nTemp > 0xFFFF)
					nTemp = 0xFFFF;
				pRef8->m_rwLast = (unsigned short)(nTemp);
				pRef8->m_colFirst = (unsigned short)(pMergedCell->GetX());
				nTemp = (unsigned int)(pRef8->m_colFirst) + (unsigned int)(pMergedCell->GetWidth()) - 1;
				if (nTemp > 0xFF)
					nTemp = 0xFF;
				pRef8->m_colLast = (unsigned short)(nTemp);
				{
					NumberDuck::Secret::Ref8Struct* __2933356801 = pRef8;
					pRef8 = 0;
					m_pRef8Vector->PushBack(__2933356801);
				}
				if (pRef8) delete pRef8;
			}
		}

		void MergeCellsRecord::PostSetDefaults()
		{
			m_pRef8Vector = new OwnedVector<Ref8Struct*>();
		}

		void MergeCellsRecord::PostBlobRead(BlobView* pBlobView)
		{
			for (unsigned short i = 0; i < m_cmcs; i++)
			{
				Ref8Struct* pRef8 = new Ref8Struct();
				pRef8->BlobRead(pBlobView);
				{
					NumberDuck::Secret::Ref8Struct* __2933356801 = pRef8;
					pRef8 = 0;
					m_pRef8Vector->PushBack(__2933356801);
				}
				if (pRef8) delete pRef8;
			}
		}

		void MergeCellsRecord::PostBlobWrite(BlobView* pBlobView)
		{
			for (unsigned short i = 0; i < m_cmcs; i++)
				m_pRef8Vector->Get(i)->BlobWrite(pBlobView);
		}

		unsigned short MergeCellsRecord::GetNumMergedCell()
		{
			return m_cmcs;
		}

		const Ref8Struct* MergeCellsRecord::GetMergedCell(unsigned short nIndex)
		{
			nbAssert::Assert(nIndex < m_cmcs);
			return m_pRef8Vector->Get(nIndex);
		}

		MergeCellsRecord::~MergeCellsRecord()
		{
			if (m_pRef8Vector) delete m_pRef8Vector;
		}

		MarkerFormatRecord::MarkerFormatRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_rgbFore = 0;
			m_rgbBack = 0;
			m_imk = 0;
			m_fAuto = 0;
			m_reserved1 = 0;
			m_fNotShowInt = 0;
			m_fNotShowBrd = 0;
			m_reserved2 = 0;
			m_icvFore = 0;
			m_icvBack = 0;
			m_miSize = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_MarkerFormat);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void MarkerFormatRecord::BlobRead(BlobView* pBlobView)
		{
			m_rgbFore = pBlobView->UnpackUint32();
			m_rgbBack = pBlobView->UnpackUint32();
			m_imk = pBlobView->UnpackUint16();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fAuto = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_reserved1 = (unsigned short)((nBitmask0 >> 1) & 0x7);
			m_fNotShowInt = (unsigned short)((nBitmask0 >> 4) & 0x1);
			m_fNotShowBrd = (unsigned short)((nBitmask0 >> 5) & 0x1);
			m_reserved2 = (unsigned short)((nBitmask0 >> 6) & 0x3ff);
			m_icvFore = pBlobView->UnpackUint16();
			m_icvBack = pBlobView->UnpackUint16();
			m_miSize = pBlobView->UnpackUint32();
		}

		void MarkerFormatRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint32(m_rgbFore);
			pBlobView->PackUint32(m_rgbBack);
			pBlobView->PackUint16(m_imk);
			int nBitmask0 = 0;
			nBitmask0 += m_fAuto << 0;
			nBitmask0 += m_reserved1 << 1;
			nBitmask0 += m_fNotShowInt << 4;
			nBitmask0 += m_fNotShowBrd << 5;
			nBitmask0 += m_reserved2 << 6;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			pBlobView->PackUint16(m_icvFore);
			pBlobView->PackUint16(m_icvBack);
			pBlobView->PackUint32(m_miSize);
		}

		void MarkerFormatRecord::SetDefaults()
		{
			m_rgbFore = 0;
			m_rgbBack = 0;
			m_imk = 0;
			m_fAuto = 0;
			m_reserved1 = 0;
			m_fNotShowInt = 0;
			m_fNotShowBrd = 0;
			m_reserved2 = 0;
			m_icvFore = 0;
			m_icvBack = 0;
			m_miSize = 0;
		}

		MarkerFormatRecord::MarkerFormatRecord(Marker* pMarker) : BiffRecord(TYPE, SIZE)
		{
			m_rgbFore = 0;
			m_rgbBack = 0;
			m_imk = 0;
			m_fAuto = 0;
			m_reserved1 = 0;
			m_fNotShowInt = 0;
			m_fNotShowBrd = 0;
			m_reserved2 = 0;
			m_icvFore = 0;
			m_icvBack = 0;
			m_miSize = 0;
			SetDefaults();
			Color* pColor = 0;
			switch (pMarker->GetType())
			{
				case Marker::Type::TYPE_NONE:
				{
					m_imk = 0x0000;
					break;
				}

				case Marker::Type::TYPE_SQUARE:
				{
					m_imk = 0x0001;
					break;
				}

				case Marker::Type::TYPE_DIAMOND:
				{
					m_imk = 0x0002;
					break;
				}

				case Marker::Type::TYPE_TRIANGLE:
				{
					m_imk = 0x0003;
					break;
				}

				case Marker::Type::TYPE_X:
				{
					m_imk = 0x0004;
					break;
				}

				case Marker::Type::TYPE_ASTERISK:
				{
					m_imk = 0x0005;
					break;
				}

				case Marker::Type::TYPE_SHORT_BAR:
				{
					m_imk = 0x0006;
					break;
				}

				case Marker::Type::TYPE_LONG_BAR:
				{
					m_imk = 0x0007;
					break;
				}

				case Marker::Type::TYPE_CIRCULAR:
				{
					m_imk = 0x0008;
					break;
				}

				case Marker::Type::TYPE_PLUS:
				{
					m_imk = 0x0009;
					break;
				}

				default:
				{
					nbAssert::Assert(false);
					break;
				}

			}
			pColor = pMarker->GetBorderColor(false);
			if (pColor != 0)
			{
				m_icvFore = BiffWorkbookGlobals::SnapToPalette(pColor);
				m_rgbFore = BiffWorkbookGlobals::GetDefaultPaletteColorByIndex(m_icvFore) & 0xFFFFFF;
			}
			else
			{
				m_fNotShowBrd = 0x1;
				m_icvFore = 0x004D;
			}
			pColor = pMarker->GetFillColor(false);
			if (pColor != 0)
			{
				m_icvBack = BiffWorkbookGlobals::SnapToPalette(pColor);
				m_rgbBack = BiffWorkbookGlobals::GetDefaultPaletteColorByIndex(m_icvBack) & 0xFFFFFF;
			}
			else
			{
				m_fNotShowInt = 0x1;
				m_icvBack = 0x004D;
			}
			m_miSize = WorksheetImplementation::PixelsToTwips((unsigned short)(pMarker->GetSize()));
		}

		void MarkerFormatRecord::ModifyMarker(Marker* pMarker, BiffWorkbookGlobals* pBiffWorkbookGlobals)
		{
			if (m_fAuto == 0x1)
				return;
			switch (m_imk)
			{
				case 0x0001:
				{
					pMarker->SetType(Marker::Type::TYPE_SQUARE);
					break;
				}

				case 0x0002:
				{
					pMarker->SetType(Marker::Type::TYPE_DIAMOND);
					break;
				}

				case 0x0003:
				{
					pMarker->SetType(Marker::Type::TYPE_TRIANGLE);
					break;
				}

				case 0x0004:
				{
					pMarker->SetType(Marker::Type::TYPE_X);
					break;
				}

				case 0x0005:
				{
					pMarker->SetType(Marker::Type::TYPE_ASTERISK);
					break;
				}

				case 0x0006:
				{
					pMarker->SetType(Marker::Type::TYPE_SHORT_BAR);
					break;
				}

				case 0x0007:
				{
					pMarker->SetType(Marker::Type::TYPE_LONG_BAR);
					break;
				}

				case 0x0008:
				{
					pMarker->SetType(Marker::Type::TYPE_CIRCULAR);
					break;
				}

				case 0x0009:
				{
					pMarker->SetType(Marker::Type::TYPE_PLUS);
					break;
				}

				default:
				{
					pMarker->SetType(Marker::Type::TYPE_NONE);
					break;
				}

			}
			if (m_fNotShowBrd == 0x0)
				pMarker->GetBorderColor(true)->Set((unsigned char)(m_rgbFore & 0xFF), (unsigned char)((m_rgbFore >> 8) & 0xFF), (unsigned char)((m_rgbFore >> 16) & 0xFF));
			else
				pMarker->ClearBorderColor();
			if (m_fNotShowInt == 0x0)
				pMarker->GetFillColor(true)->Set((unsigned char)(m_rgbBack & 0xFF), (unsigned char)((m_rgbBack >> 8) & 0xFF), (unsigned char)((m_rgbBack >> 16) & 0xFF));
			else
				pMarker->ClearFillColor();
			pMarker->SetSize(WorksheetImplementation::TwipsToPixels((unsigned short)(m_miSize)));
		}

		LineRecord::LineRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_fStacked = 0;
			m_f100 = 0;
			m_fHasShadow = 0;
			m_reserved = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_Line);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void LineRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fStacked = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_f100 = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fHasShadow = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_reserved = (unsigned short)((nBitmask0 >> 3) & 0x1fff);
		}

		void LineRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_fStacked << 0;
			nBitmask0 += m_f100 << 1;
			nBitmask0 += m_fHasShadow << 2;
			nBitmask0 += m_reserved << 3;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
		}

		void LineRecord::SetDefaults()
		{
			m_fStacked = 0;
			m_f100 = 0;
			m_fHasShadow = 0;
			m_reserved = 0;
		}

		LineRecord::LineRecord(Chart::Type eType) : BiffRecord(TYPE, SIZE)
		{
			m_fStacked = 0;
			m_f100 = 0;
			m_fHasShadow = 0;
			m_reserved = 0;
			SetDefaults();
			nbAssert::Assert(eType == Chart::Type::TYPE_LINE || eType == Chart::Type::TYPE_LINE_STACKED || eType == Chart::Type::TYPE_LINE_STACKED_100);
			if (eType == Chart::Type::TYPE_LINE_STACKED || eType == Chart::Type::TYPE_LINE_STACKED_100)
				m_fStacked = 0x1;
			if (eType == Chart::Type::TYPE_LINE_STACKED_100)
				m_f100 = 0x1;
		}

		Chart::Type LineRecord::GetChartType()
		{
			if (m_fStacked == 0x1)
				if (m_f100 == 0x1)
					return Chart::Type::TYPE_LINE_STACKED_100;
				else
					return Chart::Type::TYPE_LINE_STACKED;
			return Chart::Type::TYPE_LINE;
		}

		LineFormatRecord::LineFormatRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_rgb = 0;
			m_lns = 0;
			m_we = 0;
			m_fAuto = 0;
			m_reserved1 = 0;
			m_fAxisOn = 0;
			m_fAutoCo = 0;
			m_reserved2 = 0;
			m_icv = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_LineFormat);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void LineFormatRecord::BlobRead(BlobView* pBlobView)
		{
			m_rgb = pBlobView->UnpackUint32();
			m_lns = pBlobView->UnpackUint16();
			m_we = pBlobView->UnpackInt16();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fAuto = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_reserved1 = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fAxisOn = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_fAutoCo = (unsigned short)((nBitmask0 >> 3) & 0x1);
			m_reserved2 = (unsigned short)((nBitmask0 >> 4) & 0xfff);
			m_icv = pBlobView->UnpackUint16();
		}

		void LineFormatRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint32(m_rgb);
			pBlobView->PackUint16(m_lns);
			pBlobView->PackInt16(m_we);
			int nBitmask0 = 0;
			nBitmask0 += m_fAuto << 0;
			nBitmask0 += m_reserved1 << 1;
			nBitmask0 += m_fAxisOn << 2;
			nBitmask0 += m_fAutoCo << 3;
			nBitmask0 += m_reserved2 << 4;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			pBlobView->PackUint16(m_icv);
		}

		void LineFormatRecord::SetDefaults()
		{
			m_rgb = 0;
			m_lns = 0;
			m_we = 0;
			m_fAuto = 0;
			m_reserved1 = 0;
			m_fAxisOn = 0;
			m_fAutoCo = 0;
			m_reserved2 = 0;
			m_icv = 0;
		}

		LineFormatRecord::LineFormatRecord(unsigned int rgb, unsigned short lns, short we, bool fAuto, bool fAxisOn, bool fAutoCo, unsigned short icv) : BiffRecord(TYPE, SIZE)
		{
			m_rgb = 0;
			m_lns = 0;
			m_we = 0;
			m_fAuto = 0;
			m_reserved1 = 0;
			m_fAxisOn = 0;
			m_fAutoCo = 0;
			m_reserved2 = 0;
			m_icv = 0;
			SetDefaults();
			m_rgb = rgb;
			m_lns = lns;
			m_we = we;
			m_fAuto = fAuto ? (unsigned short)(0x1) : (unsigned short)(0x0);
			m_fAxisOn = fAxisOn ? (unsigned short)(0x1) : (unsigned short)(0x0);
			m_fAutoCo = fAutoCo ? (unsigned short)(0x1) : (unsigned short)(0x0);
			m_icv = icv;
		}

		LineFormatRecord::LineFormatRecord(Line* pLine, bool bAxis) : BiffRecord(TYPE, SIZE)
		{
			m_rgb = 0;
			m_lns = 0;
			m_we = 0;
			m_fAuto = 0;
			m_reserved1 = 0;
			m_fAxisOn = 0;
			m_fAutoCo = 0;
			m_reserved2 = 0;
			m_icv = 0;
			SetDefaults();
			m_icv = BiffWorkbookGlobals::SnapToPalette(pLine->GetColor());
			m_rgb = BiffWorkbookGlobals::GetDefaultPaletteColorByIndex(m_icv) & 0xFFFFFF;
			switch (pLine->GetType())
			{
				case Line::Type::TYPE_NONE:
				{
					m_lns = 0x0005;
					m_we = -1;
					break;
				}

				case Line::Type::TYPE_THIN:
				{
					m_lns = 0x0000;
					m_we = -1;
					break;
				}

				case Line::Type::TYPE_DASHED:
				{
					m_lns = 0x0001;
					m_we = -1;
					break;
				}

				case Line::Type::TYPE_DOTTED:
				{
					m_lns = 0x0002;
					m_we = -1;
					break;
				}

				case Line::Type::TYPE_DASH_DOT:
				{
					m_lns = 0x0003;
					m_we = -1;
					break;
				}

				case Line::Type::TYPE_DASH_DOT_DOT:
				{
					m_lns = 0x0004;
					m_we = -1;
					break;
				}

				case Line::Type::TYPE_MEDIUM:
				{
					m_lns = 0x0000;
					m_we = 0x0001;
					break;
				}

				case Line::Type::TYPE_MEDIUM_DASHED:
				{
					m_lns = 0x0001;
					m_we = 0x0001;
					break;
				}

				case Line::Type::TYPE_MEDIUM_DASH_DOT:
				{
					m_lns = 0x0003;
					m_we = 0x0001;
					break;
				}

				case Line::Type::TYPE_MEDIUM_DASH_DOT_DOT:
				{
					m_lns = 0x0004;
					m_we = 0x0001;
					break;
				}

				case Line::Type::TYPE_THICK:
				{
					m_lns = 0x0000;
					m_we = 0x0002;
					break;
				}

				default:
				{
					break;
				}

			}
			if (bAxis)
				m_fAxisOn = 0x1;
		}

		void LineFormatRecord::ModifyLine(Line* pLine, BiffWorkbookGlobals* pBiffWorkbookGlobals)
		{
			if (m_fAuto == 0x1)
				return;
			if (m_lns == 0x0005)
			{
				pLine->SetType(Line::Type::TYPE_NONE);
			}
			else
			{
				switch (m_we)
				{
					case 0x0002:
					{
						pLine->SetType(Line::Type::TYPE_THICK);
						break;
					}

					case 0x0001:
					{
						switch (m_lns)
						{
							case 0x0000:
							{
								pLine->SetType(Line::Type::TYPE_MEDIUM);
								break;
							}

							case 0x0001:
							{
								pLine->SetType(Line::Type::TYPE_MEDIUM_DASHED);
								break;
							}

							case 0x0003:
							{
								pLine->SetType(Line::Type::TYPE_MEDIUM_DASH_DOT);
								break;
							}

							case 0x0004:
							{
								pLine->SetType(Line::Type::TYPE_MEDIUM_DASH_DOT_DOT);
								break;
							}

							default:
							{
								pLine->SetType(Line::Type::TYPE_MEDIUM);
								break;
							}

						}
						break;
					}

					case 0x0000:
					case -1:
					{
						switch (m_lns)
						{
							case 0x0000:
							{
								pLine->SetType(Line::Type::TYPE_THIN);
								break;
							}

							case 0x0001:
							{
								pLine->SetType(Line::Type::TYPE_DASHED);
								break;
							}

							case 0x0002:
							{
								pLine->SetType(Line::Type::TYPE_DOTTED);
								break;
							}

							case 0x0003:
							{
								pLine->SetType(Line::Type::TYPE_DASH_DOT);
								break;
							}

							case 0x0004:
							{
								pLine->SetType(Line::Type::TYPE_DASH_DOT_DOT);
								break;
							}

							default:
							{
								pLine->SetType(Line::Type::TYPE_THIN);
								break;
							}

						}
						break;
					}

				}
			}
			if (m_icv != BiffWorkbookGlobals::PALETTE_INDEX_DEFAULT_CHART_FOREGROUND && m_icv != BiffWorkbookGlobals::PALETTE_INDEX_DEFAULT_CHART_BACKGROUND)
				pLine->GetColor()->SetFromRgba(pBiffWorkbookGlobals->GetPaletteColorByIndex(m_icv));
		}

		void LineFormatRecord::PackForChecksum(BlobView* pBlobView)
		{
			pBlobView->PackUint8((unsigned char)(m_icv));
			pBlobView->PackUint8((unsigned char)(m_lns));
			pBlobView->PackUint8((unsigned char)(m_we));
			int nBitMask = 0;
			nBitMask = nBitMask | m_fAuto << 0;
			pBlobView->PackUint8((unsigned char)(nBitMask));
			pBlobView->PackUint32(m_rgb);
		}

		LegendRecord::LegendRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_x = 0;
			m_y = 0;
			m_dx = 0;
			m_dy = 0;
			m_unused = 0;
			m_wSpace = 0;
			m_fAutoPosition = 0;
			m_reserved1 = 0;
			m_fAutoPosX = 0;
			m_fAutoPosY = 0;
			m_fVert = 0;
			m_fWasDataTable = 0;
			m_reserved2 = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_Legend);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void LegendRecord::BlobRead(BlobView* pBlobView)
		{
			m_x = pBlobView->UnpackUint32();
			m_y = pBlobView->UnpackUint32();
			m_dx = pBlobView->UnpackUint32();
			m_dy = pBlobView->UnpackUint32();
			m_unused = pBlobView->UnpackUint8();
			m_wSpace = pBlobView->UnpackUint8();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fAutoPosition = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_reserved1 = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fAutoPosX = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_fAutoPosY = (unsigned short)((nBitmask0 >> 3) & 0x1);
			m_fVert = (unsigned short)((nBitmask0 >> 4) & 0x1);
			m_fWasDataTable = (unsigned short)((nBitmask0 >> 5) & 0x1);
			m_reserved2 = (unsigned short)((nBitmask0 >> 6) & 0x3ff);
		}

		void LegendRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint32(m_x);
			pBlobView->PackUint32(m_y);
			pBlobView->PackUint32(m_dx);
			pBlobView->PackUint32(m_dy);
			pBlobView->PackUint8(m_unused);
			pBlobView->PackUint8(m_wSpace);
			int nBitmask0 = 0;
			nBitmask0 += m_fAutoPosition << 0;
			nBitmask0 += m_reserved1 << 1;
			nBitmask0 += m_fAutoPosX << 2;
			nBitmask0 += m_fAutoPosY << 3;
			nBitmask0 += m_fVert << 4;
			nBitmask0 += m_fWasDataTable << 5;
			nBitmask0 += m_reserved2 << 6;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
		}

		void LegendRecord::SetDefaults()
		{
			m_x = 0;
			m_y = 0;
			m_dx = 0;
			m_dy = 0;
			m_unused = 0x03;
			m_wSpace = 0x01;
			m_fAutoPosition = 1;
			m_reserved1 = 1;
			m_fAutoPosX = 1;
			m_fAutoPosY = 1;
			m_fVert = 1;
			m_fWasDataTable = 0;
			m_reserved2 = 0;
		}

		LegendRecord::LegendRecord(const Legend* pLegend) : BiffRecord(TYPE, SIZE)
		{
			m_x = 0;
			m_y = 0;
			m_dx = 0;
			m_dy = 0;
			m_unused = 0;
			m_wSpace = 0;
			m_fAutoPosition = 0;
			m_reserved1 = 0;
			m_fAutoPosX = 0;
			m_fAutoPosY = 0;
			m_fVert = 0;
			m_fWasDataTable = 0;
			m_reserved2 = 0;
			SetDefaults();
			nbAssert::Assert(!pLegend->GetHidden());
		}

		void LegendRecord::ModifyLegend(Legend* pLegend, BiffWorkbookGlobals* pBiffWorkbookGlobals)
		{
			pLegend->SetHidden(false);
		}

		LeftMarginRecord::LeftMarginRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_num = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_LEFT_MARGIN);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void LeftMarginRecord::BlobRead(BlobView* pBlobView)
		{
			m_num = pBlobView->UnpackDouble();
		}

		void LeftMarginRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackDouble(m_num);
		}

		void LeftMarginRecord::SetDefaults()
		{
			m_num = 0;
		}

		LeftMarginRecord::LeftMarginRecord(double num) : BiffRecord(TYPE, SIZE)
		{
			m_num = 0;
			SetDefaults();
			m_num = num;
		}

		LabelSstRecord::LabelSstRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_nRowIndex = 0;
			m_nColumnIndex = 0;
			m_nXfIndex = 0;
			m_nSstIndex = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_LABELSST);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void LabelSstRecord::BlobRead(BlobView* pBlobView)
		{
			m_nRowIndex = pBlobView->UnpackUint16();
			m_nColumnIndex = pBlobView->UnpackUint16();
			m_nXfIndex = pBlobView->UnpackUint16();
			m_nSstIndex = pBlobView->UnpackUint32();
		}

		void LabelSstRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_nRowIndex);
			pBlobView->PackUint16(m_nColumnIndex);
			pBlobView->PackUint16(m_nXfIndex);
			pBlobView->PackUint32(m_nSstIndex);
		}

		void LabelSstRecord::SetDefaults()
		{
			m_nRowIndex = 0;
			m_nColumnIndex = 0;
			m_nXfIndex = 0;
			m_nSstIndex = 0;
		}

		LabelSstRecord::LabelSstRecord(unsigned short nX, unsigned short nY, unsigned short nXfIndex, unsigned int nSstIndex) : BiffRecord(TYPE, SIZE)
		{
			m_nRowIndex = 0;
			m_nColumnIndex = 0;
			m_nXfIndex = 0;
			m_nSstIndex = 0;
			SetDefaults();
			m_nRowIndex = nY;
			m_nColumnIndex = nX;
			m_nXfIndex = nXfIndex;
			m_nSstIndex = nSstIndex;
		}

		unsigned short LabelSstRecord::GetX()
		{
			return m_nColumnIndex;
		}

		unsigned short LabelSstRecord::GetY()
		{
			return m_nRowIndex;
		}

		unsigned short LabelSstRecord::GetXfIndex()
		{
			return m_nXfIndex;
		}

		unsigned int LabelSstRecord::GetSstIndex()
		{
			return m_nSstIndex;
		}

		InterfaceHdr::InterfaceHdr() : BiffRecord(TYPE, SIZE)
		{
			m_codePage = 0;
			SetDefaults();
		}

		InterfaceHdr::InterfaceHdr(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_codePage = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_INTERFACE_HDR);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void InterfaceHdr::BlobRead(BlobView* pBlobView)
		{
			m_codePage = pBlobView->UnpackUint16();
		}

		void InterfaceHdr::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_codePage);
		}

		void InterfaceHdr::SetDefaults()
		{
			m_codePage = 0x04B0;
		}

		InterfaceEnd::InterfaceEnd() : BiffRecord(TYPE, SIZE)
		{
			SetDefaults();
		}

		InterfaceEnd::InterfaceEnd(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_INTERFACE_END);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void InterfaceEnd::BlobRead(BlobView* pBlobView)
		{
		}

		void InterfaceEnd::BlobWrite(BlobView* pBlobView)
		{
		}

		void InterfaceEnd::SetDefaults()
		{
		}

		HideObj::HideObj() : BiffRecord(TYPE, SIZE)
		{
			m_hideObj = 0;
			SetDefaults();
		}

		HideObj::HideObj(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_hideObj = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_HIDE_OBJ);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void HideObj::BlobRead(BlobView* pBlobView)
		{
			m_hideObj = pBlobView->UnpackUint16();
		}

		void HideObj::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_hideObj);
		}

		void HideObj::SetDefaults()
		{
			m_hideObj = 0;
		}

		HeaderFooterRecord::HeaderFooterRecord() : BiffRecord(TYPE, SIZE)
		{
			m_frtHeader = 0;
			m_guidSView_0 = 0;
			m_guidSView_1 = 0;
			m_guidSView_2 = 0;
			m_guidSView_3 = 0;
			m_guidSView_4 = 0;
			m_guidSView_5 = 0;
			m_guidSView_6 = 0;
			m_guidSView_7 = 0;
			m_guidSView_8 = 0;
			m_guidSView_9 = 0;
			m_guidSView_10 = 0;
			m_guidSView_11 = 0;
			m_guidSView_12 = 0;
			m_guidSView_13 = 0;
			m_guidSView_14 = 0;
			m_guidSView_15 = 0;
			m_fHFDiffOddEven = 0;
			m_fHFDiffFirst = 0;
			m_fHFScaleWithDoc = 0;
			m_fHFAlignMargins = 0;
			m_unused = 0;
			m_cchHeaderEven = 0;
			m_cchFooterEven = 0;
			m_cchHeaderFirst = 0;
			m_cchFooterFirst = 0;
			SetDefaults();
		}

		HeaderFooterRecord::HeaderFooterRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_frtHeader = 0;
			m_guidSView_0 = 0;
			m_guidSView_1 = 0;
			m_guidSView_2 = 0;
			m_guidSView_3 = 0;
			m_guidSView_4 = 0;
			m_guidSView_5 = 0;
			m_guidSView_6 = 0;
			m_guidSView_7 = 0;
			m_guidSView_8 = 0;
			m_guidSView_9 = 0;
			m_guidSView_10 = 0;
			m_guidSView_11 = 0;
			m_guidSView_12 = 0;
			m_guidSView_13 = 0;
			m_guidSView_14 = 0;
			m_guidSView_15 = 0;
			m_fHFDiffOddEven = 0;
			m_fHFDiffFirst = 0;
			m_fHFScaleWithDoc = 0;
			m_fHFAlignMargins = 0;
			m_unused = 0;
			m_cchHeaderEven = 0;
			m_cchFooterEven = 0;
			m_cchHeaderFirst = 0;
			m_cchFooterFirst = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_HeaderFooter);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void HeaderFooterRecord::BlobRead(BlobView* pBlobView)
		{
			m_frtHeader->BlobRead(pBlobView);
			m_guidSView_0 = pBlobView->UnpackUint8();
			m_guidSView_1 = pBlobView->UnpackUint8();
			m_guidSView_2 = pBlobView->UnpackUint8();
			m_guidSView_3 = pBlobView->UnpackUint8();
			m_guidSView_4 = pBlobView->UnpackUint8();
			m_guidSView_5 = pBlobView->UnpackUint8();
			m_guidSView_6 = pBlobView->UnpackUint8();
			m_guidSView_7 = pBlobView->UnpackUint8();
			m_guidSView_8 = pBlobView->UnpackUint8();
			m_guidSView_9 = pBlobView->UnpackUint8();
			m_guidSView_10 = pBlobView->UnpackUint8();
			m_guidSView_11 = pBlobView->UnpackUint8();
			m_guidSView_12 = pBlobView->UnpackUint8();
			m_guidSView_13 = pBlobView->UnpackUint8();
			m_guidSView_14 = pBlobView->UnpackUint8();
			m_guidSView_15 = pBlobView->UnpackUint8();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fHFDiffOddEven = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fHFDiffFirst = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fHFScaleWithDoc = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_fHFAlignMargins = (unsigned short)((nBitmask0 >> 3) & 0x1);
			m_unused = (unsigned short)((nBitmask0 >> 4) & 0xfff);
			m_cchHeaderEven = pBlobView->UnpackUint16();
			m_cchFooterEven = pBlobView->UnpackUint16();
			m_cchHeaderFirst = pBlobView->UnpackUint16();
			m_cchFooterFirst = pBlobView->UnpackUint16();
		}

		void HeaderFooterRecord::BlobWrite(BlobView* pBlobView)
		{
			m_frtHeader->BlobWrite(pBlobView);
			pBlobView->PackUint8(m_guidSView_0);
			pBlobView->PackUint8(m_guidSView_1);
			pBlobView->PackUint8(m_guidSView_2);
			pBlobView->PackUint8(m_guidSView_3);
			pBlobView->PackUint8(m_guidSView_4);
			pBlobView->PackUint8(m_guidSView_5);
			pBlobView->PackUint8(m_guidSView_6);
			pBlobView->PackUint8(m_guidSView_7);
			pBlobView->PackUint8(m_guidSView_8);
			pBlobView->PackUint8(m_guidSView_9);
			pBlobView->PackUint8(m_guidSView_10);
			pBlobView->PackUint8(m_guidSView_11);
			pBlobView->PackUint8(m_guidSView_12);
			pBlobView->PackUint8(m_guidSView_13);
			pBlobView->PackUint8(m_guidSView_14);
			pBlobView->PackUint8(m_guidSView_15);
			int nBitmask0 = 0;
			nBitmask0 += m_fHFDiffOddEven << 0;
			nBitmask0 += m_fHFDiffFirst << 1;
			nBitmask0 += m_fHFScaleWithDoc << 2;
			nBitmask0 += m_fHFAlignMargins << 3;
			nBitmask0 += m_unused << 4;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			pBlobView->PackUint16(m_cchHeaderEven);
			pBlobView->PackUint16(m_cchFooterEven);
			pBlobView->PackUint16(m_cchHeaderFirst);
			pBlobView->PackUint16(m_cchFooterFirst);
		}

		void HeaderFooterRecord::SetDefaults()
		{
			m_frtHeader = new FrtHeaderStruct();
			m_guidSView_0 = 0;
			m_guidSView_1 = 0;
			m_guidSView_2 = 0;
			m_guidSView_3 = 0;
			m_guidSView_4 = 0;
			m_guidSView_5 = 0;
			m_guidSView_6 = 0;
			m_guidSView_7 = 0;
			m_guidSView_8 = 0;
			m_guidSView_9 = 0;
			m_guidSView_10 = 0;
			m_guidSView_11 = 0;
			m_guidSView_12 = 0;
			m_guidSView_13 = 0;
			m_guidSView_14 = 0;
			m_guidSView_15 = 0;
			m_fHFDiffOddEven = 0;
			m_fHFDiffFirst = 0;
			m_fHFScaleWithDoc = 0x1;
			m_fHFAlignMargins = 0x1;
			m_unused = 819;
			m_cchHeaderEven = 0;
			m_cchFooterEven = 0;
			m_cchHeaderFirst = 0;
			m_cchFooterFirst = 0;
			PostSetDefaults();
		}

		void HeaderFooterRecord::PostSetDefaults()
		{
			m_frtHeader->m_rt = 2204;
		}

		HeaderFooterRecord::~HeaderFooterRecord()
		{
			if (m_frtHeader) delete m_frtHeader;
		}

		HCenterRecord::HCenterRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_hcenter = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_HCENTER);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void HCenterRecord::BlobRead(BlobView* pBlobView)
		{
			m_hcenter = pBlobView->UnpackUint16();
		}

		void HCenterRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_hcenter);
		}

		void HCenterRecord::SetDefaults()
		{
			m_hcenter = 0x0000;
		}

		HCenterRecord::HCenterRecord(bool bCenter) : BiffRecord(TYPE, SIZE)
		{
			m_hcenter = 0;
			SetDefaults();
			if (bCenter)
				m_hcenter = 0x1;
		}

		GelFrameRecord::GelFrameRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_OPT1 = 0;
			m_OPT2 = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_GelFrame);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void GelFrameRecord::BlobRead(BlobView* pBlobView)
		{
			PostBlobRead(pBlobView);
		}

		void GelFrameRecord::BlobWrite(BlobView* pBlobView)
		{
			PostBlobWrite(pBlobView);
		}

		void GelFrameRecord::SetDefaults()
		{
			PostSetDefaults();
		}

		GelFrameRecord::GelFrameRecord(Fill* pFill, WorkbookGlobals* pWorkbookGlobals) : BiffRecord(TYPE, SIZE)
		{
			m_OPT1 = 0;
			m_OPT2 = 0;
			SetDefaults();
			nbAssert::Assert(pFill != 0);
			nbAssert::Assert(pWorkbookGlobals != 0);
			m_OPT1 = new OfficeArtFOPTRecord();
			{
				Color* pColor = pFill->GetForegroundColor();
				unsigned char nR = pColor->GetRed();
				unsigned char nG = pColor->GetGreen();
				unsigned char nB = pColor->GetBlue();
				m_OPT1->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_FILL_COLOR), 0, nR << 0 | nG << 8 | nB << 16);
				m_OPT1->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_FILL_OPACITY), 0, 65536);
			}
			{
				Color* pColor = pFill->GetBackgroundColor();
				unsigned char nR = pColor->GetRed();
				unsigned char nG = pColor->GetGreen();
				unsigned char nB = pColor->GetBlue();
				m_OPT1->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_FILL_BACK_COLOR), 0, nR << 0 | nG << 8 | nB << 16);
				m_OPT1->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_FILL_BACK_OPACITY), 0, 65536);
			}
			m_OPT2 = new OfficeArtTertiaryFOPTRecord();
			m_pHeader->m_nSize = m_OPT1->GetSize() + m_OPT2->GetSize();
		}

		void GelFrameRecord::PostSetDefaults()
		{
			m_OPT1 = 0;
			m_OPT2 = 0;
		}

		void GelFrameRecord::PostBlobRead(BlobView* pBlobView)
		{
			OfficeArtRecord* pOfficeArtRecord = 0;
			nbAssert::Assert(m_OPT1 == 0);
			pOfficeArtRecord = OfficeArtRecord::CreateOfficeArtRecord(pBlobView);
			nbAssert::Assert(pOfficeArtRecord != 0);
			nbAssert::Assert(pOfficeArtRecord->GetType() == OfficeArtRecord::Type::TYPE_OFFICE_ART_FOPT);
			{
				NumberDuck::Secret::OfficeArtRecord* __3533451309 = pOfficeArtRecord;
				pOfficeArtRecord = 0;
				m_OPT1 = (OfficeArtFOPTRecord*)(__3533451309);
			}
			nbAssert::Assert(m_OPT2 == 0);
			pOfficeArtRecord = OfficeArtRecord::CreateOfficeArtRecord(pBlobView);
			nbAssert::Assert(pOfficeArtRecord != 0);
			nbAssert::Assert(pOfficeArtRecord->GetType() == OfficeArtRecord::Type::TYPE_OFFICE_ART_TERTIARY_FOPT);
			{
				NumberDuck::Secret::OfficeArtRecord* __3533451309 = pOfficeArtRecord;
				pOfficeArtRecord = 0;
				m_OPT2 = (OfficeArtTertiaryFOPTRecord*)(__3533451309);
			}
			if (pOfficeArtRecord) delete pOfficeArtRecord;
		}

		void GelFrameRecord::PostBlobWrite(BlobView* pBlobView)
		{
			m_OPT1->BlobWrite(pBlobView);
			m_OPT2->BlobWrite(pBlobView);
		}

		void GelFrameRecord::ModifyFill(Fill* pFill, WorkbookGlobals* pWorkbookGlobals)
		{
			OfficeArtFOPTEStruct* pProperty = 0;
			pProperty = m_OPT1->GetProperty(OfficeArtRecord::OPIDType::OPID_FILL_COLOR);
			if (pProperty != 0)
				pFill->GetForegroundColor()->Set((unsigned char)(pProperty->m_op & 0xFF), (unsigned char)((pProperty->m_op >> 8) & 0xFF), (unsigned char)((pProperty->m_op >> 16) & 0xFF));
			pProperty = m_OPT1->GetProperty(OfficeArtRecord::OPIDType::OPID_FILL_BACK_COLOR);
			if (pProperty != 0)
				pFill->GetBackgroundColor()->Set((unsigned char)(pProperty->m_op & 0xFF), (unsigned char)((pProperty->m_op >> 8) & 0xFF), (unsigned char)((pProperty->m_op >> 16) & 0xFF));
		}

		void GelFrameRecord::PackForChecksum(BlobView* pBlobView)
		{
		}

		GelFrameRecord::~GelFrameRecord()
		{
			if (m_OPT1) delete m_OPT1;
			if (m_OPT2) delete m_OPT2;
		}

		FrameRecord::FrameRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_frt = 0;
			m_fAutoSize = 0;
			m_fAutoPosition = 0;
			m_reserved = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_Frame);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void FrameRecord::BlobRead(BlobView* pBlobView)
		{
			m_frt = pBlobView->UnpackUint16();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fAutoSize = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fAutoPosition = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_reserved = (unsigned short)((nBitmask0 >> 2) & 0x3fff);
		}

		void FrameRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_frt);
			int nBitmask0 = 0;
			nBitmask0 += m_fAutoSize << 0;
			nBitmask0 += m_fAutoPosition << 1;
			nBitmask0 += m_reserved << 2;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
		}

		void FrameRecord::SetDefaults()
		{
			m_frt = 0x0000;
			m_fAutoSize = 0;
			m_fAutoPosition = 0;
			m_reserved = 0;
		}

		FrameRecord::FrameRecord(bool fAutoSize) : BiffRecord(TYPE, SIZE)
		{
			m_frt = 0;
			m_fAutoSize = 0;
			m_fAutoPosition = 0;
			m_reserved = 0;
			SetDefaults();
			if (fAutoSize)
				m_fAutoSize = 0x1;
			m_fAutoPosition = 0x1;
		}

		bool FrameRecord::GetDropShadow()
		{
			return m_frt == 0x0004;
		}

		bool FrameRecord::GetAutoSize()
		{
			return m_fAutoSize == 0x1;
		}

		bool FrameRecord::GetAutoPosition()
		{
			return m_fAutoPosition == 0x1;
		}

		FormulaRecord::FormulaRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_cell = 0;
			m_val = 0;
			m_fAlwaysCalc = 0;
			m_reserved1 = 0;
			m_fFill = 0;
			m_fShrFmla = 0;
			m_reserved2 = 0;
			m_fClearErrors = 0;
			m_reserved3 = 0;
			m_chn = 0;
			m_formula = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_FORMULA);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void FormulaRecord::BlobRead(BlobView* pBlobView)
		{
			m_cell->BlobRead(pBlobView);
			m_val->BlobRead(pBlobView);
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fAlwaysCalc = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_reserved1 = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fFill = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_fShrFmla = (unsigned short)((nBitmask0 >> 3) & 0x1);
			m_reserved2 = (unsigned short)((nBitmask0 >> 4) & 0x1);
			m_fClearErrors = (unsigned short)((nBitmask0 >> 5) & 0x1);
			m_reserved3 = (unsigned short)((nBitmask0 >> 6) & 0x3ff);
			m_chn = pBlobView->UnpackUint32();
			PostBlobRead(pBlobView);
		}

		void FormulaRecord::BlobWrite(BlobView* pBlobView)
		{
			m_cell->BlobWrite(pBlobView);
			m_val->BlobWrite(pBlobView);
			int nBitmask0 = 0;
			nBitmask0 += m_fAlwaysCalc << 0;
			nBitmask0 += m_reserved1 << 1;
			nBitmask0 += m_fFill << 2;
			nBitmask0 += m_fShrFmla << 3;
			nBitmask0 += m_reserved2 << 4;
			nBitmask0 += m_fClearErrors << 5;
			nBitmask0 += m_reserved3 << 6;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			pBlobView->PackUint32(m_chn);
			PostBlobWrite(pBlobView);
		}

		void FormulaRecord::SetDefaults()
		{
			m_cell = new CellStruct();
			m_val = new FormulaValueStruct();
			m_fAlwaysCalc = 0;
			m_reserved1 = 0;
			m_fFill = 0;
			m_fShrFmla = 0;
			m_reserved2 = 0;
			m_fClearErrors = 0;
			m_reserved3 = 0;
			m_chn = 0;
			PostSetDefaults();
		}

		FormulaRecord::FormulaRecord(unsigned short nX, unsigned short nY, unsigned short nXfIndex, Formula* pFormula, WorkbookGlobals* pWorkbookGlobals) : BiffRecord(TYPE, SIZE)
		{
			m_cell = 0;
			m_val = 0;
			m_fAlwaysCalc = 0;
			m_reserved1 = 0;
			m_fFill = 0;
			m_fShrFmla = 0;
			m_reserved2 = 0;
			m_fClearErrors = 0;
			m_reserved3 = 0;
			m_chn = 0;
			m_formula = 0;
			SetDefaults();
			m_cell->m_col->m_col = nX;
			m_cell->m_rw->m_rw = nY;
			m_cell->m_ixfe->m_ixfe = nXfIndex;
			m_fAlwaysCalc = 0x1;
			nbAssert::Assert(m_formula == 0);
			m_formula = new CellParsedFormulaStruct(pFormula, pWorkbookGlobals);
			m_pHeader->m_nSize += (unsigned short)(m_formula->GetSize());
		}

		void FormulaRecord::PostSetDefaults()
		{
			m_formula = 0;
		}

		void FormulaRecord::PostBlobRead(BlobView* pBlobView)
		{
			nbAssert::Assert(m_formula == 0);
			m_formula = new CellParsedFormulaStruct();
			m_formula->BlobRead(pBlobView);
		}

		void FormulaRecord::PostBlobWrite(BlobView* pBlobView)
		{
			m_formula->BlobWrite(pBlobView);
		}

		unsigned short FormulaRecord::GetX()
		{
			return m_cell->m_col->m_col;
		}

		unsigned short FormulaRecord::GetY()
		{
			return m_cell->m_rw->m_rw;
		}

		unsigned short FormulaRecord::GetXfIndex()
		{
			return m_cell->m_ixfe->m_ixfe;
		}

		Formula* FormulaRecord::GetFormula(WorkbookGlobals* pWorkbookGlobals)
		{
			return new Formula(m_formula->m_rgce->m_pParsedExpressionRecordVector, pWorkbookGlobals);
		}

		FormulaRecord::~FormulaRecord()
		{
			if (m_cell) delete m_cell;
			if (m_val) delete m_val;
			if (m_formula) delete m_formula;
		}

		Format::Format(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_ifmt = 0;
			m_stFormat = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_FORMAT);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void Format::BlobRead(BlobView* pBlobView)
		{
			m_ifmt = pBlobView->UnpackUint16();
			m_stFormat->BlobRead(pBlobView);
		}

		void Format::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_ifmt);
			m_stFormat->BlobWrite(pBlobView);
		}

		void Format::SetDefaults()
		{
			m_ifmt = 0;
			m_stFormat = new XLUnicodeStringStruct();
		}

		Format::Format(unsigned short ifmt, const char* szFormat) : BiffRecord(TYPE, SIZE)
		{
			m_ifmt = 0;
			m_stFormat = 0;
			SetDefaults();
			nbAssert::Assert(ifmt >= 5 && ifmt <= 8 || ifmt >= 23 && ifmt <= 26 || ifmt >= 41 && ifmt <= 44 || ifmt >= 63 && ifmt <= 66 || ifmt >= 164 && ifmt <= 382 || ifmt >= 383 && ifmt <= 392);
			m_ifmt = ifmt;
			m_stFormat->m_rgb->Set(szFormat);
			m_pHeader->m_nSize += (unsigned int)(m_stFormat->GetDynamicSize());
		}

		unsigned short Format::GetFormatIndex()
		{
			return m_ifmt;
		}

		const char* Format::GetFormat()
		{
			return m_stFormat->m_rgb->GetExternalString();
		}

		Format::~Format()
		{
			if (m_stFormat) delete m_stFormat;
		}

		FontXRecord::FontXRecord() : BiffRecord(TYPE, SIZE)
		{
			m_iFont = 0;
			SetDefaults();
		}

		FontXRecord::FontXRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_iFont = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_FontX);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void FontXRecord::BlobRead(BlobView* pBlobView)
		{
			m_iFont = pBlobView->UnpackUint16();
		}

		void FontXRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_iFont);
		}

		void FontXRecord::SetDefaults()
		{
			m_iFont = 0x0001;
		}

		FontRecord::FontRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_dyHeight = 0;
			m_unused1 = 0;
			m_fItalic = 0;
			m_unused2 = 0;
			m_fStrikeOut = 0;
			m_fOutline = 0;
			m_fShadow = 0;
			m_fCondense = 0;
			m_fExtend = 0;
			m_reserved = 0;
			m_icv = 0;
			m_bls = 0;
			m_sss = 0;
			m_uls = 0;
			m_bFamily = 0;
			m_bCharSet = 0;
			m_unused3 = 0;
			m_fontName = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_FONT);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void FontRecord::BlobRead(BlobView* pBlobView)
		{
			m_dyHeight = pBlobView->UnpackUint16();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_unused1 = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fItalic = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_unused2 = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_fStrikeOut = (unsigned short)((nBitmask0 >> 3) & 0x1);
			m_fOutline = (unsigned short)((nBitmask0 >> 4) & 0x1);
			m_fShadow = (unsigned short)((nBitmask0 >> 5) & 0x1);
			m_fCondense = (unsigned short)((nBitmask0 >> 6) & 0x1);
			m_fExtend = (unsigned short)((nBitmask0 >> 7) & 0x1);
			m_reserved = (unsigned short)((nBitmask0 >> 8) & 0xff);
			m_icv->BlobRead(pBlobView);
			m_bls = pBlobView->UnpackUint16();
			m_sss = pBlobView->UnpackUint16();
			m_uls = pBlobView->UnpackUint8();
			m_bFamily = pBlobView->UnpackUint8();
			m_bCharSet = pBlobView->UnpackUint8();
			m_unused3 = pBlobView->UnpackUint8();
			m_fontName->BlobRead(pBlobView);
		}

		void FontRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_dyHeight);
			int nBitmask0 = 0;
			nBitmask0 += m_unused1 << 0;
			nBitmask0 += m_fItalic << 1;
			nBitmask0 += m_unused2 << 2;
			nBitmask0 += m_fStrikeOut << 3;
			nBitmask0 += m_fOutline << 4;
			nBitmask0 += m_fShadow << 5;
			nBitmask0 += m_fCondense << 6;
			nBitmask0 += m_fExtend << 7;
			nBitmask0 += m_reserved << 8;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			m_icv->BlobWrite(pBlobView);
			pBlobView->PackUint16(m_bls);
			pBlobView->PackUint16(m_sss);
			pBlobView->PackUint8(m_uls);
			pBlobView->PackUint8(m_bFamily);
			pBlobView->PackUint8(m_bCharSet);
			pBlobView->PackUint8(m_unused3);
			m_fontName->BlobWrite(pBlobView);
		}

		void FontRecord::SetDefaults()
		{
			m_dyHeight = 0;
			m_unused1 = 0;
			m_fItalic = 0;
			m_unused2 = 0;
			m_fStrikeOut = 0;
			m_fOutline = 0;
			m_fShadow = 0;
			m_fCondense = 0;
			m_fExtend = 0;
			m_reserved = 0;
			m_icv = new IcvFontStruct();
			m_bls = 0;
			m_sss = 0;
			m_uls = 0;
			m_bFamily = 0;
			m_bCharSet = 0;
			m_unused3 = 0;
			m_fontName = new ShortXLUnicodeStringStruct();
		}

		FontRecord::FontRecord(const char* szFontName, unsigned short nSizeTwips, unsigned short nColourIndex, bool bBold, bool bItalic, Font::Underline eUnderline, unsigned char unused1, unsigned char unused3) : BiffRecord(TYPE, SIZE)
		{
			m_dyHeight = 0;
			m_unused1 = 0;
			m_fItalic = 0;
			m_unused2 = 0;
			m_fStrikeOut = 0;
			m_fOutline = 0;
			m_fShadow = 0;
			m_fCondense = 0;
			m_fExtend = 0;
			m_reserved = 0;
			m_icv = 0;
			m_bls = 0;
			m_sss = 0;
			m_uls = 0;
			m_bFamily = 0;
			m_bCharSet = 0;
			m_unused3 = 0;
			m_fontName = 0;
			SetDefaults();
			m_dyHeight = nSizeTwips;
			m_unused1 = unused1;
			if (bItalic)
				m_fItalic = 0x1;
			nbAssert::Assert(nColourIndex >= BiffWorkbookGlobals::NUM_DEFAULT_PALETTE_ENTRY && nColourIndex < BiffWorkbookGlobals::NUM_DEFAULT_PALETTE_ENTRY + BiffWorkbookGlobals::NUM_CUSTOM_PALETTE_ENTRY || nColourIndex == BiffWorkbookGlobals::PALETTE_INDEX_DEFAULT_TOOL_TIP_TEXT || nColourIndex == BiffWorkbookGlobals::PALETTE_INDEX_DEFAULT_FONT_AUTOMATIC);
			m_icv->m_icv = nColourIndex;
			if (bBold)
				m_bls = 700;
			else
				m_bls = 400;
			m_uls = 0x0;
			switch (eUnderline)
			{
				case Font::Underline::UNDERLINE_SINGLE:
				{
					m_uls = 0x1;
					break;
				}

				case Font::Underline::UNDERLINE_DOUBLE:
				{
					m_uls = 0x2;
					break;
				}

				case Font::Underline::UNDERLINE_SINGLE_ACCOUNTING:
				{
					m_uls = 0x21;
					break;
				}

				case Font::Underline::UNDERLINE_DOUBLE_ACCOUNTING:
				{
					m_uls = 0x22;
					break;
				}

				case Font::Underline::UNDERLINE_NONE:
				{
					m_uls = 0x0;
					break;
				}

			}
			m_bFamily = 2;
			m_unused3 = unused3;
			m_fontName->m_rgb->Set(szFontName);
			m_pHeader->m_nSize += (unsigned int)(m_fontName->GetDynamicSize());
		}

		unsigned short FontRecord::GetColourIndex()
		{
			return m_icv->m_icv;
		}

		const char* FontRecord::GetName()
		{
			return m_fontName->m_rgb->GetExternalString();
		}

		unsigned short FontRecord::GetSizeTwips()
		{
			return m_dyHeight;
		}

		bool FontRecord::GetBold()
		{
			return m_bls >= 700;
		}

		bool FontRecord::GetItalic()
		{
			return m_fItalic == 0x1;
		}

		Font::Underline FontRecord::GetUnderline()
		{
			switch (m_uls)
			{
				case 0x1:
				{
					return Font::Underline::UNDERLINE_SINGLE;
				}

				case 0x2:
				{
					return Font::Underline::UNDERLINE_DOUBLE;
				}

				case 0x21:
				{
					return Font::Underline::UNDERLINE_SINGLE_ACCOUNTING;
				}

				case 0x22:
				{
					return Font::Underline::UNDERLINE_DOUBLE_ACCOUNTING;
				}

			}
			return Font::Underline::UNDERLINE_NONE;
		}

		FontRecord::~FontRecord()
		{
			if (m_icv) delete m_icv;
			if (m_fontName) delete m_fontName;
		}

		ExternSheetRecord::ExternSheetRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_cXTI = 0;
			m_pXTIVector = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_EXTERN_SHEET);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void ExternSheetRecord::BlobRead(BlobView* pBlobView)
		{
			m_cXTI = pBlobView->UnpackUint16();
			PostBlobRead(pBlobView);
		}

		void ExternSheetRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_cXTI);
			PostBlobWrite(pBlobView);
		}

		void ExternSheetRecord::SetDefaults()
		{
			m_cXTI = 0;
			PostSetDefaults();
		}

		ExternSheetRecord::ExternSheetRecord(OwnedVector<WorksheetRange*>* pWorksheetRangeVector) : BiffRecord(TYPE, (unsigned int)(SIZE + XTIStruct::SIZE * pWorksheetRangeVector->GetSize()))
		{
			m_cXTI = 0;
			m_pXTIVector = 0;
			SetDefaults();
			m_cXTI = (unsigned short)(pWorksheetRangeVector->GetSize());
			nbAssert::Assert(m_pXTIVector == 0);
			m_pXTIVector = new OwnedVector<XTIStruct*>();
			for (unsigned short i = 0; i < m_cXTI; i++)
			{
				WorksheetRange* pWorksheetRange = pWorksheetRangeVector->Get(i);
				XTIStruct* pXTI = new XTIStruct();
				pXTI->m_iSupBook = 0;
				pXTI->m_itabFirst = (short)(pWorksheetRange->m_nFirst);
				pXTI->m_itabLast = (short)(pWorksheetRange->m_nLast);
				{
					NumberDuck::Secret::XTIStruct* __2160298696 = pXTI;
					pXTI = 0;
					m_pXTIVector->PushBack(__2160298696);
				}
				if (pXTI) delete pXTI;
			}
		}

		void ExternSheetRecord::PostSetDefaults()
		{
			m_pXTIVector = 0;
		}

		void ExternSheetRecord::PostBlobRead(BlobView* pBlobView)
		{
			nbAssert::Assert(m_pXTIVector == 0);
			m_pXTIVector = new OwnedVector<XTIStruct*>();
			for (unsigned short i = 0; i < m_cXTI; i++)
			{
				XTIStruct* pXTI = new XTIStruct();
				pXTI->BlobRead(pBlobView);
				{
					NumberDuck::Secret::XTIStruct* __2160298696 = pXTI;
					pXTI = 0;
					m_pXTIVector->PushBack(__2160298696);
				}
				if (pXTI) delete pXTI;
			}
		}

		void ExternSheetRecord::PostBlobWrite(BlobView* pBlobView)
		{
			for (unsigned short i = 0; i < m_cXTI; i++)
				m_pXTIVector->Get(i)->BlobWrite(pBlobView);
		}

		unsigned short ExternSheetRecord::GetNumXTI()
		{
			return m_cXTI;
		}

		XTIStruct* ExternSheetRecord::GetXTIByIndex(unsigned short nIndex)
		{
			nbAssert::Assert(nIndex < m_cXTI);
			return m_pXTIVector->Get(nIndex);
		}

		ExternSheetRecord::~ExternSheetRecord()
		{
			if (m_pXTIVector) delete m_pXTIVector;
		}

		Excel9File::Excel9File() : BiffRecord(TYPE, SIZE)
		{
			SetDefaults();
		}

		Excel9File::Excel9File(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_EXCEL9_FILE);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void Excel9File::BlobRead(BlobView* pBlobView)
		{
		}

		void Excel9File::BlobWrite(BlobView* pBlobView)
		{
		}

		void Excel9File::SetDefaults()
		{
		}

		EndBlockRecord::EndBlockRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_frtHeaderOld = 0;
			m_iObjectKind = 0;
			m_unused1 = 0;
			m_unused2 = 0;
			m_unused3 = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_EndBlock);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void EndBlockRecord::BlobRead(BlobView* pBlobView)
		{
			m_frtHeaderOld->BlobRead(pBlobView);
			m_iObjectKind = pBlobView->UnpackUint16();
			m_unused1 = pBlobView->UnpackUint16();
			m_unused2 = pBlobView->UnpackUint16();
			m_unused3 = pBlobView->UnpackUint16();
		}

		void EndBlockRecord::BlobWrite(BlobView* pBlobView)
		{
			m_frtHeaderOld->BlobWrite(pBlobView);
			pBlobView->PackUint16(m_iObjectKind);
			pBlobView->PackUint16(m_unused1);
			pBlobView->PackUint16(m_unused2);
			pBlobView->PackUint16(m_unused3);
		}

		void EndBlockRecord::SetDefaults()
		{
			m_frtHeaderOld = new FrtHeaderOldStruct();
			m_iObjectKind = 0;
			m_unused1 = 0;
			m_unused2 = 0;
			m_unused3 = 0;
		}

		EndBlockRecord::EndBlockRecord(unsigned short iObjectKind) : BiffRecord(TYPE, SIZE)
		{
			m_frtHeaderOld = 0;
			m_iObjectKind = 0;
			m_unused1 = 0;
			m_unused2 = 0;
			m_unused3 = 0;
			SetDefaults();
			m_frtHeaderOld->m_rt = 0x0853;
			m_iObjectKind = iObjectKind;
		}

		EndBlockRecord::~EndBlockRecord()
		{
			if (m_frtHeaderOld) delete m_frtHeaderOld;
		}

		DimensionRecord::DimensionRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_nFirstUsedRow = 0;
			m_nLastUsedRow = 0;
			m_nFirstUsedColumn = 0;
			m_nLastUsedColumn = 0;
			m_nUnused = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_DIMENSION);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void DimensionRecord::BlobRead(BlobView* pBlobView)
		{
			m_nFirstUsedRow = pBlobView->UnpackUint32();
			m_nLastUsedRow = pBlobView->UnpackUint32();
			m_nFirstUsedColumn = pBlobView->UnpackUint16();
			m_nLastUsedColumn = pBlobView->UnpackUint16();
			m_nUnused = pBlobView->UnpackUint16();
		}

		void DimensionRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint32(m_nFirstUsedRow);
			pBlobView->PackUint32(m_nLastUsedRow);
			pBlobView->PackUint16(m_nFirstUsedColumn);
			pBlobView->PackUint16(m_nLastUsedColumn);
			pBlobView->PackUint16(m_nUnused);
		}

		void DimensionRecord::SetDefaults()
		{
			m_nFirstUsedRow = 0;
			m_nLastUsedRow = 0;
			m_nFirstUsedColumn = 0;
			m_nLastUsedColumn = 0;
			m_nUnused = 0;
		}

		DimensionRecord::DimensionRecord(unsigned int nFirstUsedRow, unsigned int nLastUsedRow, unsigned short nFirstUsedColumn, unsigned short nLastUsedColumn, unsigned short nUnused) : BiffRecord(TYPE, SIZE)
		{
			m_nFirstUsedRow = 0;
			m_nLastUsedRow = 0;
			m_nFirstUsedColumn = 0;
			m_nLastUsedColumn = 0;
			m_nUnused = 0;
			SetDefaults();
			m_nFirstUsedRow = nFirstUsedRow;
			m_nLastUsedRow = nLastUsedRow;
			m_nFirstUsedColumn = nFirstUsedColumn;
			m_nLastUsedColumn = nLastUsedColumn;
			m_nUnused = nUnused;
		}

		DefaultTextRecord::DefaultTextRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_id = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_DefaultText);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void DefaultTextRecord::BlobRead(BlobView* pBlobView)
		{
			m_id = pBlobView->UnpackUint16();
		}

		void DefaultTextRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_id);
		}

		void DefaultTextRecord::SetDefaults()
		{
			m_id = 0;
		}

		DefaultTextRecord::DefaultTextRecord(unsigned short id) : BiffRecord(TYPE, SIZE)
		{
			m_id = 0;
			SetDefaults();
			m_id = id;
		}

		DefaultRowHeight::DefaultRowHeight(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_fUnsynced = 0;
			m_fDyZero = 0;
			m_fExAsc = 0;
			m_fExDsc = 0;
			m_reserved = 0;
			m_miyRw = 0;
			m_miyRwHidden = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_DEFAULTROWHEIGHT);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void DefaultRowHeight::BlobRead(BlobView* pBlobView)
		{
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fUnsynced = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fDyZero = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fExAsc = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_fExDsc = (unsigned short)((nBitmask0 >> 3) & 0x1);
			m_reserved = (unsigned short)((nBitmask0 >> 4) & 0xfff);
			PostBlobRead(pBlobView);
		}

		void DefaultRowHeight::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_fUnsynced << 0;
			nBitmask0 += m_fDyZero << 1;
			nBitmask0 += m_fExAsc << 2;
			nBitmask0 += m_fExDsc << 3;
			nBitmask0 += m_reserved << 4;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			PostBlobWrite(pBlobView);
		}

		void DefaultRowHeight::SetDefaults()
		{
			m_fUnsynced = 0;
			m_fDyZero = 0;
			m_fExAsc = 0;
			m_fExDsc = 0;
			m_reserved = 0;
		}

		DefaultRowHeight::DefaultRowHeight(short nRowHeight) : BiffRecord(TYPE, SIZE + 2)
		{
			m_fUnsynced = 0;
			m_fDyZero = 0;
			m_fExAsc = 0;
			m_fExDsc = 0;
			m_reserved = 0;
			m_miyRw = 0;
			m_miyRwHidden = 0;
			nbAssert::Assert(nRowHeight > 0);
			SetDefaults();
			m_fUnsynced = 1;
			m_miyRw = nRowHeight;
		}

		void DefaultRowHeight::PostBlobRead(BlobView* pBlobView)
		{
			m_miyRw = 0;
			m_miyRwHidden = 0;
			if (m_fDyZero == 0)
				m_miyRw = pBlobView->UnpackInt16();
			else
				m_miyRwHidden = pBlobView->UnpackInt16();
		}

		void DefaultRowHeight::PostBlobWrite(BlobView* pBlobView)
		{
			if (m_fDyZero == 0)
				pBlobView->PackInt16(m_miyRw);
			else
				pBlobView->PackInt16(m_miyRwHidden);
		}

		short DefaultRowHeight::GetRowHeight()
		{
			return m_miyRw;
		}

		DefColWidthRecord::DefColWidthRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_cchdefColWidth = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_DEFCOLWIDTH);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void DefColWidthRecord::BlobRead(BlobView* pBlobView)
		{
			m_cchdefColWidth = pBlobView->UnpackUint16();
		}

		void DefColWidthRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_cchdefColWidth);
		}

		void DefColWidthRecord::SetDefaults()
		{
			m_cchdefColWidth = 0;
		}

		DefColWidthRecord::DefColWidthRecord(unsigned short cchdefColWidth) : BiffRecord(TYPE, SIZE)
		{
			m_cchdefColWidth = 0;
			SetDefaults();
			m_cchdefColWidth = cchdefColWidth;
		}

		unsigned short DefColWidthRecord::GetColumnWidth()
		{
			return m_cchdefColWidth;
		}

		Date1904::Date1904() : BiffRecord(TYPE, SIZE)
		{
			m_f1904DateSystem = 0;
			SetDefaults();
		}

		Date1904::Date1904(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_f1904DateSystem = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_DATE_1904);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void Date1904::BlobRead(BlobView* pBlobView)
		{
			m_f1904DateSystem = pBlobView->UnpackUint16();
		}

		void Date1904::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_f1904DateSystem);
		}

		void Date1904::SetDefaults()
		{
			m_f1904DateSystem = 0;
		}

		DataFormatRecord::DataFormatRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_xi = 0;
			m_yi = 0;
			m_iss = 0;
			m_fXL4iss = 0;
			m_reserved = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_DataFormat);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void DataFormatRecord::BlobRead(BlobView* pBlobView)
		{
			m_xi = pBlobView->UnpackUint16();
			m_yi = pBlobView->UnpackUint16();
			m_iss = pBlobView->UnpackUint16();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fXL4iss = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_reserved = (unsigned short)((nBitmask0 >> 1) & 0x7fff);
		}

		void DataFormatRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_xi);
			pBlobView->PackUint16(m_yi);
			pBlobView->PackUint16(m_iss);
			int nBitmask0 = 0;
			nBitmask0 += m_fXL4iss << 0;
			nBitmask0 += m_reserved << 1;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
		}

		void DataFormatRecord::SetDefaults()
		{
			m_xi = 0xFFFF;
			m_yi = 0;
			m_iss = 0;
			m_fXL4iss = 0;
			m_reserved = 0;
		}

		DataFormatRecord::DataFormatRecord(unsigned short nIndex) : BiffRecord(TYPE, SIZE)
		{
			m_xi = 0;
			m_yi = 0;
			m_iss = 0;
			m_fXL4iss = 0;
			m_reserved = 0;
			SetDefaults();
			m_yi = nIndex;
			m_iss = nIndex;
		}

		DSF::DSF() : BiffRecord(TYPE, SIZE)
		{
			m_reserved = 0;
			SetDefaults();
		}

		DSF::DSF(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_reserved = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_DSF);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void DSF::BlobRead(BlobView* pBlobView)
		{
			m_reserved = pBlobView->UnpackInt16();
		}

		void DSF::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackInt16(m_reserved);
		}

		void DSF::SetDefaults()
		{
			m_reserved = 0;
		}

		CrtMlFrtRecord::CrtMlFrtRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_frtHeader = 0;
			m_cb = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_CrtMlFrt);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void CrtMlFrtRecord::BlobRead(BlobView* pBlobView)
		{
			m_frtHeader->BlobRead(pBlobView);
			m_cb = pBlobView->UnpackUint32();
		}

		void CrtMlFrtRecord::BlobWrite(BlobView* pBlobView)
		{
			m_frtHeader->BlobWrite(pBlobView);
			pBlobView->PackUint32(m_cb);
		}

		void CrtMlFrtRecord::SetDefaults()
		{
			m_frtHeader = new FrtHeaderStruct();
			m_cb = 0;
			PostSetDefaults();
		}

		void CrtMlFrtRecord::PostSetDefaults()
		{
			m_frtHeader->m_rt = 0x08A7;
		}

		CrtMlFrtRecord::~CrtMlFrtRecord()
		{
			if (m_frtHeader) delete m_frtHeader;
		}

		CrtLinkRecord::CrtLinkRecord() : BiffRecord(TYPE, SIZE)
		{
			m_unused0 = 0;
			m_unused1 = 0;
			m_unused2 = 0;
			m_unused3 = 0;
			m_unused4 = 0;
			SetDefaults();
		}

		CrtLinkRecord::CrtLinkRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_unused0 = 0;
			m_unused1 = 0;
			m_unused2 = 0;
			m_unused3 = 0;
			m_unused4 = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_CrtLink);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void CrtLinkRecord::BlobRead(BlobView* pBlobView)
		{
			m_unused0 = pBlobView->UnpackUint16();
			m_unused1 = pBlobView->UnpackUint16();
			m_unused2 = pBlobView->UnpackUint16();
			m_unused3 = pBlobView->UnpackUint16();
			m_unused4 = pBlobView->UnpackUint16();
		}

		void CrtLinkRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_unused0);
			pBlobView->PackUint16(m_unused1);
			pBlobView->PackUint16(m_unused2);
			pBlobView->PackUint16(m_unused3);
			pBlobView->PackUint16(m_unused4);
		}

		void CrtLinkRecord::SetDefaults()
		{
			m_unused0 = 0;
			m_unused1 = 0;
			m_unused2 = 0;
			m_unused3 = 0;
			m_unused4 = 0;
		}

		CrtLayout12ARecord::CrtLayout12ARecord() : BiffRecord(TYPE, SIZE)
		{
			m_frtHeader = 0;
			m_dwCheckSum = 0;
			m_fLayoutTargetInner = 0;
			m_reserved1 = 0;
			m_xTL = 0;
			m_yTL = 0;
			m_xBR = 0;
			m_yBR = 0;
			m_wXMode = 0;
			m_wYMode = 0;
			m_wWidthMode = 0;
			m_wHeightMode = 0;
			m_x = 0;
			m_y = 0;
			m_dx = 0;
			m_dy = 0;
			m_reserved2 = 0;
			SetDefaults();
		}

		CrtLayout12ARecord::CrtLayout12ARecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_frtHeader = 0;
			m_dwCheckSum = 0;
			m_fLayoutTargetInner = 0;
			m_reserved1 = 0;
			m_xTL = 0;
			m_yTL = 0;
			m_xBR = 0;
			m_yBR = 0;
			m_wXMode = 0;
			m_wYMode = 0;
			m_wWidthMode = 0;
			m_wHeightMode = 0;
			m_x = 0;
			m_y = 0;
			m_dx = 0;
			m_dy = 0;
			m_reserved2 = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_CrtLayout12A);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void CrtLayout12ARecord::BlobRead(BlobView* pBlobView)
		{
			m_frtHeader->BlobRead(pBlobView);
			m_dwCheckSum = pBlobView->UnpackUint32();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fLayoutTargetInner = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_reserved1 = (unsigned short)((nBitmask0 >> 1) & 0x7fff);
			m_xTL = pBlobView->UnpackInt16();
			m_yTL = pBlobView->UnpackInt16();
			m_xBR = pBlobView->UnpackInt16();
			m_yBR = pBlobView->UnpackInt16();
			m_wXMode = pBlobView->UnpackUint16();
			m_wYMode = pBlobView->UnpackUint16();
			m_wWidthMode = pBlobView->UnpackUint16();
			m_wHeightMode = pBlobView->UnpackUint16();
			m_x = pBlobView->UnpackDouble();
			m_y = pBlobView->UnpackDouble();
			m_dx = pBlobView->UnpackDouble();
			m_dy = pBlobView->UnpackDouble();
			m_reserved2 = pBlobView->UnpackUint16();
		}

		void CrtLayout12ARecord::BlobWrite(BlobView* pBlobView)
		{
			m_frtHeader->BlobWrite(pBlobView);
			pBlobView->PackUint32(m_dwCheckSum);
			int nBitmask0 = 0;
			nBitmask0 += m_fLayoutTargetInner << 0;
			nBitmask0 += m_reserved1 << 1;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			pBlobView->PackInt16(m_xTL);
			pBlobView->PackInt16(m_yTL);
			pBlobView->PackInt16(m_xBR);
			pBlobView->PackInt16(m_yBR);
			pBlobView->PackUint16(m_wXMode);
			pBlobView->PackUint16(m_wYMode);
			pBlobView->PackUint16(m_wWidthMode);
			pBlobView->PackUint16(m_wHeightMode);
			pBlobView->PackDouble(m_x);
			pBlobView->PackDouble(m_y);
			pBlobView->PackDouble(m_dx);
			pBlobView->PackDouble(m_dy);
			pBlobView->PackUint16(m_reserved2);
		}

		void CrtLayout12ARecord::SetDefaults()
		{
			m_frtHeader = new FrtHeaderStruct();
			m_dwCheckSum = 0x00000001;
			m_fLayoutTargetInner = 0;
			m_reserved1 = 0;
			m_xTL = 23;
			m_yTL = -34;
			m_xBR = 3877;
			m_yBR = 4038;
			m_wXMode = 0;
			m_wYMode = 0;
			m_wWidthMode = 0;
			m_wHeightMode = 0;
			m_x = 0;
			m_y = 0;
			m_dx = 0;
			m_dy = 0;
			m_reserved2 = 0;
			PostSetDefaults();
		}

		void CrtLayout12ARecord::PostSetDefaults()
		{
			m_frtHeader->m_rt = 0x08A7;
		}

		CrtLayout12ARecord::~CrtLayout12ARecord()
		{
			if (m_frtHeader) delete m_frtHeader;
		}

		ColInfoRecord::ColInfoRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_colFirst = 0;
			m_colLast = 0;
			m_coldx = 0;
			m_ixfe = 0;
			m_fHidden = 0;
			m_fUserSet = 0;
			m_fBestFit = 0;
			m_fPhonetic = 0;
			m_reserved1 = 0;
			m_iOutLevel = 0;
			m_unused1 = 0;
			m_fCollapsed = 0;
			m_reserved2 = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_COLINFO);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void ColInfoRecord::BlobRead(BlobView* pBlobView)
		{
			m_colFirst = pBlobView->UnpackUint16();
			m_colLast = pBlobView->UnpackUint16();
			m_coldx = pBlobView->UnpackUint16();
			m_ixfe = pBlobView->UnpackUint16();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fHidden = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fUserSet = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fBestFit = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_fPhonetic = (unsigned short)((nBitmask0 >> 3) & 0x1);
			m_reserved1 = (unsigned short)((nBitmask0 >> 4) & 0xf);
			m_iOutLevel = (unsigned short)((nBitmask0 >> 8) & 0x7);
			m_unused1 = (unsigned short)((nBitmask0 >> 11) & 0x1);
			m_fCollapsed = (unsigned short)((nBitmask0 >> 12) & 0x1);
			m_reserved2 = (unsigned short)((nBitmask0 >> 13) & 0x7);
		}

		void ColInfoRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_colFirst);
			pBlobView->PackUint16(m_colLast);
			pBlobView->PackUint16(m_coldx);
			pBlobView->PackUint16(m_ixfe);
			int nBitmask0 = 0;
			nBitmask0 += m_fHidden << 0;
			nBitmask0 += m_fUserSet << 1;
			nBitmask0 += m_fBestFit << 2;
			nBitmask0 += m_fPhonetic << 3;
			nBitmask0 += m_reserved1 << 4;
			nBitmask0 += m_iOutLevel << 8;
			nBitmask0 += m_unused1 << 11;
			nBitmask0 += m_fCollapsed << 12;
			nBitmask0 += m_reserved2 << 13;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			PostBlobWrite(pBlobView);
		}

		void ColInfoRecord::SetDefaults()
		{
			m_colFirst = 0;
			m_colLast = 0;
			m_coldx = 0;
			m_ixfe = 15;
			m_fHidden = 0;
			m_fUserSet = 0;
			m_fBestFit = 0;
			m_fPhonetic = 0;
			m_reserved1 = 0;
			m_iOutLevel = 0;
			m_unused1 = 0;
			m_fCollapsed = 0;
			m_reserved2 = 0;
		}

		ColInfoRecord::ColInfoRecord(unsigned short nFirstColumn, unsigned short nLastColumn, unsigned short nColumnWidth, bool bHidden) : BiffRecord(TYPE, SIZE + 2)
		{
			m_colFirst = 0;
			m_colLast = 0;
			m_coldx = 0;
			m_ixfe = 0;
			m_fHidden = 0;
			m_fUserSet = 0;
			m_fBestFit = 0;
			m_fPhonetic = 0;
			m_reserved1 = 0;
			m_iOutLevel = 0;
			m_unused1 = 0;
			m_fCollapsed = 0;
			m_reserved2 = 0;
			SetDefaults();
			m_colFirst = nFirstColumn;
			m_colLast = nLastColumn;
			m_coldx = nColumnWidth;
			if (bHidden)
				m_fHidden = 0x1;
		}

		void ColInfoRecord::PostBlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(0);
		}

		unsigned short ColInfoRecord::GetFirstColumn()
		{
			return m_colFirst;
		}

		unsigned short ColInfoRecord::GetLastColumn()
		{
			return m_colLast;
		}

		unsigned short ColInfoRecord::GetColumnWidth()
		{
			return m_coldx;
		}

		bool ColInfoRecord::GetHidden()
		{
			return m_fHidden == 0x1;
		}

		CodePage::CodePage() : BiffRecord(TYPE, SIZE)
		{
			m_cv = 0;
			SetDefaults();
		}

		CodePage::CodePage(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_cv = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_CODE_PAGE);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void CodePage::BlobRead(BlobView* pBlobView)
		{
			m_cv = pBlobView->UnpackInt16();
		}

		void CodePage::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackInt16(m_cv);
		}

		void CodePage::SetDefaults()
		{
			m_cv = 1200;
		}

		ChartRecord::ChartRecord() : BiffRecord(TYPE, SIZE)
		{
			m_x = 0;
			m_y = 0;
			m_dx = 0;
			m_dy = 0;
			SetDefaults();
		}

		ChartRecord::ChartRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_x = 0;
			m_y = 0;
			m_dx = 0;
			m_dy = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_Chart);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void ChartRecord::BlobRead(BlobView* pBlobView)
		{
			m_x = pBlobView->UnpackUint32();
			m_y = pBlobView->UnpackUint32();
			m_dx = pBlobView->UnpackUint32();
			m_dy = pBlobView->UnpackUint32();
		}

		void ChartRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint32(m_x);
			pBlobView->PackUint32(m_y);
			pBlobView->PackUint32(m_dx);
			pBlobView->PackUint32(m_dy);
		}

		void ChartRecord::SetDefaults()
		{
			m_x = 0;
			m_y = 0;
			m_dx = 23642112;
			m_dy = 14204928;
		}

		unsigned short ChartRecord::GetX()
		{
			return (unsigned short)(m_x >> 16);
		}

		unsigned short ChartRecord::GetY()
		{
			return (unsigned short)(m_y >> 16);
		}

		unsigned short ChartRecord::GetWidth()
		{
			return (unsigned short)(m_dx >> 16);
		}

		unsigned short ChartRecord::GetHeight()
		{
			return (unsigned short)(m_dy >> 16);
		}

		ChartFrtInfoRecord::ChartFrtInfoRecord() : BiffRecord(TYPE, SIZE)
		{
			m_frtHeaderOld = 0;
			m_verOriginator = 0;
			m_verWriter = 0;
			m_cCFRTID = 0;
			m_hax1 = 0;
			m_hax2 = 0;
			m_hax3 = 0;
			m_hax4 = 0;
			m_hax5 = 0;
			m_hax6 = 0;
			m_hax7 = 0;
			m_hax8 = 0;
			SetDefaults();
		}

		ChartFrtInfoRecord::ChartFrtInfoRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_frtHeaderOld = 0;
			m_verOriginator = 0;
			m_verWriter = 0;
			m_cCFRTID = 0;
			m_hax1 = 0;
			m_hax2 = 0;
			m_hax3 = 0;
			m_hax4 = 0;
			m_hax5 = 0;
			m_hax6 = 0;
			m_hax7 = 0;
			m_hax8 = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_ChartFrtInfo);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void ChartFrtInfoRecord::BlobRead(BlobView* pBlobView)
		{
			m_frtHeaderOld->BlobRead(pBlobView);
			m_verOriginator = pBlobView->UnpackUint8();
			m_verWriter = pBlobView->UnpackUint8();
			m_cCFRTID = pBlobView->UnpackUint16();
			m_hax1 = pBlobView->UnpackUint16();
			m_hax2 = pBlobView->UnpackUint16();
			m_hax3 = pBlobView->UnpackUint16();
			m_hax4 = pBlobView->UnpackUint16();
			m_hax5 = pBlobView->UnpackUint16();
			m_hax6 = pBlobView->UnpackUint16();
			m_hax7 = pBlobView->UnpackUint16();
			m_hax8 = pBlobView->UnpackUint16();
		}

		void ChartFrtInfoRecord::BlobWrite(BlobView* pBlobView)
		{
			m_frtHeaderOld->BlobWrite(pBlobView);
			pBlobView->PackUint8(m_verOriginator);
			pBlobView->PackUint8(m_verWriter);
			pBlobView->PackUint16(m_cCFRTID);
			pBlobView->PackUint16(m_hax1);
			pBlobView->PackUint16(m_hax2);
			pBlobView->PackUint16(m_hax3);
			pBlobView->PackUint16(m_hax4);
			pBlobView->PackUint16(m_hax5);
			pBlobView->PackUint16(m_hax6);
			pBlobView->PackUint16(m_hax7);
			pBlobView->PackUint16(m_hax8);
		}

		void ChartFrtInfoRecord::SetDefaults()
		{
			m_frtHeaderOld = new FrtHeaderOldStruct();
			m_verOriginator = 0xE;
			m_verWriter = 0xE;
			m_cCFRTID = 0x0004;
			m_hax1 = 0x0850;
			m_hax2 = 0x085a;
			m_hax3 = 0x0861;
			m_hax4 = 0x0861;
			m_hax5 = 0x086a;
			m_hax6 = 0x086b;
			m_hax7 = 0x089d;
			m_hax8 = 0x08a6;
			PostSetDefaults();
		}

		void ChartFrtInfoRecord::PostSetDefaults()
		{
			m_frtHeaderOld->m_rt = 2128;
		}

		ChartFrtInfoRecord::~ChartFrtInfoRecord()
		{
			if (m_frtHeaderOld) delete m_frtHeaderOld;
		}

		ChartFormatRecord::ChartFormatRecord() : BiffRecord(TYPE, SIZE)
		{
			m_reserved1 = 0;
			m_reserved2 = 0;
			m_reserved3 = 0;
			m_reserved4 = 0;
			m_fVaried = 0;
			m_reserved5 = 0;
			m_icrt = 0;
			SetDefaults();
		}

		ChartFormatRecord::ChartFormatRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_reserved1 = 0;
			m_reserved2 = 0;
			m_reserved3 = 0;
			m_reserved4 = 0;
			m_fVaried = 0;
			m_reserved5 = 0;
			m_icrt = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_ChartFormat);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void ChartFormatRecord::BlobRead(BlobView* pBlobView)
		{
			m_reserved1 = pBlobView->UnpackUint32();
			m_reserved2 = pBlobView->UnpackUint32();
			m_reserved3 = pBlobView->UnpackUint32();
			m_reserved4 = pBlobView->UnpackUint32();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fVaried = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_reserved5 = (unsigned short)((nBitmask0 >> 1) & 0x7fff);
			m_icrt = pBlobView->UnpackUint16();
		}

		void ChartFormatRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint32(m_reserved1);
			pBlobView->PackUint32(m_reserved2);
			pBlobView->PackUint32(m_reserved3);
			pBlobView->PackUint32(m_reserved4);
			int nBitmask0 = 0;
			nBitmask0 += m_fVaried << 0;
			nBitmask0 += m_reserved5 << 1;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			pBlobView->PackUint16(m_icrt);
		}

		void ChartFormatRecord::SetDefaults()
		{
			m_reserved1 = 0;
			m_reserved2 = 0;
			m_reserved3 = 0;
			m_reserved4 = 0;
			m_fVaried = 0;
			m_reserved5 = 0;
			m_icrt = 0;
		}

		Chart3DBarShapeRecord::Chart3DBarShapeRecord() : BiffRecord(TYPE, SIZE)
		{
			m_riser = 0;
			m_taper = 0;
			SetDefaults();
		}

		Chart3DBarShapeRecord::Chart3DBarShapeRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_riser = 0;
			m_taper = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_Chart3DBarShape);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void Chart3DBarShapeRecord::BlobRead(BlobView* pBlobView)
		{
			m_riser = pBlobView->UnpackUint8();
			m_taper = pBlobView->UnpackUint8();
		}

		void Chart3DBarShapeRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint8(m_riser);
			pBlobView->PackUint8(m_taper);
		}

		void Chart3DBarShapeRecord::SetDefaults()
		{
			m_riser = 0;
			m_taper = 0;
		}

		CatSerRangeRecord::CatSerRangeRecord() : BiffRecord(TYPE, SIZE)
		{
			m_catCross = 0;
			m_catLabel = 0;
			m_catMark = 0;
			m_fBetween = 0;
			m_fMaxCross = 0;
			m_fReverse = 0;
			m_reserved = 0;
			SetDefaults();
		}

		CatSerRangeRecord::CatSerRangeRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_catCross = 0;
			m_catLabel = 0;
			m_catMark = 0;
			m_fBetween = 0;
			m_fMaxCross = 0;
			m_fReverse = 0;
			m_reserved = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_CatSerRange);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void CatSerRangeRecord::BlobRead(BlobView* pBlobView)
		{
			m_catCross = pBlobView->UnpackInt16();
			m_catLabel = pBlobView->UnpackInt16();
			m_catMark = pBlobView->UnpackInt16();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fBetween = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fMaxCross = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fReverse = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_reserved = (unsigned short)((nBitmask0 >> 3) & 0x1fff);
		}

		void CatSerRangeRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackInt16(m_catCross);
			pBlobView->PackInt16(m_catLabel);
			pBlobView->PackInt16(m_catMark);
			int nBitmask0 = 0;
			nBitmask0 += m_fBetween << 0;
			nBitmask0 += m_fMaxCross << 1;
			nBitmask0 += m_fReverse << 2;
			nBitmask0 += m_reserved << 3;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
		}

		void CatSerRangeRecord::SetDefaults()
		{
			m_catCross = 1;
			m_catLabel = 1;
			m_catMark = 1;
			m_fBetween = 1;
			m_fMaxCross = 0;
			m_fReverse = 0;
			m_reserved = 0;
		}

		CatLabRecord::CatLabRecord() : BiffRecord(TYPE, SIZE)
		{
			m_frtHeaderOld = 0;
			m_wOffset = 0;
			m_at = 0;
			m_cAutoCatLabelReal = 0;
			m_unused = 0;
			m_reserved = 0;
			SetDefaults();
		}

		CatLabRecord::CatLabRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_frtHeaderOld = 0;
			m_wOffset = 0;
			m_at = 0;
			m_cAutoCatLabelReal = 0;
			m_unused = 0;
			m_reserved = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_CatLab);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void CatLabRecord::BlobRead(BlobView* pBlobView)
		{
			m_frtHeaderOld->BlobRead(pBlobView);
			m_wOffset = pBlobView->UnpackUint16();
			m_at = pBlobView->UnpackUint16();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_cAutoCatLabelReal = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_unused = (unsigned short)((nBitmask0 >> 1) & 0x7fff);
			m_reserved = pBlobView->UnpackUint16();
		}

		void CatLabRecord::BlobWrite(BlobView* pBlobView)
		{
			m_frtHeaderOld->BlobWrite(pBlobView);
			pBlobView->PackUint16(m_wOffset);
			pBlobView->PackUint16(m_at);
			int nBitmask0 = 0;
			nBitmask0 += m_cAutoCatLabelReal << 0;
			nBitmask0 += m_unused << 1;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			pBlobView->PackUint16(m_reserved);
		}

		void CatLabRecord::SetDefaults()
		{
			m_frtHeaderOld = new FrtHeaderOldStruct();
			m_wOffset = 100;
			m_at = 0x0002;
			m_cAutoCatLabelReal = 0;
			m_unused = 158;
			m_reserved = 0;
			PostSetDefaults();
		}

		void CatLabRecord::PostSetDefaults()
		{
			m_frtHeaderOld->m_rt = 0x0856;
		}

		CatLabRecord::~CatLabRecord()
		{
			if (m_frtHeaderOld) delete m_frtHeaderOld;
		}

		CalcPrecision::CalcPrecision() : BiffRecord(TYPE, SIZE)
		{
			m_fFullPrec = 0;
			SetDefaults();
		}

		CalcPrecision::CalcPrecision(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_fFullPrec = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_CALC_PRECISION);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void CalcPrecision::BlobRead(BlobView* pBlobView)
		{
			m_fFullPrec = pBlobView->UnpackUint16();
		}

		void CalcPrecision::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_fFullPrec);
		}

		void CalcPrecision::SetDefaults()
		{
			m_fFullPrec = 1;
		}

		CalcCountRecord::CalcCountRecord() : BiffRecord(TYPE, SIZE)
		{
			m_nMaxNumIteration = 0;
			SetDefaults();
		}

		CalcCountRecord::CalcCountRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_nMaxNumIteration = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_CALCCOUNT);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void CalcCountRecord::BlobRead(BlobView* pBlobView)
		{
			m_nMaxNumIteration = pBlobView->UnpackUint16();
		}

		void CalcCountRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_nMaxNumIteration);
		}

		void CalcCountRecord::SetDefaults()
		{
			m_nMaxNumIteration = 100;
		}

		BuiltInFnGroupCount::BuiltInFnGroupCount() : BiffRecord(TYPE, SIZE)
		{
			m_count = 0;
			SetDefaults();
		}

		BuiltInFnGroupCount::BuiltInFnGroupCount(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_count = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_BUILT_IN_FN_GROUP_COUNT);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void BuiltInFnGroupCount::BlobRead(BlobView* pBlobView)
		{
			m_count = pBlobView->UnpackUint16();
		}

		void BuiltInFnGroupCount::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_count);
		}

		void BuiltInFnGroupCount::SetDefaults()
		{
			m_count = 17;
		}

		BraiRecord::BraiRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_id = 0;
			m_rt = 0;
			m_fUnlinkedIfmt = 0;
			m_reserved = 0;
			m_ifmt = 0;
			m_formula = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_BRAI);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void BraiRecord::BlobRead(BlobView* pBlobView)
		{
			m_id = pBlobView->UnpackUint8();
			m_rt = pBlobView->UnpackUint8();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fUnlinkedIfmt = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_reserved = (unsigned short)((nBitmask0 >> 1) & 0x7fff);
			m_ifmt = pBlobView->UnpackUint16();
			PostBlobRead(pBlobView);
		}

		void BraiRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint8(m_id);
			pBlobView->PackUint8(m_rt);
			int nBitmask0 = 0;
			nBitmask0 += m_fUnlinkedIfmt << 0;
			nBitmask0 += m_reserved << 1;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			pBlobView->PackUint16(m_ifmt);
			PostBlobWrite(pBlobView);
		}

		void BraiRecord::SetDefaults()
		{
			m_id = 0;
			m_rt = 0;
			m_fUnlinkedIfmt = 0;
			m_reserved = 0;
			m_ifmt = 0;
			PostSetDefaults();
		}

		BraiRecord::BraiRecord(unsigned char id, unsigned char rt, bool fUnlinkedIfmt, unsigned short ifmt, Formula* pFormula, WorkbookGlobals* pWorkbookGlobals) : BiffRecord(TYPE, SIZE)
		{
			m_id = 0;
			m_rt = 0;
			m_fUnlinkedIfmt = 0;
			m_reserved = 0;
			m_ifmt = 0;
			m_formula = 0;
			SetDefaults();
			m_id = id;
			m_rt = rt;
			m_fUnlinkedIfmt = 0x0;
			if (fUnlinkedIfmt)
				m_fUnlinkedIfmt = 0x1;
			nbAssert::Assert(m_formula == 0);
			m_formula = new CellParsedFormulaStruct(pFormula, pWorkbookGlobals);
			m_pHeader->m_nSize += (unsigned short)(m_formula->GetSize());
		}

		void BraiRecord::PostSetDefaults()
		{
			m_formula = 0;
		}

		void BraiRecord::PostBlobRead(BlobView* pBlobView)
		{
			nbAssert::Assert(m_formula == 0);
			m_formula = new CellParsedFormulaStruct();
			m_formula->BlobRead(pBlobView);
		}

		void BraiRecord::PostBlobWrite(BlobView* pBlobView)
		{
			m_formula->BlobWrite(pBlobView);
		}

		unsigned char BraiRecord::GetId()
		{
			return m_id;
		}

		unsigned char BraiRecord::GetRt()
		{
			return m_rt;
		}

		Formula* BraiRecord::GetFormula(WorkbookGlobals* pWorkbookGlobals)
		{
			return new Formula(m_formula->m_rgce->m_pParsedExpressionRecordVector, pWorkbookGlobals);
		}

		BraiRecord::~BraiRecord()
		{
			if (m_formula) delete m_formula;
		}

		BoundSheet8Record::BoundSheet8Record(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_lbPlyPos = 0;
			m_hsState = 0;
			m_reserved = 0;
			m_dt = 0;
			m_stName = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_BOUND_SHEET_8);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void BoundSheet8Record::BlobRead(BlobView* pBlobView)
		{
			m_lbPlyPos = pBlobView->UnpackUint32();
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_hsState = (unsigned char)((nBitmask0 >> 0) & 0x3);
			m_reserved = (unsigned char)((nBitmask0 >> 2) & 0x3f);
			m_dt = pBlobView->UnpackUint8();
			m_stName->BlobRead(pBlobView);
		}

		void BoundSheet8Record::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint32(m_lbPlyPos);
			int nBitmask0 = 0;
			nBitmask0 += m_hsState << 0;
			nBitmask0 += m_reserved << 2;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
			pBlobView->PackUint8(m_dt);
			m_stName->BlobWrite(pBlobView);
		}

		void BoundSheet8Record::SetDefaults()
		{
			m_lbPlyPos = 0;
			m_hsState = 0;
			m_reserved = 0;
			m_dt = 0;
			m_stName = new ShortXLUnicodeStringStruct();
		}

		BoundSheet8Record::BoundSheet8Record(const char* sxName) : BiffRecord(TYPE, SIZE)
		{
			m_lbPlyPos = 0;
			m_hsState = 0;
			m_reserved = 0;
			m_dt = 0;
			m_stName = 0;
			SetDefaults();
			m_stName->m_rgb->Set(sxName);
			m_pHeader->m_nSize += (unsigned int)(m_stName->GetDynamicSize());
		}

		const char* BoundSheet8Record::GetName()
		{
			return m_stName->m_rgb->GetExternalString();
		}

		void BoundSheet8Record::SetStreamOffset(unsigned int nStreamOffset)
		{
			m_lbPlyPos = nStreamOffset;
		}

		BoundSheet8Record::~BoundSheet8Record()
		{
			if (m_stName) delete m_stName;
		}

		BottomMarginRecord::BottomMarginRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_num = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_BOTTOM_MARGIN);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void BottomMarginRecord::BlobRead(BlobView* pBlobView)
		{
			m_num = pBlobView->UnpackDouble();
		}

		void BottomMarginRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackDouble(m_num);
		}

		void BottomMarginRecord::SetDefaults()
		{
			m_num = 0.0;
		}

		BottomMarginRecord::BottomMarginRecord(double num) : BiffRecord(TYPE, SIZE)
		{
			m_num = 0;
			SetDefaults();
			m_num = num;
		}

		BoolErrRecord::BoolErrRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_cell = 0;
			m_bBoolErr = 0;
			m_fError = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_BOOLERR);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void BoolErrRecord::BlobRead(BlobView* pBlobView)
		{
			m_cell->BlobRead(pBlobView);
			m_bBoolErr = pBlobView->UnpackUint8();
			m_fError = pBlobView->UnpackUint8();
		}

		void BoolErrRecord::BlobWrite(BlobView* pBlobView)
		{
			m_cell->BlobWrite(pBlobView);
			pBlobView->PackUint8(m_bBoolErr);
			pBlobView->PackUint8(m_fError);
		}

		void BoolErrRecord::SetDefaults()
		{
			m_cell = new CellStruct();
			m_bBoolErr = 0;
			m_fError = 0;
		}

		BoolErrRecord::BoolErrRecord(unsigned short nX, unsigned short nY, unsigned short nXfIndex, bool bBoolean) : BiffRecord(TYPE, SIZE)
		{
			m_cell = 0;
			m_bBoolErr = 0;
			m_fError = 0;
			SetDefaults();
			m_cell->m_rw->m_rw = nY;
			m_cell->m_col->m_col = nX;
			m_cell->m_ixfe->m_ixfe = nXfIndex;
			m_bBoolErr = 0x00;
			if (bBoolean)
				m_bBoolErr = 0x01;
		}

		unsigned short BoolErrRecord::GetX()
		{
			return m_cell->m_col->m_col;
		}

		unsigned short BoolErrRecord::GetY()
		{
			return m_cell->m_rw->m_rw;
		}

		unsigned short BoolErrRecord::GetXfIndex()
		{
			return m_cell->m_ixfe->m_ixfe;
		}

		bool BoolErrRecord::IsBoolean()
		{
			return m_fError == 0x00;
		}

		bool BoolErrRecord::GetBoolean()
		{
			return m_bBoolErr == 0x01;
		}

		BoolErrRecord::~BoolErrRecord()
		{
			if (m_cell) delete m_cell;
		}

		BookExtRecord::BookExtRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_frtHeader = 0;
			m_cb = 0;
			m_fDontAutoRecover = 0;
			m_fHidePivotList = 0;
			m_fFilterPrivacy = 0;
			m_fEmbedFactoids = 0;
			m_mdFactoidDisplay = 0;
			m_fSavedDuringRecovery = 0;
			m_fCreatedViaMinimalSave = 0;
			m_fOpenedViaDataRecovery = 0;
			m_fOpenedViaSafeLoad = 0;
			m_reserved = 0;
			m_grbit1 = 0;
			m_grbit2 = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_BOOK_EXT);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void BookExtRecord::BlobRead(BlobView* pBlobView)
		{
			m_frtHeader->BlobRead(pBlobView);
			m_cb = pBlobView->UnpackUint32();
			unsigned int nBitmask0 = pBlobView->UnpackUint32();
			m_fDontAutoRecover = (unsigned int)((nBitmask0 >> 0) & 0x1);
			m_fHidePivotList = (unsigned int)((nBitmask0 >> 1) & 0x1);
			m_fFilterPrivacy = (unsigned int)((nBitmask0 >> 2) & 0x1);
			m_fEmbedFactoids = (unsigned int)((nBitmask0 >> 3) & 0x1);
			m_mdFactoidDisplay = (unsigned int)((nBitmask0 >> 4) & 0x3);
			m_fSavedDuringRecovery = (unsigned int)((nBitmask0 >> 6) & 0x1);
			m_fCreatedViaMinimalSave = (unsigned int)((nBitmask0 >> 7) & 0x1);
			m_fOpenedViaDataRecovery = (unsigned int)((nBitmask0 >> 8) & 0x1);
			m_fOpenedViaSafeLoad = (unsigned int)((nBitmask0 >> 9) & 0x1);
			m_reserved = (unsigned int)((nBitmask0 >> 10) & 0x3fffff);
			PostBlobRead(pBlobView);
		}

		void BookExtRecord::BlobWrite(BlobView* pBlobView)
		{
			m_frtHeader->BlobWrite(pBlobView);
			pBlobView->PackUint32(m_cb);
			unsigned int nBitmask0 = 0;
			nBitmask0 += m_fDontAutoRecover << 0;
			nBitmask0 += m_fHidePivotList << 1;
			nBitmask0 += m_fFilterPrivacy << 2;
			nBitmask0 += m_fEmbedFactoids << 3;
			nBitmask0 += m_mdFactoidDisplay << 4;
			nBitmask0 += m_fSavedDuringRecovery << 6;
			nBitmask0 += m_fCreatedViaMinimalSave << 7;
			nBitmask0 += m_fOpenedViaDataRecovery << 8;
			nBitmask0 += m_fOpenedViaSafeLoad << 9;
			nBitmask0 += m_reserved << 10;
			pBlobView->PackUint32((unsigned int)(nBitmask0));
			PostBlobWrite(pBlobView);
		}

		void BookExtRecord::SetDefaults()
		{
			m_frtHeader = new FrtHeaderStruct();
			m_cb = 0;
			m_fDontAutoRecover = 0;
			m_fHidePivotList = 0;
			m_fFilterPrivacy = 0;
			m_fEmbedFactoids = 0;
			m_mdFactoidDisplay = 0;
			m_fSavedDuringRecovery = 0;
			m_fCreatedViaMinimalSave = 0;
			m_fOpenedViaDataRecovery = 0;
			m_fOpenedViaSafeLoad = 0;
			m_reserved = 0;
		}

		BookExtRecord::BookExtRecord() : BiffRecord(TYPE, SIZE + 2)
		{
			m_frtHeader = 0;
			m_cb = 0;
			m_fDontAutoRecover = 0;
			m_fHidePivotList = 0;
			m_fFilterPrivacy = 0;
			m_fEmbedFactoids = 0;
			m_mdFactoidDisplay = 0;
			m_fSavedDuringRecovery = 0;
			m_fCreatedViaMinimalSave = 0;
			m_fOpenedViaDataRecovery = 0;
			m_fOpenedViaSafeLoad = 0;
			m_reserved = 0;
			m_grbit1 = 0;
			m_grbit2 = 0;
			SetDefaults();
			m_frtHeader->m_rt = (unsigned short)(BiffRecord::Type::TYPE_BOOK_EXT);
			m_cb = m_pHeader->m_nSize;
			m_grbit1 = 2;
			m_grbit2 = 0;
		}

		void BookExtRecord::PostBlobRead(BlobView* pBlobView)
		{
			if (m_cb > 20)
				m_grbit1 = pBlobView->UnpackUint8();
			if (m_cb > 21)
				m_grbit2 = pBlobView->UnpackUint8();
		}

		void BookExtRecord::PostBlobWrite(BlobView* pBlobView)
		{
			if (m_cb > 20)
				pBlobView->PackUint8(m_grbit1);
			if (m_cb > 21)
				pBlobView->PackUint8(m_grbit2);
		}

		BookExtRecord::~BookExtRecord()
		{
			if (m_frtHeader) delete m_frtHeader;
		}

		BookBool::BookBool() : BiffRecord(TYPE, SIZE)
		{
			m_fNoSaveSup = 0;
			m_reserved1 = 0;
			m_fHasEnvelope = 0;
			m_fEnvelopeVisible = 0;
			m_fEnvelopeInitDone = 0;
			m_grUpdateLinks = 0;
			m_unused = 0;
			m_fHideBorderUnselLists = 0;
			m_reserved2 = 0;
			SetDefaults();
		}

		BookBool::BookBool(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_fNoSaveSup = 0;
			m_reserved1 = 0;
			m_fHasEnvelope = 0;
			m_fEnvelopeVisible = 0;
			m_fEnvelopeInitDone = 0;
			m_grUpdateLinks = 0;
			m_unused = 0;
			m_fHideBorderUnselLists = 0;
			m_reserved2 = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_BOOK_BOOL);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void BookBool::BlobRead(BlobView* pBlobView)
		{
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fNoSaveSup = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_reserved1 = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fHasEnvelope = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_fEnvelopeVisible = (unsigned short)((nBitmask0 >> 3) & 0x1);
			m_fEnvelopeInitDone = (unsigned short)((nBitmask0 >> 4) & 0x1);
			m_grUpdateLinks = (unsigned short)((nBitmask0 >> 5) & 0x3);
			m_unused = (unsigned short)((nBitmask0 >> 7) & 0x1);
			m_fHideBorderUnselLists = (unsigned short)((nBitmask0 >> 8) & 0x1);
			m_reserved2 = (unsigned short)((nBitmask0 >> 9) & 0x7f);
		}

		void BookBool::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_fNoSaveSup << 0;
			nBitmask0 += m_reserved1 << 1;
			nBitmask0 += m_fHasEnvelope << 2;
			nBitmask0 += m_fEnvelopeVisible << 3;
			nBitmask0 += m_fEnvelopeInitDone << 4;
			nBitmask0 += m_grUpdateLinks << 5;
			nBitmask0 += m_unused << 7;
			nBitmask0 += m_fHideBorderUnselLists << 8;
			nBitmask0 += m_reserved2 << 9;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
		}

		void BookBool::SetDefaults()
		{
			m_fNoSaveSup = 0;
			m_reserved1 = 0;
			m_fHasEnvelope = 0;
			m_fEnvelopeVisible = 0;
			m_fEnvelopeInitDone = 0;
			m_grUpdateLinks = 0;
			m_unused = 0;
			m_fHideBorderUnselLists = 0;
			m_reserved2 = 0;
		}

		BofRecord::BofRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_vers = 0;
			m_dt = 0;
			m_rupBuild = 0;
			m_rupYear = 0;
			m_nFileHistoryFlags = 0;
			m_nMinimumExcelVersion = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_BOF);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void BofRecord::BlobRead(BlobView* pBlobView)
		{
			m_vers = pBlobView->UnpackUint16();
			m_dt = pBlobView->UnpackUint16();
			m_rupBuild = pBlobView->UnpackUint16();
			m_rupYear = pBlobView->UnpackUint16();
			m_nFileHistoryFlags = pBlobView->UnpackUint32();
			m_nMinimumExcelVersion = pBlobView->UnpackUint32();
		}

		void BofRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_vers);
			pBlobView->PackUint16(m_dt);
			pBlobView->PackUint16(m_rupBuild);
			pBlobView->PackUint16(m_rupYear);
			pBlobView->PackUint32(m_nFileHistoryFlags);
			pBlobView->PackUint32(m_nMinimumExcelVersion);
		}

		void BofRecord::SetDefaults()
		{
			m_vers = 0x0600;
			m_dt = 0;
			m_rupBuild = 12902;
			m_rupYear = 1997;
			m_nFileHistoryFlags = 98505;
			m_nMinimumExcelVersion = 1542;
		}

		BofRecord::BofRecord(BofType eType) : BiffRecord(TYPE, SIZE)
		{
			m_vers = 0;
			m_dt = 0;
			m_rupBuild = 0;
			m_rupYear = 0;
			m_nFileHistoryFlags = 0;
			m_nMinimumExcelVersion = 0;
			SetDefaults();
			m_dt = (unsigned short)(eType);
		}

		BofRecord::BofType BofRecord::GetBofType()
		{
			return (BofType)(m_dt);
		}

		Blank::Blank(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_cell = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_BLANK);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void Blank::BlobRead(BlobView* pBlobView)
		{
			m_cell->BlobRead(pBlobView);
		}

		void Blank::BlobWrite(BlobView* pBlobView)
		{
			m_cell->BlobWrite(pBlobView);
		}

		void Blank::SetDefaults()
		{
			m_cell = new CellStruct();
		}

		Blank::Blank(unsigned short nX, unsigned short nY, unsigned short nXfIndex) : BiffRecord(TYPE, SIZE)
		{
			m_cell = 0;
			SetDefaults();
			m_cell->m_rw->m_rw = nY;
			m_cell->m_col->m_col = nX;
			m_cell->m_ixfe->m_ixfe = nXfIndex;
		}

		unsigned short Blank::GetX()
		{
			return m_cell->m_col->m_col;
		}

		unsigned short Blank::GetY()
		{
			return m_cell->m_rw->m_rw;
		}

		unsigned short Blank::GetXfIndex()
		{
			return m_cell->m_ixfe->m_ixfe;
		}

		Blank::~Blank()
		{
			if (m_cell) delete m_cell;
		}

		BiffRecord_ContinueInfo::BiffRecord_ContinueInfo(int nOffset, int nType)
		{
			m_nOffset = 0;
			m_nType = 0;
			m_nOffset = nOffset;
			m_nType = nType;
		}

		BeginRecord::BeginRecord() : BiffRecord(TYPE, SIZE)
		{
			SetDefaults();
		}

		BeginRecord::BeginRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_Begin);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void BeginRecord::BlobRead(BlobView* pBlobView)
		{
		}

		void BeginRecord::BlobWrite(BlobView* pBlobView)
		{
		}

		void BeginRecord::SetDefaults()
		{
		}

		BarRecord::BarRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_pcOverlap = 0;
			m_pcGap = 0;
			m_fTranspose = 0;
			m_fStacked = 0;
			m_f100 = 0;
			m_fHasShadow = 0;
			m_reserved = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_Bar);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void BarRecord::BlobRead(BlobView* pBlobView)
		{
			m_pcOverlap = pBlobView->UnpackInt16();
			m_pcGap = pBlobView->UnpackUint16();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fTranspose = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fStacked = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_f100 = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_fHasShadow = (unsigned short)((nBitmask0 >> 3) & 0x1);
			m_reserved = (unsigned short)((nBitmask0 >> 4) & 0xfff);
		}

		void BarRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackInt16(m_pcOverlap);
			pBlobView->PackUint16(m_pcGap);
			int nBitmask0 = 0;
			nBitmask0 += m_fTranspose << 0;
			nBitmask0 += m_fStacked << 1;
			nBitmask0 += m_f100 << 2;
			nBitmask0 += m_fHasShadow << 3;
			nBitmask0 += m_reserved << 4;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
		}

		void BarRecord::SetDefaults()
		{
			m_pcOverlap = 0;
			m_pcGap = 150;
			m_fTranspose = 0;
			m_fStacked = 0;
			m_f100 = 0;
			m_fHasShadow = 0;
			m_reserved = 0;
		}

		BarRecord::BarRecord(Chart::Type eType) : BiffRecord(TYPE, SIZE)
		{
			m_pcOverlap = 0;
			m_pcGap = 0;
			m_fTranspose = 0;
			m_fStacked = 0;
			m_f100 = 0;
			m_fHasShadow = 0;
			m_reserved = 0;
			nbAssert::Assert(eType == Chart::Type::TYPE_COLUMN || eType == Chart::Type::TYPE_COLUMN_STACKED || eType == Chart::Type::TYPE_COLUMN_STACKED_100 || eType == Chart::Type::TYPE_BAR || eType == Chart::Type::TYPE_BAR_STACKED || eType == Chart::Type::TYPE_BAR_STACKED_100);
			SetDefaults();
			if (eType == Chart::Type::TYPE_BAR || eType == Chart::Type::TYPE_BAR_STACKED || eType == Chart::Type::TYPE_BAR_STACKED_100)
				m_fTranspose = 0x1;
			if (eType == Chart::Type::TYPE_COLUMN_STACKED || eType == Chart::Type::TYPE_COLUMN_STACKED_100 || eType == Chart::Type::TYPE_BAR_STACKED || eType == Chart::Type::TYPE_BAR_STACKED_100)
			{
				m_fStacked = 0x1;
			}
			if (eType == Chart::Type::TYPE_COLUMN_STACKED_100 || eType == Chart::Type::TYPE_BAR_STACKED_100)
				m_f100 = 0x1;
		}

		Chart::Type BarRecord::GetChartType()
		{
			if (m_fTranspose == 0x1)
			{
				if (m_fStacked == 0x1)
					if (m_f100 == 0x1)
						return Chart::Type::TYPE_BAR_STACKED_100;
					else
						return Chart::Type::TYPE_BAR_STACKED;
				return Chart::Type::TYPE_BAR;
			}
			if (m_fStacked == 0x1)
				if (m_f100 == 0x1)
					return Chart::Type::TYPE_COLUMN_STACKED_100;
				else
					return Chart::Type::TYPE_COLUMN_STACKED;
			return Chart::Type::TYPE_COLUMN;
		}

		Backup::Backup() : BiffRecord(TYPE, SIZE)
		{
			m_fBackup = 0;
			SetDefaults();
		}

		Backup::Backup(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_fBackup = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_BACKUP);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void Backup::BlobRead(BlobView* pBlobView)
		{
			m_fBackup = pBlobView->UnpackUint16();
		}

		void Backup::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_fBackup);
		}

		void Backup::SetDefaults()
		{
			m_fBackup = 0;
		}

		AxisRecord::AxisRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_wType = 0;
			m_reserved1 = 0;
			m_reserved2 = 0;
			m_reserved3 = 0;
			m_reserved4 = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_Axis);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void AxisRecord::BlobRead(BlobView* pBlobView)
		{
			m_wType = pBlobView->UnpackUint16();
			m_reserved1 = pBlobView->UnpackUint32();
			m_reserved2 = pBlobView->UnpackUint32();
			m_reserved3 = pBlobView->UnpackUint32();
			m_reserved4 = pBlobView->UnpackUint32();
		}

		void AxisRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_wType);
			pBlobView->PackUint32(m_reserved1);
			pBlobView->PackUint32(m_reserved2);
			pBlobView->PackUint32(m_reserved3);
			pBlobView->PackUint32(m_reserved4);
		}

		void AxisRecord::SetDefaults()
		{
			m_wType = 0x0000;
			m_reserved1 = 0;
			m_reserved2 = 0;
			m_reserved3 = 0;
			m_reserved4 = 0;
		}

		AxisRecord::AxisRecord(unsigned short wType) : BiffRecord(TYPE, SIZE)
		{
			m_wType = 0;
			m_reserved1 = 0;
			m_reserved2 = 0;
			m_reserved3 = 0;
			m_reserved4 = 0;
			SetDefaults();
			m_wType = wType;
		}

		unsigned short AxisRecord::GetType()
		{
			return m_wType;
		}

		AxisParentRecord::AxisParentRecord() : BiffRecord(TYPE, SIZE)
		{
			m_iax = 0;
			m_unused1 = 0;
			m_unused2 = 0;
			m_unused3 = 0;
			m_unused4 = 0;
			SetDefaults();
		}

		AxisParentRecord::AxisParentRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_iax = 0;
			m_unused1 = 0;
			m_unused2 = 0;
			m_unused3 = 0;
			m_unused4 = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_AxisParent);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void AxisParentRecord::BlobRead(BlobView* pBlobView)
		{
			m_iax = pBlobView->UnpackUint16();
			m_unused1 = pBlobView->UnpackUint32();
			m_unused2 = pBlobView->UnpackUint32();
			m_unused3 = pBlobView->UnpackUint32();
			m_unused4 = pBlobView->UnpackUint32();
		}

		void AxisParentRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_iax);
			pBlobView->PackUint32(m_unused1);
			pBlobView->PackUint32(m_unused2);
			pBlobView->PackUint32(m_unused3);
			pBlobView->PackUint32(m_unused4);
		}

		void AxisParentRecord::SetDefaults()
		{
			m_iax = 0x0000;
			m_unused1 = 0x000000f6;
			m_unused2 = 0x00000081;
			m_unused3 = 0x00000e44;
			m_unused4 = 0x00000d63;
		}

		AxisLineRecord::AxisLineRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_id = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_AxisLine);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void AxisLineRecord::BlobRead(BlobView* pBlobView)
		{
			m_id = pBlobView->UnpackUint16();
		}

		void AxisLineRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_id);
		}

		void AxisLineRecord::SetDefaults()
		{
			m_id = 0;
		}

		AxisLineRecord::AxisLineRecord(unsigned short id) : BiffRecord(TYPE, SIZE)
		{
			m_id = 0;
			m_id = id;
		}

		unsigned short AxisLineRecord::GetId()
		{
			SetDefaults();
			return m_id;
		}

		AxesUsedRecord::AxesUsedRecord() : BiffRecord(TYPE, SIZE)
		{
			m_cAxes = 0;
			SetDefaults();
		}

		AxesUsedRecord::AxesUsedRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_cAxes = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_AxesUsed);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void AxesUsedRecord::BlobRead(BlobView* pBlobView)
		{
			m_cAxes = pBlobView->UnpackUint16();
		}

		void AxesUsedRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_cAxes);
		}

		void AxesUsedRecord::SetDefaults()
		{
			m_cAxes = 0x0001;
		}

		AxcExtRecord::AxcExtRecord() : BiffRecord(TYPE, SIZE)
		{
			m_catMin = 0;
			m_catMax = 0;
			m_catMajor = 0;
			m_duMajor = 0;
			m_catMinor = 0;
			m_duMinor = 0;
			m_duBase = 0;
			m_catCrossDate = 0;
			m_fAutoMin = 0;
			m_fAutoMax = 0;
			m_fAutoMajor = 0;
			m_fAutoMinor = 0;
			m_fDateAxis = 0;
			m_fAutoBase = 0;
			m_fAutoCross = 0;
			m_fAutoDate = 0;
			m_reserved = 0;
			SetDefaults();
		}

		AxcExtRecord::AxcExtRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_catMin = 0;
			m_catMax = 0;
			m_catMajor = 0;
			m_duMajor = 0;
			m_catMinor = 0;
			m_duMinor = 0;
			m_duBase = 0;
			m_catCrossDate = 0;
			m_fAutoMin = 0;
			m_fAutoMax = 0;
			m_fAutoMajor = 0;
			m_fAutoMinor = 0;
			m_fDateAxis = 0;
			m_fAutoBase = 0;
			m_fAutoCross = 0;
			m_fAutoDate = 0;
			m_reserved = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_AxcExt);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void AxcExtRecord::BlobRead(BlobView* pBlobView)
		{
			m_catMin = pBlobView->UnpackUint16();
			m_catMax = pBlobView->UnpackUint16();
			m_catMajor = pBlobView->UnpackUint16();
			m_duMajor = pBlobView->UnpackUint16();
			m_catMinor = pBlobView->UnpackUint16();
			m_duMinor = pBlobView->UnpackUint16();
			m_duBase = pBlobView->UnpackUint16();
			m_catCrossDate = pBlobView->UnpackUint16();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fAutoMin = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fAutoMax = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fAutoMajor = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_fAutoMinor = (unsigned short)((nBitmask0 >> 3) & 0x1);
			m_fDateAxis = (unsigned short)((nBitmask0 >> 4) & 0x1);
			m_fAutoBase = (unsigned short)((nBitmask0 >> 5) & 0x1);
			m_fAutoCross = (unsigned short)((nBitmask0 >> 6) & 0x1);
			m_fAutoDate = (unsigned short)((nBitmask0 >> 7) & 0x1);
			m_reserved = (unsigned short)((nBitmask0 >> 8) & 0xff);
		}

		void AxcExtRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_catMin);
			pBlobView->PackUint16(m_catMax);
			pBlobView->PackUint16(m_catMajor);
			pBlobView->PackUint16(m_duMajor);
			pBlobView->PackUint16(m_catMinor);
			pBlobView->PackUint16(m_duMinor);
			pBlobView->PackUint16(m_duBase);
			pBlobView->PackUint16(m_catCrossDate);
			int nBitmask0 = 0;
			nBitmask0 += m_fAutoMin << 0;
			nBitmask0 += m_fAutoMax << 1;
			nBitmask0 += m_fAutoMajor << 2;
			nBitmask0 += m_fAutoMinor << 3;
			nBitmask0 += m_fDateAxis << 4;
			nBitmask0 += m_fAutoBase << 5;
			nBitmask0 += m_fAutoCross << 6;
			nBitmask0 += m_fAutoDate << 7;
			nBitmask0 += m_reserved << 8;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
		}

		void AxcExtRecord::SetDefaults()
		{
			m_catMin = 0;
			m_catMax = 0;
			m_catMajor = 0x0001;
			m_duMajor = 0;
			m_catMinor = 0x0001;
			m_duMinor = 0;
			m_duBase = 0;
			m_catCrossDate = 0;
			m_fAutoMin = 0x1;
			m_fAutoMax = 0x1;
			m_fAutoMajor = 0x1;
			m_fAutoMinor = 0x1;
			m_fDateAxis = 0;
			m_fAutoBase = 0x1;
			m_fAutoCross = 0x1;
			m_fAutoDate = 0x1;
			m_reserved = 0;
		}

		AreaRecord::AreaRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_fStacked = 0;
			m_f100 = 0;
			m_fHasShadow = 0;
			m_reserved = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_Area);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void AreaRecord::BlobRead(BlobView* pBlobView)
		{
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fStacked = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_f100 = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fHasShadow = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_reserved = (unsigned short)((nBitmask0 >> 3) & 0x1fff);
		}

		void AreaRecord::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_fStacked << 0;
			nBitmask0 += m_f100 << 1;
			nBitmask0 += m_fHasShadow << 2;
			nBitmask0 += m_reserved << 3;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
		}

		void AreaRecord::SetDefaults()
		{
			m_fStacked = 0;
			m_f100 = 0;
			m_fHasShadow = 0;
			m_reserved = 0;
		}

		AreaRecord::AreaRecord(Chart::Type eType) : BiffRecord(TYPE, SIZE)
		{
			m_fStacked = 0;
			m_f100 = 0;
			m_fHasShadow = 0;
			m_reserved = 0;
			nbAssert::Assert(eType == Chart::Type::TYPE_AREA || eType == Chart::Type::TYPE_AREA_STACKED || eType == Chart::Type::TYPE_AREA_STACKED_100);
			SetDefaults();
			if (eType == Chart::Type::TYPE_AREA_STACKED || eType == Chart::Type::TYPE_AREA_STACKED_100)
				m_fStacked = 1;
			if (eType == Chart::Type::TYPE_AREA_STACKED_100)
				m_f100 = 1;
		}

		Chart::Type AreaRecord::GetChartType()
		{
			if (m_fStacked == 1)
				if (m_f100 == 1)
					return Chart::Type::TYPE_AREA_STACKED_100;
				else
					return Chart::Type::TYPE_AREA_STACKED;
			return Chart::Type::TYPE_AREA;
		}

		AreaFormatRecord::AreaFormatRecord(BiffHeader* pHeader, Stream* pStream) : BiffRecord(pHeader, pStream)
		{
			m_rgbFore = 0;
			m_rgbBack = 0;
			m_fls = 0;
			m_fAuto = 0;
			m_fInvertNeg = 0;
			m_reserved = 0;
			m_icvFore = 0;
			m_icvBack = 0;
			nbAssert::Assert((BiffRecord::Type)(m_pHeader->m_nType) == BiffRecord::Type::TYPE_AreaFormat);
			SetDefaults();
			BlobRead(m_pBlobView);
		}

		void AreaFormatRecord::BlobRead(BlobView* pBlobView)
		{
			m_rgbFore = pBlobView->UnpackUint32();
			m_rgbBack = pBlobView->UnpackUint32();
			m_fls = pBlobView->UnpackUint16();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fAuto = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fInvertNeg = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_reserved = (unsigned short)((nBitmask0 >> 2) & 0x3fff);
			m_icvFore = pBlobView->UnpackUint16();
			m_icvBack = pBlobView->UnpackUint16();
		}

		void AreaFormatRecord::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint32(m_rgbFore);
			pBlobView->PackUint32(m_rgbBack);
			pBlobView->PackUint16(m_fls);
			int nBitmask0 = 0;
			nBitmask0 += m_fAuto << 0;
			nBitmask0 += m_fInvertNeg << 1;
			nBitmask0 += m_reserved << 2;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			pBlobView->PackUint16(m_icvFore);
			pBlobView->PackUint16(m_icvBack);
		}

		void AreaFormatRecord::SetDefaults()
		{
			m_rgbFore = 0;
			m_rgbBack = 0;
			m_fls = 0;
			m_fAuto = 0;
			m_fInvertNeg = 0;
			m_reserved = 0;
			m_icvFore = 0;
			m_icvBack = 0;
		}

		AreaFormatRecord::AreaFormatRecord(unsigned int rgbFore, unsigned int rgbBack, unsigned short fls, bool fAuto, bool fInvertNeg, unsigned short icvFore, unsigned short icvBack) : BiffRecord(TYPE, SIZE)
		{
			m_rgbFore = 0;
			m_rgbBack = 0;
			m_fls = 0;
			m_fAuto = 0;
			m_fInvertNeg = 0;
			m_reserved = 0;
			m_icvFore = 0;
			m_icvBack = 0;
			SetDefaults();
			m_rgbFore = rgbFore;
			m_rgbBack = rgbBack;
			m_fls = fls;
			m_fAuto = 0x0;
			if (fAuto)
				m_fAuto = 0x1;
			m_fInvertNeg = 0x0;
			if (fInvertNeg)
				m_fInvertNeg = 0x1;
			m_icvFore = icvFore;
			m_icvBack = icvBack;
		}

		AreaFormatRecord::AreaFormatRecord(Fill* pFill) : BiffRecord(TYPE, SIZE)
		{
			m_rgbFore = 0;
			m_rgbBack = 0;
			m_fls = 0;
			m_fAuto = 0;
			m_fInvertNeg = 0;
			m_reserved = 0;
			m_icvFore = 0;
			m_icvBack = 0;
			if (pFill->GetType() == Fill::Type::TYPE_NONE)
			{
				m_rgbFore = 0x00ffffff;
				m_rgbBack = 0x00000000;
				m_fls = 0x0000;
				m_icvFore = 0x004e;
				m_icvBack = 0x004d;
			}
			else
			{
				m_icvFore = BiffWorkbookGlobals::SnapToPalette(pFill->GetForegroundColor());
				m_rgbFore = BiffWorkbookGlobals::GetDefaultPaletteColorByIndex(m_icvFore) & 0xFFFFFF;
				m_icvBack = BiffWorkbookGlobals::SnapToPalette(pFill->GetBackgroundColor());
				m_rgbBack = BiffWorkbookGlobals::GetDefaultPaletteColorByIndex(m_icvBack) & 0xFFFFFF;
				m_fls = 0x0001;
			}
			m_fAuto = 0;
			m_fInvertNeg = 0;
			m_reserved = 0;
		}

		void AreaFormatRecord::ModifyFill(Fill* pFill, BiffWorkbookGlobals* pBiffWorkbookGlobals)
		{
			if (m_fAuto == 1 && m_fls == 0x0000)
				return;
			switch (m_fls)
			{
				case 0x0000:
				{
					pFill->SetType(Fill::Type::TYPE_NONE);
					break;
				}

				default:
				{
					pFill->SetType(Fill::Type::TYPE_SOLID);
					break;
				}

			}
			pFill->GetForegroundColor()->Set((unsigned char)(m_rgbFore & 0xFF), (unsigned char)((m_rgbFore >> 8) & 0xFF), (unsigned char)((m_rgbFore >> 16) & 0xFF));
			pFill->GetBackgroundColor()->Set((unsigned char)(m_rgbBack & 0xFF), (unsigned char)((m_rgbBack >> 8) & 0xFF), (unsigned char)((m_rgbBack >> 16) & 0xFF));
			if (m_icvFore != BiffWorkbookGlobals::PALETTE_INDEX_DEFAULT_CHART_FOREGROUND && m_icvFore != BiffWorkbookGlobals::PALETTE_INDEX_DEFAULT_CHART_BACKGROUND)
				pFill->GetForegroundColor()->SetFromRgba(pBiffWorkbookGlobals->GetPaletteColorByIndex(m_icvFore));
			if (m_icvBack != BiffWorkbookGlobals::PALETTE_INDEX_DEFAULT_CHART_FOREGROUND && m_icvBack != BiffWorkbookGlobals::PALETTE_INDEX_DEFAULT_CHART_BACKGROUND)
				pFill->GetBackgroundColor()->SetFromRgba(pBiffWorkbookGlobals->GetPaletteColorByIndex(m_icvBack));
		}

		void AreaFormatRecord::PackForChecksum(BlobView* pBlobView)
		{
			pBlobView->PackUint32(m_rgbFore);
			pBlobView->PackUint32(m_rgbBack);
			pBlobView->PackUint8((unsigned char)(m_fls));
		}

		XTIStruct::XTIStruct()
		{
			m_iSupBook = 0;
			m_itabFirst = 0;
			m_itabLast = 0;
			SetDefaults();
		}

		void XTIStruct::BlobRead(BlobView* pBlobView)
		{
			m_iSupBook = pBlobView->UnpackUint16();
			m_itabFirst = pBlobView->UnpackInt16();
			m_itabLast = pBlobView->UnpackInt16();
		}

		void XTIStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_iSupBook);
			pBlobView->PackInt16(m_itabFirst);
			pBlobView->PackInt16(m_itabLast);
		}

		void XTIStruct::SetDefaults()
		{
			m_iSupBook = 0;
			m_itabFirst = 0;
			m_itabLast = 0;
		}

		XLUnicodeStringStruct::XLUnicodeStringStruct()
		{
			m_cch = 0;
			m_fHighByte = 0;
			m_reserved = 0;
			m_rgb = 0;
			SetDefaults();
		}

		void XLUnicodeStringStruct::BlobRead(BlobView* pBlobView)
		{
			m_cch = pBlobView->UnpackUint16();
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_fHighByte = (unsigned char)((nBitmask0 >> 0) & 0x1);
			m_reserved = (unsigned char)((nBitmask0 >> 1) & 0x7f);
			PostBlobRead(pBlobView);
		}

		void XLUnicodeStringStruct::BlobWrite(BlobView* pBlobView)
		{
			PreBlobWrite(pBlobView);
			pBlobView->PackUint16(m_cch);
			int nBitmask0 = 0;
			nBitmask0 += m_fHighByte << 0;
			nBitmask0 += m_reserved << 1;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
			PostBlobWrite(pBlobView);
		}

		void XLUnicodeStringStruct::SetDefaults()
		{
			m_cch = 0;
			m_fHighByte = 0;
			m_reserved = 0;
			PostSetDefaults();
		}

		void XLUnicodeStringStruct::PostSetDefaults()
		{
			m_rgb = new InternalString("");
		}

		void XLUnicodeStringStruct::PostBlobRead(BlobView* pBlobView)
		{
			if (m_fHighByte == 0)
			{
				for (unsigned short i = 0; i < m_cch; i++)
					m_rgb->AppendChar((unsigned short)(pBlobView->UnpackUint8()));
			}
			else
			{
				for (unsigned short i = 0; i < m_cch; i++)
					m_rgb->AppendChar((unsigned short)(pBlobView->UnpackUint16()));
			}
		}

		void XLUnicodeStringStruct::PreBlobWrite(BlobView* pBlobView)
		{
			m_cch = (unsigned short)(m_rgb->GetLength());
			if (m_rgb->IsAscii())
				m_fHighByte = 0x0;
			else
				m_fHighByte = 0x1;
		}

		void XLUnicodeStringStruct::PostBlobWrite(BlobView* pBlobView)
		{
			if (m_fHighByte > 0)
				m_rgb->BlobWrite16Bit(pBlobView, false);
			else
				m_rgb->BlobWriteUtf8(pBlobView, false);
		}

		int XLUnicodeStringStruct::GetDynamicSize()
		{
			int nSize = m_rgb->GetLength();
			if (!m_rgb->IsAscii())
				nSize = nSize * 2;
			return nSize;
		}

		XLUnicodeStringStruct::~XLUnicodeStringStruct()
		{
			if (m_rgb) delete m_rgb;
		}

		XLUnicodeRichExtendedString_ContinueInfo::XLUnicodeRichExtendedString_ContinueInfo()
		{
			m_nOffset = 0;
			m_fHighByte = 0;
		}

		XLUnicodeRichExtendedString::XLUnicodeRichExtendedString()
		{
			m_cch = 0;
			m_fHighByte = 0;
			m_reserved1 = 0;
			m_fExtSt = 0;
			m_fRichSt = 0;
			m_reserved2 = 0;
			m_cRun = 0;
			m_cbExtRst = 0;
			m_rgb = 0;
			m_pContinueInfoVector = 0;
			SetDefaults();
		}

		void XLUnicodeRichExtendedString::BlobRead(BlobView* pBlobView)
		{
			m_cch = pBlobView->UnpackUint16();
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_fHighByte = (unsigned char)((nBitmask0 >> 0) & 0x1);
			m_reserved1 = (unsigned char)((nBitmask0 >> 1) & 0x1);
			m_fExtSt = (unsigned char)((nBitmask0 >> 2) & 0x1);
			m_fRichSt = (unsigned char)((nBitmask0 >> 3) & 0x1);
			m_reserved2 = (unsigned char)((nBitmask0 >> 4) & 0xf);
			PostBlobRead(pBlobView);
		}

		void XLUnicodeRichExtendedString::BlobWrite(BlobView* pBlobView)
		{
			PreBlobWrite(pBlobView);
			pBlobView->PackUint16(m_cch);
			int nBitmask0 = 0;
			nBitmask0 += m_fHighByte << 0;
			nBitmask0 += m_reserved1 << 1;
			nBitmask0 += m_fExtSt << 2;
			nBitmask0 += m_fRichSt << 3;
			nBitmask0 += m_reserved2 << 4;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
			PostBlobWrite(pBlobView);
		}

		void XLUnicodeRichExtendedString::SetDefaults()
		{
			m_cch = 0;
			m_fHighByte = 0;
			m_reserved1 = 0;
			m_fExtSt = 0;
			m_fRichSt = 0;
			m_reserved2 = 0;
			PostSetDefaults();
		}

		XLUnicodeRichExtendedString::XLUnicodeRichExtendedString(const char* szString)
		{
			m_cch = 0;
			m_fHighByte = 0;
			m_reserved1 = 0;
			m_fExtSt = 0;
			m_fRichSt = 0;
			m_reserved2 = 0;
			m_cRun = 0;
			m_cbExtRst = 0;
			m_rgb = 0;
			m_pContinueInfoVector = 0;
			SetDefaults();
			m_rgb->Set(szString);
			m_cch = (unsigned short)(m_rgb->GetLength());
			m_fHighByte = m_rgb->IsAscii() ? (unsigned char)(0x0) : (unsigned char)(0x1);
		}

		void XLUnicodeRichExtendedString::PostSetDefaults()
		{
			m_cRun = 0;
			m_cbExtRst = 0;
			m_rgb = new InternalString("");
			m_pContinueInfoVector = new OwnedVector<XLUnicodeRichExtendedString_ContinueInfo*>();
		}

		void XLUnicodeRichExtendedString::ContinueAwareBlobRead(BlobView* pBlobView, OwnedVector<BiffRecord_ContinueInfo*>* pContinueInfoVector)
		{
			BlobRead(pBlobView);
			int nStringLength = 0;
			unsigned char fHighByte = m_fHighByte;
			int nNextContinueIndex = 0;
			while (true)
			{
				if (nNextContinueIndex >= pContinueInfoVector->GetSize())
					break;
				int nNextContinueOffset = pContinueInfoVector->Get(nNextContinueIndex)->m_nOffset;
				if (nNextContinueOffset >= pBlobView->GetOffset())
					break;
				nNextContinueIndex++;
			}
			while (nStringLength < m_cch)
			{
				if (pContinueInfoVector->GetSize() > nNextContinueIndex)
				{
					unsigned int nCurrentOffset = (unsigned int)(pBlobView->GetOffset());
					unsigned int nNextContinueOffset = (unsigned int)(pContinueInfoVector->Get(nNextContinueIndex)->m_nOffset);
					if (nCurrentOffset == nNextContinueOffset)
					{
						if (nStringLength < m_cch)
						{
							XLUnicodeRichExtendedString_ContinueInfo* pContinueInfo = new XLUnicodeRichExtendedString_ContinueInfo();
							pContinueInfo->m_nOffset = pBlobView->GetOffset();
							pContinueInfo->m_fHighByte = pBlobView->UnpackUint8();
							fHighByte = pContinueInfo->m_fHighByte;
							{
								NumberDuck::Secret::XLUnicodeRichExtendedString_ContinueInfo* __2394809829 = pContinueInfo;
								pContinueInfo = 0;
								m_pContinueInfoVector->PushBack(__2394809829);
							}
							nNextContinueIndex++;
							if (pContinueInfo) delete pContinueInfo;
						}
					}
				}
				int nReadSize = m_cch - nStringLength;
				if (fHighByte == 1)
					nReadSize = nReadSize << 1;
				{
					int nCurrentOffset = pBlobView->GetOffset();
					int nNextContinueOffset = pBlobView->GetSize();
					while (pContinueInfoVector->GetSize() > nNextContinueIndex)
					{
						nNextContinueOffset = pContinueInfoVector->Get(nNextContinueIndex)->m_nOffset;
						if (nNextContinueOffset > nCurrentOffset)
							break;
						nNextContinueIndex++;
						if (nNextContinueIndex >= pContinueInfoVector->GetSize())
							nNextContinueOffset = pBlobView->GetSize();
					}
					if (nNextContinueOffset < nCurrentOffset + nReadSize)
						nReadSize = nNextContinueOffset - nCurrentOffset;
				}
				if (fHighByte == 0)
				{
					for (int j = 0; j < nReadSize; j++)
						m_rgb->AppendChar((unsigned short)(pBlobView->UnpackUint8()));
					nStringLength += nReadSize;
				}
				else
				{
					for (int j = 0; j < nReadSize >> 1; j++)
						m_rgb->AppendChar((unsigned short)(pBlobView->UnpackUint16()));
					nStringLength += nReadSize >> 1;
				}
			}
			if (m_fRichSt == 0x1)
			{
				for (unsigned short i = 0; i < m_cRun; i++)
				{
					pBlobView->SetOffset(pBlobView->GetOffset() + 4);
				}
			}
			if (m_fExtSt == 0x1)
			{
				pBlobView->SetOffset(pBlobView->GetOffset() + m_cbExtRst);
			}
		}

		void XLUnicodeRichExtendedString::PostBlobRead(BlobView* pBlobView)
		{
			if (m_fRichSt == 0x1)
				m_cRun = pBlobView->UnpackUint16();
			if (m_fExtSt == 0x1)
				m_cbExtRst = pBlobView->UnpackInt32();
		}

		void XLUnicodeRichExtendedString::ContinueAwareBlobWrite(BlobView* pBlobView, OwnedVector<BiffRecord_ContinueInfo*>* pContinueInfoVector)
		{
			int nOffset = pBlobView->GetOffset() + 8;
			int nContinueOffset = nOffset;
			if (pContinueInfoVector->GetSize() > 0)
				nContinueOffset -= pContinueInfoVector->Get(pContinueInfoVector->GetSize() - 1)->m_nOffset;
			if (nContinueOffset + SIZE > BiffRecord::MAX_DATA_SIZE)
			{
				pContinueInfoVector->PushBack(new BiffRecord_ContinueInfo(nOffset, 0));
				nbAssert::Assert(nContinueOffset <= BiffRecord::MAX_DATA_SIZE);
				nContinueOffset = 0;
			}
			BlobWrite(pBlobView);
			nOffset = nOffset + (int)(SIZE);
			nContinueOffset = nContinueOffset + (int)(SIZE);
			nbAssert::Assert(m_cch == m_rgb->GetLength());
			if (m_cch > 0)
			{
				Blob* pDataBlob = new Blob(true);
				BlobView* pDataBlobView = pDataBlob->GetBlobView();
				if (m_fHighByte > 0)
					m_rgb->BlobWrite16Bit(pDataBlobView, false);
				else
					m_rgb->BlobWriteUtf8(pDataBlobView, false);
				pDataBlobView->SetOffset(0);
				while (pDataBlobView->GetOffset() != pDataBlobView->GetSize())
				{
					if (nContinueOffset == 0)
					{
						pBlobView->PackUint8(m_fHighByte);
						nOffset += 1;
						nContinueOffset += 1;
					}
					int nWriteSize = pDataBlobView->GetSize() - pDataBlobView->GetOffset();
					if (nContinueOffset + nWriteSize > BiffRecord::MAX_DATA_SIZE)
					{
						nWriteSize = BiffRecord::MAX_DATA_SIZE - nContinueOffset;
						if (m_fHighByte > 0 && nWriteSize % 2 > 0)
							nWriteSize--;
					}
					if (nWriteSize > 0)
					{
						pBlobView->Pack(pDataBlobView, nWriteSize);
						nOffset += nWriteSize;
						nContinueOffset += nWriteSize;
					}
					if (pDataBlobView->GetOffset() < pDataBlobView->GetSize())
					{
						pContinueInfoVector->PushBack(new BiffRecord_ContinueInfo(nOffset, 0));
						nbAssert::Assert(nContinueOffset <= BiffRecord::MAX_DATA_SIZE);
						nContinueOffset = 0;
					}
				}
				{
					delete pDataBlob;
					pDataBlob = 0;
				}
				if (pDataBlob) delete pDataBlob;
			}
		}

		void XLUnicodeRichExtendedString::PreBlobWrite(BlobView* pBlobView)
		{
		}

		void XLUnicodeRichExtendedString::PostBlobWrite(BlobView* pBlobView)
		{
		}

		XLUnicodeRichExtendedString::~XLUnicodeRichExtendedString()
		{
			if (m_rgb) delete m_rgb;
			if (m_pContinueInfoVector) delete m_pContinueInfoVector;
		}

		ShortXLUnicodeStringStruct::ShortXLUnicodeStringStruct()
		{
			m_cch = 0;
			m_fHighByte = 0;
			m_reserved = 0;
			m_rgb = 0;
			SetDefaults();
		}

		void ShortXLUnicodeStringStruct::BlobRead(BlobView* pBlobView)
		{
			m_cch = pBlobView->UnpackUint8();
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_fHighByte = (unsigned char)((nBitmask0 >> 0) & 0x1);
			m_reserved = (unsigned char)((nBitmask0 >> 1) & 0x7f);
			PostBlobRead(pBlobView);
		}

		void ShortXLUnicodeStringStruct::BlobWrite(BlobView* pBlobView)
		{
			PreBlobWrite(pBlobView);
			pBlobView->PackUint8(m_cch);
			int nBitmask0 = 0;
			nBitmask0 += m_fHighByte << 0;
			nBitmask0 += m_reserved << 1;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
			PostBlobWrite(pBlobView);
		}

		void ShortXLUnicodeStringStruct::SetDefaults()
		{
			m_cch = 0;
			m_fHighByte = 1;
			m_reserved = 0;
			PostSetDefaults();
		}

		void ShortXLUnicodeStringStruct::PostSetDefaults()
		{
			m_rgb = new InternalString("");
		}

		void ShortXLUnicodeStringStruct::PostBlobRead(BlobView* pBlobView)
		{
			if (m_fHighByte == 0)
			{
				for (unsigned short i = 0; i < m_cch; i++)
					m_rgb->AppendChar((unsigned short)(pBlobView->UnpackUint8()));
			}
			else
			{
				for (unsigned short i = 0; i < m_cch; i++)
					m_rgb->AppendChar((unsigned short)(pBlobView->UnpackUint16()));
			}
		}

		void ShortXLUnicodeStringStruct::PreBlobWrite(BlobView* pBlobView)
		{
			m_cch = (unsigned char)(m_rgb->GetLength());
			if (m_rgb->IsAscii())
				m_fHighByte = 0x0;
			else
				m_fHighByte = 0x1;
		}

		void ShortXLUnicodeStringStruct::PostBlobWrite(BlobView* pBlobView)
		{
			if (m_fHighByte > 0)
				m_rgb->BlobWrite16Bit(pBlobView, false);
			else
				m_rgb->BlobWriteUtf8(pBlobView, false);
		}

		int ShortXLUnicodeStringStruct::GetDynamicSize()
		{
			int nSize = m_rgb->GetLength();
			if (!m_rgb->IsAscii())
				nSize = nSize * 2;
			return nSize;
		}

		ShortXLUnicodeStringStruct::~ShortXLUnicodeStringStruct()
		{
			if (m_rgb) delete m_rgb;
		}

		RwUStruct::RwUStruct()
		{
			m_rw = 0;
			SetDefaults();
		}

		void RwUStruct::BlobRead(BlobView* pBlobView)
		{
			m_rw = pBlobView->UnpackUint16();
		}

		void RwUStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_rw);
		}

		void RwUStruct::SetDefaults()
		{
			m_rw = 0;
		}

		RwStruct::RwStruct()
		{
			m_rw = 0;
			SetDefaults();
		}

		void RwStruct::BlobRead(BlobView* pBlobView)
		{
			m_rw = pBlobView->UnpackUint16();
		}

		void RwStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_rw);
		}

		void RwStruct::SetDefaults()
		{
			m_rw = 0;
		}

		RkRecStruct::RkRecStruct()
		{
			m_ixfe = 0;
			m_RK = 0;
			SetDefaults();
		}

		void RkRecStruct::BlobRead(BlobView* pBlobView)
		{
			m_ixfe = pBlobView->UnpackUint16();
			m_RK = pBlobView->UnpackUint32();
		}

		void RkRecStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_ixfe);
			pBlobView->PackUint32(m_RK);
		}

		void RkRecStruct::SetDefaults()
		{
			m_ixfe = 0;
			m_RK = 0;
		}

		RgceStruct::RgceStruct()
		{
			m_pParsedExpressionRecordVector = 0;
			SetDefaults();
		}

		void RgceStruct::BlobRead(BlobView* pBlobView)
		{
			PostBlobRead(pBlobView);
		}

		void RgceStruct::BlobWrite(BlobView* pBlobView)
		{
			PreBlobWrite(pBlobView);
			PostBlobWrite(pBlobView);
		}

		void RgceStruct::SetDefaults()
		{
			PostSetDefaults();
		}

		void RgceStruct::PostSetDefaults()
		{
			m_pParsedExpressionRecordVector = new OwnedVector<ParsedExpressionRecord*>();
		}

		void RgceStruct::PostBlobRead(BlobView* pBlobView)
		{
			while (pBlobView->GetOffset() < pBlobView->GetSize())
			{
				ParsedExpressionRecord* pParsedExpressionRecord = ParsedExpressionRecord::CreateParsedExpressionRecord(pBlobView);
				ParsedExpressionRecord::Type eTemp = pParsedExpressionRecord->GetType();
				{
					NumberDuck::Secret::ParsedExpressionRecord* __3596419756 = pParsedExpressionRecord;
					pParsedExpressionRecord = 0;
					m_pParsedExpressionRecordVector->PushBack(__3596419756);
				}
				if (eTemp == ParsedExpressionRecord::Type::TYPE_UNKNOWN)
				{
					if (pParsedExpressionRecord) delete pParsedExpressionRecord;
					break;
				}
				if (pParsedExpressionRecord) delete pParsedExpressionRecord;
			}
		}

		void RgceStruct::PreBlobWrite(BlobView* pBlobView)
		{
		}

		void RgceStruct::PostBlobWrite(BlobView* pBlobView)
		{
			int i;
			for (i = 0; i < m_pParsedExpressionRecordVector->GetSize(); i++)
			{
				ParsedExpressionRecord* pParsedExpressionRecord = m_pParsedExpressionRecordVector->Get(i);
				pParsedExpressionRecord->BlobWrite(pBlobView);
			}
		}

		int RgceStruct::GetSize()
		{
			int i;
			int nSize = 0;
			for (i = 0; i < m_pParsedExpressionRecordVector->GetSize(); i++)
			{
				ParsedExpressionRecord* pParsedExpressionRecord = m_pParsedExpressionRecordVector->Get(i);
				nSize = nSize + (int)(pParsedExpressionRecord->GetDataSize());
			}
			return nSize;
		}

		RgceStruct::~RgceStruct()
		{
			if (m_pParsedExpressionRecordVector) delete m_pParsedExpressionRecordVector;
		}

		RgceLocStruct::RgceLocStruct()
		{
			m_row = 0;
			m_column = 0;
			SetDefaults();
		}

		void RgceLocStruct::BlobRead(BlobView* pBlobView)
		{
			m_row->BlobRead(pBlobView);
			m_column->BlobRead(pBlobView);
		}

		void RgceLocStruct::BlobWrite(BlobView* pBlobView)
		{
			m_row->BlobWrite(pBlobView);
			m_column->BlobWrite(pBlobView);
		}

		void RgceLocStruct::SetDefaults()
		{
			m_row = new RwUStruct();
			m_column = new ColRelUStruct();
		}

		RgceLocStruct::~RgceLocStruct()
		{
			if (m_row) delete m_row;
			if (m_column) delete m_column;
		}

		RgceAreaStruct::RgceAreaStruct()
		{
			m_rowFirst = 0;
			m_rowLast = 0;
			m_columnFirst = 0;
			m_columnLast = 0;
			SetDefaults();
		}

		void RgceAreaStruct::BlobRead(BlobView* pBlobView)
		{
			m_rowFirst->BlobRead(pBlobView);
			m_rowLast->BlobRead(pBlobView);
			m_columnFirst->BlobRead(pBlobView);
			m_columnLast->BlobRead(pBlobView);
		}

		void RgceAreaStruct::BlobWrite(BlobView* pBlobView)
		{
			m_rowFirst->BlobWrite(pBlobView);
			m_rowLast->BlobWrite(pBlobView);
			m_columnFirst->BlobWrite(pBlobView);
			m_columnLast->BlobWrite(pBlobView);
		}

		void RgceAreaStruct::SetDefaults()
		{
			m_rowFirst = new RwUStruct();
			m_rowLast = new RwUStruct();
			m_columnFirst = new ColRelUStruct();
			m_columnLast = new ColRelUStruct();
		}

		RgceAreaStruct::~RgceAreaStruct()
		{
			if (m_rowFirst) delete m_rowFirst;
			if (m_rowLast) delete m_rowLast;
			if (m_columnFirst) delete m_columnFirst;
			if (m_columnLast) delete m_columnLast;
		}

		Ref8Struct::Ref8Struct()
		{
			m_rwFirst = 0;
			m_rwLast = 0;
			m_colFirst = 0;
			m_colLast = 0;
			SetDefaults();
		}

		void Ref8Struct::BlobRead(BlobView* pBlobView)
		{
			m_rwFirst = pBlobView->UnpackUint16();
			m_rwLast = pBlobView->UnpackUint16();
			m_colFirst = pBlobView->UnpackUint16();
			m_colLast = pBlobView->UnpackUint16();
		}

		void Ref8Struct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_rwFirst);
			pBlobView->PackUint16(m_rwLast);
			pBlobView->PackUint16(m_colFirst);
			pBlobView->PackUint16(m_colLast);
		}

		void Ref8Struct::SetDefaults()
		{
			m_rwFirst = 0;
			m_rwLast = 0;
			m_colFirst = 0;
			m_colLast = 0;
		}

		PtgAttrSpaceTypeStruct::PtgAttrSpaceTypeStruct()
		{
			m_type = 0;
			m_cch = 0;
			SetDefaults();
		}

		void PtgAttrSpaceTypeStruct::BlobRead(BlobView* pBlobView)
		{
			m_type = pBlobView->UnpackUint8();
			m_cch = pBlobView->UnpackUint8();
		}

		void PtgAttrSpaceTypeStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint8(m_type);
			pBlobView->PackUint8(m_cch);
		}

		void PtgAttrSpaceTypeStruct::SetDefaults()
		{
			m_type = 0;
			m_cch = 0;
		}

		OfficeArtRecordHeaderStruct::OfficeArtRecordHeaderStruct()
		{
			m_recVer = 0;
			m_recInstance = 0;
			m_recType = 0;
			m_recLen = 0;
			SetDefaults();
		}

		void OfficeArtRecordHeaderStruct::BlobRead(BlobView* pBlobView)
		{
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_recVer = (unsigned short)((nBitmask0 >> 0) & 0xf);
			m_recInstance = (unsigned short)((nBitmask0 >> 4) & 0xfff);
			m_recType = pBlobView->UnpackUint16();
			m_recLen = pBlobView->UnpackUint32();
		}

		void OfficeArtRecordHeaderStruct::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_recVer << 0;
			nBitmask0 += m_recInstance << 4;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
			pBlobView->PackUint16(m_recType);
			pBlobView->PackUint32(m_recLen);
		}

		void OfficeArtRecordHeaderStruct::SetDefaults()
		{
			m_recVer = 0;
			m_recInstance = 0;
			m_recType = 0;
			m_recLen = 0;
		}

		OfficeArtIDCLStruct::OfficeArtIDCLStruct()
		{
			m_dgid = 0;
			m_cspidCur = 0;
			SetDefaults();
		}

		void OfficeArtIDCLStruct::BlobRead(BlobView* pBlobView)
		{
			m_dgid = pBlobView->UnpackUint32();
			m_cspidCur = pBlobView->UnpackUint32();
		}

		void OfficeArtIDCLStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint32(m_dgid);
			pBlobView->PackUint32(m_cspidCur);
		}

		void OfficeArtIDCLStruct::SetDefaults()
		{
			m_dgid = 0;
			m_cspidCur = 0;
		}

		OfficeArtFRITStruct::OfficeArtFRITStruct()
		{
			m_fridNew = 0;
			m_fridOld = 0;
			SetDefaults();
		}

		void OfficeArtFRITStruct::BlobRead(BlobView* pBlobView)
		{
			m_fridNew = pBlobView->UnpackUint16();
			m_fridOld = pBlobView->UnpackUint16();
		}

		void OfficeArtFRITStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_fridNew);
			pBlobView->PackUint16(m_fridOld);
		}

		void OfficeArtFRITStruct::SetDefaults()
		{
			m_fridNew = 0;
			m_fridOld = 0;
		}

		OfficeArtFOPTEStruct::OfficeArtFOPTEStruct()
		{
			m_opid = 0;
			m_op = 0;
			m_pComplexData = 0;
			SetDefaults();
		}

		void OfficeArtFOPTEStruct::BlobRead(BlobView* pBlobView)
		{
			m_opid->BlobRead(pBlobView);
			m_op = pBlobView->UnpackInt32();
		}

		void OfficeArtFOPTEStruct::BlobWrite(BlobView* pBlobView)
		{
			m_opid->BlobWrite(pBlobView);
			pBlobView->PackInt32(m_op);
		}

		void OfficeArtFOPTEStruct::SetDefaults()
		{
			m_opid = new OfficeArtFOPTEOPIDStruct();
			m_op = 0;
			PostSetDefaults();
		}

		void OfficeArtFOPTEStruct::PostSetDefaults()
		{
			m_pComplexData = 0;
		}

		OfficeArtFOPTEStruct::~OfficeArtFOPTEStruct()
		{
			if (m_opid) delete m_opid;
			if (m_pComplexData) delete m_pComplexData;
		}

		OfficeArtFOPTEOPIDStruct::OfficeArtFOPTEOPIDStruct()
		{
			m_opid = 0;
			m_fBid = 0;
			m_fComplex = 0;
			SetDefaults();
		}

		void OfficeArtFOPTEOPIDStruct::BlobRead(BlobView* pBlobView)
		{
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_opid = (unsigned short)((nBitmask0 >> 0) & 0x3fff);
			m_fBid = (unsigned short)((nBitmask0 >> 14) & 0x1);
			m_fComplex = (unsigned short)((nBitmask0 >> 15) & 0x1);
		}

		void OfficeArtFOPTEOPIDStruct::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_opid << 0;
			nBitmask0 += m_fBid << 14;
			nBitmask0 += m_fComplex << 15;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
		}

		void OfficeArtFOPTEOPIDStruct::SetDefaults()
		{
			m_opid = 0;
			m_fBid = 0;
			m_fComplex = 0;
		}

		MSOCRStruct::MSOCRStruct()
		{
			m_red = 0;
			m_green = 0;
			m_blue = 0;
			m_unused1 = 0;
			m_fSchemeIndex = 0;
			m_unused2 = 0;
			SetDefaults();
		}

		void MSOCRStruct::BlobRead(BlobView* pBlobView)
		{
			m_red = pBlobView->UnpackUint8();
			m_green = pBlobView->UnpackUint8();
			m_blue = pBlobView->UnpackUint8();
			unsigned char nBitmask0 = pBlobView->UnpackUint8();
			m_unused1 = (unsigned char)((nBitmask0 >> 0) & 0x7);
			m_fSchemeIndex = (unsigned char)((nBitmask0 >> 3) & 0x1);
			m_unused2 = (unsigned char)((nBitmask0 >> 4) & 0xf);
		}

		void MSOCRStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint8(m_red);
			pBlobView->PackUint8(m_green);
			pBlobView->PackUint8(m_blue);
			int nBitmask0 = 0;
			nBitmask0 += m_unused1 << 0;
			nBitmask0 += m_fSchemeIndex << 3;
			nBitmask0 += m_unused2 << 4;
			pBlobView->PackUint8((unsigned char)(nBitmask0));
		}

		void MSOCRStruct::SetDefaults()
		{
			m_red = 0;
			m_green = 0;
			m_blue = 0;
			m_unused1 = 0;
			m_fSchemeIndex = 0;
			m_unused2 = 0;
		}

		MD4DigestStruct::MD4DigestStruct()
		{
			m_rgbUid1_0 = 0;
			m_rgbUid1_1 = 0;
			m_rgbUid1_2 = 0;
			m_rgbUid1_3 = 0;
			m_rgbUid1_4 = 0;
			m_rgbUid1_5 = 0;
			m_rgbUid1_6 = 0;
			m_rgbUid1_7 = 0;
			m_rgbUid1_8 = 0;
			m_rgbUid1_9 = 0;
			m_rgbUid1_10 = 0;
			m_rgbUid1_11 = 0;
			m_rgbUid1_12 = 0;
			m_rgbUid1_13 = 0;
			m_rgbUid1_14 = 0;
			m_rgbUid1_15 = 0;
			SetDefaults();
		}

		void MD4DigestStruct::BlobRead(BlobView* pBlobView)
		{
			m_rgbUid1_0 = pBlobView->UnpackUint8();
			m_rgbUid1_1 = pBlobView->UnpackUint8();
			m_rgbUid1_2 = pBlobView->UnpackUint8();
			m_rgbUid1_3 = pBlobView->UnpackUint8();
			m_rgbUid1_4 = pBlobView->UnpackUint8();
			m_rgbUid1_5 = pBlobView->UnpackUint8();
			m_rgbUid1_6 = pBlobView->UnpackUint8();
			m_rgbUid1_7 = pBlobView->UnpackUint8();
			m_rgbUid1_8 = pBlobView->UnpackUint8();
			m_rgbUid1_9 = pBlobView->UnpackUint8();
			m_rgbUid1_10 = pBlobView->UnpackUint8();
			m_rgbUid1_11 = pBlobView->UnpackUint8();
			m_rgbUid1_12 = pBlobView->UnpackUint8();
			m_rgbUid1_13 = pBlobView->UnpackUint8();
			m_rgbUid1_14 = pBlobView->UnpackUint8();
			m_rgbUid1_15 = pBlobView->UnpackUint8();
		}

		void MD4DigestStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint8(m_rgbUid1_0);
			pBlobView->PackUint8(m_rgbUid1_1);
			pBlobView->PackUint8(m_rgbUid1_2);
			pBlobView->PackUint8(m_rgbUid1_3);
			pBlobView->PackUint8(m_rgbUid1_4);
			pBlobView->PackUint8(m_rgbUid1_5);
			pBlobView->PackUint8(m_rgbUid1_6);
			pBlobView->PackUint8(m_rgbUid1_7);
			pBlobView->PackUint8(m_rgbUid1_8);
			pBlobView->PackUint8(m_rgbUid1_9);
			pBlobView->PackUint8(m_rgbUid1_10);
			pBlobView->PackUint8(m_rgbUid1_11);
			pBlobView->PackUint8(m_rgbUid1_12);
			pBlobView->PackUint8(m_rgbUid1_13);
			pBlobView->PackUint8(m_rgbUid1_14);
			pBlobView->PackUint8(m_rgbUid1_15);
		}

		void MD4DigestStruct::SetDefaults()
		{
			m_rgbUid1_0 = 0;
			m_rgbUid1_1 = 0;
			m_rgbUid1_2 = 0;
			m_rgbUid1_3 = 0;
			m_rgbUid1_4 = 0;
			m_rgbUid1_5 = 0;
			m_rgbUid1_6 = 0;
			m_rgbUid1_7 = 0;
			m_rgbUid1_8 = 0;
			m_rgbUid1_9 = 0;
			m_rgbUid1_10 = 0;
			m_rgbUid1_11 = 0;
			m_rgbUid1_12 = 0;
			m_rgbUid1_13 = 0;
			m_rgbUid1_14 = 0;
			m_rgbUid1_15 = 0;
		}

		IcvFontStruct::IcvFontStruct()
		{
			m_icv = 0;
			SetDefaults();
		}

		void IcvFontStruct::BlobRead(BlobView* pBlobView)
		{
			m_icv = pBlobView->UnpackUint16();
		}

		void IcvFontStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_icv);
		}

		void IcvFontStruct::SetDefaults()
		{
			m_icv = 0;
		}

		IXFCellStruct::IXFCellStruct()
		{
			m_ixfe = 0;
			SetDefaults();
		}

		void IXFCellStruct::BlobRead(BlobView* pBlobView)
		{
			m_ixfe = pBlobView->UnpackUint16();
		}

		void IXFCellStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_ixfe);
		}

		void IXFCellStruct::SetDefaults()
		{
			m_ixfe = 0;
		}

		IHlinkStruct::IHlinkStruct()
		{
			m_CLSID_StdHlink_0 = 0;
			m_CLSID_StdHlink_1 = 0;
			m_CLSID_StdHlink_2 = 0;
			m_CLSID_StdHlink_3 = 0;
			m_CLSID_StdHlink_4 = 0;
			m_CLSID_StdHlink_5 = 0;
			m_CLSID_StdHlink_6 = 0;
			m_CLSID_StdHlink_7 = 0;
			m_CLSID_StdHlink_8 = 0;
			m_CLSID_StdHlink_9 = 0;
			m_CLSID_StdHlink_10 = 0;
			m_CLSID_StdHlink_11 = 0;
			m_CLSID_StdHlink_12 = 0;
			m_CLSID_StdHlink_13 = 0;
			m_CLSID_StdHlink_14 = 0;
			m_CLSID_StdHlink_15 = 0;
			m_hyperlink = 0;
			SetDefaults();
		}

		void IHlinkStruct::BlobRead(BlobView* pBlobView)
		{
			m_CLSID_StdHlink_0 = pBlobView->UnpackUint8();
			m_CLSID_StdHlink_1 = pBlobView->UnpackUint8();
			m_CLSID_StdHlink_2 = pBlobView->UnpackUint8();
			m_CLSID_StdHlink_3 = pBlobView->UnpackUint8();
			m_CLSID_StdHlink_4 = pBlobView->UnpackUint8();
			m_CLSID_StdHlink_5 = pBlobView->UnpackUint8();
			m_CLSID_StdHlink_6 = pBlobView->UnpackUint8();
			m_CLSID_StdHlink_7 = pBlobView->UnpackUint8();
			m_CLSID_StdHlink_8 = pBlobView->UnpackUint8();
			m_CLSID_StdHlink_9 = pBlobView->UnpackUint8();
			m_CLSID_StdHlink_10 = pBlobView->UnpackUint8();
			m_CLSID_StdHlink_11 = pBlobView->UnpackUint8();
			m_CLSID_StdHlink_12 = pBlobView->UnpackUint8();
			m_CLSID_StdHlink_13 = pBlobView->UnpackUint8();
			m_CLSID_StdHlink_14 = pBlobView->UnpackUint8();
			m_CLSID_StdHlink_15 = pBlobView->UnpackUint8();
			m_hyperlink->BlobRead(pBlobView);
		}

		void IHlinkStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint8(m_CLSID_StdHlink_0);
			pBlobView->PackUint8(m_CLSID_StdHlink_1);
			pBlobView->PackUint8(m_CLSID_StdHlink_2);
			pBlobView->PackUint8(m_CLSID_StdHlink_3);
			pBlobView->PackUint8(m_CLSID_StdHlink_4);
			pBlobView->PackUint8(m_CLSID_StdHlink_5);
			pBlobView->PackUint8(m_CLSID_StdHlink_6);
			pBlobView->PackUint8(m_CLSID_StdHlink_7);
			pBlobView->PackUint8(m_CLSID_StdHlink_8);
			pBlobView->PackUint8(m_CLSID_StdHlink_9);
			pBlobView->PackUint8(m_CLSID_StdHlink_10);
			pBlobView->PackUint8(m_CLSID_StdHlink_11);
			pBlobView->PackUint8(m_CLSID_StdHlink_12);
			pBlobView->PackUint8(m_CLSID_StdHlink_13);
			pBlobView->PackUint8(m_CLSID_StdHlink_14);
			pBlobView->PackUint8(m_CLSID_StdHlink_15);
			m_hyperlink->BlobWrite(pBlobView);
		}

		void IHlinkStruct::SetDefaults()
		{
			m_CLSID_StdHlink_0 = 0xD0;
			m_CLSID_StdHlink_1 = 0xC9;
			m_CLSID_StdHlink_2 = 0xEA;
			m_CLSID_StdHlink_3 = 0x79;
			m_CLSID_StdHlink_4 = 0xF9;
			m_CLSID_StdHlink_5 = 0xBA;
			m_CLSID_StdHlink_6 = 0xCE;
			m_CLSID_StdHlink_7 = 0x11;
			m_CLSID_StdHlink_8 = 0x8C;
			m_CLSID_StdHlink_9 = 0x82;
			m_CLSID_StdHlink_10 = 0x00;
			m_CLSID_StdHlink_11 = 0xAA;
			m_CLSID_StdHlink_12 = 0x00;
			m_CLSID_StdHlink_13 = 0x4B;
			m_CLSID_StdHlink_14 = 0xA9;
			m_CLSID_StdHlink_15 = 0x0B;
			m_hyperlink = new HyperlinkObjectStruct();
		}

		IHlinkStruct::~IHlinkStruct()
		{
			if (m_hyperlink) delete m_hyperlink;
		}

		HyperlinkStringStruct::HyperlinkStringStruct()
		{
			m_length = 0;
			m_string = 0;
			SetDefaults();
		}

		void HyperlinkStringStruct::BlobRead(BlobView* pBlobView)
		{
			m_length = pBlobView->UnpackUint32();
			PostBlobRead(pBlobView);
		}

		void HyperlinkStringStruct::BlobWrite(BlobView* pBlobView)
		{
			PreBlobWrite(pBlobView);
			pBlobView->PackUint32(m_length);
			PostBlobWrite(pBlobView);
		}

		void HyperlinkStringStruct::SetDefaults()
		{
			m_length = 0;
			PostSetDefaults();
		}

		void HyperlinkStringStruct::PostSetDefaults()
		{
			m_string = new InternalString("");
		}

		void HyperlinkStringStruct::PostBlobRead(BlobView* pBlobView)
		{
			for (unsigned int i = 0; i < m_length; i++)
				m_string->AppendChar((unsigned short)(pBlobView->UnpackUint16()));
		}

		void HyperlinkStringStruct::PreBlobWrite(BlobView* pBlobView)
		{
			m_length = (unsigned int)(m_string->GetLength());
		}

		void HyperlinkStringStruct::PostBlobWrite(BlobView* pBlobView)
		{
			m_string->BlobWrite16Bit(pBlobView, false);
		}

		HyperlinkStringStruct::~HyperlinkStringStruct()
		{
			if (m_string) delete m_string;
		}

		HyperlinkObjectStruct::HyperlinkObjectStruct()
		{
			m_streamVersion = 0;
			m_hlstmfHasMoniker = 0;
			m_hlstmfIsAbsolute = 0;
			m_hlstmfSiteGaveDisplayName = 0;
			m_hlstmfHasLocationStr = 0;
			m_hlstmfHasDisplayName = 0;
			m_hlstmfHasGUID = 0;
			m_hlstmfHasCreationTime = 0;
			m_hlstmfHasFrameName = 0;
			m_hlstmfMonikerSavedAsStr = 0;
			m_hlstmfAbsFromGetdataRel = 0;
			m_reserved = 0;
			m_displayName = 0;
			m_targetFrameName = 0;
			m_moniker = 0;
			m_haxUrl = 0;
			SetDefaults();
		}

		void HyperlinkObjectStruct::BlobRead(BlobView* pBlobView)
		{
			m_streamVersion = pBlobView->UnpackUint32();
			unsigned int nBitmask0 = pBlobView->UnpackUint32();
			m_hlstmfHasMoniker = (unsigned int)((nBitmask0 >> 0) & 0x1);
			m_hlstmfIsAbsolute = (unsigned int)((nBitmask0 >> 1) & 0x1);
			m_hlstmfSiteGaveDisplayName = (unsigned int)((nBitmask0 >> 2) & 0x1);
			m_hlstmfHasLocationStr = (unsigned int)((nBitmask0 >> 3) & 0x1);
			m_hlstmfHasDisplayName = (unsigned int)((nBitmask0 >> 4) & 0x1);
			m_hlstmfHasGUID = (unsigned int)((nBitmask0 >> 5) & 0x1);
			m_hlstmfHasCreationTime = (unsigned int)((nBitmask0 >> 6) & 0x1);
			m_hlstmfHasFrameName = (unsigned int)((nBitmask0 >> 7) & 0x1);
			m_hlstmfMonikerSavedAsStr = (unsigned int)((nBitmask0 >> 8) & 0x1);
			m_hlstmfAbsFromGetdataRel = (unsigned int)((nBitmask0 >> 9) & 0x1);
			m_reserved = (unsigned int)((nBitmask0 >> 10) & 0x3fffff);
			PostBlobRead(pBlobView);
		}

		void HyperlinkObjectStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint32(m_streamVersion);
			unsigned int nBitmask0 = 0;
			nBitmask0 += m_hlstmfHasMoniker << 0;
			nBitmask0 += m_hlstmfIsAbsolute << 1;
			nBitmask0 += m_hlstmfSiteGaveDisplayName << 2;
			nBitmask0 += m_hlstmfHasLocationStr << 3;
			nBitmask0 += m_hlstmfHasDisplayName << 4;
			nBitmask0 += m_hlstmfHasGUID << 5;
			nBitmask0 += m_hlstmfHasCreationTime << 6;
			nBitmask0 += m_hlstmfHasFrameName << 7;
			nBitmask0 += m_hlstmfMonikerSavedAsStr << 8;
			nBitmask0 += m_hlstmfAbsFromGetdataRel << 9;
			nBitmask0 += m_reserved << 10;
			pBlobView->PackUint32((unsigned int)(nBitmask0));
			PostBlobWrite(pBlobView);
		}

		void HyperlinkObjectStruct::SetDefaults()
		{
			m_streamVersion = 0;
			m_hlstmfHasMoniker = 0;
			m_hlstmfIsAbsolute = 0;
			m_hlstmfSiteGaveDisplayName = 0;
			m_hlstmfHasLocationStr = 0;
			m_hlstmfHasDisplayName = 0;
			m_hlstmfHasGUID = 0;
			m_hlstmfHasCreationTime = 0;
			m_hlstmfHasFrameName = 0;
			m_hlstmfMonikerSavedAsStr = 0;
			m_hlstmfAbsFromGetdataRel = 0;
			m_reserved = 0;
			PostSetDefaults();
		}

		void HyperlinkObjectStruct::PostSetDefaults()
		{
			m_displayName = 0;
			m_targetFrameName = 0;
			m_moniker = 0;
			m_haxUrl = 0;
		}

		void HyperlinkObjectStruct::PostBlobRead(BlobView* pBlobView)
		{
			if (m_hlstmfHasDisplayName > 0)
			{
				m_displayName = new HyperlinkStringStruct();
				m_displayName->BlobRead(pBlobView);
			}
			if (m_hlstmfHasFrameName > 0)
			{
				m_targetFrameName = new HyperlinkStringStruct();
				m_targetFrameName->BlobRead(pBlobView);
			}
			if (m_hlstmfHasMoniker > 0 && m_hlstmfMonikerSavedAsStr > 0)
			{
				m_moniker = new HyperlinkStringStruct();
				m_moniker->BlobRead(pBlobView);
			}
			if (m_hlstmfHasMoniker > 0 && m_hlstmfMonikerSavedAsStr == 0)
				if (pBlobView->UnpackUint8() == 0xE0 && pBlobView->UnpackUint8() == 0xC9 && pBlobView->UnpackUint8() == 0xEA && pBlobView->UnpackUint8() == 0x79 && pBlobView->UnpackUint8() == 0xF9 && pBlobView->UnpackUint8() == 0xBA && pBlobView->UnpackUint8() == 0xCE && pBlobView->UnpackUint8() == 0x11 && pBlobView->UnpackUint8() == 0x8C && pBlobView->UnpackUint8() == 0x82 && pBlobView->UnpackUint8() == 0x00 && pBlobView->UnpackUint8() == 0xAA && pBlobView->UnpackUint8() == 0x00 && pBlobView->UnpackUint8() == 0x4B && pBlobView->UnpackUint8() == 0xA9 && pBlobView->UnpackUint8() == 0x0B)
				{
					unsigned int nLength = pBlobView->UnpackUint32();
					nLength = nLength >> 1;
					m_haxUrl = new InternalString("");
					for (unsigned int i = 0; i < nLength; i++)
						m_haxUrl->AppendChar((unsigned short)(pBlobView->UnpackUint16()));
				}
		}

		void HyperlinkObjectStruct::PostBlobWrite(BlobView* pBlobView)
		{
			nbAssert::Assert(m_haxUrl != 0);
			nbAssert::Assert(m_hlstmfHasMoniker > 0 && m_hlstmfMonikerSavedAsStr == 0);
			pBlobView->PackUint8(0xE0);
			pBlobView->PackUint8(0xC9);
			pBlobView->PackUint8(0xEA);
			pBlobView->PackUint8(0x79);
			pBlobView->PackUint8(0xF9);
			pBlobView->PackUint8(0xBA);
			pBlobView->PackUint8(0xCE);
			pBlobView->PackUint8(0x11);
			pBlobView->PackUint8(0x8C);
			pBlobView->PackUint8(0x82);
			pBlobView->PackUint8(0x00);
			pBlobView->PackUint8(0xAA);
			pBlobView->PackUint8(0x00);
			pBlobView->PackUint8(0x4B);
			pBlobView->PackUint8(0xA9);
			pBlobView->PackUint8(0x0B);
			unsigned int URLMoniker_nSize = (unsigned int)((m_haxUrl->GetLength() + 1) * 2 + 16 + 4 + 4);
			pBlobView->PackUint32(URLMoniker_nSize);
			m_haxUrl->BlobWrite16Bit(pBlobView, true);
			pBlobView->PackUint8(0x79);
			pBlobView->PackUint8(0x58);
			pBlobView->PackUint8(0x81);
			pBlobView->PackUint8(0xF4);
			pBlobView->PackUint8(0x3B);
			pBlobView->PackUint8(0x1D);
			pBlobView->PackUint8(0x7F);
			pBlobView->PackUint8(0x48);
			pBlobView->PackUint8(0xAF);
			pBlobView->PackUint8(0x2C);
			pBlobView->PackUint8(0x82);
			pBlobView->PackUint8(0x5D);
			pBlobView->PackUint8(0xC4);
			pBlobView->PackUint8(0x85);
			pBlobView->PackUint8(0x27);
			pBlobView->PackUint8(0x63);
			pBlobView->PackUint32(0);
			pBlobView->PackUint32(43941);
		}

		HyperlinkObjectStruct::~HyperlinkObjectStruct()
		{
			if (m_displayName) delete m_displayName;
			if (m_targetFrameName) delete m_targetFrameName;
			if (m_moniker) delete m_moniker;
			if (m_haxUrl) delete m_haxUrl;
		}

		FullColorExtStruct::FullColorExtStruct()
		{
			m_xclrType = 0;
			m_nTintShade = 0;
			m_xclrValue = 0;
			m_unusedA = 0;
			m_unusedB = 0;
			m_unusedC = 0;
			m_unusedD = 0;
			m_unusedE = 0;
			m_unusedF = 0;
			m_unusedG = 0;
			m_unusedH = 0;
			SetDefaults();
		}

		void FullColorExtStruct::BlobRead(BlobView* pBlobView)
		{
			m_xclrType = pBlobView->UnpackUint16();
			m_nTintShade = pBlobView->UnpackInt16();
			m_xclrValue = pBlobView->UnpackUint32();
			m_unusedA = pBlobView->UnpackUint8();
			m_unusedB = pBlobView->UnpackUint8();
			m_unusedC = pBlobView->UnpackUint8();
			m_unusedD = pBlobView->UnpackUint8();
			m_unusedE = pBlobView->UnpackUint8();
			m_unusedF = pBlobView->UnpackUint8();
			m_unusedG = pBlobView->UnpackUint8();
			m_unusedH = pBlobView->UnpackUint8();
		}

		void FullColorExtStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_xclrType);
			pBlobView->PackInt16(m_nTintShade);
			pBlobView->PackUint32(m_xclrValue);
			pBlobView->PackUint8(m_unusedA);
			pBlobView->PackUint8(m_unusedB);
			pBlobView->PackUint8(m_unusedC);
			pBlobView->PackUint8(m_unusedD);
			pBlobView->PackUint8(m_unusedE);
			pBlobView->PackUint8(m_unusedF);
			pBlobView->PackUint8(m_unusedG);
			pBlobView->PackUint8(m_unusedH);
		}

		void FullColorExtStruct::SetDefaults()
		{
			m_xclrType = 0;
			m_nTintShade = 0;
			m_xclrValue = 0;
			m_unusedA = 0;
			m_unusedB = 0;
			m_unusedC = 0;
			m_unusedD = 0;
			m_unusedE = 0;
			m_unusedF = 0;
			m_unusedG = 0;
			m_unusedH = 0;
		}

		FtPioGrbitStruct::FtPioGrbitStruct()
		{
			m_ft = 0;
			m_cb = 0;
			m_fAutoPict = 0;
			m_fDde = 0;
			m_fPrintCalc = 0;
			m_fIcon = 0;
			m_fCtl = 0;
			m_fPrstm = 0;
			m_unused1 = 0;
			m_fCamera = 0;
			m_fDefaultSize = 0;
			m_fAutoLoad = 0;
			m_unused2 = 0;
			SetDefaults();
		}

		void FtPioGrbitStruct::BlobRead(BlobView* pBlobView)
		{
			m_ft = pBlobView->UnpackUint16();
			m_cb = pBlobView->UnpackUint16();
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fAutoPict = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fDde = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_fPrintCalc = (unsigned short)((nBitmask0 >> 2) & 0x1);
			m_fIcon = (unsigned short)((nBitmask0 >> 3) & 0x1);
			m_fCtl = (unsigned short)((nBitmask0 >> 4) & 0x1);
			m_fPrstm = (unsigned short)((nBitmask0 >> 5) & 0x1);
			m_unused1 = (unsigned short)((nBitmask0 >> 6) & 0x1);
			m_fCamera = (unsigned short)((nBitmask0 >> 7) & 0x1);
			m_fDefaultSize = (unsigned short)((nBitmask0 >> 8) & 0x1);
			m_fAutoLoad = (unsigned short)((nBitmask0 >> 9) & 0x1);
			m_unused2 = (unsigned short)((nBitmask0 >> 10) & 0x3f);
		}

		void FtPioGrbitStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_ft);
			pBlobView->PackUint16(m_cb);
			int nBitmask0 = 0;
			nBitmask0 += m_fAutoPict << 0;
			nBitmask0 += m_fDde << 1;
			nBitmask0 += m_fPrintCalc << 2;
			nBitmask0 += m_fIcon << 3;
			nBitmask0 += m_fCtl << 4;
			nBitmask0 += m_fPrstm << 5;
			nBitmask0 += m_unused1 << 6;
			nBitmask0 += m_fCamera << 7;
			nBitmask0 += m_fDefaultSize << 8;
			nBitmask0 += m_fAutoLoad << 9;
			nBitmask0 += m_unused2 << 10;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
		}

		void FtPioGrbitStruct::SetDefaults()
		{
			m_ft = 0x0008;
			m_cb = 0x0002;
			m_fAutoPict = 0;
			m_fDde = 0;
			m_fPrintCalc = 0;
			m_fIcon = 0;
			m_fCtl = 0;
			m_fPrstm = 0;
			m_unused1 = 0;
			m_fCamera = 0;
			m_fDefaultSize = 0;
			m_fAutoLoad = 0;
			m_unused2 = 0;
		}

		FtCfStruct::FtCfStruct()
		{
			m_ft = 0;
			m_cb = 0;
			m_cf = 0;
			SetDefaults();
		}

		void FtCfStruct::BlobRead(BlobView* pBlobView)
		{
			m_ft = pBlobView->UnpackUint16();
			m_cb = pBlobView->UnpackUint16();
			m_cf = pBlobView->UnpackUint16();
		}

		void FtCfStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_ft);
			pBlobView->PackUint16(m_cb);
			pBlobView->PackUint16(m_cf);
		}

		void FtCfStruct::SetDefaults()
		{
			m_ft = 0x0007;
			m_cb = 0x0002;
			m_cf = 0;
		}

		FrtHeaderStruct::FrtHeaderStruct()
		{
			m_rt = 0;
			m_grbitFrt = 0;
			m_reservedA = 0;
			m_reservedB = 0;
			SetDefaults();
		}

		void FrtHeaderStruct::BlobRead(BlobView* pBlobView)
		{
			m_rt = pBlobView->UnpackUint16();
			m_grbitFrt->BlobRead(pBlobView);
			m_reservedA = pBlobView->UnpackUint32();
			m_reservedB = pBlobView->UnpackUint32();
		}

		void FrtHeaderStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_rt);
			m_grbitFrt->BlobWrite(pBlobView);
			pBlobView->PackUint32(m_reservedA);
			pBlobView->PackUint32(m_reservedB);
		}

		void FrtHeaderStruct::SetDefaults()
		{
			m_rt = 0;
			m_grbitFrt = new FrtFlagsStruct();
			m_reservedA = 0;
			m_reservedB = 0;
		}

		FrtHeaderStruct::~FrtHeaderStruct()
		{
			if (m_grbitFrt) delete m_grbitFrt;
		}

		FrtHeaderOldStruct::FrtHeaderOldStruct()
		{
			m_rt = 0;
			m_grbitFrt = 0;
			SetDefaults();
		}

		void FrtHeaderOldStruct::BlobRead(BlobView* pBlobView)
		{
			m_rt = pBlobView->UnpackUint16();
			m_grbitFrt->BlobRead(pBlobView);
		}

		void FrtHeaderOldStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_rt);
			m_grbitFrt->BlobWrite(pBlobView);
		}

		void FrtHeaderOldStruct::SetDefaults()
		{
			m_rt = 0;
			m_grbitFrt = new FrtFlagsStruct();
		}

		FrtHeaderOldStruct::~FrtHeaderOldStruct()
		{
			if (m_grbitFrt) delete m_grbitFrt;
		}

		FrtFlagsStruct::FrtFlagsStruct()
		{
			m_fFrtRef = 0;
			m_fFrtAlert = 0;
			m_reserved = 0;
			SetDefaults();
		}

		void FrtFlagsStruct::BlobRead(BlobView* pBlobView)
		{
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_fFrtRef = (unsigned short)((nBitmask0 >> 0) & 0x1);
			m_fFrtAlert = (unsigned short)((nBitmask0 >> 1) & 0x1);
			m_reserved = (unsigned short)((nBitmask0 >> 2) & 0x3fff);
		}

		void FrtFlagsStruct::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_fFrtRef << 0;
			nBitmask0 += m_fFrtAlert << 1;
			nBitmask0 += m_reserved << 2;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
		}

		void FrtFlagsStruct::SetDefaults()
		{
			m_fFrtRef = 0;
			m_fFrtAlert = 0;
			m_reserved = 0;
		}

		FormulaValueStruct::FormulaValueStruct()
		{
			m_byte1 = 0;
			m_byte2 = 0;
			m_byte3 = 0;
			m_byte4 = 0;
			m_byte5 = 0;
			m_byte6 = 0;
			m_fExprO = 0;
			SetDefaults();
		}

		void FormulaValueStruct::BlobRead(BlobView* pBlobView)
		{
			m_byte1 = pBlobView->UnpackUint8();
			m_byte2 = pBlobView->UnpackUint8();
			m_byte3 = pBlobView->UnpackUint8();
			m_byte4 = pBlobView->UnpackUint8();
			m_byte5 = pBlobView->UnpackUint8();
			m_byte6 = pBlobView->UnpackUint8();
			m_fExprO = pBlobView->UnpackUint16();
		}

		void FormulaValueStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint8(m_byte1);
			pBlobView->PackUint8(m_byte2);
			pBlobView->PackUint8(m_byte3);
			pBlobView->PackUint8(m_byte4);
			pBlobView->PackUint8(m_byte5);
			pBlobView->PackUint8(m_byte6);
			pBlobView->PackUint16(m_fExprO);
		}

		void FormulaValueStruct::SetDefaults()
		{
			m_byte1 = 0;
			m_byte2 = 0;
			m_byte3 = 0;
			m_byte4 = 0;
			m_byte5 = 0;
			m_byte6 = 0;
			m_fExprO = 0;
		}

		ExtPropStruct::ExtPropStruct()
		{
			m_extType = 0;
			m_cb = 0;
			m_pFullColorExt = 0;
			SetDefaults();
		}

		void ExtPropStruct::BlobRead(BlobView* pBlobView)
		{
			m_extType = pBlobView->UnpackUint16();
			m_cb = pBlobView->UnpackUint16();
			PostBlobRead(pBlobView);
		}

		void ExtPropStruct::BlobWrite(BlobView* pBlobView)
		{
			PreBlobWrite(pBlobView);
			pBlobView->PackUint16(m_extType);
			pBlobView->PackUint16(m_cb);
			PostBlobWrite(pBlobView);
		}

		void ExtPropStruct::SetDefaults()
		{
			m_extType = 0;
			m_cb = 0;
			PostSetDefaults();
		}

		void ExtPropStruct::PostSetDefaults()
		{
			m_pFullColorExt = 0;
		}

		void ExtPropStruct::PostBlobRead(BlobView* pBlobView)
		{
			nbAssert::Assert(m_pFullColorExt == 0);
			switch (m_extType)
			{
				case 0x0004:
				case 0x0005:
				case 0x0007:
				case 0x0008:
				case 0x0009:
				case 0x000A:
				case 0x000B:
				case 0x000D:
				{
					m_pFullColorExt = new FullColorExtStruct();
					m_pFullColorExt->BlobRead(pBlobView);
					break;
				}

				default:
				{
					pBlobView->SetOffset(pBlobView->GetOffset() + m_cb - SIZE);
					break;
				}

			}
		}

		void ExtPropStruct::PreBlobWrite(BlobView* pBlobView)
		{
			nbAssert::Assert(m_pFullColorExt != 0);
			m_cb = SIZE + FullColorExtStruct::SIZE;
		}

		void ExtPropStruct::PostBlobWrite(BlobView* pBlobView)
		{
			if (m_pFullColorExt != 0)
				m_pFullColorExt->BlobWrite(pBlobView);
		}

		ExtPropStruct::~ExtPropStruct()
		{
			if (m_pFullColorExt) delete m_pFullColorExt;
		}

		ColStruct::ColStruct()
		{
			m_col = 0;
			SetDefaults();
		}

		void ColStruct::BlobRead(BlobView* pBlobView)
		{
			m_col = pBlobView->UnpackUint16();
		}

		void ColStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint16(m_col);
		}

		void ColStruct::SetDefaults()
		{
			m_col = 0;
		}

		ColRelUStruct::ColRelUStruct()
		{
			m_col = 0;
			m_colRelative = 0;
			m_rowRelative = 0;
			SetDefaults();
		}

		void ColRelUStruct::BlobRead(BlobView* pBlobView)
		{
			unsigned short nBitmask0 = pBlobView->UnpackUint16();
			m_col = (unsigned short)((nBitmask0 >> 0) & 0x3fff);
			m_colRelative = (unsigned short)((nBitmask0 >> 14) & 0x1);
			m_rowRelative = (unsigned short)((nBitmask0 >> 15) & 0x1);
		}

		void ColRelUStruct::BlobWrite(BlobView* pBlobView)
		{
			int nBitmask0 = 0;
			nBitmask0 += m_col << 0;
			nBitmask0 += m_colRelative << 14;
			nBitmask0 += m_rowRelative << 15;
			pBlobView->PackUint16((unsigned short)(nBitmask0));
		}

		void ColRelUStruct::SetDefaults()
		{
			m_col = 0;
			m_colRelative = 0;
			m_rowRelative = 0;
		}

		CellStruct::CellStruct()
		{
			m_rw = 0;
			m_col = 0;
			m_ixfe = 0;
			SetDefaults();
		}

		void CellStruct::BlobRead(BlobView* pBlobView)
		{
			m_rw->BlobRead(pBlobView);
			m_col->BlobRead(pBlobView);
			m_ixfe->BlobRead(pBlobView);
		}

		void CellStruct::BlobWrite(BlobView* pBlobView)
		{
			m_rw->BlobWrite(pBlobView);
			m_col->BlobWrite(pBlobView);
			m_ixfe->BlobWrite(pBlobView);
		}

		void CellStruct::SetDefaults()
		{
			m_rw = new RwStruct();
			m_col = new ColStruct();
			m_ixfe = new IXFCellStruct();
		}

		CellStruct::~CellStruct()
		{
			if (m_rw) delete m_rw;
			if (m_col) delete m_col;
			if (m_ixfe) delete m_ixfe;
		}

		CellParsedFormulaStruct::CellParsedFormulaStruct()
		{
			m_cce = 0;
			m_rgce = 0;
			SetDefaults();
		}

		void CellParsedFormulaStruct::BlobRead(BlobView* pBlobView)
		{
			m_cce = pBlobView->UnpackUint16();
			PostBlobRead(pBlobView);
		}

		void CellParsedFormulaStruct::BlobWrite(BlobView* pBlobView)
		{
			PreBlobWrite(pBlobView);
			pBlobView->PackUint16(m_cce);
			PostBlobWrite(pBlobView);
		}

		void CellParsedFormulaStruct::SetDefaults()
		{
			m_cce = 0;
			PostSetDefaults();
		}

		CellParsedFormulaStruct::CellParsedFormulaStruct(Formula* pFormula, WorkbookGlobals* pWorkbookGlobals)
		{
			m_cce = 0;
			m_rgce = 0;
			SetDefaults();
			if (pFormula != 0)
			{
				nbAssert::Assert(pWorkbookGlobals != 0);
				pFormula->ToRgce(m_rgce, pWorkbookGlobals);
			}
		}

		void CellParsedFormulaStruct::PostSetDefaults()
		{
			m_rgce = new RgceStruct();
		}

		void CellParsedFormulaStruct::PostBlobRead(BlobView* pBlobView)
		{
			int nStart = pBlobView->GetStart() + pBlobView->GetOffset();
			int nEnd = nStart + m_cce;
			nbAssert::Assert(nEnd <= pBlobView->GetEnd());
			BlobView* pTempBlobView = new BlobView(pBlobView->GetBlob(), nStart, nEnd);
			m_rgce->BlobRead(pTempBlobView);
			pBlobView->SetOffset(pBlobView->GetOffset() + pTempBlobView->GetOffset());
			if (pTempBlobView) delete pTempBlobView;
		}

		void CellParsedFormulaStruct::PreBlobWrite(BlobView* pBlobView)
		{
			m_cce = (unsigned short)(m_rgce->GetSize());
		}

		void CellParsedFormulaStruct::PostBlobWrite(BlobView* pBlobView)
		{
			m_rgce->BlobWrite(pBlobView);
		}

		int CellParsedFormulaStruct::GetSize()
		{
			return SIZE + m_rgce->GetSize();
		}

		CellParsedFormulaStruct::~CellParsedFormulaStruct()
		{
			if (m_rgce) delete m_rgce;
		}

		BuiltInStyleStruct::BuiltInStyleStruct()
		{
			m_istyBuiltIn = 0;
			m_iLevel = 0;
			SetDefaults();
		}

		void BuiltInStyleStruct::BlobRead(BlobView* pBlobView)
		{
			m_istyBuiltIn = pBlobView->UnpackUint8();
			m_iLevel = pBlobView->UnpackUint8();
		}

		void BuiltInStyleStruct::BlobWrite(BlobView* pBlobView)
		{
			pBlobView->PackUint8(m_istyBuiltIn);
			pBlobView->PackUint8(m_iLevel);
		}

		void BuiltInStyleStruct::SetDefaults()
		{
			m_istyBuiltIn = 0;
			m_iLevel = 0;
		}

		OfficeArtDimensions::OfficeArtDimensions()
		{
			m_nCellX1 = 0;
			m_nSubCellX1 = 0;
			m_nCellY1 = 0;
			m_nSubCellY1 = 0;
			m_nCellX2 = 0;
			m_nSubCellX2 = 0;
			m_nCellY2 = 0;
			m_nSubCellY2 = 0;
		}

		BiffWorksheet::BiffWorksheet(Workbook* pWorkbook) : Worksheet(pWorkbook)
		{
			m_pBiffRecordContainer = 0;
			m_pBiffRecordContainer = 0;
		}

		BiffWorksheet::BiffWorksheet(Workbook* pWorkbook, BiffWorkbookGlobals* pBiffWorkbookGlobals, BiffRecord* pInitialBiffRecord, Stream* pStream) : Worksheet(pWorkbook)
		{
			m_pBiffRecordContainer = 0;
			m_pBiffRecordContainer = new BiffRecordContainer(pInitialBiffRecord, pStream);
			SetName(pBiffWorkbookGlobals->GetNextWorksheetName());
			for (int i = 0; i < m_pBiffRecordContainer->m_pBiffRecordVector->GetSize(); i++)
			{
				BiffRecord* pBiffRecord = m_pBiffRecordContainer->m_pBiffRecordVector->Get(i);
				switch (pBiffRecord->GetType())
				{
					case BiffRecord::Type::TYPE_PrintGrid:
					{
						PrintGridRecord* pPrintGridRecord = (PrintGridRecord*)(pBiffRecord);
						SetPrintGridlines(pPrintGridRecord->GetPrintGridlines());
						break;
					}

					case BiffRecord::Type::TYPE_DEFAULTROWHEIGHT:
					{
						DefaultRowHeight* pDefaultRowHeight = (DefaultRowHeight*)(pBiffRecord);
						m_pImpl->m_nDefaultRowHeight = (unsigned short)(pDefaultRowHeight->GetRowHeight());
						break;
					}

					case BiffRecord::Type::TYPE_SETUP:
					{
						SetupRecord* pSetupRecord = (SetupRecord*)(pBiffRecord);
						if (pSetupRecord->GetPortrait())
							SetOrientation(Orientation::ORIENTATION_PORTRAIT);
						else
							SetOrientation(Orientation::ORIENTATION_LANDSCAPE);
						break;
					}

					case BiffRecord::Type::TYPE_COLINFO:
					{
						ColInfoRecord* pColInfoRecord = (ColInfoRecord*)(pBiffRecord);
						for (unsigned short j = pColInfoRecord->GetFirstColumn(); j <= pColInfoRecord->GetLastColumn(); j++)
						{
							SetColumnWidth(j, (unsigned short)(((unsigned int)(pColInfoRecord->GetColumnWidth()) * 1789 + 65426 / 2) / 65426));
							SetColumnHidden(j, pColInfoRecord->GetHidden());
						}
						break;
					}

					case BiffRecord::Type::TYPE_ROW:
					{
						RowRecord* pRowRecord = (RowRecord*)(pBiffRecord);
						SetRowHeight(pRowRecord->GetRow(), (unsigned short)(((unsigned int)(pRowRecord->GetHeight()) * 546 + 8190 / 2) / 8190));
						break;
					}

					case BiffRecord::Type::TYPE_LABELSST:
					{
						LabelSstRecord* pLabelSstRecord = (LabelSstRecord*)(pBiffRecord);
						Cell* pCell = GetCell(pLabelSstRecord->GetX(), pLabelSstRecord->GetY());
						pCell->SetString(pBiffWorkbookGlobals->GetSharedStringByIndex(pLabelSstRecord->GetSstIndex()));
						pCell->SetStyle(pBiffWorkbookGlobals->GetStyleByXfIndex(pLabelSstRecord->GetXfIndex()));
						break;
					}

					case BiffRecord::Type::TYPE_RK:
					{
						RkRecord* pRkRecord = (RkRecord*)(pBiffRecord);
						Cell* pCell = GetCell(pRkRecord->GetX(), pRkRecord->GetY());
						pCell->SetFloat(BiffUtils::RkValueDecode(pRkRecord->GetRkValue()));
						pCell->SetStyle(pBiffWorkbookGlobals->GetStyleByXfIndex(pRkRecord->GetXfIndex()));
						break;
					}

					case BiffRecord::Type::TYPE_MULRK:
					{
						MulRkRecord* pMulRkRecord = (MulRkRecord*)(pBiffRecord);
						unsigned short nX = pMulRkRecord->GetX();
						unsigned short nY = pMulRkRecord->GetY();
						unsigned short nNumRk = pMulRkRecord->GetNumRk();
						for (unsigned short j = 0; j < nNumRk; j++)
						{
							Cell* pCell = GetCell((unsigned short)(nX + j), nY);
							pCell->SetFloat(BiffUtils::RkValueDecode(pMulRkRecord->GetRkValueByIndex(j)));
							pCell->SetStyle(pBiffWorkbookGlobals->GetStyleByXfIndex(pMulRkRecord->GetXfIndexByIndex(j)));
						}
						break;
					}

					case BiffRecord::Type::TYPE_BLANK:
					{
						Blank* pBlank = (Blank*)(pBiffRecord);
						Cell* pCell = GetCell(pBlank->GetX(), pBlank->GetY());
						pCell->SetStyle(pBiffWorkbookGlobals->GetStyleByXfIndex(pBlank->GetXfIndex()));
						break;
					}

					case BiffRecord::Type::TYPE_MULBLANK:
					{
						MulBlank* pMulBlank = (MulBlank*)(pBiffRecord);
						unsigned short nX = pMulBlank->GetX();
						unsigned short nY = pMulBlank->GetY();
						unsigned short nNumColumn = pMulBlank->GetNumColumn();
						for (unsigned short j = 0; j < nNumColumn; j++)
						{
							Cell* pCell = GetCell((unsigned short)(nX + j), nY);
							pCell->SetStyle(pBiffWorkbookGlobals->GetStyleByXfIndex(pMulBlank->GetXfIndexByIndex(j)));
						}
						break;
					}

					case BiffRecord::Type::TYPE_NUMBER:
					{
						NumberRecord* pNumberRecord = (NumberRecord*)(pBiffRecord);
						Cell* pCell = GetCell(pNumberRecord->GetX(), pNumberRecord->GetY());
						pCell->SetFloat(pNumberRecord->GetNumber());
						pCell->SetStyle(pBiffWorkbookGlobals->GetStyleByXfIndex(pNumberRecord->GetXfIndex()));
						break;
					}

					case BiffRecord::Type::TYPE_BOOLERR:
					{
						BoolErrRecord* pBoolErrRecord = (BoolErrRecord*)(pBiffRecord);
						if (pBoolErrRecord->IsBoolean())
						{
							Cell* pCell = GetCell(pBoolErrRecord->GetX(), pBoolErrRecord->GetY());
							pCell->SetBoolean(pBoolErrRecord->GetBoolean());
							pCell->SetStyle(pBiffWorkbookGlobals->GetStyleByXfIndex(pBoolErrRecord->GetXfIndex()));
						}
						break;
					}

					case BiffRecord::Type::TYPE_FORMULA:
					{
						FormulaRecord* pFormulaRecord = (FormulaRecord*)(pBiffRecord);
						unsigned short nX = pFormulaRecord->GetX();
						unsigned short nY = pFormulaRecord->GetY();
						Cell* pCell = GetCell(nX, nY);
						pCell->m_pImpl->SetFormula(pFormulaRecord->GetFormula(pBiffWorkbookGlobals));
						pCell->SetStyle(pBiffWorkbookGlobals->GetStyleByXfIndex(pFormulaRecord->GetXfIndex()));
						break;
					}

					case BiffRecord::Type::TYPE_OBJ:
					{
						ObjRecord* pObjRecord = (ObjRecord*)(pBiffRecord);
						if (pObjRecord->GetType() == FtCmoStruct::ObjType::OBJ_TYPE_PICTURE || pObjRecord->GetType() == FtCmoStruct::ObjType::OBJ_TYPE_CHART)
						{
							if (m_pBiffRecordContainer->m_pBiffRecordVector->Get(i - 1)->GetType() == BiffRecord::Type::TYPE_MSO_DRAWING)
							{
								MsoDrawingRecord* pMsoDrawingRecord = (MsoDrawingRecord*)(m_pBiffRecordContainer->m_pBiffRecordVector->Get(i - 1));
								const MsoDrawingRecord_Position* pPosition = pMsoDrawingRecord->GetPosition();
								if (pPosition != 0)
								{
									unsigned short nX = pPosition->m_nCellX1;
									int nColumnWidth = GetColumnWidth(nX);
									int nSubX = (pPosition->m_nSubCellX1 * nColumnWidth + 1024 / 2) / 1024;
									unsigned short nY = pPosition->m_nCellY1;
									int nRowHeight = GetRowHeight(nY);
									int nSubY = (pPosition->m_nSubCellY1 * nRowHeight + 256 / 2) / 256;
									int nSubX2 = (pPosition->m_nSubCellX2 * GetColumnWidth(pPosition->m_nCellX2) + 1024 / 2) / 1024;
									int nSubY2 = (pPosition->m_nSubCellY2 * GetRowHeight(pPosition->m_nCellY2) + 256 / 2) / 256;
									int nWidth = 0;
									if (pPosition->m_nCellX1 == pPosition->m_nCellX2)
									{
										nWidth = nSubX2 - nSubX;
									}
									else
									{
										nWidth = nColumnWidth - nSubX;
										for (unsigned short nColumn = (unsigned short)(pPosition->m_nCellX1 + 1); nColumn < pPosition->m_nCellX2; nColumn++)
											nWidth = nWidth + GetColumnWidth(nColumn);
										nWidth = nWidth + nSubX2;
									}
									int nHeight = 0;
									if (pPosition->m_nCellY1 == pPosition->m_nCellY2)
									{
										nHeight = nSubY2 - nSubY;
									}
									else
									{
										nHeight = nRowHeight - nSubY;
										for (unsigned short nRow = (unsigned short)(pPosition->m_nCellY1 + 1); nRow < pPosition->m_nCellY2; nRow++)
											nHeight = nHeight + GetRowHeight(nRow);
										nHeight = nHeight + nSubY2;
									}
									switch (pObjRecord->GetType())
									{
										case FtCmoStruct::ObjType::OBJ_TYPE_PICTURE:
										{
											OfficeArtFOPTEStruct* pPib = pMsoDrawingRecord->GetProperty(OfficeArtRecord::OPIDType::OPID_PIB);
											if (pPib != 0)
											{
												if (pPib->m_opid->m_fComplex == 0x0)
												{
													unsigned int nBlipIndex = Utils::ByteConvertInt32ToUint32(pPib->m_op) - 1;
													MsoDrawingGroupRecord* pMsoDrawingGroupRecord = pBiffWorkbookGlobals->GetMsoDrawingGroupRecord();
													OfficeArtDggContainerRecord* pOfficeArtDggContainerRecord = pMsoDrawingGroupRecord->GetOfficeArtDggContainerRecord();
													OfficeArtBStoreContainerRecord* pOfficeArtBStoreContainerRecord = (OfficeArtBStoreContainerRecord*)(pOfficeArtDggContainerRecord->FindOfficeArtRecordByType(OfficeArtRecord::Type::TYPE_OFFICE_ART_B_STORE_CONTAINER));
													if (nBlipIndex < pOfficeArtBStoreContainerRecord->GetNumOfficeArtRecord())
													{
														OfficeArtRecord* pOfficeArtRecord = pOfficeArtBStoreContainerRecord->GetOfficeArtRecordByIndex((unsigned short)(nBlipIndex));
														if (pOfficeArtRecord != 0 && pOfficeArtRecord->GetType() == OfficeArtRecord::Type::TYPE_OFFICE_ART_FBSE)
														{
															OfficeArtFBSERecord* pOfficeArtFBSERecord = (OfficeArtFBSERecord*)(pOfficeArtRecord);
															OfficeArtBlipRecord* pEmbeddedBlip = pOfficeArtFBSERecord->GetEmbeddedBlip();
															Picture::Format eFormat = Picture::Format::JPEG;
															switch (pEmbeddedBlip->GetType())
															{
																case OfficeArtRecord::Type::TYPE_OFFICE_ART_BLIP_EMF:
																{
																	eFormat = Picture::Format::EMF;
																	break;
																}

																case OfficeArtRecord::Type::TYPE_OFFICE_ART_BLIP_WMF:
																{
																	eFormat = Picture::Format::WMF;
																	break;
																}

																case OfficeArtRecord::Type::TYPE_OFFICE_ART_BLIP_PICT:
																{
																	eFormat = Picture::Format::PICT;
																	break;
																}

																case OfficeArtRecord::Type::TYPE_OFFICE_ART_BLIP_JPEG:
																{
																	eFormat = Picture::Format::JPEG;
																	break;
																}

																case OfficeArtRecord::Type::TYPE_OFFICE_ART_BLIP_PNG:
																{
																	eFormat = Picture::Format::PNG;
																	break;
																}

																case OfficeArtRecord::Type::TYPE_OFFICE_ART_BLIP_DIB:
																{
																	eFormat = Picture::Format::DIB;
																	break;
																}

																case OfficeArtRecord::Type::TYPE_OFFICE_ART_BLIP_TIFF:
																{
																	eFormat = Picture::Format::TIFF;
																	break;
																}

																case OfficeArtRecord::Type::TYPE_OFFICE_ART_BLIP_JPEG_CMYK:
																{
																	eFormat = Picture::Format::JPEG;
																	break;
																}

																default:
																{
																	nbAssert::Assert(false);
																	break;
																}

															}
															InternalString* sUrl = new InternalString("");
															OfficeArtFOPTEStruct* pHyperlink = pMsoDrawingRecord->GetProperty(OfficeArtRecord::OPIDType::OPID_HYPERLINK);
															if (pHyperlink != 0 && pHyperlink->m_pComplexData != 0)
															{
																BlobView* pBlobView = pHyperlink->m_pComplexData->GetBlobView();
																pBlobView->SetOffset(0);
																IHlinkStruct* pIHlink = new IHlinkStruct();
																pIHlink->BlobRead(pBlobView);
																if (pIHlink->m_hyperlink->m_haxUrl != 0)
																	sUrl->Set(pIHlink->m_hyperlink->m_haxUrl->GetExternalString());
																{
																	delete pIHlink;
																	pIHlink = 0;
																}
																if (pIHlink) delete pIHlink;
															}
															Picture* pPicture = new Picture(pEmbeddedBlip->GetBlob(), eFormat);
															pPicture->SetX(nX);
															pPicture->SetSubX((unsigned short)(nSubX));
															pPicture->SetY(nY);
															pPicture->SetSubY((unsigned short)(nSubY));
															pPicture->SetWidth((unsigned short)(nWidth));
															pPicture->SetHeight((unsigned short)(nHeight));
															pPicture->SetUrl(sUrl->GetExternalString());
															{
																NumberDuck::Picture* __417512960 = pPicture;
																pPicture = 0;
																m_pImpl->m_pPictureVector->PushBack(__417512960);
															}
															{
																delete sUrl;
																sUrl = 0;
															}
															if (sUrl) delete sUrl;
															if (pPicture) delete pPicture;
														}
													}
												}
											}
											break;
										}

										case FtCmoStruct::ObjType::OBJ_TYPE_CHART:
										{
											if (m_pBiffRecordContainer->m_pBiffRecordVector->Get(i + 1)->GetType() == BiffRecord::Type::TYPE_BOF)
											{
												BofRecord* pBofRecord = (BofRecord*)(m_pBiffRecordContainer->m_pBiffRecordVector->Get(i + 1));
												if (pBofRecord->GetBofType() == BofRecord::BofType::BOF_TYPE_CHART)
												{
													Chart* pChart = 0;
													LineFormatRecord* pDefaultLineFormatRecord = 0;
													AreaFormatRecord* pDefaultAreaFormatRecord = 0;
													MarkerFormatRecord* pDefaultMarkerFormatRecord = 0;
													int j = i + 2;
													pBiffRecord = m_pBiffRecordContainer->m_pBiffRecordVector->Get(j);
													while (pBiffRecord->GetType() != BiffRecord::Type::TYPE_EOF)
													{
														j++;
														pBiffRecord = m_pBiffRecordContainer->m_pBiffRecordVector->Get(j);
														if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_ChartFormat && m_pBiffRecordContainer->m_pBiffRecordVector->Get(j + 1)->GetType() == BiffRecord::Type::TYPE_Begin)
														{
															j++;
															while (true)
															{
																j++;
																pBiffRecord = m_pBiffRecordContainer->m_pBiffRecordVector->Get(j);
																if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Bar)
																	pChart = new Chart(this, ((BarRecord*)(pBiffRecord))->GetChartType());
																else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Line)
																	pChart = new Chart(this, ((LineRecord*)(pBiffRecord))->GetChartType());
																else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Area)
																	pChart = new Chart(this, ((AreaRecord*)(pBiffRecord))->GetChartType());
																else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Scatter)
																	pChart = new Chart(this, ((ScatterRecord*)(pBiffRecord))->GetChartType());
																else if (pChart != 0 && pBiffRecord->GetType() == BiffRecord::Type::TYPE_DataFormat && m_pBiffRecordContainer->m_pBiffRecordVector->Get(j + 1)->GetType() == BiffRecord::Type::TYPE_Begin)
																{
																	j++;
																	while (true)
																	{
																		j++;
																		pBiffRecord = m_pBiffRecordContainer->m_pBiffRecordVector->Get(j);
																		if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_LineFormat)
																			pDefaultLineFormatRecord = (LineFormatRecord*)(pBiffRecord);
																		if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_AreaFormat)
																			pDefaultAreaFormatRecord = (AreaFormatRecord*)(pBiffRecord);
																		else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_MarkerFormat)
																			pDefaultMarkerFormatRecord = (MarkerFormatRecord*)(pBiffRecord);
																		else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Begin)
																			j = LoopToEnd(j, m_pBiffRecordContainer);
																		else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_End)
																			break;
																	}
																}
																else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Begin)
																	j = LoopToEnd(j, m_pBiffRecordContainer);
																else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_End)
																	break;
															}
														}
													}
													if (pChart != 0)
													{
														pChart->SetX(nX);
														pChart->SetSubX((unsigned short)(nSubX));
														pChart->SetY(nY);
														pChart->SetSubY((unsigned short)(nSubY));
														pChart->SetWidth((unsigned short)(nWidth));
														pChart->SetHeight((unsigned short)(nHeight));
														pChart->m_pImpl->SetClassicStyle();
														while (true)
														{
															i++;
															pBiffRecord = m_pBiffRecordContainer->m_pBiffRecordVector->Get(i);
															if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Chart && m_pBiffRecordContainer->m_pBiffRecordVector->Get(i + 1)->GetType() == BiffRecord::Type::TYPE_Begin)
															{
																i++;
																while (true)
																{
																	i++;
																	pBiffRecord = m_pBiffRecordContainer->m_pBiffRecordVector->Get(i);
																	if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Frame && m_pBiffRecordContainer->m_pBiffRecordVector->Get(i + 1)->GetType() == BiffRecord::Type::TYPE_Begin)
																	{
																		i++;
																		LineFormatRecord* pLineFormat = 0;
																		AreaFormatRecord* pAreaFormat = 0;
																		while (true)
																		{
																			i++;
																			pBiffRecord = m_pBiffRecordContainer->m_pBiffRecordVector->Get(i);
																			if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_LineFormat)
																			{
																				pLineFormat = (LineFormatRecord*)(pBiffRecord);
																				pLineFormat->ModifyLine(pChart->GetFrameBorderLine(), pBiffWorkbookGlobals);
																			}
																			else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_AreaFormat)
																			{
																				pAreaFormat = (AreaFormatRecord*)(pBiffRecord);
																				pAreaFormat->ModifyFill(pChart->GetFrameFill(), pBiffWorkbookGlobals);
																			}
																			else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Begin)
																				i = LoopToEnd(i, m_pBiffRecordContainer);
																			else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_ShapePropsStream)
																			{
																			}
																			else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_End)
																				break;
																		}
																	}
																	else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Series && m_pBiffRecordContainer->m_pBiffRecordVector->Get(i + 1)->GetType() == BiffRecord::Type::TYPE_Begin)
																	{
																		i++;
																		Formula* pNameFormula = 0;
																		Formula* pValuesFormula = 0;
																		Formula* pCategoriesFormula = 0;
																		int k = i;
																		while (true)
																		{
																			k++;
																			pBiffRecord = m_pBiffRecordContainer->m_pBiffRecordVector->Get(k);
																			if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_BRAI)
																			{
																				BraiRecord* pBraiRecord = (BraiRecord*)(pBiffRecord);
																				if (pBraiRecord->GetRt() == 0x02)
																				{
																					if (pBraiRecord->GetId() == 0x00)
																						pNameFormula = pBraiRecord->GetFormula(pBiffWorkbookGlobals);
																					else if (pBraiRecord->GetId() == 0x01)
																						pValuesFormula = pBraiRecord->GetFormula(pBiffWorkbookGlobals);
																					else if (pBraiRecord->GetId() == 0x02)
																						pCategoriesFormula = pBraiRecord->GetFormula(pBiffWorkbookGlobals);
																				}
																			}
																			else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Begin)
																				k = LoopToEnd(k, m_pBiffRecordContainer);
																			else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_End)
																				break;
																		}
																		if (pValuesFormula != 0)
																		{
																			Series* pSeries = 0;
																			{
																				NumberDuck::Secret::Formula* __310527988 = pValuesFormula;
																				pValuesFormula = 0;
																				pSeries = pChart->m_pImpl->CreateSeries(__310527988);
																			}
																			if (pNameFormula != 0)
																			{
																				NumberDuck::Secret::Formula* __4039636097 = pNameFormula;
																				pNameFormula = 0;
																				pSeries->m_pImpl->SetNameFormula(__4039636097);
																			}
																			if (pCategoriesFormula != 0)
																			{
																				NumberDuck::Secret::Formula* __3225269424 = pCategoriesFormula;
																				pCategoriesFormula = 0;
																				pChart->m_pImpl->SetCategoriesFormula(__3225269424);
																			}
																			pSeries->m_pImpl->SetClassicStyle(pChart->GetType(), (unsigned short)(pChart->GetNumSeries() - 1));
																			if (pDefaultLineFormatRecord != 0)
																				pDefaultLineFormatRecord->ModifyLine(pSeries->GetLine(), pBiffWorkbookGlobals);
																			if (pDefaultAreaFormatRecord != 0)
																				pDefaultAreaFormatRecord->ModifyFill(pSeries->GetFill(), pBiffWorkbookGlobals);
																			if (pDefaultMarkerFormatRecord != 0)
																				pDefaultMarkerFormatRecord->ModifyMarker(pSeries->GetMarker(), pBiffWorkbookGlobals);
																			while (true)
																			{
																				i++;
																				pBiffRecord = m_pBiffRecordContainer->m_pBiffRecordVector->Get(i);
																				if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_DataFormat && m_pBiffRecordContainer->m_pBiffRecordVector->Get(i + 1)->GetType() == BiffRecord::Type::TYPE_Begin)
																				{
																					i++;
																					while (true)
																					{
																						i++;
																						pBiffRecord = m_pBiffRecordContainer->m_pBiffRecordVector->Get(i);
																						if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_LineFormat)
																							((LineFormatRecord*)(pBiffRecord))->ModifyLine(pSeries->GetLine(), pBiffWorkbookGlobals);
																						else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_AreaFormat)
																							((AreaFormatRecord*)(pBiffRecord))->ModifyFill(pSeries->GetFill(), pBiffWorkbookGlobals);
																						else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_MarkerFormat)
																							((MarkerFormatRecord*)(pBiffRecord))->ModifyMarker(pSeries->GetMarker(), pBiffWorkbookGlobals);
																						else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Begin)
																							i = LoopToEnd(i, m_pBiffRecordContainer);
																						else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_End)
																							break;
																					}
																				}
																				else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Begin)
																					i = LoopToEnd(i, m_pBiffRecordContainer);
																				else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_End)
																					break;
																			}
																		}
																		else
																		{
																			{
																				delete pNameFormula;
																				pNameFormula = 0;
																			}
																			{
																				delete pValuesFormula;
																				pValuesFormula = 0;
																			}
																			{
																				delete pCategoriesFormula;
																				pCategoriesFormula = 0;
																			}
																			i = LoopToEnd(i, m_pBiffRecordContainer);
																		}
																		if (pNameFormula) delete pNameFormula;
																		if (pValuesFormula) delete pValuesFormula;
																		if (pCategoriesFormula) delete pCategoriesFormula;
																	}
																	else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_AxisParent && m_pBiffRecordContainer->m_pBiffRecordVector->Get(i + 1)->GetType() == BiffRecord::Type::TYPE_Begin)
																	{
																		i++;
																		while (true)
																		{
																			i++;
																			pBiffRecord = m_pBiffRecordContainer->m_pBiffRecordVector->Get(i);
																			if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Axis && m_pBiffRecordContainer->m_pBiffRecordVector->Get(i + 1)->GetType() == BiffRecord::Type::TYPE_Begin)
																			{
																				i++;
																				unsigned short nType = ((AxisRecord*)(pBiffRecord))->GetType();
																				if (nType == 0x0000 || nType == 0x0001)
																				{
																					Line* pAxisLine = pChart->GetHorizontalAxisLine();
																					Line* pGridLine = pChart->GetHorizontalGridLine();
																					if (((AxisRecord*)(pBiffRecord))->GetType() == 0x0001)
																					{
																						pAxisLine = pChart->GetVerticalAxisLine();
																						pGridLine = pChart->GetVerticalGridLine();
																					}
																					while (true)
																					{
																						i++;
																						pBiffRecord = m_pBiffRecordContainer->m_pBiffRecordVector->Get(i);
																						if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_AxisLine && m_pBiffRecordContainer->m_pBiffRecordVector->Get(i + 1)->GetType() == BiffRecord::Type::TYPE_LineFormat)
																						{
																							switch (((AxisLineRecord*)(pBiffRecord))->GetId())
																							{
																								case 0x0000:
																								{
																									i++;
																									pBiffRecord = m_pBiffRecordContainer->m_pBiffRecordVector->Get(i);
																									((LineFormatRecord*)(pBiffRecord))->ModifyLine(pAxisLine, pBiffWorkbookGlobals);
																									break;
																								}

																								case 0x0001:
																								{
																									i++;
																									pBiffRecord = m_pBiffRecordContainer->m_pBiffRecordVector->Get(i);
																									((LineFormatRecord*)(pBiffRecord))->ModifyLine(pGridLine, pBiffWorkbookGlobals);
																									break;
																								}

																							}
																						}
																						else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Begin)
																							i = LoopToEnd(i, m_pBiffRecordContainer);
																						else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_End)
																							break;
																					}
																				}
																			}
																			else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_PlotArea && m_pBiffRecordContainer->m_pBiffRecordVector->Get(i + 1)->GetType() == BiffRecord::Type::TYPE_Frame && m_pBiffRecordContainer->m_pBiffRecordVector->Get(i + 2)->GetType() == BiffRecord::Type::TYPE_Begin)
																			{
																				i += 2;
																				while (true)
																				{
																					i++;
																					pBiffRecord = m_pBiffRecordContainer->m_pBiffRecordVector->Get(i);
																					if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_LineFormat)
																						((LineFormatRecord*)(pBiffRecord))->ModifyLine(pChart->GetPlotBorderLine(), pBiffWorkbookGlobals);
																					else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_AreaFormat)
																						((AreaFormatRecord*)(pBiffRecord))->ModifyFill(pChart->GetPlotFill(), pBiffWorkbookGlobals);
																					else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Begin)
																						i = LoopToEnd(i, m_pBiffRecordContainer);
																					else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_End)
																						break;
																				}
																			}
																			else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_ChartFormat && m_pBiffRecordContainer->m_pBiffRecordVector->Get(i + 1)->GetType() == BiffRecord::Type::TYPE_Begin)
																			{
																				i++;
																				while (true)
																				{
																					i++;
																					pBiffRecord = m_pBiffRecordContainer->m_pBiffRecordVector->Get(i);
																					if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Legend && m_pBiffRecordContainer->m_pBiffRecordVector->Get(i + 1)->GetType() == BiffRecord::Type::TYPE_Begin)
																					{
																						((LegendRecord*)(pBiffRecord))->ModifyLegend(pChart->GetLegend(), pBiffWorkbookGlobals);
																						i++;
																						while (true)
																						{
																							i++;
																							pBiffRecord = m_pBiffRecordContainer->m_pBiffRecordVector->Get(i);
																							if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Frame && m_pBiffRecordContainer->m_pBiffRecordVector->Get(i + 1)->GetType() == BiffRecord::Type::TYPE_Begin)
																							{
																								i++;
																								while (true)
																								{
																									i++;
																									pBiffRecord = m_pBiffRecordContainer->m_pBiffRecordVector->Get(i);
																									if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_LineFormat)
																										((LineFormatRecord*)(pBiffRecord))->ModifyLine(pChart->GetLegend()->GetBorderLine(), pBiffWorkbookGlobals);
																									else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_AreaFormat)
																										((AreaFormatRecord*)(pBiffRecord))->ModifyFill(pChart->GetLegend()->GetFill(), pBiffWorkbookGlobals);
																									else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Begin)
																										i = LoopToEnd(i, m_pBiffRecordContainer);
																									else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_End)
																										break;
																								}
																							}
																							else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Begin)
																								i = LoopToEnd(i, m_pBiffRecordContainer);
																							else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_End)
																								break;
																						}
																					}
																					else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Begin)
																						i = LoopToEnd(i, m_pBiffRecordContainer);
																					else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_End)
																						break;
																				}
																			}
																			else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Begin)
																				i = LoopToEnd(i, m_pBiffRecordContainer);
																			else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_End)
																				break;
																		}
																	}
																	else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Begin)
																		i = LoopToEnd(i, m_pBiffRecordContainer);
																	else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_End)
																		break;
																}
															}
															else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_EOF)
																break;
														}
														{
															NumberDuck::Chart* __477487748 = pChart;
															pChart = 0;
															m_pImpl->m_pChartVector->PushBack(__477487748);
														}
													}
													if (pChart) delete pChart;
												}
											}
											break;
										}

									}
								}
							}
						}
						break;
					}

					case BiffRecord::Type::TYPE_WINDOW2:
					{
						Window2Record* pWindow2Record = (Window2Record*)(pBiffRecord);
						SetShowGridlines(pWindow2Record->GetShowGridlines());
						break;
					}

					case BiffRecord::Type::TYPE_MergeCells:
					{
						MergeCellsRecord* pMergeCellsRecord = (MergeCellsRecord*)(pBiffRecord);
						for (unsigned short j = 0; j < pMergeCellsRecord->GetNumMergedCell(); j++)
						{
							const Ref8Struct* pRef8 = pMergeCellsRecord->GetMergedCell(j);
							MergedCell* pMergedCell = CreateMergedCell(pRef8->m_colFirst, pRef8->m_rwFirst, (unsigned short)(pRef8->m_colLast - pRef8->m_colFirst + 1), (unsigned short)(pRef8->m_rwLast - pRef8->m_rwFirst + 1));
						}
						break;
					}

				}
			}
		}

		void BiffWorksheet::Write(Worksheet* pWorksheet, WorkbookGlobals* pWorkbookGlobals, unsigned short nWorksheetIndex, BiffRecordContainer* pBiffRecordContainer)
		{
			pBiffRecordContainer->AddBiffRecord(new BofRecord(BofRecord::BofType::BOF_TYPE_SHEET));
			pBiffRecordContainer->AddBiffRecord(new PrintRowColRecord());
			pBiffRecordContainer->AddBiffRecord(new PrintGridRecord(pWorksheet->m_pImpl->m_bPrintGridlines));
			pBiffRecordContainer->AddBiffRecord(new DefaultRowHeight((short)(pWorksheet->m_pImpl->m_nDefaultRowHeight)));
			pBiffRecordContainer->AddBiffRecord(new SetupRecord(pWorksheet->m_pImpl->m_eOrientation == Orientation::ORIENTATION_PORTRAIT));
			pBiffRecordContainer->AddBiffRecord(new HeaderFooterRecord());
			int nLastUsedRow = 0;
			{
				int nSize = pWorksheet->m_pImpl->m_pRowInfoTable->GetSize();
				if (nSize > 0)
				{
					TableElement<RowInfo*>* pLastElement = pWorksheet->m_pImpl->m_pRowInfoTable->GetByIndex(nSize - 1);
					nLastUsedRow = pLastElement->m_nRow;
				}
			}
			{
				int nSize = pWorksheet->m_pImpl->m_pCellTable->GetSize();
				if (nSize > 0)
				{
					TableElement<Cell*>* pElement = pWorksheet->m_pImpl->m_pCellTable->GetByIndex(nSize - 1);
					if (pElement->m_nRow > nLastUsedRow)
						nLastUsedRow = pElement->m_nRow;
				}
			}
			DefColWidthRecord* pDefColWidth = new DefColWidthRecord(8);
			{
				NumberDuck::Secret::DefColWidthRecord* __2009045423 = pDefColWidth;
				pDefColWidth = 0;
				pBiffRecordContainer->AddBiffRecord(__2009045423);
			}
			{
				int i = 0;
				while (true)
				{
					if (i >= pWorksheet->m_pImpl->m_pColumnInfoTable->GetSize())
						break;
					TableElement<ColumnInfo*>* pCurrent = pWorksheet->m_pImpl->m_pColumnInfoTable->GetByIndex(i);
					TableElement<ColumnInfo*>* pLast = pWorksheet->m_pImpl->m_pColumnInfoTable->GetByIndex(i);
					int nNextIndex = i;
					while (true)
					{
						if (i == pWorksheet->m_pImpl->m_pColumnInfoTable->GetSize() - 1)
							break;
						TableElement<ColumnInfo*>* pNext = pWorksheet->m_pImpl->m_pColumnInfoTable->GetByIndex(i + 1);
						if (pNext->m_xObject->m_nWidth != pCurrent->m_xObject->m_nWidth)
							break;
						if (pNext->m_xObject->m_bHidden != pCurrent->m_xObject->m_bHidden)
							break;
						pLast = pNext;
						i++;
					}
					ColInfoRecord* pColInfo = new ColInfoRecord((unsigned short)(pCurrent->m_nColumn), (unsigned short)(pLast->m_nColumn), (unsigned short)((unsigned int)(pCurrent->m_xObject->m_nWidth) * 65426 / 1789), pCurrent->m_xObject->m_bHidden);
					{
						NumberDuck::Secret::ColInfoRecord* __4169651391 = pColInfo;
						pColInfo = 0;
						pBiffRecordContainer->AddBiffRecord(__4169651391);
					}
					i++;
					if (pColInfo) delete pColInfo;
				}
			}
			pBiffRecordContainer->AddBiffRecord(new DimensionRecord(0, (unsigned int)(nLastUsedRow + 1), 0, 0, 0));
			int nCurrentRowBlock = 0;
			RowRecord* pLastRow = 0;
			RowRecord* pCurrentRow = 0;
			OwnedVector<RowRecord*>* pRowRecordVector = new OwnedVector<RowRecord*>();
			OwnedVector<BiffRecord*>* pCellRecordVector = new OwnedVector<BiffRecord*>();
			int nCellIndex = 0;
			int nRowIndex = 0;
			while (true)
			{
				if (nCellIndex < pWorksheet->m_pImpl->m_pCellTable->GetSize())
				{
					TableElement<Cell*>* pElement = pWorksheet->m_pImpl->m_pCellTable->GetByIndex(nCellIndex);
					if (pElement->m_nRow / 32 == (int)(nCurrentRowBlock))
					{
						Cell* pCell = pElement->m_xObject;
						if (pCurrentRow == 0 || pCurrentRow->GetRow() < pElement->m_nRow)
						{
							while (true)
							{
								if (nRowIndex == pWorksheet->m_pImpl->m_pRowInfoTable->GetSize())
									break;
								TableElement<RowInfo*>* pRowElement = pWorksheet->m_pImpl->m_pRowInfoTable->GetByIndex(nRowIndex);
								if (pRowElement->m_nRow > pElement->m_nRow)
									break;
								if (pRowElement->m_xObject->m_nHeight > 0)
								{
									pLastRow = pCurrentRow;
									RowRecord* pOwnedRowRecord = new RowRecord((unsigned short)(pRowElement->m_nRow), (unsigned short)((unsigned int)(pRowElement->m_xObject->m_nHeight) * 8190 / 546));
									pCurrentRow = pOwnedRowRecord;
									{
										NumberDuck::Secret::RowRecord* __3618893028 = pOwnedRowRecord;
										pOwnedRowRecord = 0;
										pRowRecordVector->PushBack(__3618893028);
									}
									if (pLastRow != 0 && pCurrentRow->GetRow() == pLastRow->GetRow() + 1 && pLastRow->GetBottomThick())
										pCurrentRow->SetTopThick();
									if (pOwnedRowRecord) delete pOwnedRowRecord;
								}
								nRowIndex++;
							}
							if (pCurrentRow == 0 || pCurrentRow->GetRow() < pElement->m_nRow)
							{
								pLastRow = pCurrentRow;
								RowRecord* pOwnedRowRecord = new RowRecord((unsigned short)(pElement->m_nRow), (unsigned short)(DEFAULT_ROW_HEIGHT * 8190 / 546));
								pCurrentRow = pOwnedRowRecord;
								{
									NumberDuck::Secret::RowRecord* __3618893028 = pOwnedRowRecord;
									pOwnedRowRecord = 0;
									pRowRecordVector->PushBack(__3618893028);
								}
								if (pLastRow != 0 && pCurrentRow->GetRow() == pLastRow->GetRow() + 1 && pLastRow->GetBottomThick())
									pCurrentRow->SetTopThick();
								if (pOwnedRowRecord) delete pOwnedRowRecord;
							}
						}
						Style* pStyle = pCell->GetStyle();
						Line::Type eType = pStyle->GetTopBorderLine()->GetType();
						switch (eType)
						{
							case Line::Type::TYPE_THICK:
							case Line::Type::TYPE_DOUBLE:
							{
								if (pLastRow != 0 && pCurrentRow->GetRow() == pLastRow->GetRow() + 1)
									pLastRow->SetBottomThick();
								pCurrentRow->SetTopThick();
								break;
							}

							case Line::Type::TYPE_MEDIUM:
							case Line::Type::TYPE_MEDIUM_DASHED:
							case Line::Type::TYPE_MEDIUM_DASH_DOT:
							case Line::Type::TYPE_MEDIUM_DASH_DOT_DOT:
							case Line::Type::TYPE_SLANT_DASH_DOT_DOT:
							{
								if (pLastRow != 0 && pCurrentRow->GetRow() == pLastRow->GetRow() + 1)
									pLastRow->SetBottomMedium();
								pCurrentRow->SetTopMedium();
								break;
							}

						}
						eType = pStyle->GetBottomBorderLine()->GetType();
						switch (eType)
						{
							case Line::Type::TYPE_THICK:
							case Line::Type::TYPE_DOUBLE:
							{
								pCurrentRow->SetBottomThick();
								break;
							}

							case Line::Type::TYPE_MEDIUM:
							case Line::Type::TYPE_MEDIUM_DASHED:
							case Line::Type::TYPE_MEDIUM_DASH_DOT:
							case Line::Type::TYPE_MEDIUM_DASH_DOT_DOT:
							case Line::Type::TYPE_SLANT_DASH_DOT_DOT:
							{
								pCurrentRow->SetBottomMedium();
								break;
							}

						}
						switch (pCell->GetType())
						{
							case Value::Type::TYPE_EMPTY:
							{
								Vector<int>* pXFIndexVector = new Vector<int>();
								TableElement<Cell*>* pFirstElement = pElement;
								int nNextCellIndex = nCellIndex;
								nNextCellIndex++;
								pXFIndexVector->PushBack(pWorkbookGlobals->GetStyleIndex(pCell->GetStyle()));
								while (nNextCellIndex < pWorksheet->m_pImpl->m_pCellTable->GetSize())
								{
									TableElement<Cell*>* pNextElement = pWorksheet->m_pImpl->m_pCellTable->GetByIndex(nNextCellIndex);
									if (pNextElement->m_nRow != pElement->m_nRow || pNextElement->m_nColumn != pElement->m_nColumn + 1 || pNextElement->m_xObject->GetType() != Value::Type::TYPE_EMPTY)
										break;
									pXFIndexVector->PushBack(pWorkbookGlobals->GetStyleIndex(pNextElement->m_xObject->GetStyle()));
									nCellIndex++;
									pElement = pWorksheet->m_pImpl->m_pCellTable->GetByIndex(nCellIndex);
									pCell = pElement->m_xObject;
									nNextCellIndex++;
								}
								if (pXFIndexVector->GetSize() > 1)
									pCellRecordVector->PushBack(new MulBlank((unsigned short)(pFirstElement->m_nColumn), (unsigned short)(pFirstElement->m_nRow), pXFIndexVector));
								else
									pCellRecordVector->PushBack(new Blank((unsigned short)(pFirstElement->m_nColumn), (unsigned short)(pFirstElement->m_nRow), (unsigned short)(pXFIndexVector->Get(0))));
								{
									delete pXFIndexVector;
									pXFIndexVector = 0;
								}
								{
									if (pXFIndexVector) delete pXFIndexVector;
									break;
								}
							}

							case Value::Type::TYPE_STRING:
							{
								pCellRecordVector->PushBack(new LabelSstRecord((unsigned short)(pElement->m_nColumn), (unsigned short)(pElement->m_nRow), pWorkbookGlobals->GetStyleIndex(pStyle), pWorkbookGlobals->GetSharedStringIndex(pCell->GetString())));
								break;
							}

							case Value::Type::TYPE_FLOAT:
							{
								pCellRecordVector->PushBack(new NumberRecord((unsigned short)(pElement->m_nColumn), (unsigned short)(pElement->m_nRow), pWorkbookGlobals->GetStyleIndex(pStyle), pCell->GetFloat()));
								break;
							}

							case Value::Type::TYPE_BOOLEAN:
							{
								pCellRecordVector->PushBack(new BoolErrRecord((unsigned short)(pElement->m_nColumn), (unsigned short)(pElement->m_nRow), pWorkbookGlobals->GetStyleIndex(pStyle), pCell->GetBoolean()));
								break;
							}

							case Value::Type::TYPE_FORMULA:
							{
								Formula* pFormula = new Formula(pCell->GetFormula(), pWorksheet->m_pImpl);
								pCellRecordVector->PushBack(new FormulaRecord((unsigned short)(pElement->m_nColumn), (unsigned short)(pElement->m_nRow), pWorkbookGlobals->GetStyleIndex(pStyle), pFormula, pWorkbookGlobals));
								{
									delete pFormula;
									pFormula = 0;
								}
								{
									if (pFormula) delete pFormula;
									break;
								}
							}

						}
						nCellIndex++;
					}
				}
				if (nCellIndex >= pWorksheet->m_pImpl->m_pCellTable->GetSize() || pWorksheet->m_pImpl->m_pCellTable->GetByIndex(nCellIndex)->m_nRow / 32 != (int)(nCurrentRowBlock))
				{
					while (true)
					{
						if (nRowIndex == pWorksheet->m_pImpl->m_pRowInfoTable->GetSize())
							break;
						TableElement<RowInfo*>* pRowElement = pWorksheet->m_pImpl->m_pRowInfoTable->GetByIndex(nRowIndex);
						if (pRowElement->m_nRow / 32 != nCurrentRowBlock)
							break;
						if (pRowElement->m_xObject->m_nHeight > 0)
						{
							pLastRow = pCurrentRow;
							RowRecord* pOwnedRowRecord = new RowRecord((unsigned short)(pRowElement->m_nRow), (unsigned short)((unsigned int)(pRowElement->m_xObject->m_nHeight) * 8190 / 546));
							pCurrentRow = pOwnedRowRecord;
							{
								NumberDuck::Secret::RowRecord* __3618893028 = pOwnedRowRecord;
								pOwnedRowRecord = 0;
								pRowRecordVector->PushBack(__3618893028);
							}
							if (pLastRow != 0 && pCurrentRow->GetRow() == pLastRow->GetRow() + 1 && pLastRow->GetBottomThick())
								pCurrentRow->SetTopThick();
							if (pOwnedRowRecord) delete pOwnedRowRecord;
						}
						nRowIndex++;
					}
					if (nRowIndex == pWorksheet->m_pImpl->m_pRowInfoTable->GetSize() || pWorksheet->m_pImpl->m_pRowInfoTable->GetByIndex(nRowIndex)->m_nRow / 32 != nCurrentRowBlock)
					{
						while (pRowRecordVector->GetSize() > 0)
						{
							pBiffRecordContainer->AddBiffRecord(pRowRecordVector->PopFront());
						}
						while (pCellRecordVector->GetSize() > 0)
						{
							pBiffRecordContainer->AddBiffRecord(pCellRecordVector->PopFront());
						}
						nCurrentRowBlock++;
						if (nCellIndex >= pWorksheet->m_pImpl->m_pCellTable->GetSize() && nRowIndex == pWorksheet->m_pImpl->m_pRowInfoTable->GetSize())
							break;
					}
				}
			}
			if (pWorksheet->GetNumPicture() > 0 || pWorksheet->GetNumChart() > 0)
			{
				unsigned short nIndex = 0;
				unsigned int nFirstOffset = 0;
				Vector<OfficeArtSpContainerRecord*>* pOfficeArtSpContainerRecordVector = new Vector<OfficeArtSpContainerRecord*>();
				OfficeArtDgContainerRecord* pOfficeArtDgContainerRecord = new OfficeArtDgContainerRecord();
				pOfficeArtDgContainerRecord->AddOfficeArtRecord(new OfficeArtFDGRecord(1, 2, 1026));
				OfficeArtSpgrContainerRecord* pOfficeArtSpgrContainerRecord = new OfficeArtSpgrContainerRecord();
				OfficeArtSpContainerRecord* pOfficeArtSpContainerRecord = new OfficeArtSpContainerRecord();
				pOfficeArtSpContainerRecord->AddOfficeArtRecord(new OfficeArtFSPGRRecord());
				pOfficeArtSpContainerRecord->AddOfficeArtRecord(new OfficeArtFSPRecord(0, 1024, 1, 1, 0, 0));
				{
					NumberDuck::Secret::OfficeArtSpContainerRecord* __1049470179 = pOfficeArtSpContainerRecord;
					pOfficeArtSpContainerRecord = 0;
					pOfficeArtSpgrContainerRecord->AddOfficeArtRecord(__1049470179);
				}
				nIndex = 0;
				for (unsigned short i = 0; i < pWorksheet->GetNumPicture(); i++)
				{
					Picture* pPicture = pWorksheet->GetPictureByIndex(i);
					unsigned int nImageDataIndex = pWorkbookGlobals->PushPicture(pPicture);
					const char* szUrl = pPicture->GetUrl();
					pOfficeArtSpContainerRecord = new OfficeArtSpContainerRecord();
					pOfficeArtSpContainerRecord->AddOfficeArtRecord(new OfficeArtFSPRecord(75, (unsigned int)(1025 + nIndex), 0, 0, 1, 1));
					OfficeArtFOPTRecord* pOfficeArtFOPTRecord = new OfficeArtFOPTRecord();
					pOfficeArtFOPTRecord->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_PROTECTION_BOOLEAN_PROPERTIES), 0, 33226880);
					pOfficeArtFOPTRecord->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_PIB), 1, (int)(nImageDataIndex));
					pOfficeArtFOPTRecord->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_BLIP_BOOLEAN_PROPERTIES), 0, 393216);
					if (!ExternalString::Equal(szUrl, ""))
					{
						pOfficeArtFOPTRecord->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_FILL_STYLE_BOOLEAN_PROPERTIES), 0, 0x00110001);
						pOfficeArtFOPTRecord->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_LINE_STYLE_BOOLEAN_PROPERTIES), 0, 0x00180010);
					}
					else
					{
						pOfficeArtFOPTRecord->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_FILL_STYLE_BOOLEAN_PROPERTIES), 0, 1048576);
						pOfficeArtFOPTRecord->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_LINE_STYLE_BOOLEAN_PROPERTIES), 0, 1572880);
					}
					pOfficeArtFOPTRecord->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_SHAPE_BOOLEAN_PROPERTIES), 0, 1572880);
					pOfficeArtFOPTRecord->AddStringProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_WZ_NAME), "Picture 1");
					if (!ExternalString::Equal(szUrl, ""))
					{
						Blob* pBlob = new Blob(true);
						BlobView* pBlobView = pBlob->GetBlobView();
						IHlinkStruct* pIHlink = new IHlinkStruct();
						pIHlink->m_hyperlink->m_streamVersion = 2;
						pIHlink->m_hyperlink->m_hlstmfHasMoniker = 1;
						pIHlink->m_hyperlink->m_hlstmfIsAbsolute = 1;
						pIHlink->m_hyperlink->m_haxUrl = new InternalString(szUrl);
						pIHlink->BlobWrite(pBlobView);
						pOfficeArtFOPTRecord->AddBlobProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_HYPERLINK), 1, pBlob);
						pOfficeArtFOPTRecord->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_GROUP_SHAPE_BOOLEAN_PROPERTIES), 0, 0x000A0008);
						{
							delete pIHlink;
							pIHlink = 0;
						}
						{
							delete pBlob;
							pBlob = 0;
						}
						if (pBlob) delete pBlob;
						if (pIHlink) delete pIHlink;
					}
					else
					{
						pOfficeArtFOPTRecord->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_GROUP_SHAPE_BOOLEAN_PROPERTIES), 0, 131072);
					}
					{
						NumberDuck::Secret::OfficeArtFOPTRecord* __1214438724 = pOfficeArtFOPTRecord;
						pOfficeArtFOPTRecord = 0;
						pOfficeArtSpContainerRecord->AddOfficeArtRecord(__1214438724);
					}
					OfficeArtDimensions* pDimensions = ComputeDimensions(pWorksheet, (unsigned short)(pPicture->GetX()), (unsigned short)(pPicture->GetSubX()), (unsigned short)(pPicture->GetWidth()), (unsigned short)(pPicture->GetY()), (unsigned short)(pPicture->GetSubY()), (unsigned short)(pPicture->GetHeight()));
					pOfficeArtSpContainerRecord->AddOfficeArtRecord(new OfficeArtClientAnchorSheetRecord(pDimensions->m_nCellX1, pDimensions->m_nSubCellX1, pDimensions->m_nCellY1, pDimensions->m_nSubCellY1, pDimensions->m_nCellX2, pDimensions->m_nSubCellX2, pDimensions->m_nCellY2, pDimensions->m_nSubCellY2));
					{
						delete pDimensions;
						pDimensions = 0;
					}
					pOfficeArtSpContainerRecord->AddOfficeArtRecord(new OfficeArtClientDataRecord());
					pOfficeArtSpContainerRecordVector->PushBack(pOfficeArtSpContainerRecord);
					{
						NumberDuck::Secret::OfficeArtSpContainerRecord* __1049470179 = pOfficeArtSpContainerRecord;
						pOfficeArtSpContainerRecord = 0;
						pOfficeArtSpgrContainerRecord->AddOfficeArtRecord(__1049470179);
					}
					if (nIndex == 0)
						nFirstOffset = pOfficeArtDgContainerRecord->GetRecursiveSize() + pOfficeArtSpgrContainerRecord->GetRecursiveSize();
					nIndex++;
					if (pOfficeArtFOPTRecord) delete pOfficeArtFOPTRecord;
					if (pDimensions) delete pDimensions;
				}
				for (unsigned short i = 0; i < pWorksheet->GetNumChart(); i++)
				{
					Chart* pChart = pWorksheet->GetChartByIndex(i);
					pOfficeArtSpContainerRecord = new OfficeArtSpContainerRecord();
					pOfficeArtSpContainerRecord->AddOfficeArtRecord(new OfficeArtFSPRecord(201, (unsigned int)(1026 + nIndex), 0, 0, 1, 1));
					OfficeArtFOPTRecord* pOfficeArtFOPTRecord = new OfficeArtFOPTRecord();
					pOfficeArtFOPTRecord->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_PROTECTION_BOOLEAN_PROPERTIES), 0, 31785220);
					pOfficeArtFOPTRecord->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_TEXT_BOOLEAN_PROPERTIES), 0, 524296);
					pOfficeArtFOPTRecord->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_FILL_COLOR), 0, 134217806);
					pOfficeArtFOPTRecord->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_FILL_STYLE_BOOLEAN_PROPERTIES), 0, 1048592);
					pOfficeArtFOPTRecord->AddStringProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_WZ_NAME), "Chart 1");
					pOfficeArtFOPTRecord->AddProperty((unsigned short)(OfficeArtRecord::OPIDType::OPID_GROUP_SHAPE_BOOLEAN_PROPERTIES), 0, 131072);
					{
						NumberDuck::Secret::OfficeArtFOPTRecord* __1214438724 = pOfficeArtFOPTRecord;
						pOfficeArtFOPTRecord = 0;
						pOfficeArtSpContainerRecord->AddOfficeArtRecord(__1214438724);
					}
					OfficeArtDimensions* pDimensions = ComputeDimensions(pWorksheet, (unsigned short)(pChart->GetX()), (unsigned short)(pChart->GetSubX()), (unsigned short)(pChart->GetWidth()), (unsigned short)(pChart->GetY()), (unsigned short)(pChart->GetSubY()), (unsigned short)(pChart->GetHeight()));
					pOfficeArtSpContainerRecord->AddOfficeArtRecord(new OfficeArtClientAnchorSheetRecord(pDimensions->m_nCellX1, pDimensions->m_nSubCellX1, pDimensions->m_nCellY1, pDimensions->m_nSubCellY1, pDimensions->m_nCellX2, pDimensions->m_nSubCellX2, pDimensions->m_nCellY2, pDimensions->m_nSubCellY2));
					{
						delete pDimensions;
						pDimensions = 0;
					}
					pOfficeArtSpContainerRecord->AddOfficeArtRecord(new OfficeArtClientDataRecord());
					pOfficeArtSpContainerRecordVector->PushBack(pOfficeArtSpContainerRecord);
					{
						NumberDuck::Secret::OfficeArtSpContainerRecord* __1049470179 = pOfficeArtSpContainerRecord;
						pOfficeArtSpContainerRecord = 0;
						pOfficeArtSpgrContainerRecord->AddOfficeArtRecord(__1049470179);
					}
					if (nIndex == 0)
						nFirstOffset = pOfficeArtDgContainerRecord->GetRecursiveSize() + pOfficeArtSpgrContainerRecord->GetRecursiveSize();
					nIndex++;
					if (pOfficeArtFOPTRecord) delete pOfficeArtFOPTRecord;
					if (pDimensions) delete pDimensions;
				}
				{
					NumberDuck::Secret::OfficeArtSpgrContainerRecord* __2757789752 = pOfficeArtSpgrContainerRecord;
					pOfficeArtSpgrContainerRecord = 0;
					pOfficeArtDgContainerRecord->AddOfficeArtRecord(__2757789752);
				}
				nIndex = 0;
				for (unsigned short i = 0; i < pWorksheet->GetNumPicture(); i++)
				{
					if (nIndex == 0)
						pBiffRecordContainer->AddBiffRecord(new MsoDrawingRecord(pOfficeArtDgContainerRecord, nFirstOffset));
					else
						pBiffRecordContainer->AddBiffRecord(new MsoDrawingRecord(pOfficeArtSpContainerRecordVector->Get(nIndex)));
					pBiffRecordContainer->AddBiffRecord(new ObjRecord(nIndex, FtCmoStruct::ObjType::OBJ_TYPE_PICTURE));
					nIndex++;
				}
				for (unsigned short i = 0; i < pWorksheet->GetNumChart(); i++)
				{
					Chart* pChart = pWorksheet->GetChartByIndex(i);
					if (nIndex == 0)
						pBiffRecordContainer->AddBiffRecord(new MsoDrawingRecord(pOfficeArtDgContainerRecord, nFirstOffset));
					else
						pBiffRecordContainer->AddBiffRecord(new MsoDrawingRecord(pOfficeArtSpContainerRecordVector->Get(nIndex)));
					pBiffRecordContainer->AddBiffRecord(new ObjRecord(nIndex, FtCmoStruct::ObjType::OBJ_TYPE_CHART));
					pBiffRecordContainer->AddBiffRecord(new BofRecord(BofRecord::BofType::BOF_TYPE_CHART));
					pBiffRecordContainer->AddBiffRecord(new ChartFrtInfoRecord());
					pBiffRecordContainer->AddBiffRecord(new UnitsRecord());
					pBiffRecordContainer->AddBiffRecord(new ChartRecord());
					pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_Begin, 0));
					pBiffRecordContainer->AddBiffRecord(new SclRecord());
					pBiffRecordContainer->AddBiffRecord(new PlotGrowthRecord());
					pBiffRecordContainer->AddBiffRecord(new FrameRecord(false));
					pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_Begin, 0));
					{
						pBiffRecordContainer->AddBiffRecord(new LineFormatRecord(pChart->GetFrameBorderLine(), false));
						pBiffRecordContainer->AddBiffRecord(new AreaFormatRecord(pChart->GetFrameFill()));
					}
					pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_End, 0));
					for (unsigned short j = 0; j < pChart->GetNumSeries(); j++)
					{
						Series* pSeries = pChart->GetSeriesByIndex(j);
						pBiffRecordContainer->AddBiffRecord(new SeriesRecord());
						pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_Begin, 0));
						{
							Formula* pFormula = new Formula(pSeries->GetName(), pWorksheet->m_pImpl);
							if (pFormula->GetNumToken() > 0)
							{
								pBiffRecordContainer->AddBiffRecord(new BraiRecord(0x00, 0x02, false, 0, pFormula, pWorkbookGlobals));
							}
							else
							{
								pBiffRecordContainer->AddBiffRecord(new BraiRecord(0x00, 0x01, false, 0, 0, 0));
							}
							{
								delete pFormula;
								pFormula = 0;
							}
							if (pFormula) delete pFormula;
						}
						{
							Formula* pFormula = new Formula(pSeries->GetValues(), pWorksheet->m_pImpl);
							pBiffRecordContainer->AddBiffRecord(new BraiRecord(0x01, 0x02, false, 0, pFormula, pWorkbookGlobals));
							{
								delete pFormula;
								pFormula = 0;
							}
							if (pFormula) delete pFormula;
						}
						{
							Formula* pFormula = new Formula(pChart->GetCategories(), pWorksheet->m_pImpl);
							if (pFormula->GetNumToken() > 0)
							{
								pBiffRecordContainer->AddBiffRecord(new BraiRecord(0x02, 0x02, false, 0, pFormula, pWorkbookGlobals));
							}
							else
							{
								pBiffRecordContainer->AddBiffRecord(new BraiRecord(0x02, 0x00, false, 0, 0, 0));
							}
							{
								delete pFormula;
								pFormula = 0;
							}
							if (pFormula) delete pFormula;
						}
						pBiffRecordContainer->AddBiffRecord(new BraiRecord(3, 1, false, 0, 0, 0));
						pBiffRecordContainer->AddBiffRecord(new DataFormatRecord(j));
						pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_Begin, 0));
						pBiffRecordContainer->AddBiffRecord(new Chart3DBarShapeRecord());
						pBiffRecordContainer->AddBiffRecord(new LineFormatRecord(pSeries->GetLine(), false));
						pBiffRecordContainer->AddBiffRecord(new AreaFormatRecord(pSeries->GetFill()));
						pBiffRecordContainer->AddBiffRecord(new PieFormatRecord());
						pBiffRecordContainer->AddBiffRecord(new MarkerFormatRecord(pSeries->GetMarker()));
						pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_End, 0));
						pBiffRecordContainer->AddBiffRecord(new SerToCrtRecord(0));
						pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_End, 0));
					}
					pBiffRecordContainer->AddBiffRecord(new ShtPropsRecord());
					pBiffRecordContainer->AddBiffRecord(new AxesUsedRecord());
					pBiffRecordContainer->AddBiffRecord(new AxisParentRecord());
					pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_Begin, 0));
					pBiffRecordContainer->AddBiffRecord(new PosRecord(23, -34, 0xffff, 3877, 4038));
					pBiffRecordContainer->AddBiffRecord(new AxisRecord(0x0000));
					pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_Begin, 0));
					pBiffRecordContainer->AddBiffRecord(new CatSerRangeRecord());
					pBiffRecordContainer->AddBiffRecord(new AxcExtRecord());
					pBiffRecordContainer->AddBiffRecord(new AxisLineRecord(0x0000));
					pBiffRecordContainer->AddBiffRecord(new LineFormatRecord(pChart->GetHorizontalAxisLine(), true));
					pBiffRecordContainer->AddBiffRecord(new AxisLineRecord(0x0001));
					pBiffRecordContainer->AddBiffRecord(new LineFormatRecord(pChart->GetHorizontalGridLine(), false));
					pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_End, 0));
					pBiffRecordContainer->AddBiffRecord(new AxisRecord(0x0001));
					pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_Begin, 0));
					pBiffRecordContainer->AddBiffRecord(new ValueRangeRecord());
					pBiffRecordContainer->AddBiffRecord(new TickRecord(true));
					pBiffRecordContainer->AddBiffRecord(new FontXRecord());
					pBiffRecordContainer->AddBiffRecord(new AxisLineRecord(0x0000));
					pBiffRecordContainer->AddBiffRecord(new LineFormatRecord(pChart->GetVerticalAxisLine(), true));
					pBiffRecordContainer->AddBiffRecord(new AxisLineRecord(0x0001));
					pBiffRecordContainer->AddBiffRecord(new LineFormatRecord(pChart->GetVerticalGridLine(), false));
					pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_End, 0));
					if (!ExternalString::Equal(pChart->GetHorizontalAxisLabel(), ""))
					{
						pBiffRecordContainer->AddBiffRecord(new TextRecord(0, 0, 0x00212121, true, false, false, false, 63, 0));
						pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_Begin, 0));
						pBiffRecordContainer->AddBiffRecord(new PosRecord(0, 0, 0x0000, 0, 0));
						pBiffRecordContainer->AddBiffRecord(new FontXRecord());
						pBiffRecordContainer->AddBiffRecord(new BraiRecord(0, 1, false, 0, 0, 0));
						pBiffRecordContainer->AddBiffRecord(new SeriesTextRecord(pChart->GetHorizontalAxisLabel()));
						pBiffRecordContainer->AddBiffRecord(new ObjectLinkRecord(0x0003, 0, 0));
						pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_End, 0));
					}
					if (!ExternalString::Equal(pChart->GetVerticalAxisLabel(), ""))
					{
						pBiffRecordContainer->AddBiffRecord(new TextRecord(0, 0, 0x00212121, true, false, false, false, 63, 90));
						pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_Begin, 0));
						pBiffRecordContainer->AddBiffRecord(new PosRecord(0, 0, 0x0000, 0, 0));
						pBiffRecordContainer->AddBiffRecord(new FontXRecord());
						pBiffRecordContainer->AddBiffRecord(new BraiRecord(0, 1, false, 0, 0, 0));
						pBiffRecordContainer->AddBiffRecord(new SeriesTextRecord(pChart->GetVerticalAxisLabel()));
						pBiffRecordContainer->AddBiffRecord(new ObjectLinkRecord(0x0002, 0, 0));
						pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_End, 0));
					}
					pBiffRecordContainer->AddBiffRecord(new PlotAreaRecord());
					pBiffRecordContainer->AddBiffRecord(new FrameRecord(true));
					pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_Begin, 0));
					pBiffRecordContainer->AddBiffRecord(new LineFormatRecord(pChart->GetPlotBorderLine(), false));
					pBiffRecordContainer->AddBiffRecord(new AreaFormatRecord(pChart->GetPlotFill()));
					pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_End, 0));
					pBiffRecordContainer->AddBiffRecord(new ChartFormatRecord());
					pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_Begin, 0));
					switch (pChart->GetType())
					{
						case Chart::Type::TYPE_COLUMN:
						case Chart::Type::TYPE_COLUMN_STACKED:
						case Chart::Type::TYPE_COLUMN_STACKED_100:
						case Chart::Type::TYPE_BAR:
						case Chart::Type::TYPE_BAR_STACKED:
						case Chart::Type::TYPE_BAR_STACKED_100:
						{
							pBiffRecordContainer->AddBiffRecord(new BarRecord(pChart->GetType()));
							break;
						}

						case Chart::Type::TYPE_AREA:
						case Chart::Type::TYPE_AREA_STACKED:
						case Chart::Type::TYPE_AREA_STACKED_100:
						{
							pBiffRecordContainer->AddBiffRecord(new AreaRecord(pChart->GetType()));
							break;
						}

						case Chart::Type::TYPE_LINE:
						case Chart::Type::TYPE_LINE_STACKED:
						case Chart::Type::TYPE_LINE_STACKED_100:
						{
							pBiffRecordContainer->AddBiffRecord(new LineRecord(pChart->GetType()));
							break;
						}

						case Chart::Type::TYPE_SCATTER:
						{
							pBiffRecordContainer->AddBiffRecord(new ScatterRecord(pChart->GetType()));
							break;
						}

						default:
						{
							nbAssert::Assert(false);
							break;
						}

					}
					pBiffRecordContainer->AddBiffRecord(new CrtLinkRecord());
					if (!pChart->GetLegend()->GetHidden())
					{
						pBiffRecordContainer->AddBiffRecord(new LegendRecord(pChart->GetLegend()));
						pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_Begin, 0));
						pBiffRecordContainer->AddBiffRecord(new FrameRecord(true));
						pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_Begin, 0));
						pBiffRecordContainer->AddBiffRecord(new LineFormatRecord(pChart->GetLegend()->GetBorderLine(), false));
						pBiffRecordContainer->AddBiffRecord(new AreaFormatRecord(pChart->GetLegend()->GetFill()));
						pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_End, 0));
						pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_End, 0));
					}
					pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_End, 0));
					pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_End, 0));
					if (!ExternalString::Equal(pChart->GetTitle(), ""))
					{
						pBiffRecordContainer->AddBiffRecord(new TextRecord(0, 0, 0x00212121, true, false, false, true, 63, 0));
						pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_Begin, 0));
						pBiffRecordContainer->AddBiffRecord(new PosRecord(0, 0, 0x0000, 0, 0));
						pBiffRecordContainer->AddBiffRecord(new FontXRecord());
						pBiffRecordContainer->AddBiffRecord(new BraiRecord(0, 1, false, 0, 0, 0));
						pBiffRecordContainer->AddBiffRecord(new SeriesTextRecord(pChart->GetTitle()));
						pBiffRecordContainer->AddBiffRecord(new ObjectLinkRecord(0x0001, 0, 0));
						pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_End, 0));
					}
					pBiffRecordContainer->AddBiffRecord(new CrtLayout12ARecord());
					pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_End, 0));
					pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_EOF, 0));
					nIndex++;
				}
				{
					delete pOfficeArtSpContainerRecordVector;
					pOfficeArtSpContainerRecordVector = 0;
				}
				{
					delete pOfficeArtDgContainerRecord;
					pOfficeArtDgContainerRecord = 0;
				}
				if (pOfficeArtSpContainerRecordVector) delete pOfficeArtSpContainerRecordVector;
				if (pOfficeArtDgContainerRecord) delete pOfficeArtDgContainerRecord;
				if (pOfficeArtSpgrContainerRecord) delete pOfficeArtSpgrContainerRecord;
				if (pOfficeArtSpContainerRecord) delete pOfficeArtSpContainerRecord;
			}
			if (nWorksheetIndex == 0)
				pBiffRecordContainer->AddBiffRecord(new Window2Record(true, true, pWorksheet->m_pImpl->m_bShowGridlines));
			else
				pBiffRecordContainer->AddBiffRecord(new Window2Record(false, false, pWorksheet->m_pImpl->m_bShowGridlines));
			pBiffRecordContainer->AddBiffRecord(new SelectionRecord());
			int nOffset = 0;
			while (nOffset < pWorksheet->m_pImpl->m_pMergedCellVector->GetSize())
			{
				int nSize = pWorksheet->m_pImpl->m_pMergedCellVector->GetSize() - nOffset;
				if (nSize > 1026)
					nSize = 1026;
				pBiffRecordContainer->AddBiffRecord(new MergeCellsRecord(pWorksheet->m_pImpl->m_pMergedCellVector, nOffset, nSize));
				nOffset += nSize;
			}
			pBiffRecordContainer->AddBiffRecord(new BiffRecord(BiffRecord::Type::TYPE_EOF, 0));
			{
				delete pRowRecordVector;
				pRowRecordVector = 0;
			}
			{
				delete pCellRecordVector;
				pCellRecordVector = 0;
			}
			if (pDefColWidth) delete pDefColWidth;
			if (pRowRecordVector) delete pRowRecordVector;
			if (pCellRecordVector) delete pCellRecordVector;
		}

		OfficeArtDimensions* BiffWorksheet::ComputeDimensions(Worksheet* pWorksheet, unsigned short nCellX, unsigned short nSubCellX, unsigned short nWidth, unsigned short nCellY, unsigned short nSubCellY, unsigned short nHeight)
		{
			OfficeArtDimensions* pDimensions = new OfficeArtDimensions();
			pDimensions->m_nCellX1 = nCellX;
			unsigned short nColumnWidth = pWorksheet->GetColumnWidth(pDimensions->m_nCellX1);
			if (nSubCellX > nColumnWidth)
				nSubCellX = nColumnWidth;
			pDimensions->m_nSubCellX1 = (unsigned short)((nSubCellX * 1024 + nColumnWidth / 2) / nColumnWidth);
			pDimensions->m_nCellY1 = nCellY;
			unsigned short nRowHeight = pWorksheet->GetRowHeight(pDimensions->m_nCellY1);
			if (nSubCellY > nRowHeight)
				nSubCellY = nRowHeight;
			pDimensions->m_nSubCellY1 = (unsigned short)((nSubCellY * 256 + nRowHeight / 2) / nRowHeight);
			pDimensions->m_nCellX2 = pDimensions->m_nCellX1;
			pDimensions->m_nSubCellX2 = (unsigned short)(nSubCellX + nWidth);
			while (pDimensions->m_nSubCellX2 > nColumnWidth)
			{
				pDimensions->m_nSubCellX2 = (unsigned short)(pDimensions->m_nSubCellX2 - nColumnWidth);
				pDimensions->m_nCellX2++;
				nColumnWidth = pWorksheet->GetColumnWidth(pDimensions->m_nCellX2);
			}
			pDimensions->m_nSubCellX2 = (unsigned short)((pDimensions->m_nSubCellX2 * 1024 + nColumnWidth / 2) / nColumnWidth);
			pDimensions->m_nCellY2 = pDimensions->m_nCellY1;
			pDimensions->m_nSubCellY2 = (unsigned short)(nSubCellY + nHeight);
			while (pDimensions->m_nSubCellY2 > nRowHeight)
			{
				pDimensions->m_nSubCellY2 = (unsigned short)(pDimensions->m_nSubCellY2 - nRowHeight);
				pDimensions->m_nCellY2++;
				nRowHeight = pWorksheet->GetRowHeight(pDimensions->m_nCellY2);
			}
			pDimensions->m_nSubCellY2 = (unsigned short)((pDimensions->m_nSubCellY2 * 256 + nRowHeight / 2) / nRowHeight);
			{
				NumberDuck::Secret::OfficeArtDimensions* __2049702641 = pDimensions;
				pDimensions = 0;
				return __2049702641;
			}
		}

		int BiffWorksheet::LoopToEnd(int i, BiffRecordContainer* pBiffRecordContainer)
		{
			unsigned short nDepth = 1;
			while (nDepth > 0)
			{
				i++;
				BiffRecord* pBiffRecord = pBiffRecordContainer->m_pBiffRecordVector->Get(i);
				if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_Begin)
					nDepth++;
				else if (pBiffRecord->GetType() == BiffRecord::Type::TYPE_End)
					nDepth--;
			}
			return i;
		}

		BiffWorksheet::~BiffWorksheet()
		{
			if (m_pBiffRecordContainer) delete m_pBiffRecordContainer;
		}

		double BiffUtils::RkValueDecode(unsigned int nRkValue)
		{
			unsigned int nMultiplierBit = nRkValue & 0x00000001;
			unsigned int nTypeBit = (nRkValue & 0x00000002) >> 1;
			unsigned int nEncodedValue = (nRkValue & 0xFFFFFFFC);
			double fTemp;
			if (nTypeBit == 0)
			{
				unsigned long long nTemp = nEncodedValue;
				nTemp = nTemp << 32;
				fTemp = Utils::ByteConvertUint64ToDouble(nTemp);
			}
			else
			{
				nEncodedValue = nEncodedValue >> 2;
				fTemp = Utils::ByteConvertUint32ToInt32(nEncodedValue);
			}
			if (nMultiplierBit == 1)
				return fTemp / 100.0f;
			else
				return fTemp;
		}

		BiffRecordContainer::BiffRecordContainer()
		{
			m_pBiffRecordVector = 0;
			m_pBiffRecordVector = new OwnedVector<BiffRecord*>();
		}

		BiffRecordContainer::BiffRecordContainer(BiffRecord* pInitialBiffRecord, Stream* pStream)
		{
			m_pBiffRecordVector = 0;
			m_pBiffRecordVector = new OwnedVector<BiffRecord*>();
			int nDepth = 1;
			AddBiffRecord(pInitialBiffRecord);
			while (true)
			{
				BiffRecord* pBiffRecord = BiffRecord::CreateBiffRecord(pStream);
				BiffRecord::Type eType = pBiffRecord->GetType();
				{
					NumberDuck::Secret::BiffRecord* __3036547922 = pBiffRecord;
					pBiffRecord = 0;
					AddBiffRecord(__3036547922);
				}
				if (eType == BiffRecord::Type::TYPE_BOF)
				{
					nDepth++;
				}
				if (eType == BiffRecord::Type::TYPE_EOF)
				{
					nDepth--;
					if (nDepth == 0)
					{
						if (pBiffRecord) delete pBiffRecord;
						break;
					}
				}
				if (pBiffRecord) delete pBiffRecord;
			}
		}

		void BiffRecordContainer::AddBiffRecord(BiffRecord* pBiffRecord)
		{
			m_pBiffRecordVector->PushBack(pBiffRecord);
		}

		unsigned int BiffRecordContainer::GetSize()
		{
			unsigned int nSize = 0;
			for (int i = 0; i < m_pBiffRecordVector->GetSize(); i++)
				nSize += m_pBiffRecordVector->Get(i)->GetSize();
			return nSize;
		}

		void BiffRecordContainer::Write(Stream* pStream)
		{
			Blob* pBlob = new Blob(true);
			BlobView* pBlobView = pBlob->GetBlobView();
			for (int i = 0; i < m_pBiffRecordVector->GetSize(); i++)
			{
				pBlob->Resize(0, false);
				pBlobView->SetOffset(0);
				m_pBiffRecordVector->Get(i)->Write(pStream, pBlobView);
			}
			if (pBlob) delete pBlob;
		}

		BiffRecordContainer::~BiffRecordContainer()
		{
			if (m_pBiffRecordVector) delete m_pBiffRecordVector;
		}

		void StreamDirectoryImplementation::AppendStream(Stream* pStream)
		{
			nbAssert::Assert(m_pStreamVector->GetSize() == pStream->GetStreamId());
			m_pStreamVector->PushBack(pStream);
		}

		int StreamDirectoryImplementation::RedBlackTreeComparisonCallback(const void* pObjectA, const void* pObjectB)
		{
			Stream* pStreamA = (Stream*)(pObjectA);
			Stream* pStreamB = (Stream*)(pObjectB);
			if (pStreamA->GetNameLengthUtf16() > pStreamB->GetNameLengthUtf16())
				return -1;
			else if (pStreamA->GetNameLengthUtf16() < pStreamB->GetNameLengthUtf16())
				return 1;
			unsigned short nLength = pStreamA->GetNameLengthUtf16();
			for (unsigned short i = 0; i < nLength; i++)
			{
				unsigned short a = pStreamA->GetNameUtf16(i);
				unsigned short b = pStreamB->GetNameUtf16(i);
				if (a > b)
					return -1;
				else if (a < b)
					return 1;
			}
			return 0;
		}

		void StreamDirectoryImplementation::RedBlackTreeWalk(RedBlackNode* pNode, Stream* pStorage)
		{
			Stream* pStream = (Stream*)(pNode->GetStoredObject());
			if (pNode->GetParent() == 0)
			{
				pStorage->SetLeftChildNodeStreamId(-1);
				pStorage->SetRightChildNodeStreamId(-1);
				pStorage->SetRootNodeStreamId(pStream->GetStreamId());
			}
			pStream->SetRootNodeStreamId(-1);
			pStream->SetNodeColour((unsigned char)(pNode->GetColor()));
			for (int nDirection = 0; nDirection < 2; nDirection++)
			{
				if (pNode->GetChild(nDirection) != 0)
				{
					Stream* pChild = (Stream*)(pNode->GetChild(nDirection)->GetStoredObject());
					if (nDirection == 0)
						pStream->SetLeftChildNodeStreamId(pChild->GetStreamId());
					else
						pStream->SetRightChildNodeStreamId(pChild->GetStreamId());
					this->RedBlackTreeWalk(pNode->GetChild(nDirection), pStorage);
				}
				else
				{
					if (nDirection == 0)
						pStream->SetLeftChildNodeStreamId(-1);
					else
						pStream->SetRightChildNodeStreamId(-1);
				}
			}
		}

		StreamDirectoryImplementation::StreamDirectoryImplementation()
		{
			m_nMinimumStandardStreamSize = 0;
			m_pStreamVector = 0;
			m_pCompoundFile = 0;
		}

		StreamDirectoryImplementation::~StreamDirectoryImplementation()
		{
			if (m_pStreamVector) delete m_pStreamVector;
		}

		StreamDirectory::StreamDirectory(int nSectorSize, unsigned int nMinimumStandardStreamSize, CompoundFile* pCompoundFile) : SectorChain(nSectorSize)
		{
			m_pImpl = 0;
			m_pImpl = new StreamDirectoryImplementation();
			m_pImpl->m_nMinimumStandardStreamSize = nMinimumStandardStreamSize;
			m_pImpl->m_pStreamVector = new OwnedVector<Stream*>();
			m_pImpl->m_pCompoundFile = pCompoundFile;
		}

		int StreamDirectory::GetNumStream()
		{
			return m_pImpl->m_pStreamVector->GetSize();
		}

		Stream* StreamDirectory::GetStreamByIndex(int nStreamDirectoryId)
		{
			nbAssert::Assert(nStreamDirectoryId >= 0);
			nbAssert::Assert(nStreamDirectoryId < GetNumStream());
			return m_pImpl->m_pStreamVector->Get(nStreamDirectoryId);
		}

		Stream* StreamDirectory::GetStreamByName(const char* sxName)
		{
			for (int i = 0; i < m_pImpl->m_pStreamVector->GetSize(); i++)
			{
				Stream* pStream = m_pImpl->m_pStreamVector->Get(i);
				if (ExternalString::Equal(pStream->GetName(), sxName))
					return pStream;
			}
			return 0;
		}

		Stream* StreamDirectory::CreateStream(const char* sxName, Stream::Type eType)
		{
			if (eType == Stream::Type::TYPE_EMPTY)
				return 0;
			for (int i = 0; i < m_pImpl->m_pStreamVector->GetSize(); i++)
			{
				if (m_pImpl->m_pStreamVector->Get(i)->GetType() == Stream::Type::TYPE_EMPTY)
				{
					Stream* pStream = m_pImpl->m_pStreamVector->Get(i);
					pStream->Allocate(eType, 0);
					pStream->SetName(sxName);
					RedBlackTreeRebuild();
					return pStream;
				}
			}
			m_pImpl->m_pCompoundFile->StreamDirectoryExtend();
			return CreateStream(sxName, eType);
		}

		void StreamDirectory::AppendSector(Sector* pSector)
		{
			SectorChain::AppendSector(pSector);
			BlobView* pBlobView = GetBlobView();
			int nOffset = pBlobView->GetSize() - pSector->GetDataSize();
			while (nOffset < pBlobView->GetSize())
			{
				m_pImpl->AppendStream(new Stream(GetNumStream(), (int)(m_pImpl->m_nMinimumStandardStreamSize), m_pBlob, nOffset, m_pImpl->m_pCompoundFile));
				nOffset += Stream::DATA_SIZE;
			}
		}

		void StreamDirectory::Extend(Sector* pSector)
		{
			AppendSector(pSector);
		}

		void StreamDirectory::RedBlackTreeRebuild()
		{
			RedBlackTree* pRedBlackTree = new RedBlackTree(StreamDirectoryImplementation::RedBlackTreeComparisonCallback);
			for (int i = 1; i < m_pImpl->m_pStreamVector->GetSize(); i++)
			{
				Stream* pStream = m_pImpl->m_pStreamVector->Get(i);
				if (pStream->GetType() != Stream::Type::TYPE_EMPTY)
					nbAssert::Assert(pRedBlackTree->AddObject(pStream));
			}
			m_pImpl->RedBlackTreeWalk(pRedBlackTree->GetRootNode(), m_pImpl->m_pStreamVector->Get(0));
			{
				delete pRedBlackTree;
				pRedBlackTree = 0;
			}
			if (pRedBlackTree) delete pRedBlackTree;
		}

		StreamDirectory::~StreamDirectory()
		{
			if (m_pImpl) delete m_pImpl;
		}

		SectorAllocationTable::SectorAllocationTable(int nSectorSize) : SectorChain(nSectorSize)
		{
			m_nNumFreeSectorId = 0;
			m_nNumFreeSectorId = 0;
		}

		int SectorAllocationTable::GetNumSectorId()
		{
			return GetDataSize() >> 2;
		}

		int SectorAllocationTable::GetNumFreeSectorId()
		{
			return m_nNumFreeSectorId;
		}

		int SectorAllocationTable::GetSectorId(int nIndex)
		{
			nbAssert::Assert(nIndex >= 0);
			nbAssert::Assert(nIndex < GetNumSectorId());
			BlobView* pBlobView = GetBlobView();
			pBlobView->SetOffset(nIndex << 2);
			return pBlobView->UnpackInt32();
		}

		void SectorAllocationTable::SetSectorId(int nIndex, int nSectorId)
		{
			BlobView* pBlobView = GetBlobView();
			nbAssert::Assert(nIndex >= 0);
			nbAssert::Assert(nIndex < GetNumSectorId());
			int nLastSectorId = pBlobView->UnpackInt32At(nIndex << 2);
			if (nSectorId != nLastSectorId)
			{
				if (nSectorId == (int)(Sector::SectorId::FREE_SECTOR_SECTOR_ID))
					m_nNumFreeSectorId++;
				if (nLastSectorId == (int)(Sector::SectorId::FREE_SECTOR_SECTOR_ID))
					m_nNumFreeSectorId--;
				pBlobView->SetOffset(nIndex << 2);
				pBlobView->PackInt32(nSectorId);
			}
		}

		int SectorAllocationTable::GetFreeSectorId()
		{
			int nNumSectorId = GetNumSectorId();
			for (int i = nNumSectorId - 1; i >= 0; i--)
				if (GetSectorId(i) == (int)(Sector::SectorId::FREE_SECTOR_SECTOR_ID))
					return i;
			return -1;
		}

		void SectorAllocationTable::AppendSector(Sector* pSector)
		{
			SectorChain::AppendSector(pSector);
			BlobView* pBlobView = pSector->GetBlobView();
			pBlobView->SetOffset(0);
			while (pBlobView->GetOffset() < pBlobView->GetSize())
			{
				if (pBlobView->UnpackInt32() == (int)(Sector::SectorId::FREE_SECTOR_SECTOR_ID))
					m_nNumFreeSectorId++;
			}
		}

		void SectorAllocationTable::Extend(Sector* pSector)
		{
			BlobView* pBlobView = pSector->GetBlobView();
			pBlobView->SetOffset(0);
			while (pBlobView->GetOffset() < pBlobView->GetSize())
			{
				pBlobView->PackInt32((int)(Sector::SectorId::FREE_SECTOR_SECTOR_ID));
			}
			AppendSector(pSector);
		}

		SectorImplementation::SectorImplementation()
		{
			m_nSectorId = 0;
			m_pBlobView = 0;
		}

		SectorImplementation::~SectorImplementation()
		{
			if (m_pBlobView) delete m_pBlobView;
		}

		Sector::Sector(int nSectorId, BlobView* pBlobView, int nDataSize)
		{
			m_pImpl = 0;
			nbAssert::Assert(pBlobView != 0);
			nbAssert::Assert(((nDataSize & (nDataSize - 1)) == 0));
			m_pImpl = new SectorImplementation();
			m_pImpl->m_nSectorId = nSectorId;
			m_pImpl->m_pBlobView = new BlobView(pBlobView->GetBlob(), pBlobView->GetOffset(), pBlobView->GetOffset() + nDataSize);
			pBlobView->SetOffset(pBlobView->GetOffset() + nDataSize);
		}

		int Sector::GetDataSize()
		{
			return m_pImpl->m_pBlobView->GetSize();
		}

		int Sector::GetSectorId()
		{
			return m_pImpl->m_nSectorId;
		}

		BlobView* Sector::GetBlobView()
		{
			return m_pImpl->m_pBlobView;
		}

		Sector::~Sector()
		{
			if (m_pImpl) delete m_pImpl;
		}

		MasterSectorAllocationTable::MasterSectorAllocationTable(CompoundFileHeader* pHeader) : SectorAllocationTable(pHeader->GetSectorSize())
		{
			m_pHeader = 0;
			m_pHeader = pHeader;
		}

		int MasterSectorAllocationTable::GetNumSectorId()
		{
			return INITIAL_SECTOR_ID_ARRAY_SIZE + GetNumSector() * ((m_nSectorSize >> 2) - 1);
		}

		int MasterSectorAllocationTable::GetNumInternalSectorId()
		{
			return INITIAL_SECTOR_ID_ARRAY_SIZE + GetNumSector() * (m_nSectorSize >> 2);
		}

		int MasterSectorAllocationTable::GetSectorId(int nIndex)
		{
			int nTranslatedIndex = TranslateIndex(nIndex);
			if (nTranslatedIndex == nIndex)
				return m_pHeader->m_pMasterSectorAllocationTable[nTranslatedIndex];
			else
				return SectorAllocationTable::GetSectorId(nTranslatedIndex);
		}

		void MasterSectorAllocationTable::SetSectorId(int nIndex, int nSectorId)
		{
			int nTranslatedIndex = TranslateIndex(nIndex);
			if (nTranslatedIndex == nIndex)
			{
				if (nSectorId != m_pHeader->m_pMasterSectorAllocationTable[nTranslatedIndex])
				{
					if (nSectorId == (int)(Sector::SectorId::FREE_SECTOR_SECTOR_ID))
						m_nNumFreeSectorId++;
					if (m_pHeader->m_pMasterSectorAllocationTable[nTranslatedIndex] == (int)(Sector::SectorId::FREE_SECTOR_SECTOR_ID))
						m_nNumFreeSectorId--;
				}
				m_pHeader->m_pMasterSectorAllocationTable[nTranslatedIndex] = nSectorId;
			}
			else
			{
				SectorAllocationTable::SetSectorId(nTranslatedIndex, nSectorId);
			}
		}

		int MasterSectorAllocationTable::GetInternalSectorId(int nIndex)
		{
			nbAssert::Assert(nIndex >= 0);
			if (nIndex < INITIAL_SECTOR_ID_ARRAY_SIZE)
				return m_pHeader->m_pMasterSectorAllocationTable[nIndex];
			else
				return SectorAllocationTable::GetSectorId(nIndex - INITIAL_SECTOR_ID_ARRAY_SIZE);
		}

		void MasterSectorAllocationTable::SetInternalSectorId(int nIndex, int nSectorId)
		{
			nbAssert::Assert(nIndex >= 0);
			if (nIndex < INITIAL_SECTOR_ID_ARRAY_SIZE)
				m_pHeader->m_pMasterSectorAllocationTable[nIndex] = nSectorId;
			else
				SectorAllocationTable::SetSectorId(nIndex - INITIAL_SECTOR_ID_ARRAY_SIZE, nSectorId);
		}

		int MasterSectorAllocationTable::TranslateIndex(int nIndex)
		{
			nbAssert::Assert(nIndex >= 0);
			if (nIndex >= INITIAL_SECTOR_ID_ARRAY_SIZE)
			{
				int nSectorIndex = nIndex - INITIAL_SECTOR_ID_ARRAY_SIZE;
				nSectorIndex += nSectorIndex / ((m_nSectorSize >> 2) - 1);
				return nSectorIndex;
			}
			return nIndex;
		}

		int MasterSectorAllocationTable::GetSectorIdToAppend()
		{
			if (GetNumSector() == 0)
				return m_pHeader->m_nMasterSectorAllocationTableSectorId;
			BlobView* pBlobView = GetBlobView();
			return pBlobView->UnpackInt32At(GetDataSize() - (1 << 2));
		}

		void MasterSectorAllocationTable::AppendSector(Sector* pSector)
		{
			nbAssert::Assert(GetSectorIdToAppend() == pSector->GetSectorId());
			SectorAllocationTable::AppendSector(pSector);
		}

		void MasterSectorAllocationTable::Extend(Sector* pSector)
		{
			int nNumSectorIdPerSector = pSector->GetDataSize() >> 2;
			BlobView* pBlobView = pSector->GetBlobView();
			pBlobView->SetOffset(0);
			for (int i = 0; i < nNumSectorIdPerSector - 1; i++)
				pBlobView->PackInt32((int)(Sector::SectorId::FREE_SECTOR_SECTOR_ID));
			pBlobView->PackInt32((int)(Sector::SectorId::END_OF_CHAIN_SECTOR_ID));
			SectorAllocationTable::AppendSector(pSector);
			int nIndex = GetNumInternalSectorId() - nNumSectorIdPerSector - 1;
			if (nIndex > INITIAL_SECTOR_ID_ARRAY_SIZE)
				SetInternalSectorId(nIndex, pSector->GetSectorId());
			else
				m_pHeader->m_nMasterSectorAllocationTableSectorId = pSector->GetSectorId();
			m_pHeader->m_nMasterSectorAllocationTableSize++;
		}

		const unsigned char CompoundFileHeader::MAGIC_WORD[CompoundFileHeader::MAGIC_WORD_SIZE] = {0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1};
		CompoundFileHeader::CompoundFileHeader(unsigned int nSectorSize, unsigned int nShortSectorSize)
		{
			m_nRevisonNumber = 0;
			m_nVersionNumber = 0;
			m_nByteOrderIdentifier = 0;
			m_nSectorSize = 0;
			m_nShortSectorSize = 0;
			m_nSectorAllocationTableSize = 0;
			m_nStreamDirectoryStreamSectorId = 0;
			m_nMinimumStandardStreamSize = 0;
			m_nShortSectorAllocationTableSectorId = 0;
			m_nShortSectorAllocationTableSize = 0;
			m_nMasterSectorAllocationTableSectorId = 0;
			m_nMasterSectorAllocationTableSize = 0;
			unsigned int i;
			for (i = 0; i < MAGIC_WORD_SIZE; i++)
				m_pMagicWord[i] = MAGIC_WORD[i];
			for (i = 0; i < UNIQUE_IDENTIFIER_SIZE; i++)
				m_pUniqueIdentifier[i] = 0;
			m_nRevisonNumber = REVISION_NUMBER;
			m_nVersionNumber = VERSION_NUMBER;
			m_nByteOrderIdentifier = BOM_BIG_ENDIAN;
			unsigned int nTemp = nSectorSize;
			m_nSectorSize = 0;
			while (nTemp != 1)
			{
				nTemp = nTemp >> 1;
				m_nSectorSize++;
			}
			nTemp = nShortSectorSize;
			m_nShortSectorSize = 0;
			while (nTemp != 1)
			{
				nTemp = nTemp >> 1;
				m_nShortSectorSize++;
			}
			for (i = 0; i < 10; i++)
				m_pUnusedA[i] = 0;
			m_nSectorAllocationTableSize = 0;
			m_nStreamDirectoryStreamSectorId = 0;
			for (i = 0; i < 4; i++)
				m_pUnusedB[i] = 0;
			m_nMinimumStandardStreamSize = 0;
			m_nShortSectorAllocationTableSectorId = 0;
			m_nShortSectorAllocationTableSize = 0;
			m_nMasterSectorAllocationTableSectorId = 0;
			m_nMasterSectorAllocationTableSize = 0;
			for (i = 0; i < MasterSectorAllocationTable::INITIAL_SECTOR_ID_ARRAY_SIZE; i++)
				m_pMasterSectorAllocationTable[i] = (int)(Sector::SectorId::FREE_SECTOR_SECTOR_ID);
		}

		int CompoundFileHeader::GetSectorSize()
		{
			return 1 << m_nSectorSize;
		}

		bool CompoundFileHeader::Unpack(Blob* pBlob)
		{
			unsigned int i;
			BlobView* pBlobView = pBlob->GetBlobView();
			for (i = 0; i < MAGIC_WORD_SIZE; i++)
			{
				m_pMagicWord[i] = pBlobView->UnpackUint8();
				if (m_pMagicWord[i] != MAGIC_WORD[i])
					return false;
			}
			for (i = 0; i < UNIQUE_IDENTIFIER_SIZE; i++)
				m_pUniqueIdentifier[i] = pBlobView->UnpackUint8();
			m_nRevisonNumber = pBlobView->UnpackUint16();
			m_nVersionNumber = pBlobView->UnpackUint16();
			m_nByteOrderIdentifier = pBlobView->UnpackUint16();
			m_nSectorSize = pBlobView->UnpackUint16();
			m_nShortSectorSize = pBlobView->UnpackUint16();
			for (i = 0; i < 10; i++)
				m_pUnusedA[i] = pBlobView->UnpackUint8();
			m_nSectorAllocationTableSize = pBlobView->UnpackUint32();
			m_nStreamDirectoryStreamSectorId = pBlobView->UnpackInt32();
			for (i = 0; i < 4; i++)
				m_pUnusedB[i] = pBlobView->UnpackUint8();
			m_nMinimumStandardStreamSize = pBlobView->UnpackUint32();
			m_nShortSectorAllocationTableSectorId = pBlobView->UnpackInt32();
			m_nShortSectorAllocationTableSize = pBlobView->UnpackUint32();
			m_nMasterSectorAllocationTableSectorId = pBlobView->UnpackInt32();
			m_nMasterSectorAllocationTableSize = pBlobView->UnpackUint32();
			for (i = 0; i < MasterSectorAllocationTable::INITIAL_SECTOR_ID_ARRAY_SIZE; i++)
				m_pMasterSectorAllocationTable[i] = pBlobView->UnpackInt32();
			return true;
		}

		void CompoundFileHeader::Pack(Blob* pBlob)
		{
			unsigned int i;
			BlobView* pBlobView = pBlob->GetBlobView();
			for (i = 0; i < MAGIC_WORD_SIZE; i++)
				pBlobView->PackUint8(m_pMagicWord[i]);
			for (i = 0; i < UNIQUE_IDENTIFIER_SIZE; i++)
				pBlobView->PackUint8(m_pUniqueIdentifier[i]);
			pBlobView->PackUint16(m_nRevisonNumber);
			pBlobView->PackUint16(m_nVersionNumber);
			pBlobView->PackUint16(m_nByteOrderIdentifier);
			pBlobView->PackUint16(m_nSectorSize);
			pBlobView->PackUint16(m_nShortSectorSize);
			for (i = 0; i < 10; i++)
				pBlobView->PackUint8(m_pUnusedA[i]);
			pBlobView->PackUint32(m_nSectorAllocationTableSize);
			pBlobView->PackInt32(m_nStreamDirectoryStreamSectorId);
			for (i = 0; i < 4; i++)
				pBlobView->PackUint8(m_pUnusedB[i]);
			pBlobView->PackUint32(m_nMinimumStandardStreamSize);
			pBlobView->PackUint32((unsigned int)(m_nShortSectorAllocationTableSectorId));
			pBlobView->PackUint32(m_nShortSectorAllocationTableSize);
			pBlobView->PackInt32(m_nMasterSectorAllocationTableSectorId);
			pBlobView->PackUint32(m_nMasterSectorAllocationTableSize);
			for (i = 0; i < MasterSectorAllocationTable::INITIAL_SECTOR_ID_ARRAY_SIZE; i++)
				pBlobView->PackUint32((unsigned int)(m_pMasterSectorAllocationTable[i]));
		}

		CompoundFile::CompoundFile(unsigned int nSectorSize, unsigned int nShortSectorSize, unsigned int nMinimumStandardStreamSize)
		{
			m_pHeader = 0;
			m_pBlob = 0;
			m_pMasterSectorAllocationTable = 0;
			m_pSectorAllocationTable = 0;
			m_pShortSectorAllocationTable = 0;
			m_pStreamDirectory = 0;
			m_pSectorVector = 0;
			m_pShortSectorVector = 0;
			nbAssert::Assert(nSectorSize >= Sector::MINIMUM_SECTOR_SIZE && ((nSectorSize & (nSectorSize - 1)) == 0));
			nbAssert::Assert(nShortSectorSize < nSectorSize && ((nShortSectorSize & (nShortSectorSize - 1)) == 0));
			m_pSectorVector = new OwnedVector<Sector*>();
			m_pShortSectorVector = new OwnedVector<Sector*>();
			m_pBlob = new Blob(false);
			m_pBlob->Resize(HEADER_SIZE, false);
			m_pHeader = new CompoundFileHeader(nSectorSize, nShortSectorSize);
			m_pMasterSectorAllocationTable = new MasterSectorAllocationTable(m_pHeader);
			m_pHeader->m_nMasterSectorAllocationTableSectorId = (int)(Sector::SectorId::END_OF_CHAIN_SECTOR_ID);
			m_pSectorAllocationTable = new SectorAllocationTable(1 << m_pHeader->m_nSectorSize);
			SectorAllocationTableExtend(false);
			m_pHeader->m_nMinimumStandardStreamSize = nMinimumStandardStreamSize;
			m_pStreamDirectory = new StreamDirectory((int)(nSectorSize), m_pHeader->m_nMinimumStandardStreamSize, this);
			StreamDirectoryExtend();
			Stream* pStream = m_pStreamDirectory->GetStreamByIndex(0);
			pStream->SetName("Root Entry");
			m_pShortSectorAllocationTable = new SectorAllocationTable(1 << m_pHeader->m_nSectorSize);
			SectorAllocationTableExtend(true);
		}

		CompoundFile::~CompoundFile()
		{
			if (m_pHeader) delete m_pHeader;
			if (m_pBlob) delete m_pBlob;
			if (m_pMasterSectorAllocationTable) delete m_pMasterSectorAllocationTable;
			if (m_pSectorAllocationTable) delete m_pSectorAllocationTable;
			if (m_pShortSectorAllocationTable) delete m_pShortSectorAllocationTable;
			if (m_pStreamDirectory) delete m_pStreamDirectory;
			if (m_pSectorVector) delete m_pSectorVector;
			if (m_pShortSectorVector) delete m_pShortSectorVector;
		}

		bool CompoundFile::Load(const char* sxFileName)
		{
			{
				delete m_pMasterSectorAllocationTable;
				m_pMasterSectorAllocationTable = 0;
			}
			m_pMasterSectorAllocationTable = 0;
			{
				delete m_pSectorAllocationTable;
				m_pSectorAllocationTable = 0;
			}
			m_pSectorAllocationTable = 0;
			{
				delete m_pShortSectorAllocationTable;
				m_pShortSectorAllocationTable = 0;
			}
			m_pShortSectorAllocationTable = 0;
			{
				delete m_pStreamDirectory;
				m_pStreamDirectory = 0;
			}
			m_pStreamDirectory = 0;
			m_pSectorVector->Clear();
			m_pShortSectorVector->Clear();
			{
				delete m_pBlob;
				m_pBlob = 0;
			}
			m_pBlob = new Blob(false);
			if (m_pBlob->Load(sxFileName))
			{
				if (m_pHeader->Unpack(m_pBlob))
				{
					int nSectorId;
					int nSectorSize = (1 << m_pHeader->m_nSectorSize);
					int nNumSector = (m_pBlob->GetSize() - HEADER_SIZE) / nSectorSize;
					BlobView* pBlobView = m_pBlob->GetBlobView();
					nbAssert::Assert(pBlobView->GetOffset() == HEADER_SIZE);
					nbAssert::Assert(pBlobView->GetOffset() + nNumSector * nSectorSize == m_pBlob->GetSize());
					for (int i = 0; i < nNumSector; i++)
						m_pSectorVector->PushBack(new Sector(i, pBlobView, nSectorSize));
					m_pMasterSectorAllocationTable = new MasterSectorAllocationTable(m_pHeader);
					nSectorId = m_pMasterSectorAllocationTable->GetSectorIdToAppend();
					while (nSectorId >= 0)
					{
						m_pMasterSectorAllocationTable->AppendSector(m_pSectorVector->Get(nSectorId));
						nSectorId = m_pMasterSectorAllocationTable->GetSectorIdToAppend();
					}
					nbAssert::Assert(m_pMasterSectorAllocationTable->GetNumSector() == (int)(m_pHeader->m_nMasterSectorAllocationTableSize));
					m_pSectorAllocationTable = new SectorAllocationTable(1 << m_pHeader->m_nSectorSize);
					for (int i = 0; i < (int)(m_pHeader->m_nSectorAllocationTableSize); i++)
						m_pSectorAllocationTable->AppendSector(GetSector(m_pMasterSectorAllocationTable->GetSectorId(i), false));
					nbAssert::Assert(m_pSectorAllocationTable->GetNumSector() == (int)(m_pHeader->m_nSectorAllocationTableSize));
					m_pShortSectorAllocationTable = new SectorAllocationTable(1 << m_pHeader->m_nSectorSize);
					FillSectorChain(m_pShortSectorAllocationTable, m_pHeader->m_nShortSectorAllocationTableSectorId, false);
					nbAssert::Assert(m_pShortSectorAllocationTable->GetNumSector() == (int)(m_pHeader->m_nShortSectorAllocationTableSize));
					m_pStreamDirectory = new StreamDirectory((int)(nSectorSize), m_pHeader->m_nMinimumStandardStreamSize, this);
					FillSectorChain(m_pStreamDirectory, m_pHeader->m_nStreamDirectoryStreamSectorId, false);
					Stream* pRootStream = m_pStreamDirectory->GetStreamByIndex(0);
					nbAssert::Assert(pRootStream->GetType() == Stream::Type::TYPE_ROOT_STORAGE);
					pRootStream->FillSectorChain();
					int nShortSectorSize = (1 << m_pHeader->m_nShortSectorSize);
					int nNumShortSector = pRootStream->GetSize() / nShortSectorSize;
					pRootStream->GetSectorChain()->SetOffset(0);
					for (int i = 0; i < nNumShortSector; i++)
					{
						Sector* pSector = new Sector(i, pRootStream->GetSectorChain()->GetBlobView(), nShortSectorSize);
						{
							NumberDuck::Secret::Sector* __3878760436 = pSector;
							pSector = 0;
							m_pShortSectorVector->PushBack(__3878760436);
						}
						if (pSector) delete pSector;
					}
					for (int i = 1; i < m_pStreamDirectory->GetNumStream(); i++)
					{
						Stream* pStream = m_pStreamDirectory->GetStreamByIndex(i);
						if (pStream->GetType() != Stream::Type::TYPE_EMPTY)
						{
							pStream->FillSectorChain();
						}
					}
					return true;
				}
			}
			return false;
		}

		bool CompoundFile::Save(const char* sxFileName)
		{
			for (int i = 0; i < m_pStreamDirectory->GetNumStream(); i++)
				m_pStreamDirectory->GetStreamByIndex(i)->WriteToSectors();
			m_pStreamDirectory->GetStreamByIndex(0)->WriteToSectors();
			m_pMasterSectorAllocationTable->WriteToSectors();
			m_pSectorAllocationTable->WriteToSectors();
			m_pShortSectorAllocationTable->WriteToSectors();
			m_pStreamDirectory->WriteToSectors();
			m_pBlob->GetBlobView()->SetOffset(0);
			m_pHeader->Pack(m_pBlob);
			bool bResult = m_pBlob->Save(sxFileName);
			return bResult;
		}

		CompoundFileHeader* CompoundFile::GetHeader()
		{
			return m_pHeader;
		}

		StreamDirectory* CompoundFile::GetStreamDirectory()
		{
			return m_pStreamDirectory;
		}

		Stream* CompoundFile::CreateStream(const char* sxName, Stream::Type eType)
		{
			return m_pStreamDirectory->CreateStream(sxName, eType);
		}

		int CompoundFile::GetNumStream()
		{
			return m_pStreamDirectory->GetNumStream();
		}

		Stream* CompoundFile::GetStreamByIndex(int nIndex)
		{
			return m_pStreamDirectory->GetStreamByIndex(nIndex);
		}

		Stream* CompoundFile::GetStreamByName(const char* sxName)
		{
			return m_pStreamDirectory->GetStreamByName(sxName);
		}

		int CompoundFile::GetSectorSize(bool bShortSector)
		{
			if (bShortSector)
				return 1 << m_pHeader->m_nShortSectorSize;
			else
				return 1 << m_pHeader->m_nSectorSize;
		}

		int CompoundFile::GetSectorId(int nSectorId, bool bShortSector)
		{
			nbAssert::Assert(nSectorId >= 0);
			if (bShortSector)
			{
				return m_pShortSectorAllocationTable->GetSectorId(nSectorId);
			}
			else
			{
				return m_pSectorAllocationTable->GetSectorId(nSectorId);
			}
		}

		Sector* CompoundFile::GetSector(int nSectorId, bool bShortSector)
		{
			nbAssert::Assert(nSectorId >= 0);
			if (bShortSector)
			{
				nbAssert::Assert(nSectorId < m_pShortSectorVector->GetSize());
				return m_pShortSectorVector->Get(nSectorId);
			}
			else
			{
				nbAssert::Assert(nSectorId < m_pSectorVector->GetSize());
				return m_pSectorVector->Get(nSectorId);
			}
		}

		void CompoundFile::FillSectorChain(SectorChain* pSectorChain, int nInitialSectorId, bool bShortSector)
		{
			nbAssert::Assert(pSectorChain != 0);
			int nSectorId = nInitialSectorId;
			while (nSectorId != (int)(Sector::SectorId::END_OF_CHAIN_SECTOR_ID))
			{
				pSectorChain->AppendSector(GetSector(nSectorId, bShortSector));
				nSectorId = GetSectorId(nSectorId, bShortSector);
			}
		}

		int CompoundFile::GetFreeSectorId(bool bShortSector)
		{
			if (bShortSector)
				return m_pShortSectorAllocationTable->GetFreeSectorId();
			return m_pSectorAllocationTable->GetFreeSectorId();
		}

		SectorAllocationTable* CompoundFile::GetSectorAllocationTable(bool bShortSector)
		{
			if (bShortSector)
				return m_pShortSectorAllocationTable;
			else
				return m_pSectorAllocationTable;
		}

		MasterSectorAllocationTable* CompoundFile::GetMasterSectorAllocationTable()
		{
			return m_pMasterSectorAllocationTable;
		}

		void CompoundFile::MasterSectorAllocationTableExtend()
		{
			int nFreeSectorId = GetFreeSectorId(false);
			if (nFreeSectorId < 0)
			{
				int nSectorSize = GetSectorSize(false);
				BlobView* pBlobView = m_pBlob->GetBlobView();
				m_pBlob->Resize(HEADER_SIZE + (m_pSectorVector->GetSize() + 1) * nSectorSize, false);
				pBlobView->SetOffset(HEADER_SIZE + m_pSectorVector->GetSize() * nSectorSize);
				nFreeSectorId = m_pSectorVector->GetSize();
				m_pSectorVector->PushBack(new Sector(nFreeSectorId, pBlobView, GetSectorSize(false)));
			}
			m_pMasterSectorAllocationTable->Extend(m_pSectorVector->Get(nFreeSectorId));
			if (m_pSectorAllocationTable->GetNumFreeSectorId() == 0)
				SectorAllocationTableExtend(false);
			m_pSectorAllocationTable->SetSectorId(nFreeSectorId, (int)(Sector::SectorId::MASTER_SECTOR_ALLOCATION_TABLE_SECTOR_ID));
		}

		void CompoundFile::SectorAllocationTableExtend(bool bShortSector)
		{
			int nSectorSize = GetSectorSize(bShortSector);
			if (bShortSector)
			{
				Stream* pRootStream = m_pStreamDirectory->GetStreamByIndex(0);
				SectorChainExtend(m_pShortSectorAllocationTable);
				m_pHeader->m_nShortSectorAllocationTableSectorId = m_pShortSectorAllocationTable->GetSectorByIndex(0)->GetSectorId();
				m_pHeader->m_nShortSectorAllocationTableSize = (unsigned int)(m_pShortSectorAllocationTable->GetNumSector());
				pRootStream->Resize(m_pShortSectorAllocationTable->GetNumSectorId() * nSectorSize);
				BlobView* pBlobView = pRootStream->GetSectorChain()->GetBlobView();
				pBlobView->SetOffset(m_pShortSectorVector->GetSize() * nSectorSize);
				while (m_pShortSectorVector->GetSize() != m_pShortSectorAllocationTable->GetNumSectorId())
				{
					Sector* pSector = new Sector(m_pShortSectorVector->GetSize(), pBlobView, nSectorSize);
					{
						NumberDuck::Secret::Sector* __3878760436 = pSector;
						pSector = 0;
						m_pShortSectorVector->PushBack(__3878760436);
					}
					if (pSector) delete pSector;
				}
			}
			else
			{
				BlobView* pBlobView = m_pBlob->GetBlobView();
				if (m_pMasterSectorAllocationTable->GetNumSectorId() == m_pSectorAllocationTable->GetNumSector())
					MasterSectorAllocationTableExtend();
				m_pBlob->Resize(HEADER_SIZE + (m_pSectorVector->GetSize() + 1) * nSectorSize, false);
				pBlobView->SetOffset(HEADER_SIZE + m_pSectorVector->GetSize() * nSectorSize);
				int nSectorId = m_pSectorVector->GetSize();
				Sector* pSector = new Sector(nSectorId, pBlobView, nSectorSize);
				Sector* pTemp = pSector;
				{
					NumberDuck::Secret::Sector* __3878760436 = pSector;
					pSector = 0;
					m_pSectorVector->PushBack(__3878760436);
				}
				m_pMasterSectorAllocationTable->SetSectorId(m_pSectorAllocationTable->GetNumSector(), nSectorId);
				m_pSectorAllocationTable->Extend(pTemp);
				if (m_pSectorVector->GetSize() > 1)
					m_pSectorAllocationTable->SetSectorId(m_pSectorVector->Get(m_pSectorVector->GetSize() - 1)->GetSectorId(), nSectorId);
				m_pSectorAllocationTable->SetSectorId(nSectorId, (int)(Sector::SectorId::END_OF_CHAIN_SECTOR_ID));
				m_pHeader->m_nSectorAllocationTableSize++;
				m_pBlob->Resize(HEADER_SIZE + m_pSectorAllocationTable->GetNumSectorId() * nSectorSize, false);
				while (m_pSectorVector->GetSize() != m_pSectorAllocationTable->GetNumSectorId())
				{
					m_pSectorVector->PushBack(new Sector(m_pSectorVector->GetSize(), pBlobView, nSectorSize));
				}
				if (pSector) delete pSector;
			}
		}

		void CompoundFile::SectorChainExtend(SectorChain* pSectorChain)
		{
			bool bShortSector = pSectorChain->GetSectorSize() == GetSectorSize(true);
			if (GetSectorAllocationTable(bShortSector)->GetNumFreeSectorId() == 0)
				SectorAllocationTableExtend(bShortSector);
			int nFreeSectorId = GetFreeSectorId(bShortSector);
			Sector* pSector = GetSector(nFreeSectorId, bShortSector);
			pSectorChain->Extend(pSector);
			SectorAllocationTable* pSectorAllocationTable = GetSectorAllocationTable(bShortSector);
			if (pSectorChain->GetNumSector() > 1)
				pSectorAllocationTable->SetSectorId(pSectorChain->GetSectorByIndex(pSectorChain->GetNumSector() - 2)->GetSectorId(), pSector->GetSectorId());
			pSectorAllocationTable->SetSectorId(pSector->GetSectorId(), (int)(Sector::SectorId::END_OF_CHAIN_SECTOR_ID));
		}

		void CompoundFile::StreamDirectoryExtend()
		{
			SectorChainExtend(m_pStreamDirectory);
			m_pHeader->m_nStreamDirectoryStreamSectorId = m_pStreamDirectory->GetSectorByIndex(0)->GetSectorId();
		}

		Token::Token(Type eType, SubType eSubType, unsigned char nParameterCount)
		{
			m_eType = Type::TYPE_FUNC_COUNT;
			m_eSubType = SubType::SUB_TYPE_FUNCTION;
			m_nParameterCount = 0;
			m_eType = eType;
			m_eSubType = eSubType;
			m_nParameterCount = nParameterCount;
		}

		Token::~Token()
		{
		}

		Token::Type Token::GetType() const
		{
			return m_eType;
		}

		Token::SubType Token::GetSubType()
		{
			return m_eSubType;
		}

		unsigned char Token::GetParameterCount()
		{
			return m_nParameterCount;
		}

		void Token::ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut)
		{
			sOut->AppendString(GetTypeName(m_eType));
		}

		ParsedExpressionRecord* Token::ToParsedExpression(WorkbookGlobals* pWorkbookGlobals)
		{
			if (m_eType == Type::TYPE_PAREN)
				return new PtgParenRecord();
			return new PtgFuncVarRecord((unsigned short)(m_eType), m_nParameterCount);
		}

		bool Token::Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth)
		{
			switch (m_eType)
			{
				case Type::TYPE_PAREN:
				{
					return true;
				}

				case Type::TYPE_FUNC_CONCATENATE:
				{
					InternalString* sTemp = new InternalString("");
					if (ppValueVector->GetSize() >= m_nParameterCount)
					{
						for (unsigned short i = 0; i < m_nParameterCount; i++)
						{
							Value* pValue = ppValueVector->Get(ppValueVector->GetSize() - 1);
							if (pValue->GetType() == Value::Type::TYPE_STRING)
							{
								sTemp->PrependString(pValue->GetString());
							}
							else
							{
								{
									delete sTemp;
									sTemp = 0;
								}
								{
									if (sTemp) delete sTemp;
									return false;
								}
							}
							ppValueVector->PopBack();
							{
								delete pValue;
								pValue = 0;
							}
						}
						ppValueVector->PushBack(Secret::ValueImplementation::CreateStringValue(sTemp->GetExternalString()));
						{
							delete sTemp;
							sTemp = 0;
						}
						{
							if (sTemp) delete sTemp;
							return true;
						}
					}
					{
						delete sTemp;
						sTemp = 0;
					}
					{
						if (sTemp) delete sTemp;
						return false;
					}
				}

				case Type::TYPE_FUNC_HOUR:
				{
					if (ppValueVector->GetSize() >= 1)
					{
						Value* pValue = ppValueVector->Get(ppValueVector->GetSize() - 1);
						if (pValue->GetType() == Value::Type::TYPE_FLOAT)
						{
							Value* pOwnedValue = ppValueVector->PopBack();
							unsigned int nInteger = (unsigned int)(pValue->GetFloat());
							double fInteger = (double)(nInteger);
							double fFraction = pValue->GetFloat() - fInteger;
							ppValueVector->PushBack(Secret::ValueImplementation::CreateFloatValue((double)((int)(fFraction * 24))));
							{
								if (pOwnedValue) delete pOwnedValue;
								return true;
							}
						}
					}
					return false;
				}

				case Type::TYPE_FUNC_IF:
				{
					if (ppValueVector->GetSize() >= 3)
					{
						Value* pA = ppValueVector->Get(ppValueVector->GetSize() - 3);
						Value* pB = ppValueVector->Get(ppValueVector->GetSize() - 2);
						Value* pC = ppValueVector->Get(ppValueVector->GetSize() - 1);
						if (pA->GetType() == Value::Type::TYPE_BOOLEAN)
						{
							Value* pOwnedC = ppValueVector->PopBack();
							Value* pOwnedB = ppValueVector->PopBack();
							Value* pOwnedA = ppValueVector->PopBack();
							if (pA->GetBoolean())
							{
								{
									NumberDuck::Value* __1092584474 = pOwnedB;
									pOwnedB = 0;
									ppValueVector->PushBack(__1092584474);
								}
							}
							else
							{
								{
									NumberDuck::Value* __3995042842 = pOwnedC;
									pOwnedC = 0;
									ppValueVector->PushBack(__3995042842);
								}
							}
							{
								if (pOwnedC) delete pOwnedC;
								if (pOwnedB) delete pOwnedB;
								if (pOwnedA) delete pOwnedA;
								return true;
							}
						}
					}
					break;
				}

				case Type::TYPE_FUNC_AVERAGE:
				{
					if (ppValueVector->GetSize() >= 1)
					{
						Value* pValue = ppValueVector->Get(ppValueVector->GetSize() - 1);
						if (pValue->GetType() == Value::Type::TYPE_AREA)
						{
							Value* pOwnedValue = ppValueVector->PopBack();
							Coordinate* pCoordinate = pValue->m_pImpl->m_pArea->m_pTopLeft->CreateClone();
							double fSum = 0.0f;
							int nCount = 0;
							while (pCoordinate->m_nX <= pValue->m_pImpl->m_pArea->m_pBottomRight->m_nX)
							{
								while (pCoordinate->m_nY <= pValue->m_pImpl->m_pArea->m_pBottomRight->m_nY)
								{
									Cell* pCell = pWorksheetImplementation->m_pWorksheet->GetCell(pCoordinate->m_nX, pCoordinate->m_nY);
									if (pCell->GetType() != Value::Type::TYPE_FLOAT)
									{
										if (pOwnedValue) delete pOwnedValue;
										if (pCoordinate) delete pCoordinate;
										return false;
									}
									fSum += pCell->GetFloat();
									nCount++;
									pCoordinate->m_nY++;
								}
								pCoordinate->m_nX++;
							}
							if (nCount == 0)
							{
								if (pOwnedValue) delete pOwnedValue;
								if (pCoordinate) delete pCoordinate;
								return false;
							}
							ppValueVector->PushBack(Secret::ValueImplementation::CreateFloatValue(fSum / (double)(nCount)));
							{
								if (pOwnedValue) delete pOwnedValue;
								if (pCoordinate) delete pCoordinate;
								return true;
							}
						}
					}
					break;
				}

				case Type::TYPE_FUNC_PI:
				{
					ppValueVector->PushBack(Secret::ValueImplementation::CreateFloatValue(3.14159265358979));
					return true;
				}

			}
			return false;
		}

		void Token::InsertColumn(unsigned short nWorksheet, unsigned short nColumn)
		{
		}

		void Token::DeleteColumn(unsigned short nWorksheet, unsigned short nColumn)
		{
		}

		void Token::InsertRow(unsigned short nWorksheet, unsigned short nRow)
		{
		}

		void Token::DeleteRow(unsigned short nWorksheet, unsigned short nRow)
		{
		}

		const char* Token::GetTypeName(Type eType)
		{
			switch (eType)
			{
				case Type::TYPE_FUNC_COUNT:
				{
					return "COUNT";
				}

				case Type::TYPE_FUNC_IF:
				{
					return "IF";
				}

				case Type::TYPE_FUNC_ISNA:
				{
					return "ISNA";
				}

				case Type::TYPE_FUNC_ISERROR:
				{
					return "ISERROR";
				}

				case Type::TYPE_FUNC_SUM:
				{
					return "SUM";
				}

				case Type::TYPE_FUNC_AVERAGE:
				{
					return "AVERAGE";
				}

				case Type::TYPE_FUNC_MIN:
				{
					return "MIN";
				}

				case Type::TYPE_FUNC_MAX:
				{
					return "MAX";
				}

				case Type::TYPE_FUNC_ROW:
				{
					return "ROW";
				}

				case Type::TYPE_FUNC_COLUMN:
				{
					return "COLUMN";
				}

				case Type::TYPE_FUNC_NA:
				{
					return "NA";
				}

				case Type::TYPE_FUNC_NPV:
				{
					return "NPV";
				}

				case Type::TYPE_FUNC_STDEV:
				{
					return "STDEV";
				}

				case Type::TYPE_FUNC_DOLLAR:
				{
					return "DOLLAR";
				}

				case Type::TYPE_FUNC_FIXED:
				{
					return "FIXED";
				}

				case Type::TYPE_FUNC_SIN:
				{
					return "SIN";
				}

				case Type::TYPE_FUNC_COS:
				{
					return "COS";
				}

				case Type::TYPE_FUNC_TAN:
				{
					return "TAN";
				}

				case Type::TYPE_FUNC_ATAN:
				{
					return "ATAN";
				}

				case Type::TYPE_FUNC_PI:
				{
					return "PI";
				}

				case Type::TYPE_FUNC_SQRT:
				{
					return "SQRT";
				}

				case Type::TYPE_FUNC_EXP:
				{
					return "EXP";
				}

				case Type::TYPE_FUNC_LN:
				{
					return "LN";
				}

				case Type::TYPE_FUNC_LOG10:
				{
					return "LOG10";
				}

				case Type::TYPE_FUNC_ABS:
				{
					return "ABS";
				}

				case Type::TYPE_FUNC_INT:
				{
					return "INT";
				}

				case Type::TYPE_FUNC_SIGN:
				{
					return "SIGN";
				}

				case Type::TYPE_FUNC_ROUND:
				{
					return "ROUND";
				}

				case Type::TYPE_FUNC_LOOKUP:
				{
					return "LOOKUP";
				}

				case Type::TYPE_FUNC_INDEX:
				{
					return "INDEX";
				}

				case Type::TYPE_FUNC_REPT:
				{
					return "REPT";
				}

				case Type::TYPE_FUNC_MID:
				{
					return "MID";
				}

				case Type::TYPE_FUNC_LEN:
				{
					return "LEN";
				}

				case Type::TYPE_FUNC_VALUE:
				{
					return "VALUE";
				}

				case Type::TYPE_FUNC_TRUE:
				{
					return "TRUE";
				}

				case Type::TYPE_FUNC_FALSE:
				{
					return "FALSE";
				}

				case Type::TYPE_FUNC_AND:
				{
					return "AND";
				}

				case Type::TYPE_FUNC_OR:
				{
					return "OR";
				}

				case Type::TYPE_FUNC_NOT:
				{
					return "NOT";
				}

				case Type::TYPE_FUNC_MOD:
				{
					return "MOD";
				}

				case Type::TYPE_FUNC_DCOUNT:
				{
					return "DCOUNT";
				}

				case Type::TYPE_FUNC_DSUM:
				{
					return "DSUM";
				}

				case Type::TYPE_FUNC_DAVERAGE:
				{
					return "DAVERAGE";
				}

				case Type::TYPE_FUNC_DMIN:
				{
					return "DMIN";
				}

				case Type::TYPE_FUNC_DMAX:
				{
					return "DMAX";
				}

				case Type::TYPE_FUNC_DSTDEV:
				{
					return "DSTDEV";
				}

				case Type::TYPE_FUNC_VAR:
				{
					return "VAR";
				}

				case Type::TYPE_FUNC_DVAR:
				{
					return "DVAR";
				}

				case Type::TYPE_FUNC_TEXT:
				{
					return "TEXT";
				}

				case Type::TYPE_FUNC_LINEST:
				{
					return "LINEST";
				}

				case Type::TYPE_FUNC_TREND:
				{
					return "TREND";
				}

				case Type::TYPE_FUNC_LOGEST:
				{
					return "LOGEST";
				}

				case Type::TYPE_FUNC_GROWTH:
				{
					return "GROWTH";
				}

				case Type::TYPE_FUNC_GOTO:
				{
					return "GOTO";
				}

				case Type::TYPE_FUNC_HALT:
				{
					return "HALT";
				}

				case Type::TYPE_FUNC_RETURN:
				{
					return "RETURN";
				}

				case Type::TYPE_FUNC_PV:
				{
					return "PV";
				}

				case Type::TYPE_FUNC_FV:
				{
					return "FV";
				}

				case Type::TYPE_FUNC_NPER:
				{
					return "NPER";
				}

				case Type::TYPE_FUNC_PMT:
				{
					return "PMT";
				}

				case Type::TYPE_FUNC_RATE:
				{
					return "RATE";
				}

				case Type::TYPE_FUNC_MIRR:
				{
					return "MIRR";
				}

				case Type::TYPE_FUNC_IRR:
				{
					return "IRR";
				}

				case Type::TYPE_FUNC_RAND:
				{
					return "RAND";
				}

				case Type::TYPE_FUNC_MATCH:
				{
					return "MATCH";
				}

				case Type::TYPE_FUNC_DATE:
				{
					return "DATE";
				}

				case Type::TYPE_FUNC_TIME:
				{
					return "TIME";
				}

				case Type::TYPE_FUNC_DAY:
				{
					return "DAY";
				}

				case Type::TYPE_FUNC_MONTH:
				{
					return "MONTH";
				}

				case Type::TYPE_FUNC_YEAR:
				{
					return "YEAR";
				}

				case Type::TYPE_FUNC_WEEKDAY:
				{
					return "WEEKDAY";
				}

				case Type::TYPE_FUNC_HOUR:
				{
					return "HOUR";
				}

				case Type::TYPE_FUNC_MINUTE:
				{
					return "MINUTE";
				}

				case Type::TYPE_FUNC_SECOND:
				{
					return "SECOND";
				}

				case Type::TYPE_FUNC_NOW:
				{
					return "NOW";
				}

				case Type::TYPE_FUNC_AREAS:
				{
					return "AREAS";
				}

				case Type::TYPE_FUNC_ROWS:
				{
					return "ROWS";
				}

				case Type::TYPE_FUNC_COLUMNS:
				{
					return "COLUMNS";
				}

				case Type::TYPE_FUNC_OFFSET:
				{
					return "OFFSET";
				}

				case Type::TYPE_FUNC_ABSREF:
				{
					return "ABSREF";
				}

				case Type::TYPE_FUNC_RELREF:
				{
					return "RELREF";
				}

				case Type::TYPE_FUNC_ARGUMENT:
				{
					return "ARGUMENT";
				}

				case Type::TYPE_FUNC_SEARCH:
				{
					return "SEARCH";
				}

				case Type::TYPE_FUNC_TRANSPOSE:
				{
					return "TRANSPOSE";
				}

				case Type::TYPE_FUNC_ERROR:
				{
					return "ERROR";
				}

				case Type::TYPE_FUNC_STEP:
				{
					return "STEP";
				}

				case Type::TYPE_FUNC_TYPE:
				{
					return "TYPE";
				}

				case Type::TYPE_FUNC_ECHO:
				{
					return "ECHO";
				}

				case Type::TYPE_FUNC_SET_NAME:
				{
					return "SET.NAME";
				}

				case Type::TYPE_FUNC_CALLER:
				{
					return "CALLER";
				}

				case Type::TYPE_FUNC_DEREF:
				{
					return "DEREF";
				}

				case Type::TYPE_FUNC_WINDOWS:
				{
					return "WINDOWS";
				}

				case Type::TYPE_FUNC_SERIES:
				{
					return "SERIES";
				}

				case Type::TYPE_FUNC_DOCUMENTS:
				{
					return "DOCUMENTS";
				}

				case Type::TYPE_FUNC_ACTIVE_CELL:
				{
					return "ACTIVE.CELL";
				}

				case Type::TYPE_FUNC_SELECTION:
				{
					return "SELECTION";
				}

				case Type::TYPE_FUNC_RESULT:
				{
					return "RESULT";
				}

				case Type::TYPE_FUNC_ATAN2:
				{
					return "ATAN2";
				}

				case Type::TYPE_FUNC_ASIN:
				{
					return "ASIN";
				}

				case Type::TYPE_FUNC_ACOS:
				{
					return "ACOS";
				}

				case Type::TYPE_FUNC_CHOOSE:
				{
					return "CHOOSE";
				}

				case Type::TYPE_FUNC_HLOOKUP:
				{
					return "HLOOKUP";
				}

				case Type::TYPE_FUNC_VLOOKUP:
				{
					return "VLOOKUP";
				}

				case Type::TYPE_FUNC_LINKS:
				{
					return "LINKS";
				}

				case Type::TYPE_FUNC_INPUT:
				{
					return "INPUT";
				}

				case Type::TYPE_FUNC_ISREF:
				{
					return "ISREF";
				}

				case Type::TYPE_FUNC_GET_FORMULA:
				{
					return "GET.FORMULA";
				}

				case Type::TYPE_FUNC_GET_NAME:
				{
					return "GET.NAME";
				}

				case Type::TYPE_FUNC_SET_VALUE:
				{
					return "SET.VALUE";
				}

				case Type::TYPE_FUNC_LOG:
				{
					return "LOG";
				}

				case Type::TYPE_FUNC_EXEC:
				{
					return "EXEC";
				}

				case Type::TYPE_FUNC_CHAR:
				{
					return "CHAR";
				}

				case Type::TYPE_FUNC_LOWER:
				{
					return "LOWER";
				}

				case Type::TYPE_FUNC_UPPER:
				{
					return "UPPER";
				}

				case Type::TYPE_FUNC_PROPER:
				{
					return "PROPER";
				}

				case Type::TYPE_FUNC_LEFT:
				{
					return "LEFT";
				}

				case Type::TYPE_FUNC_RIGHT:
				{
					return "RIGHT";
				}

				case Type::TYPE_FUNC_EXACT:
				{
					return "EXACT";
				}

				case Type::TYPE_FUNC_TRIM:
				{
					return "TRIM";
				}

				case Type::TYPE_FUNC_REPLACE:
				{
					return "REPLACE";
				}

				case Type::TYPE_FUNC_SUBSTITUTE:
				{
					return "SUBSTITUTE";
				}

				case Type::TYPE_FUNC_CODE:
				{
					return "CODE";
				}

				case Type::TYPE_FUNC_NAMES:
				{
					return "NAMES";
				}

				case Type::TYPE_FUNC_DIRECTORY:
				{
					return "DIRECTORY";
				}

				case Type::TYPE_FUNC_FIND:
				{
					return "FIND";
				}

				case Type::TYPE_FUNC_CELL:
				{
					return "CELL";
				}

				case Type::TYPE_FUNC_ISERR:
				{
					return "ISERR";
				}

				case Type::TYPE_FUNC_ISTEXT:
				{
					return "ISTEXT";
				}

				case Type::TYPE_FUNC_ISNUMBER:
				{
					return "ISNUMBER";
				}

				case Type::TYPE_FUNC_ISBLANK:
				{
					return "ISBLANK";
				}

				case Type::TYPE_FUNC_T:
				{
					return "T";
				}

				case Type::TYPE_FUNC_N:
				{
					return "N";
				}

				case Type::TYPE_FUNC_FOPEN:
				{
					return "FOPEN";
				}

				case Type::TYPE_FUNC_FCLOSE:
				{
					return "FCLOSE";
				}

				case Type::TYPE_FUNC_FSIZE:
				{
					return "FSIZE";
				}

				case Type::TYPE_FUNC_FREADLN:
				{
					return "FREADLN";
				}

				case Type::TYPE_FUNC_FREAD:
				{
					return "FREAD";
				}

				case Type::TYPE_FUNC_FWRITELN:
				{
					return "FWRITELN";
				}

				case Type::TYPE_FUNC_FWRITE:
				{
					return "FWRITE";
				}

				case Type::TYPE_FUNC_FPOS:
				{
					return "FPOS";
				}

				case Type::TYPE_FUNC_DATEVALUE:
				{
					return "DATEVALUE";
				}

				case Type::TYPE_FUNC_TIMEVALUE:
				{
					return "TIMEVALUE";
				}

				case Type::TYPE_FUNC_SLN:
				{
					return "SLN";
				}

				case Type::TYPE_FUNC_SYD:
				{
					return "SYD";
				}

				case Type::TYPE_FUNC_DDB:
				{
					return "DDB";
				}

				case Type::TYPE_FUNC_GET_DEF:
				{
					return "GET.DEF";
				}

				case Type::TYPE_FUNC_REFTEXT:
				{
					return "REFTEXT";
				}

				case Type::TYPE_FUNC_TEXTREF:
				{
					return "TEXTREF";
				}

				case Type::TYPE_FUNC_INDIRECT:
				{
					return "INDIRECT";
				}

				case Type::TYPE_FUNC_REGISTER:
				{
					return "REGISTER";
				}

				case Type::TYPE_FUNC_CALL:
				{
					return "CALL";
				}

				case Type::TYPE_FUNC_ADD_BAR:
				{
					return "ADD.BAR";
				}

				case Type::TYPE_FUNC_ADD_MENU:
				{
					return "ADD.MENU";
				}

				case Type::TYPE_FUNC_ADD_COMMAND:
				{
					return "ADD.COMMAND";
				}

				case Type::TYPE_FUNC_ENABLE_COMMAND:
				{
					return "ENABLE.COMMAND";
				}

				case Type::TYPE_FUNC_CHECK_COMMAND:
				{
					return "CHECK.COMMAND";
				}

				case Type::TYPE_FUNC_RENAME_COMMAND:
				{
					return "RENAME.COMMAND";
				}

				case Type::TYPE_FUNC_SHOW_BAR:
				{
					return "SHOW.BAR";
				}

				case Type::TYPE_FUNC_DELETE_MENU:
				{
					return "DELETE.MENU";
				}

				case Type::TYPE_FUNC_DELETE_COMMAND:
				{
					return "DELETE.COMMAND";
				}

				case Type::TYPE_FUNC_GET_CHART_ITEM:
				{
					return "GET.CHART.ITEM";
				}

				case Type::TYPE_FUNC_DIALOG_BOX:
				{
					return "DIALOG.BOX";
				}

				case Type::TYPE_FUNC_CLEAN:
				{
					return "CLEAN";
				}

				case Type::TYPE_FUNC_MDETERM:
				{
					return "MDETERM";
				}

				case Type::TYPE_FUNC_MINVERSE:
				{
					return "MINVERSE";
				}

				case Type::TYPE_FUNC_MMULT:
				{
					return "MMULT";
				}

				case Type::TYPE_FUNC_FILES:
				{
					return "FILES";
				}

				case Type::TYPE_FUNC_IPMT:
				{
					return "IPMT";
				}

				case Type::TYPE_FUNC_PPMT:
				{
					return "PPMT";
				}

				case Type::TYPE_FUNC_COUNTA:
				{
					return "COUNTA";
				}

				case Type::TYPE_FUNC_CANCEL_KEY:
				{
					return "CANCEL.KEY";
				}

				case Type::TYPE_FUNC_FOR:
				{
					return "FOR";
				}

				case Type::TYPE_FUNC_WHILE:
				{
					return "WHILE";
				}

				case Type::TYPE_FUNC_BREAK:
				{
					return "BREAK";
				}

				case Type::TYPE_FUNC_NEXT:
				{
					return "NEXT";
				}

				case Type::TYPE_FUNC_INITIATE:
				{
					return "INITIATE";
				}

				case Type::TYPE_FUNC_REQUEST:
				{
					return "REQUEST";
				}

				case Type::TYPE_FUNC_POKE:
				{
					return "POKE";
				}

				case Type::TYPE_FUNC_EXECUTE:
				{
					return "EXECUTE";
				}

				case Type::TYPE_FUNC_TERMINATE:
				{
					return "TERMINATE";
				}

				case Type::TYPE_FUNC_RESTART:
				{
					return "RESTART";
				}

				case Type::TYPE_FUNC_HELP:
				{
					return "HELP";
				}

				case Type::TYPE_FUNC_GET_BAR:
				{
					return "GET.BAR";
				}

				case Type::TYPE_FUNC_PRODUCT:
				{
					return "PRODUCT";
				}

				case Type::TYPE_FUNC_FACT:
				{
					return "FACT";
				}

				case Type::TYPE_FUNC_GET_CELL:
				{
					return "GET.CELL";
				}

				case Type::TYPE_FUNC_GET_WORKSPACE:
				{
					return "GET.WORKSPACE";
				}

				case Type::TYPE_FUNC_GET_WINDOW:
				{
					return "GET.WINDOW";
				}

				case Type::TYPE_FUNC_GET_DOCUMENT:
				{
					return "GET.DOCUMENT";
				}

				case Type::TYPE_FUNC_DPRODUCT:
				{
					return "DPRODUCT";
				}

				case Type::TYPE_FUNC_ISNONTEXT:
				{
					return "ISNONTEXT";
				}

				case Type::TYPE_FUNC_GET_NOTE:
				{
					return "GET.NOTE";
				}

				case Type::TYPE_FUNC_NOTE:
				{
					return "NOTE";
				}

				case Type::TYPE_FUNC_STDEVP:
				{
					return "STDEVP";
				}

				case Type::TYPE_FUNC_VARP:
				{
					return "VARP";
				}

				case Type::TYPE_FUNC_DSTDEVP:
				{
					return "DSTDEVP";
				}

				case Type::TYPE_FUNC_DVARP:
				{
					return "DVARP";
				}

				case Type::TYPE_FUNC_TRUNC:
				{
					return "TRUNC";
				}

				case Type::TYPE_FUNC_ISLOGICAL:
				{
					return "ISLOGICAL";
				}

				case Type::TYPE_FUNC_DCOUNTA:
				{
					return "DCOUNTA";
				}

				case Type::TYPE_FUNC_DELETE_BAR:
				{
					return "DELETE.BAR";
				}

				case Type::TYPE_FUNC_UNREGISTER:
				{
					return "UNREGISTER";
				}

				case Type::TYPE_FUNC_USDOLLAR:
				{
					return "USDOLLAR";
				}

				case Type::TYPE_FUNC_FINDB:
				{
					return "FINDB";
				}

				case Type::TYPE_FUNC_SEARCHB:
				{
					return "SEARCHB";
				}

				case Type::TYPE_FUNC_REPLACEB:
				{
					return "REPLACEB";
				}

				case Type::TYPE_FUNC_LEFTB:
				{
					return "LEFTB";
				}

				case Type::TYPE_FUNC_RIGHTB:
				{
					return "RIGHTB";
				}

				case Type::TYPE_FUNC_MIDB:
				{
					return "MIDB";
				}

				case Type::TYPE_FUNC_LENB:
				{
					return "LENB";
				}

				case Type::TYPE_FUNC_ROUNDUP:
				{
					return "ROUNDUP";
				}

				case Type::TYPE_FUNC_ROUNDDOWN:
				{
					return "ROUNDDOWN";
				}

				case Type::TYPE_FUNC_ASC:
				{
					return "ASC";
				}

				case Type::TYPE_FUNC_DBCS:
				{
					return "DBCS";
				}

				case Type::TYPE_FUNC_RANK:
				{
					return "RANK";
				}

				case Type::TYPE_FUNC_ADDRESS:
				{
					return "ADDRESS";
				}

				case Type::TYPE_FUNC_DAYS360:
				{
					return "DAYS360";
				}

				case Type::TYPE_FUNC_TODAY:
				{
					return "TODAY";
				}

				case Type::TYPE_FUNC_VDB:
				{
					return "VDB";
				}

				case Type::TYPE_FUNC_ELSE:
				{
					return "ELSE";
				}

				case Type::TYPE_FUNC_ELSE_IF:
				{
					return "ELSE.IF";
				}

				case Type::TYPE_FUNC_END_IF:
				{
					return "END.IF";
				}

				case Type::TYPE_FUNC_FOR_CELL:
				{
					return "FOR.CELL";
				}

				case Type::TYPE_FUNC_MEDIAN:
				{
					return "MEDIAN";
				}

				case Type::TYPE_FUNC_SUMPRODUCT:
				{
					return "SUMPRODUCT";
				}

				case Type::TYPE_FUNC_SINH:
				{
					return "SINH";
				}

				case Type::TYPE_FUNC_COSH:
				{
					return "COSH";
				}

				case Type::TYPE_FUNC_TANH:
				{
					return "TANH";
				}

				case Type::TYPE_FUNC_ASINH:
				{
					return "ASINH";
				}

				case Type::TYPE_FUNC_ACOSH:
				{
					return "ACOSH";
				}

				case Type::TYPE_FUNC_ATANH:
				{
					return "ATANH";
				}

				case Type::TYPE_FUNC_DGET:
				{
					return "DGET";
				}

				case Type::TYPE_FUNC_CREATE_OBJECT:
				{
					return "CREATE.OBJECT";
				}

				case Type::TYPE_FUNC_VOLATILE:
				{
					return "VOLATILE";
				}

				case Type::TYPE_FUNC_LAST_ERROR:
				{
					return "LAST.ERROR";
				}

				case Type::TYPE_FUNC_CUSTOM_UNDO:
				{
					return "CUSTOM.UNDO";
				}

				case Type::TYPE_FUNC_CUSTOM_REPEAT:
				{
					return "CUSTOM.REPEAT";
				}

				case Type::TYPE_FUNC_FORMULA_CONVERT:
				{
					return "FORMULA.CONVERT";
				}

				case Type::TYPE_FUNC_GET_LINK_INFO:
				{
					return "GET.LINK.INFO";
				}

				case Type::TYPE_FUNC_TEXT_BOX:
				{
					return "TEXT.BOX";
				}

				case Type::TYPE_FUNC_INFO:
				{
					return "INFO";
				}

				case Type::TYPE_FUNC_GROUP:
				{
					return "GROUP";
				}

				case Type::TYPE_FUNC_GET_OBJECT:
				{
					return "GET.OBJECT";
				}

				case Type::TYPE_FUNC_DB:
				{
					return "DB";
				}

				case Type::TYPE_FUNC_PAUSE:
				{
					return "PAUSE";
				}

				case Type::TYPE_FUNC_RESUME:
				{
					return "RESUME";
				}

				case Type::TYPE_FUNC_FREQUENCY:
				{
					return "FREQUENCY";
				}

				case Type::TYPE_FUNC_ADD_TOOLBAR:
				{
					return "ADD.TOOLBAR";
				}

				case Type::TYPE_FUNC_DELETE_TOOLBAR:
				{
					return "DELETE.TOOLBAR";
				}

				case Type::TYPE_FUNC_RESET_TOOLBAR:
				{
					return "RESET.TOOLBAR";
				}

				case Type::TYPE_FUNC_EVALUATE:
				{
					return "EVALUATE";
				}

				case Type::TYPE_FUNC_GET_TOOLBAR:
				{
					return "GET.TOOLBAR";
				}

				case Type::TYPE_FUNC_GET_TOOL:
				{
					return "GET.TOOL";
				}

				case Type::TYPE_FUNC_SPELLING_CHECK:
				{
					return "SPELLING.CHECK";
				}

				case Type::TYPE_FUNC_ERROR_TYPE:
				{
					return "ERROR.TYPE";
				}

				case Type::TYPE_FUNC_APP_TITLE:
				{
					return "APP.TITLE";
				}

				case Type::TYPE_FUNC_WINDOW_TITLE:
				{
					return "WINDOW.TITLE";
				}

				case Type::TYPE_FUNC_SAVE_TOOLBAR:
				{
					return "SAVE.TOOLBAR";
				}

				case Type::TYPE_FUNC_ENABLE_TOOL:
				{
					return "ENABLE.TOOL";
				}

				case Type::TYPE_FUNC_PRESS_TOOL:
				{
					return "PRESS.TOOL";
				}

				case Type::TYPE_FUNC_REGISTER_ID:
				{
					return "REGISTER.ID";
				}

				case Type::TYPE_FUNC_GET_WORKBOOK:
				{
					return "GET.WORKBOOK";
				}

				case Type::TYPE_FUNC_AVEDEV:
				{
					return "AVEDEV";
				}

				case Type::TYPE_FUNC_BETADIST:
				{
					return "BETADIST";
				}

				case Type::TYPE_FUNC_GAMMALN:
				{
					return "GAMMALN";
				}

				case Type::TYPE_FUNC_BETAINV:
				{
					return "BETAINV";
				}

				case Type::TYPE_FUNC_BINOMDIST:
				{
					return "BINOMDIST";
				}

				case Type::TYPE_FUNC_CHIDIST:
				{
					return "CHIDIST";
				}

				case Type::TYPE_FUNC_CHIINV:
				{
					return "CHIINV";
				}

				case Type::TYPE_FUNC_COMBIN:
				{
					return "COMBIN";
				}

				case Type::TYPE_FUNC_CONFIDENCE:
				{
					return "CONFIDENCE";
				}

				case Type::TYPE_FUNC_CRITBINOM:
				{
					return "CRITBINOM";
				}

				case Type::TYPE_FUNC_EVEN:
				{
					return "EVEN";
				}

				case Type::TYPE_FUNC_EXPONDIST:
				{
					return "EXPONDIST";
				}

				case Type::TYPE_FUNC_FDIST:
				{
					return "FDIST";
				}

				case Type::TYPE_FUNC_FINV:
				{
					return "FINV";
				}

				case Type::TYPE_FUNC_FISHER:
				{
					return "FISHER";
				}

				case Type::TYPE_FUNC_FISHERINV:
				{
					return "FISHERINV";
				}

				case Type::TYPE_FUNC_FLOOR:
				{
					return "FLOOR";
				}

				case Type::TYPE_FUNC_GAMMADIST:
				{
					return "GAMMADIST";
				}

				case Type::TYPE_FUNC_GAMMAINV:
				{
					return "GAMMAINV";
				}

				case Type::TYPE_FUNC_CEILING:
				{
					return "CEILING";
				}

				case Type::TYPE_FUNC_HYPGEOMDIST:
				{
					return "HYPGEOMDIST";
				}

				case Type::TYPE_FUNC_LOGNORMDIST:
				{
					return "LOGNORMDIST";
				}

				case Type::TYPE_FUNC_LOGINV:
				{
					return "LOGINV";
				}

				case Type::TYPE_FUNC_NEGBINOMDIST:
				{
					return "NEGBINOMDIST";
				}

				case Type::TYPE_FUNC_NORMDIST:
				{
					return "NORMDIST";
				}

				case Type::TYPE_FUNC_NORMSDIST:
				{
					return "NORMSDIST";
				}

				case Type::TYPE_FUNC_NORMINV:
				{
					return "NORMINV";
				}

				case Type::TYPE_FUNC_NORMSINV:
				{
					return "NORMSINV";
				}

				case Type::TYPE_FUNC_STANDARDIZE:
				{
					return "STANDARDIZE";
				}

				case Type::TYPE_FUNC_ODD:
				{
					return "ODD";
				}

				case Type::TYPE_FUNC_PERMUT:
				{
					return "PERMUT";
				}

				case Type::TYPE_FUNC_POISSON:
				{
					return "POISSON";
				}

				case Type::TYPE_FUNC_TDIST:
				{
					return "TDIST";
				}

				case Type::TYPE_FUNC_WEIBULL:
				{
					return "WEIBULL";
				}

				case Type::TYPE_FUNC_SUMXMY2:
				{
					return "SUMXMY2";
				}

				case Type::TYPE_FUNC_SUMX2MY2:
				{
					return "SUMX2MY2";
				}

				case Type::TYPE_FUNC_SUMX2PY2:
				{
					return "SUMX2PY2";
				}

				case Type::TYPE_FUNC_CHITEST:
				{
					return "CHITEST";
				}

				case Type::TYPE_FUNC_CORREL:
				{
					return "CORREL";
				}

				case Type::TYPE_FUNC_COVAR:
				{
					return "COVAR";
				}

				case Type::TYPE_FUNC_FORECAST:
				{
					return "FORECAST";
				}

				case Type::TYPE_FUNC_FTEST:
				{
					return "FTEST";
				}

				case Type::TYPE_FUNC_INTERCEPT:
				{
					return "INTERCEPT";
				}

				case Type::TYPE_FUNC_PEARSON:
				{
					return "PEARSON";
				}

				case Type::TYPE_FUNC_RSQ:
				{
					return "RSQ";
				}

				case Type::TYPE_FUNC_STEYX:
				{
					return "STEYX";
				}

				case Type::TYPE_FUNC_SLOPE:
				{
					return "SLOPE";
				}

				case Type::TYPE_FUNC_TTEST:
				{
					return "TTEST";
				}

				case Type::TYPE_FUNC_PROB:
				{
					return "PROB";
				}

				case Type::TYPE_FUNC_DEVSQ:
				{
					return "DEVSQ";
				}

				case Type::TYPE_FUNC_GEOMEAN:
				{
					return "GEOMEAN";
				}

				case Type::TYPE_FUNC_HARMEAN:
				{
					return "HARMEAN";
				}

				case Type::TYPE_FUNC_SUMSQ:
				{
					return "SUMSQ";
				}

				case Type::TYPE_FUNC_KURT:
				{
					return "KURT";
				}

				case Type::TYPE_FUNC_SKEW:
				{
					return "SKEW";
				}

				case Type::TYPE_FUNC_ZTEST:
				{
					return "ZTEST";
				}

				case Type::TYPE_FUNC_LARGE:
				{
					return "LARGE";
				}

				case Type::TYPE_FUNC_SMALL:
				{
					return "SMALL";
				}

				case Type::TYPE_FUNC_QUARTILE:
				{
					return "QUARTILE";
				}

				case Type::TYPE_FUNC_PERCENTILE:
				{
					return "PERCENTILE";
				}

				case Type::TYPE_FUNC_PERCENTRANK:
				{
					return "PERCENTRANK";
				}

				case Type::TYPE_FUNC_MODE:
				{
					return "MODE";
				}

				case Type::TYPE_FUNC_TRIMMEAN:
				{
					return "TRIMMEAN";
				}

				case Type::TYPE_FUNC_TINV:
				{
					return "TINV";
				}

				case Type::TYPE_FUNC_MOVIE_COMMAND:
				{
					return "MOVIE.COMMAND";
				}

				case Type::TYPE_FUNC_GET_MOVIE:
				{
					return "GET.MOVIE";
				}

				case Type::TYPE_FUNC_CONCATENATE:
				{
					return "CONCATENATE";
				}

				case Type::TYPE_FUNC_POWER:
				{
					return "POWER";
				}

				case Type::TYPE_FUNC_PIVOT_ADD_DATA:
				{
					return "PIVOT.ADD.DATA";
				}

				case Type::TYPE_FUNC_GET_PIVOT_TABLE:
				{
					return "GET.PIVOT.TABLE";
				}

				case Type::TYPE_FUNC_GET_PIVOT_FIELD:
				{
					return "GET.PIVOT.FIELD";
				}

				case Type::TYPE_FUNC_GET_PIVOT_ITEM:
				{
					return "GET.PIVOT.ITEM";
				}

				case Type::TYPE_FUNC_RADIANS:
				{
					return "RADIANS";
				}

				case Type::TYPE_FUNC_DEGREES:
				{
					return "DEGREES";
				}

				case Type::TYPE_FUNC_SUBTOTAL:
				{
					return "SUBTOTAL";
				}

				case Type::TYPE_FUNC_SUMIF:
				{
					return "SUMIF";
				}

				case Type::TYPE_FUNC_COUNTIF:
				{
					return "COUNTIF";
				}

				case Type::TYPE_FUNC_COUNTBLANK:
				{
					return "COUNTBLANK";
				}

				case Type::TYPE_FUNC_SCENARIO_GET:
				{
					return "SCENARIO.GET";
				}

				case Type::TYPE_FUNC_OPTIONS_LISTS_GET:
				{
					return "OPTIONS.LISTS.GET";
				}

				case Type::TYPE_FUNC_ISPMT:
				{
					return "ISPMT";
				}

				case Type::TYPE_FUNC_DATEDIF:
				{
					return "DATEDIF";
				}

				case Type::TYPE_FUNC_DATESTRING:
				{
					return "DATESTRING";
				}

				case Type::TYPE_FUNC_NUMBERSTRING:
				{
					return "NUMBERSTRING";
				}

				case Type::TYPE_FUNC_ROMAN:
				{
					return "ROMAN";
				}

				case Type::TYPE_FUNC_OPEN_DIALOG:
				{
					return "OPEN.DIALOG";
				}

				case Type::TYPE_FUNC_SAVE_DIALOG:
				{
					return "SAVE.DIALOG";
				}

				case Type::TYPE_FUNC_VIEW_GET:
				{
					return "VIEW.GET";
				}

				case Type::TYPE_FUNC_GETPIVOTDATA:
				{
					return "GETPIVOTDATA";
				}

				case Type::TYPE_FUNC_HYPERLINK:
				{
					return "HYPERLINK";
				}

				case Type::TYPE_FUNC_PHONETIC:
				{
					return "PHONETIC";
				}

				case Type::TYPE_FUNC_AVERAGEA:
				{
					return "AVERAGEA";
				}

				case Type::TYPE_FUNC_MAXA:
				{
					return "MAXA";
				}

				case Type::TYPE_FUNC_MINA:
				{
					return "MINA";
				}

				case Type::TYPE_FUNC_STDEVPA:
				{
					return "STDEVPA";
				}

				case Type::TYPE_FUNC_VARPA:
				{
					return "VARPA";
				}

				case Type::TYPE_FUNC_STDEVA:
				{
					return "STDEVA";
				}

				case Type::TYPE_FUNC_VARA:
				{
					return "VARA";
				}

				case Type::TYPE_FUNC_BAHTTEXT:
				{
					return "BAHTTEXT";
				}

				case Type::TYPE_FUNC_THAIDAYOFWEEK:
				{
					return "THAIDAYOFWEEK";
				}

				case Type::TYPE_FUNC_THAIDIGIT:
				{
					return "THAIDIGIT";
				}

				case Type::TYPE_FUNC_THAIMONTHOFYEAR:
				{
					return "THAIMONTHOFYEAR";
				}

				case Type::TYPE_FUNC_THAINUMSOUND:
				{
					return "THAINUMSOUND";
				}

				case Type::TYPE_FUNC_THAINUMSTRING:
				{
					return "THAINUMSTRING";
				}

				case Type::TYPE_FUNC_THAISTRINGLENGTH:
				{
					return "THAISTRINGLENGTH";
				}

				case Type::TYPE_FUNC_ISTHAIDIGIT:
				{
					return "ISTHAIDIGIT";
				}

				case Type::TYPE_FUNC_ROUNDBAHTDOWN:
				{
					return "ROUNDBAHTDOWN";
				}

				case Type::TYPE_FUNC_ROUNDBAHTUP:
				{
					return "ROUNDBAHTUP";
				}

				case Type::TYPE_FUNC_THAIYEAR:
				{
					return "THAIYEAR";
				}

				case Type::TYPE_FUNC_RTD:
				{
					return "RTD";
				}

				case Type::TYPE_PAREN:
				{
					return "";
				}

			}
			return "???";
		}

		SumToken::SumToken(unsigned char nParameterCount) : Token(Type::TYPE_FUNC_SUM, SubType::SUB_TYPE_FUNCTION, nParameterCount)
		{
		}

		void SumToken::ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut)
		{
			sOut->AppendString("SUM");
		}

		ParsedExpressionRecord* SumToken::ToParsedExpression(WorkbookGlobals* pWorkbookGlobals)
		{
			return new PtgFuncVarRecord((unsigned short)(Token::Type::TYPE_FUNC_SUM), m_nParameterCount);
		}

		bool SumToken::Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth)
		{
			double fValue = 0.0f;
			if (ppValueVector->GetSize() >= m_nParameterCount)
			{
				for (unsigned short i = 0; i < m_nParameterCount; i++)
				{
					Value* pValue = ppValueVector->Get(ppValueVector->GetSize() - 1);
					switch (pValue->GetType())
					{
						case Value::Type::TYPE_FLOAT:
						{
							fValue += pValue->GetFloat();
							break;
						}

						case Value::Type::TYPE_AREA:
						{
							Area* pArea = pValue->m_pImpl->m_pArea;
							for (unsigned short nX = pArea->m_pTopLeft->m_nX; nX <= pArea->m_pBottomRight->m_nX; nX++)
							{
								for (unsigned short nY = pArea->m_pTopLeft->m_nY; nY <= pArea->m_pBottomRight->m_nY; nY++)
								{
									Cell* pCell = pWorksheetImplementation->m_pWorksheet->GetCell(nX, nY);
									if (pCell->GetType() == Value::Type::TYPE_FLOAT)
										fValue += pCell->GetFloat();
								}
							}
							break;
						}

						case Value::Type::TYPE_AREA_3D:
						{
							Area3d* pArea3d = pValue->m_pImpl->m_pArea3d;
							Area* pArea = pArea3d->m_pArea;
							for (unsigned short nSheet = pArea3d->m_pWorksheetRange->m_nFirst; nSheet <= pArea3d->m_pWorksheetRange->m_nLast; nSheet++)
							{
								Worksheet* pWorksheet = pWorksheetImplementation->GetWorkbook()->GetWorksheetByIndex(nSheet);
								if (pWorksheet == 0)
									return false;
								for (unsigned short nX = pArea->m_pTopLeft->m_nX; nX <= pArea->m_pBottomRight->m_nX; nX++)
								{
									for (unsigned short nY = pArea->m_pTopLeft->m_nY; nY <= pArea->m_pBottomRight->m_nY; nY++)
									{
										Cell* pCell = pWorksheet->GetCell(nX, nY);
										if (pCell->GetType() == Value::Type::TYPE_FLOAT)
											fValue += pCell->GetFloat();
										else if (pCell->GetType() == Value::Type::TYPE_FORMULA)
										{
											const Value* pResult = pCell->GetValue()->m_pImpl->m_pFormula->Evaluate(pWorksheet->m_pImpl, (unsigned short)(nDepth + 1));
											if (pResult->GetType() == Value::Type::TYPE_FLOAT)
												fValue += pResult->GetFloat();
										}
									}
								}
							}
							break;
						}

					}
					ppValueVector->PopBack();
					{
						delete pValue;
						pValue = 0;
					}
				}
			}
			ppValueVector->PushBack(ValueImplementation::CreateFloatValue(fValue));
			return true;
		}

		StringToken::StringToken(const char* sxString) : Token(Type::TYPE_STRING, SubType::SUB_TYPE_VARIABLE, 0)
		{
			m_sString = 0;
			m_sString = new InternalString(sxString);
		}

		void StringToken::ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut)
		{
			int i;
			sOut->AppendChar('"');
			for (i = 0; i < m_sString->GetLength(); i++)
			{
				unsigned short nChar = m_sString->GetChar(i);
				if (nChar == '"')
					sOut->AppendChar('"');
				sOut->AppendChar(nChar);
			}
			sOut->AppendChar('"');
		}

		ParsedExpressionRecord* StringToken::ToParsedExpression(WorkbookGlobals* pWorkbookGlobals)
		{
			return new PtgStrRecord(m_sString->GetExternalString());
		}

		bool StringToken::Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth)
		{
			ppValueVector->PushBack(ValueImplementation::CreateStringValue(m_sString->GetExternalString()));
			return true;
		}

		StringToken::~StringToken()
		{
			if (m_sString) delete m_sString;
		}

		SpaceToken::SpaceToken(SpaceType eSpaceType, unsigned char nCount) : Token(Type::TYPE_SPACE, SubType::SUB_TYPE_VARIABLE, 0)
		{
			m_eSpaceType = SpaceType::TYPE_SPACE_BEFORE_BASE_EXPRESSION;
			m_nCount = 0;
			nbAssert::Assert(eSpaceType >= SpaceType::TYPE_SPACE_BEFORE_BASE_EXPRESSION && eSpaceType <= SpaceType::TYPE_SPACE_BEFORE_EXPRESSION);
			nbAssert::Assert(nCount > 0);
			m_eSpaceType = eSpaceType;
			m_nCount = nCount;
		}

		void SpaceToken::ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut)
		{
			unsigned short cChar = ' ';
			if (m_eSpaceType == SpaceType::TYPE_RETURN_BEFORE_BASE_EXPRESSION || m_eSpaceType == SpaceType::TYPE_RETURN_BEFORE_OPEN || m_eSpaceType == SpaceType::TYPE_RETURN_BEFORE_CLOSE)
				cChar = '\n';
			for (unsigned char i = 0; i < m_nCount; i++)
				sOut->AppendChar(cChar);
		}

		ParsedExpressionRecord* SpaceToken::ToParsedExpression(WorkbookGlobals* pWorkbookGlobals)
		{
			return new PtgAttrSpaceRecord((unsigned char)(m_eSpaceType), m_nCount);
		}

		SpaceToken::SpaceType SpaceToken::GetSpaceType()
		{
			return m_eSpaceType;
		}

		bool SpaceToken::Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth)
		{
			return true;
		}

		OperatorToken::OperatorToken(const char* szOperator) : Token(Type::TYPE_OPERATOR, SubType::SUB_TYPE_OPERATOR, 2)
		{
			m_sOperator = 0;
			m_sOperator = new InternalString(szOperator);
		}

		void OperatorToken::ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut)
		{
			sOut->AppendString(m_sOperator->GetExternalString());
		}

		ParsedExpressionRecord* OperatorToken::ToParsedExpression(WorkbookGlobals* pWorkbookGlobals)
		{
			if (m_sOperator->IsEqual("+"))
				return new PtgOperatorRecord(0x03);
			if (m_sOperator->IsEqual("-"))
				return new PtgOperatorRecord(0x04);
			if (m_sOperator->IsEqual("*"))
				return new PtgOperatorRecord(0x05);
			if (m_sOperator->IsEqual("/"))
				return new PtgOperatorRecord(0x06);
			if (m_sOperator->IsEqual("^"))
				return new PtgOperatorRecord(0x07);
			if (m_sOperator->IsEqual("&"))
				return new PtgOperatorRecord(0x08);
			if (m_sOperator->IsEqual("<"))
				return new PtgOperatorRecord(0x09);
			if (m_sOperator->IsEqual("<="))
				return new PtgOperatorRecord(0x0A);
			if (m_sOperator->IsEqual("="))
				return new PtgOperatorRecord(0x0B);
			if (m_sOperator->IsEqual(">="))
				return new PtgOperatorRecord(0x0C);
			if (m_sOperator->IsEqual(">"))
				return new PtgOperatorRecord(0x0D);
			if (m_sOperator->IsEqual("<>"))
				return new PtgOperatorRecord(0x0E);
			nbAssert::Assert(false);
			return 0;
		}

		bool OperatorToken::Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth)
		{
			if (ppValueVector->GetSize() >= 2)
			{
				Value* a = ppValueVector->Get(ppValueVector->GetSize() - 2);
				Value* b = ppValueVector->Get(ppValueVector->GetSize() - 1);
				if (a->GetType() == Value::Type::TYPE_FLOAT && b->GetType() == Value::Type::TYPE_FLOAT)
				{
					Value* pOwnedB = ppValueVector->PopBack();
					Value* pOwnedA = ppValueVector->PopBack();
					bool bReturnable = true;
					if (m_sOperator->IsEqual("+"))
						ppValueVector->PushBack(ValueImplementation::CreateFloatValue(a->GetFloat() + b->GetFloat()));
					else if (m_sOperator->IsEqual("*"))
						ppValueVector->PushBack(ValueImplementation::CreateFloatValue(a->GetFloat() * b->GetFloat()));
					else if (m_sOperator->IsEqual("-"))
						ppValueVector->PushBack(ValueImplementation::CreateFloatValue(a->GetFloat() - b->GetFloat()));
					else if (m_sOperator->IsEqual("/") && b->GetFloat() != 0.0f)
						ppValueVector->PushBack(ValueImplementation::CreateFloatValue(a->GetFloat() / b->GetFloat()));
					else if (m_sOperator->IsEqual("^"))
						ppValueVector->PushBack(ValueImplementation::CreateFloatValue(Utils::Pow(a->GetFloat(), b->GetFloat())));
					else if (m_sOperator->IsEqual(">"))
						ppValueVector->PushBack(ValueImplementation::CreateBooleanValue(a->GetFloat() > b->GetFloat()));
					else if (m_sOperator->IsEqual(">="))
						ppValueVector->PushBack(ValueImplementation::CreateBooleanValue(a->GetFloat() >= b->GetFloat()));
					else if (m_sOperator->IsEqual("<"))
						ppValueVector->PushBack(ValueImplementation::CreateBooleanValue(a->GetFloat() < b->GetFloat()));
					else if (m_sOperator->IsEqual("<="))
						ppValueVector->PushBack(ValueImplementation::CreateBooleanValue(a->GetFloat() <= b->GetFloat()));
					else if (m_sOperator->IsEqual("="))
						ppValueVector->PushBack(ValueImplementation::CreateBooleanValue(a->GetFloat() == b->GetFloat()));
					else if (m_sOperator->IsEqual("<>"))
						ppValueVector->PushBack(ValueImplementation::CreateBooleanValue(a->GetFloat() != b->GetFloat()));
					else
						bReturnable = false;
					{
						if (pOwnedB) delete pOwnedB;
						if (pOwnedA) delete pOwnedA;
						return bReturnable;
					}
				}
				if (a->GetType() == Value::Type::TYPE_STRING && b->GetType() == Value::Type::TYPE_STRING)
				{
					Value* pOwnedB = ppValueVector->PopBack();
					Value* pOwnedA = ppValueVector->PopBack();
					bool bReturnable = true;
					if (m_sOperator->IsEqual("="))
						ppValueVector->PushBack(ValueImplementation::CreateBooleanValue(ExternalString::Equal(a->GetString(), b->GetString())));
					else if (m_sOperator->IsEqual("&"))
					{
						InternalString* sTemp = new InternalString(a->GetString());
						sTemp->AppendString(b->GetString());
						ppValueVector->PushBack(ValueImplementation::CreateStringValue(sTemp->GetExternalString()));
						{
							delete sTemp;
							sTemp = 0;
						}
						if (sTemp) delete sTemp;
					}
					else
						bReturnable = false;
					{
						if (pOwnedB) delete pOwnedB;
						if (pOwnedA) delete pOwnedA;
						return bReturnable;
					}
				}
			}
			return false;
		}

		OperatorToken::~OperatorToken()
		{
			if (m_sOperator) delete m_sOperator;
		}

		NumToken::NumToken(double fNumber) : Token(Type::TYPE_NUMBER, SubType::SUB_TYPE_VARIABLE, 0)
		{
			m_fNumber = 0;
			m_fNumber = fNumber;
		}

		void NumToken::ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut)
		{
			sOut->AppendDouble(m_fNumber);
		}

		ParsedExpressionRecord* NumToken::ToParsedExpression(WorkbookGlobals* pWorkbookGlobals)
		{
			return new PtgNumRecord(m_fNumber);
		}

		bool NumToken::Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth)
		{
			ppValueVector->PushBack(ValueImplementation::CreateFloatValue(m_fNumber));
			return true;
		}

		MissArgToken::MissArgToken() : Token(Type::TYPE_MISS_ARG, SubType::SUB_TYPE_VARIABLE, 0)
		{
		}

		void MissArgToken::ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut)
		{
		}

		ParsedExpressionRecord* MissArgToken::ToParsedExpression(WorkbookGlobals* pWorkbookGlobals)
		{
			return new PtgMissArgRecord();
		}

		bool MissArgToken::Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth)
		{
			return true;
		}

		IntToken::IntToken(unsigned short nInt) : Token(Type::TYPE_INT, SubType::SUB_TYPE_VARIABLE, 0)
		{
			m_nInt = 0;
			m_nInt = nInt;
		}

		void IntToken::ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut)
		{
			sOut->AppendUint32(m_nInt);
		}

		ParsedExpressionRecord* IntToken::ToParsedExpression(WorkbookGlobals* pWorkbookGlobals)
		{
			return new PtgIntRecord(m_nInt);
		}

		bool IntToken::Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth)
		{
			ppValueVector->PushBack(ValueImplementation::CreateFloatValue((double)(m_nInt)));
			return true;
		}

		ParseFunctionData::ParseFunctionData()
		{
			m_nCount = 0;
		}

		ParseSpaceData::ParseSpaceData()
		{
			m_nIndex = 0;
			m_cChar = '0';
			m_nCount = 0;
			m_nIndex = 0;
			m_cChar = '\0';
			m_nCount = 0;
		}

		Formula::Formula(const char* szFormula, WorksheetImplementation* pWorksheetImplementation)
		{
			m_pTokenVector = 0;
			m_pValue = 0;
			m_sTemp = 0;
			m_sTemp = new InternalString(szFormula);
			m_pTokenVector = new OwnedVector<Token*>();
			m_pValue = 0;
			if (m_sTemp->GetLength() > 0 && m_sTemp->GetChar(0) == '=')
			{
				m_sTemp->CropFront(1);
				Parse(m_sTemp, pWorksheetImplementation);
			}
		}

		Formula::Formula(Vector<ParsedExpressionRecord*>* pParsedExpressionRecordVector, WorkbookGlobals* pWorkbookGlobals)
		{
			m_pTokenVector = 0;
			m_pValue = 0;
			m_sTemp = 0;
			int i;
			m_sTemp = new InternalString("");
			m_pTokenVector = new OwnedVector<Token*>();
			m_pValue = 0;
			for (i = 0; i < pParsedExpressionRecordVector->GetSize(); i++)
			{
				ParsedExpressionRecord* pParsedExpressionRecord = pParsedExpressionRecordVector->Get(i);
				Token* pToken = pParsedExpressionRecord->GetToken(pWorkbookGlobals);
				if (pToken != 0)
				{
					NumberDuck::Secret::Token* __2538616708 = pToken;
					pToken = 0;
					m_pTokenVector->PushBack(__2538616708);
				}
				if (pParsedExpressionRecord->GetType() == ParsedExpressionRecord::Type::TYPE_UNKNOWN)
				{
					if (pToken) delete pToken;
					break;
				}
				if (pToken) delete pToken;
			}
		}

		Formula::Formula(OwnedVector<ParsedExpressionRecord*>* pParsedExpressionRecordVector, WorkbookGlobals* pWorkbookGlobals)
		{
			m_pTokenVector = 0;
			m_pValue = 0;
			m_sTemp = 0;
			int i;
			m_sTemp = new InternalString("");
			m_pTokenVector = new OwnedVector<Token*>();
			m_pValue = 0;
			for (i = 0; i < pParsedExpressionRecordVector->GetSize(); i++)
			{
				ParsedExpressionRecord* pParsedExpressionRecord = pParsedExpressionRecordVector->Get(i);
				Token* pToken = pParsedExpressionRecord->GetToken(pWorkbookGlobals);
				if (pToken != 0)
				{
					NumberDuck::Secret::Token* __2538616708 = pToken;
					pToken = 0;
					m_pTokenVector->PushBack(__2538616708);
				}
				if (pParsedExpressionRecord->GetType() == ParsedExpressionRecord::Type::TYPE_UNKNOWN)
				{
					if (pToken) delete pToken;
					break;
				}
				if (pToken) delete pToken;
			}
		}

		unsigned short Formula::GetNumToken()
		{
			return (unsigned short)(m_pTokenVector->GetSize());
		}

		const Token* Formula::GetTokenByIndex(unsigned short nIndex)
		{
			nbAssert::Assert(nIndex < m_pTokenVector->GetSize());
			return m_pTokenVector->Get(nIndex);
		}

		const Value* Formula::Evaluate(WorksheetImplementation* pWorksheetImplementation, unsigned short nDepth)
		{
			bool bError = false;
			OwnedVector<Value*>* ppValueVector = new OwnedVector<Value*>();
			for (int i = 0; i < m_pTokenVector->GetSize(); i++)
			{
				if (!m_pTokenVector->Get(i)->Evaluate(pWorksheetImplementation, ppValueVector, (unsigned short)(nDepth + 1)))
				{
					bError = true;
					break;
				}
			}
			if (m_pValue != 0)
				{
					delete m_pValue;
					m_pValue = 0;
				}
			if (bError || ppValueVector->GetSize() != 1)
			{
				ppValueVector->Clear();
				m_pValue = ValueImplementation::CreateErrorValue();
			}
			else
			{
				m_pValue = ppValueVector->PopBack();
			}
			{
				if (ppValueVector) delete ppValueVector;
				return m_pValue;
			}
		}

		const char* Formula::ToString(WorksheetImplementation* pWorksheetImplementation)
		{
			InternalString* sPreSpace = new InternalString("");
			InternalString* sPostSpace = new InternalString("");
			OwnedVector<InternalString*>* sParameterVector = new OwnedVector<InternalString*>();
			for (int i = 0; i < m_pTokenVector->GetSize(); i++)
			{
				Token* pToken = m_pTokenVector->Get(i);
				SpaceToken* pSpaceToken = 0;
				if (pToken->GetType() == Token::Type::TYPE_SPACE)
					pSpaceToken = (SpaceToken*)(pToken);
				if (pToken->GetSubType() == Token::SubType::SUB_TYPE_OPERATOR)
				{
					if (sParameterVector->GetSize() < 2 || pToken->GetParameterCount() != 2)
					{
						m_sTemp->Set("=");
						{
							if (sPreSpace) delete sPreSpace;
							if (sPostSpace) delete sPostSpace;
							if (sParameterVector) delete sParameterVector;
							return m_sTemp->GetExternalString();
						}
					}
					InternalString* sTempB = sParameterVector->PopBack();
					InternalString* sTempA = sParameterVector->PopBack();
					sTempA->AppendString(sPreSpace->GetExternalString());
					pToken->ToString(pWorksheetImplementation, sTempA);
					sTempA->AppendString(sTempB->GetExternalString());
					{
						NumberDuck::Secret::InternalString* __2442592686 = sTempA;
						sTempA = 0;
						sParameterVector->PushBack(__2442592686);
					}
					sPreSpace->Set("");
					sPostSpace->Set("");
					if (sTempB) delete sTempB;
					if (sTempA) delete sTempA;
				}
				else if (pToken->GetSubType() == Token::SubType::SUB_TYPE_FUNCTION)
				{
					InternalString* sParameters = new InternalString("");
					for (unsigned short j = 0; j < pToken->GetParameterCount(); j++)
					{
						if (sParameterVector->GetSize() == 0)
						{
							m_sTemp->Set("=");
							{
								if (sParameters) delete sParameters;
								if (sPreSpace) delete sPreSpace;
								if (sPostSpace) delete sPostSpace;
								if (sParameterVector) delete sParameterVector;
								return m_sTemp->GetExternalString();
							}
						}
						InternalString* sPopped = sParameterVector->PopBack();
						if (j > 0)
							sPopped->AppendString(",");
						sPopped->AppendString(sParameters->GetExternalString());
						{
							delete sParameters;
							sParameters = 0;
						}
						{
							NumberDuck::Secret::InternalString* __2953685605 = sPopped;
							sPopped = 0;
							sParameters = __2953685605;
						}
						if (sPopped) delete sPopped;
					}
					InternalString* sTemp = new InternalString("");
					sTemp->AppendString(sPreSpace->GetExternalString());
					pToken->ToString(pWorksheetImplementation, sTemp);
					sTemp->AppendString("(");
					sTemp->AppendString(sParameters->GetExternalString());
					sTemp->AppendString(sPostSpace->GetExternalString());
					sTemp->AppendString(")");
					{
						NumberDuck::Secret::InternalString* __1006353954 = sTemp;
						sTemp = 0;
						sParameterVector->PushBack(__1006353954);
					}
					sPreSpace->Set("");
					sPostSpace->Set("");
					if (sParameters) delete sParameters;
					if (sTemp) delete sTemp;
				}
				else
				{
					if (pSpaceToken != 0)
					{
						if (pSpaceToken->GetSpaceType() == SpaceToken::SpaceType::TYPE_SPACE_BEFORE_BASE_EXPRESSION || pSpaceToken->GetSpaceType() == SpaceToken::SpaceType::TYPE_RETURN_BEFORE_BASE_EXPRESSION)
							pToken->ToString(pWorksheetImplementation, sPreSpace);
						else
							pToken->ToString(pWorksheetImplementation, sPostSpace);
					}
					else
					{
						InternalString* sTemp = new InternalString("");
						sTemp->AppendString(sPreSpace->GetExternalString());
						pToken->ToString(pWorksheetImplementation, sTemp);
						sTemp->AppendString(sPostSpace->GetExternalString());
						{
							NumberDuck::Secret::InternalString* __1006353954 = sTemp;
							sTemp = 0;
							sParameterVector->PushBack(__1006353954);
						}
						sPreSpace->Set("");
						sPostSpace->Set("");
						if (sTemp) delete sTemp;
					}
				}
			}
			m_sTemp->Set("=");
			if (sParameterVector->GetSize() > 0)
				m_sTemp->AppendString(sParameterVector->Get(0)->GetExternalString());
			{
				if (sPreSpace) delete sPreSpace;
				if (sPostSpace) delete sPostSpace;
				if (sParameterVector) delete sParameterVector;
				return m_sTemp->GetExternalString();
			}
		}

		void Formula::ToRgce(RgceStruct* pRgce, WorkbookGlobals* pWorkbookGlobals)
		{
			for (int i = 0; i < m_pTokenVector->GetSize(); i++)
			{
				Token* pToken = m_pTokenVector->Get(i);
				ParsedExpressionRecord* pTemp = pToken->ToParsedExpression(pWorkbookGlobals);
				nbAssert::Assert(pTemp != 0);
				{
					NumberDuck::Secret::ParsedExpressionRecord* __432555651 = pTemp;
					pTemp = 0;
					pRgce->m_pParsedExpressionRecordVector->PushBack(__432555651);
				}
				if (pTemp) delete pTemp;
			}
		}

		void Formula::InsertColumn(unsigned short nWorksheet, unsigned short nColumn)
		{
			for (int i = 0; i < m_pTokenVector->GetSize(); i++)
				m_pTokenVector->Get(i)->InsertColumn(nWorksheet, nColumn);
		}

		void Formula::DeleteColumn(unsigned short nWorksheet, unsigned short nColumn)
		{
			for (int i = 0; i < m_pTokenVector->GetSize(); i++)
				m_pTokenVector->Get(i)->DeleteColumn(nWorksheet, nColumn);
		}

		void Formula::InsertRow(unsigned short nWorksheet, unsigned short nRow)
		{
			for (int i = 0; i < m_pTokenVector->GetSize(); i++)
				m_pTokenVector->Get(i)->InsertRow(nWorksheet, nRow);
		}

		void Formula::DeleteRow(unsigned short nWorksheet, unsigned short nRow)
		{
			for (int i = 0; i < m_pTokenVector->GetSize(); i++)
				m_pTokenVector->Get(i)->DeleteRow(nWorksheet, nRow);
		}

		bool Formula::ValidateForChart(WorksheetImplementation* pWorksheetImplementation)
		{
			if (GetNumToken() == 1)
			{
				const Token* pToken = GetTokenByIndex(0);
				if (pToken->GetType() == Token::Type::TYPE_AREA_3D)
				{
					Area3d* pArea3d = ((Area3dToken*)(pToken))->GetArea3d()->CreateClone();
					pArea3d->m_pArea->m_pTopLeft->m_bXRelative = false;
					pArea3d->m_pArea->m_pTopLeft->m_bYRelative = false;
					pArea3d->m_pArea->m_pBottomRight->m_bXRelative = false;
					pArea3d->m_pArea->m_pBottomRight->m_bYRelative = false;
					m_pTokenVector->Erase(0);
					{
						NumberDuck::Secret::Area3d* __2738670685 = pArea3d;
						pArea3d = 0;
						m_pTokenVector->Insert(0, new Area3dToken(__2738670685));
					}
					if (pArea3d) delete pArea3d;
				}
				else if (pToken->GetType() == Token::Type::TYPE_AREA)
				{
					unsigned short nWorksheet = 0;
					Workbook* pWorkbook = pWorksheetImplementation->GetWorkbook();
					for (unsigned short i = 0; i < pWorkbook->GetNumWorksheet(); i++)
					{
						if (pWorkbook->GetWorksheetByIndex(i)->m_pImpl == pWorksheetImplementation)
						{
							nWorksheet = i;
							break;
						}
					}
					Area* pArea = ((AreaToken*)(pToken))->GetArea()->CreateClone();
					pArea->m_pTopLeft->m_bXRelative = false;
					pArea->m_pTopLeft->m_bYRelative = false;
					pArea->m_pBottomRight->m_bXRelative = false;
					pArea->m_pBottomRight->m_bYRelative = false;
					Area3d* pArea3d = 0;
					{
						NumberDuck::Secret::Area* __4245081970 = pArea;
						pArea = 0;
						pArea3d = new Area3d(nWorksheet, nWorksheet, __4245081970);
					}
					m_pTokenVector->Erase(0);
					{
						NumberDuck::Secret::Area3d* __2738670685 = pArea3d;
						pArea3d = 0;
						m_pTokenVector->Insert(0, new Area3dToken(__2738670685));
					}
					if (pArea) delete pArea;
					if (pArea3d) delete pArea3d;
				}
				return true;
			}
			return false;
		}

		const char* Formula::ToChartString(WorksheetImplementation* pWorksheetImplementation)
		{
			m_sTemp->Set("=");
			if (GetNumToken() == 1)
			{
				const Token* pToken = GetTokenByIndex(0);
				if (pToken->GetType() == Token::Type::TYPE_AREA_3D)
				{
					Area3d* pArea3d = ((Area3dToken*)(pToken))->GetArea3d()->CreateClone();
					pArea3d->m_pArea->m_pTopLeft->m_bXRelative = true;
					pArea3d->m_pArea->m_pTopLeft->m_bYRelative = true;
					pArea3d->m_pArea->m_pBottomRight->m_bXRelative = true;
					pArea3d->m_pArea->m_pBottomRight->m_bYRelative = true;
					pWorksheetImplementation->Area3dToAddress(pArea3d, m_sTemp);
					{
						delete pArea3d;
						pArea3d = 0;
					}
					if (pArea3d) delete pArea3d;
				}
			}
			return m_sTemp->GetExternalString();
		}

		bool Formula::ValidateForChartName(WorksheetImplementation* pWorksheetImplementation)
		{
			if (GetNumToken() == 1)
			{
				const Token* pToken = GetTokenByIndex(0);
				if (pToken->GetType() == Token::Type::TYPE_COORDINATE_3D)
				{
					Coordinate3d* pCoordinate3d = ((Coordinate3dToken*)(pToken))->GetCoordinate3d()->CreateClone();
					pCoordinate3d->m_pCoordinate->m_bXRelative = false;
					pCoordinate3d->m_pCoordinate->m_bYRelative = false;
					m_pTokenVector->Erase(0);
					{
						NumberDuck::Secret::Coordinate3d* __1094936853 = pCoordinate3d;
						pCoordinate3d = 0;
						m_pTokenVector->Insert(0, new Coordinate3dToken(__1094936853));
					}
					{
						if (pCoordinate3d) delete pCoordinate3d;
						return true;
					}
				}
				else if (pToken->GetType() == Token::Type::TYPE_COORDINATE)
				{
					unsigned short nWorksheet = 0;
					Workbook* pWorkbook = pWorksheetImplementation->GetWorkbook();
					for (unsigned short i = 0; i < pWorkbook->GetNumWorksheet(); i++)
					{
						if (pWorkbook->GetWorksheetByIndex(i)->m_pImpl == pWorksheetImplementation)
						{
							nWorksheet = i;
							break;
						}
					}
					Coordinate* pCoordinate = ((CoordinateToken*)(pToken))->GetCoordinate()->CreateClone();
					pCoordinate->m_bXRelative = false;
					pCoordinate->m_bYRelative = false;
					Coordinate3d* pCoordinate3d = 0;
					{
						NumberDuck::Secret::Coordinate* __3642692973 = pCoordinate;
						pCoordinate = 0;
						pCoordinate3d = new Coordinate3d(nWorksheet, nWorksheet, __3642692973);
					}
					m_pTokenVector->Erase(0);
					{
						NumberDuck::Secret::Coordinate3d* __1094936853 = pCoordinate3d;
						pCoordinate3d = 0;
						m_pTokenVector->Insert(0, new Coordinate3dToken(__1094936853));
					}
					{
						if (pCoordinate) delete pCoordinate;
						if (pCoordinate3d) delete pCoordinate3d;
						return true;
					}
				}
			}
			return false;
		}

		const char* Formula::ToChartNameString(WorksheetImplementation* pWorksheetImplementation)
		{
			m_sTemp->Set("=");
			if (GetNumToken() == 1)
			{
				const Token* pToken = GetTokenByIndex(0);
				if (pToken->GetType() == Token::Type::TYPE_COORDINATE_3D)
				{
					Coordinate3d* pCoordinate3d = ((Coordinate3dToken*)(pToken))->GetCoordinate3d()->CreateClone();
					pCoordinate3d->m_pCoordinate->m_bXRelative = true;
					pCoordinate3d->m_pCoordinate->m_bYRelative = true;
					pCoordinate3d->ToString(pWorksheetImplementation, m_sTemp);
					{
						delete pCoordinate3d;
						pCoordinate3d = 0;
					}
					if (pCoordinate3d) delete pCoordinate3d;
				}
			}
			return m_sTemp->GetExternalString();
		}

		unsigned char Formula::Parse(InternalString* sFormula, WorksheetImplementation* pWorksheetImplementation)
		{
			if (sFormula->GetLength() == 0)
				return 0;
			{
				ParseSpaceData* pParseSpaceData = new ParseSpaceData();
				while (ParseSpace(sFormula, pParseSpaceData))
				{
					SpaceToken::SpaceType eSpaceType = SpaceToken::SpaceType::TYPE_SPACE_BEFORE_BASE_EXPRESSION;
					if (pParseSpaceData->m_cChar == '\n')
						eSpaceType = SpaceToken::SpaceType::TYPE_RETURN_BEFORE_BASE_EXPRESSION;
					m_pTokenVector->PushBack(new SpaceToken(eSpaceType, (unsigned char)(pParseSpaceData->m_nCount)));
				}
				int nIndex = pParseSpaceData->m_nIndex;
				if (nIndex > 0)
				{
					sFormula->CropFront(nIndex);
					{
						if (pParseSpaceData) delete pParseSpaceData;
						return Parse(sFormula, pWorksheetImplementation);
					}
				}
				if (pParseSpaceData) delete pParseSpaceData;
			}
			if (ParseBool(sFormula, pWorksheetImplementation))
				return 1;
			if (ParseInt(sFormula))
				return 1;
			if (ParseFloat(sFormula))
				return 1;
			ParseFunctionData* pParseFunctionData = new ParseFunctionData();
			if (ParseFunction(sFormula, "SUM", pParseFunctionData, pWorksheetImplementation))
			{
				m_pTokenVector->PushBack(new SumToken((unsigned char)(pParseFunctionData->m_nCount)));
				{
					if (pParseFunctionData) delete pParseFunctionData;
					return 1;
				}
			}
			for (int i = 0; i <= (int)(Token::Type::TYPE_FUNC_RTD); i++)
			{
				Token::Type e = (Token::Type)(i);
				if (ParseFunction(sFormula, Token::GetTypeName(e), pParseFunctionData, pWorksheetImplementation))
				{
					m_pTokenVector->PushBack(new Token(e, Token::SubType::SUB_TYPE_FUNCTION, (unsigned char)(pParseFunctionData->m_nCount)));
					{
						if (pParseFunctionData) delete pParseFunctionData;
						return 1;
					}
				}
			}
			if (ParseFunction(sFormula, "", pParseFunctionData, pWorksheetImplementation))
			{
				m_pTokenVector->PushBack(new Token(Token::Type::TYPE_PAREN, Token::SubType::SUB_TYPE_FUNCTION, (unsigned char)(pParseFunctionData->m_nCount)));
				{
					if (pParseFunctionData) delete pParseFunctionData;
					return 1;
				}
			}
			Coordinate* pCoordinate = WorksheetImplementation::AddressToCoordinate(sFormula->GetExternalString());
			if (pCoordinate != 0)
			{
				{
					NumberDuck::Secret::Coordinate* __3642692973 = pCoordinate;
					pCoordinate = 0;
					m_pTokenVector->PushBack(new CoordinateToken(__3642692973));
				}
				{
					if (pParseFunctionData) delete pParseFunctionData;
					if (pCoordinate) delete pCoordinate;
					return 1;
				}
			}
			Area* pArea = WorksheetImplementation::AddressToArea(sFormula->GetExternalString());
			if (pArea != 0)
			{
				{
					NumberDuck::Secret::Area* __4245081970 = pArea;
					pArea = 0;
					m_pTokenVector->PushBack(new AreaToken(__4245081970));
				}
				{
					if (pParseFunctionData) delete pParseFunctionData;
					if (pCoordinate) delete pCoordinate;
					if (pArea) delete pArea;
					return 1;
				}
			}
			Coordinate3d* pCoordinate3d = pWorksheetImplementation->ParseCoordinate3d(sFormula);
			if (pCoordinate3d != 0)
			{
				{
					NumberDuck::Secret::Coordinate3d* __1094936853 = pCoordinate3d;
					pCoordinate3d = 0;
					m_pTokenVector->PushBack(new Coordinate3dToken(__1094936853));
				}
				{
					if (pParseFunctionData) delete pParseFunctionData;
					if (pCoordinate) delete pCoordinate;
					if (pArea) delete pArea;
					if (pCoordinate3d) delete pCoordinate3d;
					return 1;
				}
			}
			Area3d* pArea3d = pWorksheetImplementation->ParseArea3d(sFormula);
			if (pArea3d != 0)
			{
				{
					NumberDuck::Secret::Area3d* __2738670685 = pArea3d;
					pArea3d = 0;
					m_pTokenVector->PushBack(new Area3dToken(__2738670685));
				}
				{
					if (pParseFunctionData) delete pParseFunctionData;
					if (pCoordinate) delete pCoordinate;
					if (pArea) delete pArea;
					if (pCoordinate3d) delete pCoordinate3d;
					if (pArea3d) delete pArea3d;
					return 1;
				}
			}
			if (ParseString(sFormula))
			{
				InternalString* sTemp = new InternalString("");
				for (int i = 1; i < sFormula->GetLength() - 1; i++)
				{
					unsigned short nChar = sFormula->GetChar(i);
					sTemp->AppendChar(nChar);
					if (nChar == '"')
						i++;
				}
				m_pTokenVector->PushBack(new StringToken(sTemp->GetExternalString()));
				{
					if (sTemp) delete sTemp;
					if (pParseFunctionData) delete pParseFunctionData;
					if (pCoordinate) delete pCoordinate;
					if (pArea) delete pArea;
					if (pCoordinate3d) delete pCoordinate3d;
					if (pArea3d) delete pArea3d;
					return 1;
				}
			}
			InternalString* sToken = new InternalString("");
			InternalString* sOperator = new InternalString("");
			InternalString* sTrailingSpaces = new InternalString("");
			InternalString* sNextOperator = new InternalString("");
			InternalString* sLastOperator = new InternalString("");
			InternalString* sLastTrailingSpaces = new InternalString("");
			int nCount = 0;
			unsigned short nQuoteDepth = 0;
			unsigned short nParenDepth = 0;
			for (int i = 0; i < sFormula->GetLength(); i++)
			{
				unsigned short nChar = sFormula->GetChar(i);
				if (nChar == '"')
				{
					if (nQuoteDepth == 1)
					{
						if (i < sFormula->GetLength() - 1 && sFormula->GetChar(i + 1) == '"')
							nQuoteDepth++;
						else
							nQuoteDepth--;
					}
					else if (nQuoteDepth == 2)
					{
						nQuoteDepth--;
					}
					else
						nQuoteDepth++;
				}
				if (nQuoteDepth == 0)
				{
					if (nChar == '(')
						nParenDepth++;
					if (nChar == ')')
						if (nParenDepth == 0)
						{
							{
								if (pParseFunctionData) delete pParseFunctionData;
								if (pCoordinate) delete pCoordinate;
								if (pArea) delete pArea;
								if (pCoordinate3d) delete pCoordinate3d;
								if (pArea3d) delete pArea3d;
								if (sToken) delete sToken;
								if (sOperator) delete sOperator;
								if (sTrailingSpaces) delete sTrailingSpaces;
								if (sNextOperator) delete sNextOperator;
								if (sLastOperator) delete sLastOperator;
								if (sLastTrailingSpaces) delete sLastTrailingSpaces;
								return 0;
							}
						}
						else
							nParenDepth--;
				}
				sNextOperator->Set("");
				if (nChar == '<' && i + 1 < sFormula->GetLength() && sFormula->GetChar(i + 1) == '>')
					sNextOperator->Set("<>");
				else if (nChar == '<' && i + 1 < sFormula->GetLength() && sFormula->GetChar(i + 1) == '=')
					sNextOperator->Set("<=");
				else if (nChar == '>' && i + 1 < sFormula->GetLength() && sFormula->GetChar(i + 1) == '=')
					sNextOperator->Set(">=");
				else if (nChar == '+' || nChar == '-' || nChar == '*' || nChar == '/' || nChar == '<' || nChar == '>' || nChar == '^' || nChar == '&' || nChar == '=')
					sNextOperator->AppendChar(nChar);
				if (nQuoteDepth == 0 && nParenDepth == 0 && (nChar == ',' || sNextOperator->GetLength() > 0))
				{
					sLastOperator->Set(sOperator->GetExternalString());
					sLastTrailingSpaces->Set(sTrailingSpaces->GetExternalString());
					int nIndex = sToken->GetLength();
					while (nIndex > 0 && (sToken->GetChar(nIndex - 1) == ' ' || sToken->GetChar(nIndex - 1) == '\n'))
					{
						sTrailingSpaces->PrependChar(sToken->GetChar(nIndex - 1));
						nIndex--;
					}
					sToken->SubStr(0, nIndex);
					if (sToken->GetLength() > 0)
					{
						sOperator->Set(sNextOperator->GetExternalString());
						nCount = nCount + Parse(sToken, pWorksheetImplementation);
						sToken->Set("");
					}
					if (sLastOperator->GetLength() > 0 && nCount >= 2)
					{
						InsertOperator(sLastOperator, sLastTrailingSpaces);
						nCount--;
					}
				}
				else
				{
					sToken->AppendChar(nChar);
				}
			}
			if (!ExternalString::Equal(sToken->GetExternalString(), sFormula->GetExternalString()))
				nCount = nCount + Parse(sToken, pWorksheetImplementation);
			if (sOperator->GetLength() > 0 && nCount >= 2)
			{
				InsertOperator(sOperator, sTrailingSpaces);
				nCount--;
			}
			{
				if (pParseFunctionData) delete pParseFunctionData;
				if (pCoordinate) delete pCoordinate;
				if (pArea) delete pArea;
				if (pCoordinate3d) delete pCoordinate3d;
				if (pArea3d) delete pArea3d;
				if (sToken) delete sToken;
				if (sOperator) delete sOperator;
				if (sTrailingSpaces) delete sTrailingSpaces;
				if (sNextOperator) delete sNextOperator;
				if (sLastOperator) delete sLastOperator;
				if (sLastTrailingSpaces) delete sLastTrailingSpaces;
				return (unsigned char)(nCount);
			}
		}

		bool Formula::ParseFunction(InternalString* sFormula, const char* szFunction, ParseFunctionData* pData, WorksheetImplementation* pWorksheetImplementation)
		{
			InternalString* sTemp = new InternalString(szFunction);
			sTemp->AppendChar('(');
			int nFunctionLength = sTemp->GetLength();
			bool bStartsWith = sFormula->StartsWith(sTemp->GetExternalString());
			bool bEndsWith = sFormula->EndsWith(")");
			{
				delete sTemp;
				sTemp = 0;
			}
			if (bStartsWith && bEndsWith)
			{
				unsigned short nQuoteDepth = 0;
				unsigned short nParenDepth = 0;
				for (int i = nFunctionLength; i < sFormula->GetLength() - 1; i++)
				{
					if (sFormula->GetChar(i) == '"')
					{
						if (nQuoteDepth == 1)
						{
							if (i < sFormula->GetLength() - 1 && sFormula->GetChar(i + 1) == '"')
								i++;
							else
								nQuoteDepth--;
						}
						else
							nQuoteDepth++;
					}
					if (nQuoteDepth == 0)
					{
						if (sFormula->GetChar(i) == '(')
							nParenDepth++;
						if (sFormula->GetChar(i) == ')')
							if (nParenDepth == 0)
							{
								if (sTemp) delete sTemp;
								return false;
							}
							else
								nParenDepth--;
					}
				}
				if (nQuoteDepth == 0 && nParenDepth == 0)
				{
					ParseSpaceData* pParseSpaceData = new ParseSpaceData();
					pParseSpaceData->m_nIndex = (int)(sFormula->GetLength() - 1);
					while (true)
					{
						if (pParseSpaceData->m_nIndex <= 0)
							break;
						unsigned short nChar = sFormula->GetChar(pParseSpaceData->m_nIndex - 1);
						if (nChar != ' ' && nChar != '\n')
							break;
						pParseSpaceData->m_nIndex--;
					}
					int nSpaceStart = pParseSpaceData->m_nIndex;
					InternalString* sCount = new InternalString(sFormula->GetExternalString());
					sCount->SubStr(nFunctionLength, nSpaceStart - nFunctionLength);
					pData->m_nCount = Parse(sCount, pWorksheetImplementation);
					{
						delete sCount;
						sCount = 0;
					}
					while (ParseSpace(sFormula, pParseSpaceData))
					{
						SpaceToken::SpaceType eSpaceType = SpaceToken::SpaceType::TYPE_SPACE_BEFORE_CLOSE;
						if (pParseSpaceData->m_cChar == '\n')
							eSpaceType = SpaceToken::SpaceType::TYPE_RETURN_BEFORE_CLOSE;
						m_pTokenVector->PushBack(new SpaceToken(eSpaceType, (unsigned char)(pParseSpaceData->m_nCount)));
					}
					{
						if (pParseSpaceData) delete pParseSpaceData;
						if (sCount) delete sCount;
						if (sTemp) delete sTemp;
						return true;
					}
				}
			}
			{
				if (sTemp) delete sTemp;
				return false;
			}
		}

		bool Formula::ParseSpace(InternalString* sFormula, ParseSpaceData* pData)
		{
			pData->m_nCount = 0;
			while (pData->m_nIndex < sFormula->GetLength() && sFormula->GetChar(pData->m_nIndex) == ' ')
			{
				pData->m_cChar = ' ';
				pData->m_nIndex++;
				pData->m_nCount++;
			}
			if (pData->m_nCount > 0)
				return true;
			while (pData->m_nIndex < sFormula->GetLength() && sFormula->GetChar(pData->m_nIndex) == '\n')
			{
				pData->m_cChar = '\n';
				pData->m_nIndex++;
				pData->m_nCount++;
			}
			if (pData->m_nCount > 0)
				return true;
			return false;
		}

		bool Formula::ParseString(InternalString* sFormula)
		{
			int nLength = sFormula->GetLength();
			if (nLength >= 2)
				if (sFormula->GetChar(0) == '"' && sFormula->GetChar(nLength - 1) == '"')
				{
					for (int i = 1; i < nLength - 1; i++)
					{
						if (sFormula->GetChar(i) == '"')
							if (i < nLength - 2 && sFormula->GetChar(i + 1) == '"')
								i++;
							else
								return false;
					}
					return true;
				}
			return false;
		}

		bool Formula::ParseBool(InternalString* sFormula, WorksheetImplementation* pWorksheetImplementation)
		{
			ParseFunctionData* pParseFunctionData = new ParseFunctionData();
			Token* pToken = 0;
			if (sFormula->IsEqual("FALSE"))
				pToken = new BoolToken(false, false);
			else if (sFormula->IsEqual("TRUE"))
				pToken = new BoolToken(true, false);
			else if (ParseFunction(sFormula, "FALSE", pParseFunctionData, pWorksheetImplementation))
				pToken = new BoolToken(false, true);
			else if (ParseFunction(sFormula, "TRUE", pParseFunctionData, pWorksheetImplementation))
				pToken = new BoolToken(true, true);
			if (pToken != 0)
			{
				{
					NumberDuck::Secret::Token* __2538616708 = pToken;
					pToken = 0;
					m_pTokenVector->PushBack(__2538616708);
				}
				{
					if (pParseFunctionData) delete pParseFunctionData;
					if (pToken) delete pToken;
					return true;
				}
			}
			{
				if (pParseFunctionData) delete pParseFunctionData;
				if (pToken) delete pToken;
				return false;
			}
		}

		bool Formula::ParseInt(InternalString* sFormula)
		{
			unsigned short nInt = 0;
			unsigned short nMultiplier = 1;
			for (int i = 0; i < sFormula->GetLength(); i++)
			{
				int nIndex = sFormula->GetLength() - 1 - i;
				unsigned short nChar = sFormula->GetChar(nIndex);
				if (nChar < '0' || nChar > '9')
					return false;
				nInt = (unsigned short)(nInt + (nChar - '0') * nMultiplier);
				nMultiplier = (unsigned short)(nMultiplier * 10);
			}
			m_pTokenVector->PushBack(new IntToken(nInt));
			return true;
		}

		bool Formula::ParseFloat(InternalString* sFormula)
		{
			bool bNumber = false;
			bool bDecimalPoint = false;
			for (int i = 0; i < sFormula->GetLength(); i++)
			{
				unsigned short nChar = sFormula->GetChar(i);
				if (nChar == '-' && i == 0)
					continue;
				if (nChar >= '0' && nChar <= '9')
				{
					bNumber = true;
					continue;
				}
				if (nChar == '.' && bNumber && !bDecimalPoint)
				{
					bDecimalPoint = true;
					continue;
				}
				return false;
			}
			double fTemp = sFormula->ParseDouble();
			m_pTokenVector->PushBack(new NumToken(fTemp));
			return true;
		}

		void Formula::InsertOperator(InternalString* sOperator, InternalString* sTrailingSpaces)
		{
			ParseSpaceData* pParseSpaceData = new ParseSpaceData();
			while (ParseSpace(sTrailingSpaces, pParseSpaceData))
			{
				SpaceToken::SpaceType eSpaceType = SpaceToken::SpaceType::TYPE_SPACE_BEFORE_BASE_EXPRESSION;
				if (pParseSpaceData->m_cChar == '\n')
					eSpaceType = SpaceToken::SpaceType::TYPE_RETURN_BEFORE_BASE_EXPRESSION;
				m_pTokenVector->PushBack(new SpaceToken(eSpaceType, (unsigned char)(pParseSpaceData->m_nCount)));
			}
			m_pTokenVector->PushBack(new OperatorToken(sOperator->GetExternalString()));
			if (pParseSpaceData) delete pParseSpaceData;
		}

		Formula::~Formula()
		{
			if (m_pTokenVector) delete m_pTokenVector;
			if (m_pValue) delete m_pValue;
			if (m_sTemp) delete m_sTemp;
		}

		CoordinateToken::CoordinateToken(Coordinate* pCoordinate) : Token(Type::TYPE_COORDINATE, SubType::SUB_TYPE_VARIABLE, 0)
		{
			m_pCoordinate = 0;
			m_pCoordinate = pCoordinate;
		}

		Coordinate* CoordinateToken::GetCoordinate()
		{
			return m_pCoordinate;
		}

		void CoordinateToken::ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut)
		{
			WorksheetImplementation::CoordinateToAddress(m_pCoordinate, sOut);
		}

		ParsedExpressionRecord* CoordinateToken::ToParsedExpression(WorkbookGlobals* pWorkbookGlobals)
		{
			return new PtgRefRecord(m_pCoordinate);
		}

		bool CoordinateToken::Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth)
		{
			Cell* pCell = pWorksheetImplementation->m_pWorksheet->GetCell(m_pCoordinate->m_nX, m_pCoordinate->m_nY);
			const Value* pValue = pCell->GetValue();
			ppValueVector->PushBack(ValueImplementation::CopyValue(pValue));
			return true;
		}

		CoordinateToken::~CoordinateToken()
		{
			if (m_pCoordinate) delete m_pCoordinate;
		}

		Coordinate3dToken::Coordinate3dToken(Coordinate3d* pCoordinate3d) : Token(Type::TYPE_COORDINATE_3D, SubType::SUB_TYPE_VARIABLE, 0)
		{
			m_pCoordinate3d = 0;
			m_pCoordinate3d = pCoordinate3d;
		}

		Coordinate3d* Coordinate3dToken::GetCoordinate3d()
		{
			return m_pCoordinate3d;
		}

		void Coordinate3dToken::ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut)
		{
			m_pCoordinate3d->ToString(pWorksheetImplementation, sOut);
		}

		ParsedExpressionRecord* Coordinate3dToken::ToParsedExpression(WorkbookGlobals* pWorkbookGlobals)
		{
			return new PtgRef3dRecord(m_pCoordinate3d, pWorkbookGlobals);
		}

		bool Coordinate3dToken::Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth)
		{
			if (m_pCoordinate3d->m_nWorksheetFirst == m_pCoordinate3d->m_nWorksheetLast)
			{
				Cell* pCell = pWorksheetImplementation->GetWorkbook()->GetWorksheetByIndex(m_pCoordinate3d->m_nWorksheetFirst)->GetCell(m_pCoordinate3d->m_pCoordinate->m_nX, m_pCoordinate3d->m_pCoordinate->m_nY);
				const Value* pValue = pCell->GetValue();
				ppValueVector->PushBack(ValueImplementation::CopyValue(pValue));
			}
			else
			{
				Area* pArea = 0;
				pArea = new Area(m_pCoordinate3d->m_pCoordinate->CreateClone(), m_pCoordinate3d->m_pCoordinate->CreateClone());
				Area3d* pArea3d = 0;
				{
					NumberDuck::Secret::Area* __4245081970 = pArea;
					pArea = 0;
					pArea3d = new Area3d(m_pCoordinate3d->m_nWorksheetFirst, m_pCoordinate3d->m_nWorksheetLast, __4245081970);
				}
				{
					NumberDuck::Secret::Area3d* __2738670685 = pArea3d;
					pArea3d = 0;
					ppValueVector->PushBack(ValueImplementation::CreateArea3dValue(__2738670685));
				}
				if (pArea) delete pArea;
				if (pArea3d) delete pArea3d;
			}
			return true;
		}

		void Coordinate3dToken::InsertColumn(unsigned short nWorksheet, unsigned short nColumn)
		{
			if (nWorksheet == m_pCoordinate3d->m_nWorksheetLast && nWorksheet == m_pCoordinate3d->m_nWorksheetFirst)
			{
				if (m_pCoordinate3d->m_pCoordinate->m_nX >= nColumn && m_pCoordinate3d->m_pCoordinate->m_nX < Worksheet::MAX_COLUMN)
					m_pCoordinate3d->m_pCoordinate->m_nX++;
			}
		}

		void Coordinate3dToken::DeleteColumn(unsigned short nWorksheet, unsigned short nColumn)
		{
			if (nWorksheet == m_pCoordinate3d->m_nWorksheetLast && nWorksheet == m_pCoordinate3d->m_nWorksheetFirst)
			{
				if (m_pCoordinate3d->m_pCoordinate->m_nX > nColumn)
					m_pCoordinate3d->m_pCoordinate->m_nX--;
			}
		}

		void Coordinate3dToken::InsertRow(unsigned short nWorksheet, unsigned short nRow)
		{
			if (nWorksheet == m_pCoordinate3d->m_nWorksheetLast && nWorksheet == m_pCoordinate3d->m_nWorksheetFirst)
			{
				if (m_pCoordinate3d->m_pCoordinate->m_nY >= nRow && m_pCoordinate3d->m_pCoordinate->m_nY < Worksheet::MAX_ROW)
					m_pCoordinate3d->m_pCoordinate->m_nY++;
			}
		}

		void Coordinate3dToken::DeleteRow(unsigned short nWorksheet, unsigned short nRow)
		{
			if (nWorksheet == m_pCoordinate3d->m_nWorksheetLast && nWorksheet == m_pCoordinate3d->m_nWorksheetFirst)
			{
				if (m_pCoordinate3d->m_pCoordinate->m_nY > nRow)
					m_pCoordinate3d->m_pCoordinate->m_nY--;
			}
		}

		Coordinate3dToken::~Coordinate3dToken()
		{
			if (m_pCoordinate3d) delete m_pCoordinate3d;
		}

		BoolToken::BoolToken(bool bBool, bool bFunction) : Token(Type::TYPE_BOOL, bFunction ? SubType::SUB_TYPE_FUNCTION : SubType::SUB_TYPE_VARIABLE, 0)
		{
			m_bBool = false;
			m_bBool = bBool;
		}

		void BoolToken::ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut)
		{
			sOut->AppendString(m_bBool ? "TRUE" : "FALSE");
		}

		ParsedExpressionRecord* BoolToken::ToParsedExpression(WorkbookGlobals* pWorkbookGlobals)
		{
			if (m_eSubType == SubType::SUB_TYPE_FUNCTION)
				if (m_bBool)
					return new PtgFuncVarRecord((unsigned short)(Token::Type::TYPE_FUNC_TRUE), m_nParameterCount);
				else
					return new PtgFuncVarRecord((unsigned short)(Token::Type::TYPE_FUNC_FALSE), m_nParameterCount);
			return new PtgBoolRecord(m_bBool);
		}

		bool BoolToken::Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth)
		{
			ppValueVector->PushBack(ValueImplementation::CreateBooleanValue(m_bBool));
			return true;
		}

		AreaToken::AreaToken(Area* pArea) : Token(Type::TYPE_AREA, SubType::SUB_TYPE_VARIABLE, 0)
		{
			m_pArea = 0;
			m_pArea = pArea;
		}

		Area* AreaToken::GetArea()
		{
			return m_pArea;
		}

		void AreaToken::ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut)
		{
			WorksheetImplementation::AreaToAddress(m_pArea, sOut);
		}

		ParsedExpressionRecord* AreaToken::ToParsedExpression(WorkbookGlobals* pWorkbookGlobals)
		{
			return new PtgAreaRecord(m_pArea);
		}

		bool AreaToken::Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth)
		{
			ppValueVector->PushBack(ValueImplementation::CreateAreaValue(m_pArea->CreateClone()));
			return true;
		}

		AreaToken::~AreaToken()
		{
			if (m_pArea) delete m_pArea;
		}

		Area3dToken::Area3dToken(Area3d* pArea3d) : Token(Type::TYPE_AREA_3D, SubType::SUB_TYPE_VARIABLE, 0)
		{
			m_pArea3d = 0;
			m_pArea3d = pArea3d;
		}

		Area3d* Area3dToken::GetArea3d()
		{
			return m_pArea3d;
		}

		void Area3dToken::ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut)
		{
			pWorksheetImplementation->Area3dToAddress(m_pArea3d, sOut);
		}

		ParsedExpressionRecord* Area3dToken::ToParsedExpression(WorkbookGlobals* pWorkbookGlobals)
		{
			return new PtgArea3dRecord(m_pArea3d, pWorkbookGlobals);
		}

		bool Area3dToken::Evaluate(WorksheetImplementation* pWorksheetImplementation, OwnedVector<Value*>* ppValueVector, unsigned short nDepth)
		{
			ppValueVector->PushBack(ValueImplementation::CreateArea3dValue(m_pArea3d->CreateClone()));
			return true;
		}

		void Area3dToken::InsertColumn(unsigned short nWorksheet, unsigned short nColumn)
		{
			if (nWorksheet == m_pArea3d->m_pWorksheetRange->m_nLast && nWorksheet == m_pArea3d->m_pWorksheetRange->m_nFirst)
			{
				if (m_pArea3d->m_pArea->m_pTopLeft->m_nX >= nColumn && m_pArea3d->m_pArea->m_pTopLeft->m_nX < Worksheet::MAX_COLUMN)
					m_pArea3d->m_pArea->m_pTopLeft->m_nX++;
				if (m_pArea3d->m_pArea->m_pBottomRight->m_nX >= nColumn && m_pArea3d->m_pArea->m_pTopLeft->m_nX < Worksheet::MAX_COLUMN)
					m_pArea3d->m_pArea->m_pBottomRight->m_nX++;
			}
		}

		void Area3dToken::DeleteColumn(unsigned short nWorksheet, unsigned short nColumn)
		{
			if (nWorksheet == m_pArea3d->m_pWorksheetRange->m_nLast && nWorksheet == m_pArea3d->m_pWorksheetRange->m_nFirst)
			{
				if (m_pArea3d->m_pArea->m_pTopLeft->m_nX > nColumn)
					m_pArea3d->m_pArea->m_pTopLeft->m_nX--;
				if (m_pArea3d->m_pArea->m_pBottomRight->m_nX > nColumn)
					m_pArea3d->m_pArea->m_pBottomRight->m_nX--;
			}
		}

		void Area3dToken::InsertRow(unsigned short nWorksheet, unsigned short nRow)
		{
			if (nWorksheet == m_pArea3d->m_pWorksheetRange->m_nLast && nWorksheet == m_pArea3d->m_pWorksheetRange->m_nFirst)
			{
				if (m_pArea3d->m_pArea->m_pTopLeft->m_nY >= nRow && m_pArea3d->m_pArea->m_pTopLeft->m_nY < Worksheet::MAX_ROW)
					m_pArea3d->m_pArea->m_pTopLeft->m_nY++;
				if (m_pArea3d->m_pArea->m_pBottomRight->m_nY >= nRow && m_pArea3d->m_pArea->m_pTopLeft->m_nY < Worksheet::MAX_ROW)
					m_pArea3d->m_pArea->m_pBottomRight->m_nY++;
			}
		}

		void Area3dToken::DeleteRow(unsigned short nWorksheet, unsigned short nRow)
		{
			if (nWorksheet == m_pArea3d->m_pWorksheetRange->m_nLast && nWorksheet == m_pArea3d->m_pWorksheetRange->m_nFirst)
			{
				if (m_pArea3d->m_pArea->m_pTopLeft->m_nY > nRow)
					m_pArea3d->m_pArea->m_pTopLeft->m_nY--;
				if (m_pArea3d->m_pArea->m_pBottomRight->m_nY > nRow)
					m_pArea3d->m_pArea->m_pBottomRight->m_nY--;
			}
		}

		Area3dToken::~Area3dToken()
		{
			if (m_pArea3d) delete m_pArea3d;
		}

		RedBlackNode::NodeColor RedBlackNode::GetColor() const
		{
			return NodeColor::COLOR_RED;
		}

		RedBlackNode* RedBlackNode::GetParent() const
		{
			return 0;
		}

		RedBlackNode* RedBlackNode::GetLeftChild() const
		{
			return 0;
		}

		RedBlackNode* RedBlackNode::GetRightChild() const
		{
			return 0;
		}

		RedBlackNode* RedBlackNode::GetChild(int nDirection) const
		{
			return 0;
		}

		void* RedBlackNode::GetStoredObject() const
		{
			return 0;
		}

		RedBlackNodeImplementation::RedBlackNodeImplementation(void* pObject)
		{
			m_eColor = NodeColor::COLOR_RED;
			m_pParent = 0;
			m_pObject = 0;
			m_eColor = RedBlackNode::NodeColor::COLOR_BLACK;
			m_pObject = pObject;
			m_pParent = 0;
			m_pChild[0] = 0;
			m_pChild[1] = 0;
		}

		RedBlackNodeImplementation* RedBlackNodeImplementation::GetUncle() const
		{
			RedBlackNodeImplementation* pGrandparent = GetGrandparent();
			if (pGrandparent != 0)
			{
				if (pGrandparent->m_pChild[0] == m_pParent)
					return pGrandparent->m_pChild[1];
				else
					return pGrandparent->m_pChild[0];
			}
			return 0;
		}

		RedBlackNodeImplementation* RedBlackNodeImplementation::GetGrandparent() const
		{
			if (m_pParent != 0)
				return m_pParent->m_pParent;
			return 0;
		}

		RedBlackNode::NodeColor RedBlackNodeImplementation::GetColor() const
		{
			return m_eColor;
		}

		RedBlackNode* RedBlackNodeImplementation::GetParent() const
		{
			return m_pParent;
		}

		RedBlackNode* RedBlackNodeImplementation::GetLeftChild() const
		{
			return m_pChild[0];
		}

		RedBlackNode* RedBlackNodeImplementation::GetRightChild() const
		{
			return m_pChild[1];
		}

		RedBlackNode* RedBlackNodeImplementation::GetChild(int nDirection) const
		{
			return m_pChild[nDirection];
		}

		void* RedBlackNodeImplementation::GetStoredObject() const
		{
			return m_pObject;
		}

		RedBlackNodeImplementation::~RedBlackNodeImplementation()
		{
			for (int _x = 0; _x < 2; _x++) if (m_pChild[_x]) delete m_pChild[_x];
		}

		RedBlackTree::RedBlackTree(ComparisonCallback* pComparisonCallback)
		{
			m_pImpl = 0;
			nbAssert::Assert(pComparisonCallback != 0);
			m_pImpl = new RedBlackTreeImplementation();
			m_pImpl->m_pComparisonCallback = pComparisonCallback;
			m_pImpl->m_pRootNode = 0;
		}

		RedBlackTree::~RedBlackTree()
		{
			{
				NumberDuck::Secret::RedBlackNodeImplementation* __608107594 = m_pImpl->m_pRootNode;
				m_pImpl->m_pRootNode = 0;
				m_pImpl->RecursiveDelete(__608107594);
			}
			{
				delete m_pImpl;
				m_pImpl = 0;
			}
			if (m_pImpl) delete m_pImpl;
		}

		bool RedBlackTree::AddObject(void* pObject)
		{
			if (pObject == 0)
				return false;
			RedBlackNodeImplementation* pNewNode = new RedBlackNodeImplementation(pObject);
			if (m_pImpl->m_pRootNode == 0)
			{
				{
					NumberDuck::Secret::RedBlackNodeImplementation* __615123591 = pNewNode;
					pNewNode = 0;
					m_pImpl->m_pRootNode = __615123591;
				}
				{
					if (pNewNode) delete pNewNode;
					return true;
				}
			}
			pNewNode->m_eColor = RedBlackNode::NodeColor::COLOR_RED;
			RedBlackNodeImplementation* pNode = m_pImpl->m_pRootNode;
			while (true)
			{
				int nComparison = m_pImpl->m_pComparisonCallback(pNode->GetStoredObject(), pObject);
				nbAssert::Assert(nComparison >= -1);
				nbAssert::Assert(nComparison <= 1);
				if (nComparison == 0)
				{
					if (pNewNode) delete pNewNode;
					return false;
				}
				int nDirection = 0;
				if (nComparison > 0)
					nDirection = nComparison;
				if (pNode->m_pChild[nDirection] == 0)
				{
					RedBlackNodeImplementation* pTempNode = pNewNode;
					{
						NumberDuck::Secret::RedBlackNodeImplementation* __615123591 = pNewNode;
						pNewNode = 0;
						pNode->m_pChild[nDirection] = __615123591;
					}
					pTempNode->m_pParent = pNode;
					while (true)
					{
						if (pTempNode->m_pParent == 0)
						{
							pTempNode->m_eColor = RedBlackNode::NodeColor::COLOR_BLACK;
							{
								if (pNewNode) delete pNewNode;
								return true;
							}
						}
						if (pTempNode->m_pParent->m_eColor == RedBlackNode::NodeColor::COLOR_BLACK)
						{
							{
								if (pNewNode) delete pNewNode;
								return true;
							}
						}
						RedBlackNodeImplementation* pUncle = pTempNode->GetUncle();
						if (pUncle != 0 && pUncle->m_eColor == RedBlackNode::NodeColor::COLOR_RED)
						{
							pTempNode->m_pParent->m_eColor = RedBlackNode::NodeColor::COLOR_BLACK;
							pUncle->m_eColor = RedBlackNode::NodeColor::COLOR_BLACK;
							pTempNode = pTempNode->GetGrandparent();
							pTempNode->m_eColor = RedBlackNode::NodeColor::COLOR_RED;
							continue;
						}
						RedBlackNodeImplementation* pGrandparent = pTempNode->GetGrandparent();
						if ((pTempNode == pTempNode->m_pParent->m_pChild[1]) && (pTempNode->m_pParent == pGrandparent->m_pChild[0]))
						{
							m_pImpl->Rotate(pTempNode->m_pParent, 0);
							pTempNode = pTempNode->m_pChild[0];
						}
						else if ((pTempNode == pTempNode->m_pParent->m_pChild[0]) && (pTempNode->m_pParent == pGrandparent->m_pChild[1]))
						{
							m_pImpl->Rotate(pTempNode->m_pParent, 1);
							pTempNode = pTempNode->m_pChild[1];
						}
						pUncle = pTempNode->GetUncle();
						pGrandparent = pTempNode->GetGrandparent();
						pTempNode->m_pParent->m_eColor = RedBlackNode::NodeColor::COLOR_BLACK;
						pGrandparent->m_eColor = RedBlackNode::NodeColor::COLOR_RED;
						if (pTempNode == pTempNode->m_pParent->m_pChild[0])
							m_pImpl->Rotate(pGrandparent, 1);
						else
							m_pImpl->Rotate(pGrandparent, 0);
						{
							if (pNewNode) delete pNewNode;
							return true;
						}
					}
				}
				pNode = pNode->m_pChild[nDirection];
			}
			if (pNewNode) delete pNewNode;
		}

		bool RedBlackTree::DeleteObject(void* pObject)
		{
			nbAssert::Assert(false);
			return false;
		}

		RedBlackNode* RedBlackTree::GetRootNode()
		{
			return m_pImpl->m_pRootNode;
		}

		RedBlackNode* RedBlackTree::GetNode(void* pObject)
		{
			if (pObject == 0)
				return 0;
			RedBlackNodeImplementation* pNode = m_pImpl->m_pRootNode;
			while (pNode != 0)
			{
				int nComparison = m_pImpl->m_pComparisonCallback(pNode->GetStoredObject(), pObject);
				nbAssert::Assert(nComparison >= -1);
				nbAssert::Assert(nComparison <= 1);
				if (nComparison == 0)
					return pNode;
				int nDirection = 0;
				if (nComparison > 0)
					nDirection = nComparison;
				pNode = pNode->m_pChild[nDirection];
			}
			return 0;
		}

		void RedBlackTreeImplementation::RecursiveDelete(RedBlackNodeImplementation* pNode)
		{
			RedBlackNodeImplementation* pTempNode = pNode;
			if (pTempNode != 0)
			{
				{
					NumberDuck::Secret::RedBlackNodeImplementation* __3820686225 = pTempNode->m_pChild[0];
					pTempNode->m_pChild[0] = 0;
					RecursiveDelete(__3820686225);
				}
				pTempNode->m_pChild[0] = 0;
				{
					NumberDuck::Secret::RedBlackNodeImplementation* __3065717485 = pTempNode->m_pChild[1];
					pTempNode->m_pChild[1] = 0;
					RecursiveDelete(__3065717485);
				}
				pTempNode->m_pChild[1] = 0;
				{
					delete pTempNode;
					pTempNode = 0;
				}
			}
			if (pTempNode) delete pTempNode;
		}

		void RedBlackTreeImplementation::Rotate(RedBlackNodeImplementation* pNode, int nDirection)
		{
			int nOpposite = 1;
			if (nDirection > 0)
				nOpposite = 0;
			nbAssert::Assert(pNode->m_pChild[nOpposite] != 0);
			RedBlackNodeImplementation* pChild = 0;
			{
				NumberDuck::Secret::RedBlackNodeImplementation* __474790283 = pNode->m_pChild[nOpposite];
				pNode->m_pChild[nOpposite] = 0;
				pChild = __474790283;
			}
			{
				NumberDuck::Secret::RedBlackNodeImplementation* __2982843613 = pChild->m_pChild[nDirection];
				pChild->m_pChild[nDirection] = 0;
				pNode->m_pChild[nOpposite] = __2982843613;
			}
			if (pNode->m_pChild[nOpposite] != 0)
				pNode->m_pChild[nOpposite]->m_pParent = pNode;
			RedBlackNodeImplementation* pParent = pNode->m_pParent;
			pChild->m_pParent = pParent;
			pNode->m_pParent = pChild;
			if (pParent == 0)
			{
				nbAssert::Assert(pNode == m_pRootNode);
				{
					NumberDuck::Secret::RedBlackNodeImplementation* __1798688362 = m_pRootNode;
					m_pRootNode = 0;
					pChild->m_pChild[nDirection] = __1798688362;
				}
				{
					NumberDuck::Secret::RedBlackNodeImplementation* __4076228335 = pChild;
					pChild = 0;
					m_pRootNode = __4076228335;
				}
			}
			else
			{
				if (pParent->m_pChild[0] == pNode)
				{
					{
						NumberDuck::Secret::RedBlackNodeImplementation* __3633264354 = pParent->m_pChild[0];
						pParent->m_pChild[0] = 0;
						pChild->m_pChild[nDirection] = __3633264354;
					}
					{
						NumberDuck::Secret::RedBlackNodeImplementation* __4076228335 = pChild;
						pChild = 0;
						pParent->m_pChild[0] = __4076228335;
					}
				}
				else
				{
					{
						NumberDuck::Secret::RedBlackNodeImplementation* __2374967198 = pParent->m_pChild[1];
						pParent->m_pChild[1] = 0;
						pChild->m_pChild[nDirection] = __2374967198;
					}
					{
						NumberDuck::Secret::RedBlackNodeImplementation* __4076228335 = pChild;
						pChild = 0;
						pParent->m_pChild[1] = __4076228335;
					}
				}
			}
			if (pChild) delete pChild;
		}

		RedBlackTreeImplementation::RedBlackTreeImplementation()
		{
			m_pRootNode = 0;
			m_pComparisonCallback = 0;
		}

		RedBlackTreeImplementation::~RedBlackTreeImplementation()
		{
			if (m_pRootNode) delete m_pRootNode;
		}

																		PngImageInfo::PngImageInfo()
		{
			m_nWidth = 0;
			m_nHeight = 0;
		}

		PngImageInfo* PngLoader::Load(Blob* pBlob)
		{
			if (m_pImageInfo != 0)
				{
					delete m_pImageInfo;
					m_pImageInfo = 0;
				}
			BlobView* pBlobView = pBlob->GetBlobView();
			pBlobView->SetOffset(0);
			if (pBlob->GetSize() > 24)
			{
				if (pBlobView->UnpackUint8() == 0x89 && pBlobView->UnpackUint8() == 'P' && pBlobView->UnpackUint8() == 'N' && pBlobView->UnpackUint8() == 'G' && pBlobView->UnpackUint8() == 0x0D && pBlobView->UnpackUint8() == 0x0A && pBlobView->UnpackUint8() == 0x1A && pBlobView->UnpackUint8() == 0xA)
				{
					unsigned char n0;
					unsigned char n1;
					unsigned char n2;
					unsigned char n3;
					int nChunkSize;
					n0 = pBlobView->UnpackUint8();
					n1 = pBlobView->UnpackUint8();
					n2 = pBlobView->UnpackUint8();
					n3 = pBlobView->UnpackUint8();
					nChunkSize = (n0 << 24) | (n1 << 16) | (n2 << 8) | (n3 << 0);
					if (pBlobView->GetOffset() + nChunkSize < pBlobView->GetEnd() && pBlobView->UnpackUint8() == 'I' && pBlobView->UnpackUint8() == 'H' && pBlobView->UnpackUint8() == 'D' && pBlobView->UnpackUint8() == 'R')
					{
						m_pImageInfo = new PngImageInfo();
						n0 = pBlobView->UnpackUint8();
						n1 = pBlobView->UnpackUint8();
						n2 = pBlobView->UnpackUint8();
						n3 = pBlobView->UnpackUint8();
						m_pImageInfo->m_nWidth = ((int)(n0)) << 24 | ((int)(n1)) << 16 | ((int)(n2)) << 8 | ((int)(n3)) << 0;
						n0 = pBlobView->UnpackUint8();
						n1 = pBlobView->UnpackUint8();
						n2 = pBlobView->UnpackUint8();
						n3 = pBlobView->UnpackUint8();
						m_pImageInfo->m_nHeight = (n0 << 24) | (n1 << 16) | (n2 << 8) | (n3 << 0);
					}
				}
			}
			return m_pImageInfo;
		}

		PngLoader::PngLoader()
		{
			m_pImageInfo = 0;
		}

		PngLoader::~PngLoader()
		{
			if (m_pImageInfo) delete m_pImageInfo;
		}

		JpegImageInfo::JpegImageInfo()
		{
			m_nWidth = 0;
			m_nHeight = 0;
		}

		JpegImageInfo* JpegLoader::Load(Blob* pBlob)
		{
			if (m_pImageInfo != 0)
				{
					delete m_pImageInfo;
					m_pImageInfo = 0;
				}
			BlobView* pBlobView = pBlob->GetBlobView();
			pBlobView->SetOffset(0);
			if (pBlob->GetSize() > 2)
			{
				unsigned char cMarker;
				unsigned char cType;
				cMarker = pBlobView->UnpackUint8();
				cType = pBlobView->UnpackUint8();
				if (cMarker == 0xFF && cType == 0xD8)
				{
					while (pBlobView->GetOffset() < pBlobView->GetEnd())
					{
						int nStart;
						int nSize;
						int cSize0;
						int cSize1;
						if (pBlobView->GetOffset() + 4 > pBlobView->GetEnd())
							break;
						cMarker = pBlobView->UnpackUint8();
						cType = pBlobView->UnpackUint8();
						nStart = pBlobView->GetOffset();
						cSize0 = pBlobView->UnpackUint8();
						cSize1 = pBlobView->UnpackUint8();
						nSize = cSize0 << 8 | cSize1;
						if (cType == 0xC0 || cType == 0xC2)
						{
							if (pBlobView->GetOffset() + 5 > pBlobView->GetEnd())
								break;
							pBlobView->UnpackUint8();
							unsigned char nHeight0 = pBlobView->UnpackUint8();
							unsigned char nHeight1 = pBlobView->UnpackUint8();
							unsigned char nWidth0 = pBlobView->UnpackUint8();
							unsigned char nWidth1 = pBlobView->UnpackUint8();
							m_pImageInfo = new JpegImageInfo();
							m_pImageInfo->m_nHeight = (int)(((unsigned int)(nHeight0)) << 8 | ((unsigned int)(nHeight1)));
							m_pImageInfo->m_nWidth = (int)(((unsigned int)(nWidth0)) << 8 | ((unsigned int)(nWidth1)));
							break;
						}
						else if (cType == 0xDA)
						{
							break;
						}
						pBlobView->SetOffset(nStart + nSize);
					}
				}
			}
			return m_pImageInfo;
		}

		JpegLoader::JpegLoader()
		{
			m_pImageInfo = 0;
		}

		JpegLoader::~JpegLoader()
		{
			if (m_pImageInfo) delete m_pImageInfo;
		}

		XlsxWorksheet::XlsxWorksheet(Workbook* pWorkbook) : Worksheet(pWorkbook)
		{
		}

		bool XlsxWorksheet::Parse(XlsxWorkbookGlobals* pWorkbookGlobals, XmlNode* pWorksheetNode)
		{
			double dDefaultRowHeight = -1.0;
			{
				XmlNode* pSheetFormatPrElement = pWorksheetNode->GetFirstChildElement("sheetFormatPr");
				if (pSheetFormatPrElement != 0)
				{
					const char* szDefaultRowHeight = pSheetFormatPrElement->GetAttribute("defaultRowHeight");
					if (szDefaultRowHeight != 0)
						dDefaultRowHeight = ExternalString::atof(szDefaultRowHeight);
				}
			}
			{
				XmlNode* pColsNode = pWorksheetNode->GetFirstChildElement("cols");
				if (pColsNode != 0)
				{
					XmlNode* pColNode = pColsNode->GetFirstChildElement("col");
					while (pColNode != 0)
					{
						const char* szMin = pColNode->GetAttribute("min");
						if (szMin == 0)
							return false;
						unsigned short nMin = (unsigned short)(ExternalString::atol(szMin));
						const char* szMax = pColNode->GetAttribute("max");
						if (szMax == 0)
							return false;
						unsigned short nMax = (unsigned short)(ExternalString::atol(szMax));
						const char* szWidth = pColNode->GetAttribute("width");
						if (szWidth == 0)
							return false;
						double dWidth = ExternalString::atof(szWidth);
						bool bHidden = false;
						const char* szHidden = pColNode->GetAttribute("hidden");
						if (szHidden != 0 && szHidden[0] == '1')
							bHidden = true;
						for (unsigned short i = nMin; i <= nMax; i++)
						{
							SetColumnWidth((unsigned short)(i - 1), (unsigned short)(dWidth * 7.01));
							SetColumnHidden((unsigned short)(i - 1), bHidden);
						}
						pColNode = pColNode->GetNextSiblingElement("col");
					}
				}
			}
			{
				XmlNode* pMergeCellsNode = pWorksheetNode->GetFirstChildElement("mergeCells");
				if (pMergeCellsNode != 0)
				{
					XmlNode* pMergeCellNode = pMergeCellsNode->GetFirstChildElement("mergeCell");
					while (pMergeCellNode != 0)
					{
						const char* szRef = pMergeCellNode->GetAttribute("ref");
						if (szRef == 0)
							return false;
						Secret::Area* pArea = Secret::WorksheetImplementation::AddressToArea(szRef);
						CreateMergedCell(pArea->m_pTopLeft->m_nX, pArea->m_pTopLeft->m_nY, (unsigned short)(pArea->m_pBottomRight->m_nX - pArea->m_pTopLeft->m_nX + 1), (unsigned short)(pArea->m_pBottomRight->m_nY - pArea->m_pTopLeft->m_nY + 1));
						{
							delete pArea;
							pArea = 0;
						}
						pMergeCellNode = pMergeCellNode->GetNextSiblingElement("mergeCell");
						if (pArea) delete pArea;
					}
				}
			}
			{
				XmlNode* pSheetDataNode = pWorksheetNode->GetFirstChildElement("sheetData");
				if (pSheetDataNode != 0)
				{
					XmlNode* pRowNode = 0;
					pRowNode = pSheetDataNode->GetFirstChildElement("row");
					while (pRowNode != 0)
					{
						const char* szRow = pRowNode->GetAttribute("r");
						if (szRow == 0)
							return false;
						unsigned short nRow = (unsigned short)(ExternalString::atol(szRow));
						double dHeight = dDefaultRowHeight;
						const char* szHeight = pRowNode->GetAttribute("ht");
						if (szHeight != 0)
							dHeight = ExternalString::atof(szHeight);
						if (dHeight > 0)
							SetRowHeight((unsigned short)(nRow - 1), (unsigned short)(dHeight * 1.334));
						XmlNode* pCellNode = 0;
						pCellNode = pRowNode->GetFirstChildElement("c");
						while (pCellNode != 0)
						{
							Cell* pCell = 0;
							{
								const char* szReference = pCellNode->GetAttribute("r");
								if (szReference == 0)
									return false;
								pCell = GetCellByAddress(szReference);
								if (pCell == 0)
									return false;
							}
							{
								const char* szStyle = pCellNode->GetAttribute("s");
								if (szStyle != 0)
								{
									int nStyle = ExternalString::atoi(szStyle);
									Style* pStyle = pWorkbookGlobals->GetStyleByIndex((unsigned short)(nStyle));
									pCell->SetStyle(pStyle);
								}
							}
							const char* szType = pCellNode->GetAttribute("t");
							if (szType != 0)
							{
								if (ExternalString::Equal(szType, "s"))
								{
									XmlNode* pValueElement = 0;
									pValueElement = pCellNode->GetFirstChildElement("v");
									unsigned int nIndex = (unsigned int)(ExternalString::atol(pValueElement->GetText()));
									pCell->SetString(pWorkbookGlobals->GetSharedStringByIndex(nIndex));
								}
							}
							pCellNode = pCellNode->GetNextSiblingElement("c");
						}
						pRowNode = pRowNode->GetNextSiblingElement("row");
					}
				}
			}
			return true;
		}

		bool XlsxWorkbookGlobals::LoadVector(Vector<XmlNode*>* pVector, XmlNode* pStyleSheetNode, const char* szParent, const char* szChild)
		{
			XmlNode* pParentNode = pStyleSheetNode->GetFirstChildElement(szParent);
			if (pParentNode == 0)
				return false;
			XmlNode* pChildNode = pParentNode->GetFirstChildElement(szChild);
			while (pChildNode != 0)
			{
				pVector->PushBack(pChildNode);
				pChildNode = pChildNode->GetNextSiblingElement(szChild);
			}
			return true;
		}

		XmlNode* XlsxWorkbookGlobals::GetElement(Vector<XmlNode*>* pVector, int nIndex)
		{
			if (nIndex < 0 || pVector->GetSize() <= nIndex)
				return 0;
			return pVector->Get(nIndex);
		}

		unsigned int XlsxWorkbookGlobals::ParseColor(XmlNode* pColorNode)
		{
			const char* szIndexed = pColorNode->GetAttribute("indexed");
			const char* szRgb = pColorNode->GetAttribute("rgb");
			if (szIndexed != 0)
			{
				int nIndexed = ExternalString::atoi(szIndexed);
				if (nIndexed < BiffWorkbookGlobals::NUM_DEFAULT_PALETTE_ENTRY + BiffWorkbookGlobals::NUM_CUSTOM_PALETTE_ENTRY)
					return BiffWorkbookGlobals::GetDefaultPaletteColorByIndex((unsigned short)(nIndexed));
				if (nIndexed == BiffWorkbookGlobals::PALETTE_INDEX_DEFAULT_FOREGROUND)
					return 0x000000;
			}
			else if (szRgb != 0)
			{
				InternalString* sTemp = new InternalString("0x");
				sTemp->AppendString(szRgb);
				unsigned int nRgb = sTemp->ParseHex();
				{
					delete sTemp;
					sTemp = 0;
				}
				{
					if (sTemp) delete sTemp;
					return nRgb;
				}
			}
			nbAssert::Assert(false);
			return 0x000000;
		}

		bool XlsxWorkbookGlobals::ApplyFont(XmlNode* pFontNode, Style* pStyle)
		{
			Font* pFont = pStyle->GetFont();
			{
				XmlNode* pNameNode = pFontNode->GetFirstChildElement("name");
				if (pNameNode != 0)
				{
					const char* szVal = pNameNode->GetAttribute("val");
					if (szVal == 0)
						return false;
					pFont->SetName(szVal);
				}
			}
			{
				XmlNode* pSzElement = pFontNode->GetFirstChildElement("sz");
				if (pSzElement != 0)
				{
					const char* szVal = pSzElement->GetAttribute("val");
					if (szVal == 0)
						return false;
					double dPoints = (double)(ExternalString::atoi(szVal));
					double dPixels = (dPoints * 96.0 + 72.0 / 2.0) / 72.0;
					pFont->SetSize((unsigned char)(dPixels));
				}
			}
			{
				XmlNode* pBElement = pFontNode->GetFirstChildElement("b");
				if (pBElement != 0)
				{
					const char* szVal = pBElement->GetAttribute("val");
					if (szVal == 0 || szVal[0] == '1')
						pFont->SetBold(true);
					else
						pFont->SetBold(false);
				}
			}
			{
				XmlNode* pUElement = pFontNode->GetFirstChildElement("u");
				if (pUElement != 0)
				{
					const char* szVal = pUElement->GetAttribute("val");
					if (szVal == 0 || ExternalString::Equal(szVal, "single"))
						pFont->SetUnderline(Font::Underline::UNDERLINE_SINGLE);
					else if (ExternalString::Equal(szVal, "double"))
						pFont->SetUnderline(Font::Underline::UNDERLINE_DOUBLE);
					else if (ExternalString::Equal(szVal, "singleAccounting"))
						pFont->SetUnderline(Font::Underline::UNDERLINE_SINGLE_ACCOUNTING);
					else if (ExternalString::Equal(szVal, "doubleAccounting"))
						pFont->SetUnderline(Font::Underline::UNDERLINE_DOUBLE_ACCOUNTING);
				}
			}
			return true;
		}

		bool XlsxWorkbookGlobals::ApplyBorderLine(XmlNode* pSideElement, Line* pLine)
		{
			const char* szStyle = pSideElement->GetAttribute("style");
			if (szStyle != 0)
			{
				if (ExternalString::Equal(szStyle, "dashDot"))
					pLine->SetType(Line::Type::TYPE_DASH_DOT);
				else if (ExternalString::Equal(szStyle, "dashDotDot"))
					pLine->SetType(Line::Type::TYPE_DASH_DOT_DOT);
				else if (ExternalString::Equal(szStyle, "dashed"))
					pLine->SetType(Line::Type::TYPE_DASHED);
				else if (ExternalString::Equal(szStyle, "dotted"))
					pLine->SetType(Line::Type::TYPE_DOTTED);
				else if (ExternalString::Equal(szStyle, "double"))
					pLine->SetType(Line::Type::TYPE_THICK);
				else if (ExternalString::Equal(szStyle, "hair"))
					pLine->SetType(Line::Type::TYPE_THIN);
				else if (ExternalString::Equal(szStyle, "medium"))
					pLine->SetType(Line::Type::TYPE_MEDIUM);
				else if (ExternalString::Equal(szStyle, "mediumDashDot"))
					pLine->SetType(Line::Type::TYPE_MEDIUM_DASH_DOT);
				else if (ExternalString::Equal(szStyle, "mediumDashDotDot"))
					pLine->SetType(Line::Type::TYPE_MEDIUM_DASH_DOT_DOT);
				else if (ExternalString::Equal(szStyle, "mediumDashed"))
					pLine->SetType(Line::Type::TYPE_MEDIUM_DASHED);
				else if (ExternalString::Equal(szStyle, "none"))
					pLine->SetType(Line::Type::TYPE_NONE);
				else if (ExternalString::Equal(szStyle, "slantDashDot"))
					pLine->SetType(Line::Type::TYPE_DASHED);
				else if (ExternalString::Equal(szStyle, "thick"))
					pLine->SetType(Line::Type::TYPE_THICK);
				else if (ExternalString::Equal(szStyle, "thin"))
					pLine->SetType(Line::Type::TYPE_THIN);
				else
					return false;
			}
			XmlNode* pColorElement = pSideElement->GetFirstChildElement("color");
			if (pColorElement != 0)
				pLine->GetColor()->SetFromRgba(ParseColor(pColorElement));
			return true;
		}

		bool XlsxWorkbookGlobals::ApplyBorder(XmlNode* pBorderElement, Style* pStyle)
		{
			XmlNode* pSideElement = 0;
			pSideElement = pBorderElement->GetFirstChildElement("left");
			if (pSideElement != 0)
				if (!ApplyBorderLine(pSideElement, pStyle->GetLeftBorderLine()))
					return false;
			pSideElement = pBorderElement->GetFirstChildElement("right");
			if (pSideElement != 0)
				if (!ApplyBorderLine(pSideElement, pStyle->GetRightBorderLine()))
					return false;
			pSideElement = pBorderElement->GetFirstChildElement("top");
			if (pSideElement != 0)
				if (!ApplyBorderLine(pSideElement, pStyle->GetTopBorderLine()))
					return false;
			pSideElement = pBorderElement->GetFirstChildElement("bottom");
			if (pSideElement != 0)
				if (!ApplyBorderLine(pSideElement, pStyle->GetBottomBorderLine()))
					return false;
			return true;
		}

		bool XlsxWorkbookGlobals::ApplyFill(XmlNode* pFillElement, Style* pStyle)
		{
			XmlNode* pPatternFillElement = pFillElement->GetFirstChildElement("patternFill");
			if (pPatternFillElement != 0)
			{
				const char* szPatternType = pPatternFillElement->GetAttribute("patternType");
				if (szPatternType != 0)
				{
				}
				XmlNode* pColorElement = pPatternFillElement->GetFirstChildElement("fgColor");
				if (pColorElement != 0)
					pStyle->GetBackgroundColor(true)->SetFromRgba(ParseColor(pColorElement));
			}
			else
			{
			}
			return true;
		}

		bool XlsxWorkbookGlobals::ParseStyles(WorkbookGlobals* pWorkbookGlobals, XmlNode* pStyleSheetNode)
		{
			pWorkbookGlobals->m_pStyleVector->Clear();
			Vector<XmlNode*>* pNumFmtVector = new Vector<XmlNode*>();
			Vector<XmlNode*>* pFontVector = new Vector<XmlNode*>();
			Vector<XmlNode*>* pFillVector = new Vector<XmlNode*>();
			Vector<XmlNode*>* pBorderVector = new Vector<XmlNode*>();
			Vector<XmlNode*>* pCellStyleXfVector = new Vector<XmlNode*>();
			Vector<XmlNode*>* pCellXfVector = new Vector<XmlNode*>();
			Vector<XmlNode*>* pCellStyleVector = new Vector<XmlNode*>();
			bool bResult;
			LoadVector(pNumFmtVector, pStyleSheetNode, "numFmts", "numFmt");
			LoadVector(pFontVector, pStyleSheetNode, "fonts", "font");
			LoadVector(pFillVector, pStyleSheetNode, "fills", "fill");
			LoadVector(pBorderVector, pStyleSheetNode, "borders", "border");
			LoadVector(pCellStyleXfVector, pStyleSheetNode, "cellStyleXfs", "xf");
			LoadVector(pCellXfVector, pStyleSheetNode, "cellXfs", "xf");
			LoadVector(pCellStyleVector, pStyleSheetNode, "cellStyles", "cellStyle");
			bResult = SubParseStyles(pWorkbookGlobals, pStyleSheetNode, pNumFmtVector, pFontVector, pFillVector, pBorderVector, pCellStyleXfVector, pCellXfVector, pCellStyleVector);
			{
				delete pNumFmtVector;
				pNumFmtVector = 0;
			}
			{
				delete pFontVector;
				pFontVector = 0;
			}
			{
				delete pFillVector;
				pFillVector = 0;
			}
			{
				delete pBorderVector;
				pBorderVector = 0;
			}
			{
				delete pCellStyleXfVector;
				pCellStyleXfVector = 0;
			}
			{
				delete pCellXfVector;
				pCellXfVector = 0;
			}
			{
				delete pCellStyleVector;
				pCellStyleVector = 0;
			}
			{
				if (pNumFmtVector) delete pNumFmtVector;
				if (pFontVector) delete pFontVector;
				if (pFillVector) delete pFillVector;
				if (pBorderVector) delete pBorderVector;
				if (pCellStyleXfVector) delete pCellStyleXfVector;
				if (pCellXfVector) delete pCellXfVector;
				if (pCellStyleVector) delete pCellStyleVector;
				return bResult;
			}
		}

		bool XlsxWorkbookGlobals::SubParseStyles(WorkbookGlobals* pWorkbookGlobals, XmlNode* pStyleSheetNode, Vector<XmlNode*>* pNumFmtVector, Vector<XmlNode*>* pFontVector, Vector<XmlNode*>* pFillVector, Vector<XmlNode*>* pBorderVector, Vector<XmlNode*>* pCellStyleXfVector, Vector<XmlNode*>* pCellXfVector, Vector<XmlNode*>* pCellStyleVector)
		{
			for (int i = 0; i < pCellXfVector->GetSize(); i++)
			{
				Style* pStyle = pWorkbookGlobals->CreateStyle();
				XmlNode* pXfElement = pCellXfVector->Get(i);
				XmlNode* pInheritXfElement = 0;
				XmlNode* pCellStyleElement = 0;
				const char* szXfId = pXfElement->GetAttribute("xfId");
				if (szXfId != 0)
				{
					int nXfId = ExternalString::atoi(szXfId);
					if (nXfId < 0 || pCellStyleXfVector->GetSize() <= nXfId)
						return false;
					pInheritXfElement = pCellStyleXfVector->Get(nXfId);
					if (nXfId < 0 || pCellStyleVector->GetSize() <= nXfId)
						return false;
					pCellStyleElement = pCellStyleVector->Get(nXfId);
				}
				{
					const char* szFontId = 0;
					const char* szApplyFont = pXfElement->GetAttribute("applyFont");
					if (szApplyFont != 0 && szApplyFont[0] == '1')
						szFontId = pXfElement->GetAttribute("fontId");
					else
						szFontId = pInheritXfElement->GetAttribute("fontId");
					if (szFontId != 0)
					{
						XmlNode* pFontElement = GetElement(pFontVector, ExternalString::atoi(szFontId));
						if (pFontElement == 0)
							return false;
						if (!ApplyFont(pFontElement, pStyle))
							return false;
					}
				}
				{
					const char* szBorderId = 0;
					const char* szApplyBorder = pXfElement->GetAttribute("applyBorder");
					if (szApplyBorder != 0 && szApplyBorder[0] == '1')
						szBorderId = pXfElement->GetAttribute("borderId");
					else
						szBorderId = pInheritXfElement->GetAttribute("borderId");
					if (szBorderId != 0)
					{
						XmlNode* pBorderElement = GetElement(pBorderVector, ExternalString::atoi(szBorderId));
						if (pBorderElement == 0)
							return false;
						if (!ApplyBorder(pBorderElement, pStyle))
							return false;
					}
				}
				{
					const char* szFillId = 0;
					const char* szApplyFill = pXfElement->GetAttribute("applyFill");
					if (szApplyFill != 0 && szApplyFill[0] == '1')
						szFillId = pXfElement->GetAttribute("fillId");
					else
						szFillId = pInheritXfElement->GetAttribute("fillId");
					if (szFillId != 0)
					{
						XmlNode* pFillElement = GetElement(pFillVector, ExternalString::atoi(szFillId));
						if (pFillElement == 0)
							return false;
						if (!ApplyFill(pFillElement, pStyle))
							return false;
					}
				}
				{
					XmlNode* pAlignmentElement = 0;
					const char* szApplyAlignment = pXfElement->GetAttribute("applyAlignment");
					if (szApplyAlignment != 0 && szApplyAlignment[0] == '1')
						pAlignmentElement = pXfElement->GetFirstChildElement("alignment");
					else
						pAlignmentElement = pInheritXfElement->GetFirstChildElement("alignment");
					if (pAlignmentElement != 0)
					{
						const char* szHorizontal = pAlignmentElement->GetAttribute("horizontal");
						if (szHorizontal != 0)
						{
							if (ExternalString::Equal(szHorizontal, "general"))
								pStyle->SetHorizontalAlign(Style::HorizontalAlign::HORIZONTAL_ALIGN_GENERAL);
							else if (ExternalString::Equal(szHorizontal, "left"))
								pStyle->SetHorizontalAlign(Style::HorizontalAlign::HORIZONTAL_ALIGN_LEFT);
							else if (ExternalString::Equal(szHorizontal, "center"))
								pStyle->SetHorizontalAlign(Style::HorizontalAlign::HORIZONTAL_ALIGN_CENTER);
							else if (ExternalString::Equal(szHorizontal, "right"))
								pStyle->SetHorizontalAlign(Style::HorizontalAlign::HORIZONTAL_ALIGN_RIGHT);
							else if (ExternalString::Equal(szHorizontal, "fill"))
								pStyle->SetHorizontalAlign(Style::HorizontalAlign::HORIZONTAL_ALIGN_FILL);
							else if (ExternalString::Equal(szHorizontal, "justify"))
								pStyle->SetHorizontalAlign(Style::HorizontalAlign::HORIZONTAL_ALIGN_JUSTIFY);
							else if (ExternalString::Equal(szHorizontal, "centerContinuous"))
								pStyle->SetHorizontalAlign(Style::HorizontalAlign::HORIZONTAL_ALIGN_CENTER_ACROSS_SELECTION);
							else if (ExternalString::Equal(szHorizontal, "distributed"))
								pStyle->SetHorizontalAlign(Style::HorizontalAlign::HORIZONTAL_ALIGN_DISTRIBUTED);
						}
						const char* szVertical = pAlignmentElement->GetAttribute("vertical");
						if (szVertical != 0)
						{
							if (ExternalString::Equal(szVertical, "top"))
								pStyle->SetVerticalAlign(Style::VerticalAlign::VERTICAL_ALIGN_TOP);
							else if (ExternalString::Equal(szVertical, "center"))
								pStyle->SetVerticalAlign(Style::VerticalAlign::VERTICAL_ALIGN_CENTER);
							else if (ExternalString::Equal(szVertical, "bottom"))
								pStyle->SetVerticalAlign(Style::VerticalAlign::VERTICAL_ALIGN_BOTTOM);
							else if (ExternalString::Equal(szVertical, "justify"))
								pStyle->SetVerticalAlign(Style::VerticalAlign::VERTICAL_ALIGN_JUSTIFY);
							else if (ExternalString::Equal(szVertical, "distributed"))
								pStyle->SetVerticalAlign(Style::VerticalAlign::VERTICAL_ALIGN_DISTRIBUTED);
						}
					}
				}
				{
					const char* szNumFmtId = 0;
					const char* szApplyNumberFormat = pXfElement->GetAttribute("applyNumberFormat");
					if (szApplyNumberFormat != 0 && szApplyNumberFormat[0] == '1')
						szNumFmtId = pXfElement->GetAttribute("numFmtId");
					else
						szNumFmtId = pInheritXfElement->GetAttribute("numFmtId");
					if (szNumFmtId != 0)
					{
						int nNumFmtId = ExternalString::atoi(szNumFmtId);
						bool bFound = false;
						for (int j = 0; j < pNumFmtVector->GetSize(); j++)
						{
							XmlNode* pNumberFormatElement = pNumFmtVector->Get(j);
							const char* szTestNumFmtId = pNumberFormatElement->GetAttribute("numFmtId");
							if (szTestNumFmtId == 0)
								return false;
							if (ExternalString::Equal(szTestNumFmtId, szNumFmtId))
							{
								const char* szFormatCode = pNumberFormatElement->GetAttribute("formatCode");
								if (szFormatCode == 0)
									return false;
								pStyle->SetFormat(szFormatCode);
								bFound = true;
								break;
							}
						}
						if (!bFound)
						{
							switch (nNumFmtId)
							{
								case 0:
								{
									pStyle->SetFormat("General");
									break;
								}

								case 1:
								{
									pStyle->SetFormat("0");
									break;
								}

								case 2:
								{
									pStyle->SetFormat("0.00");
									break;
								}

								case 3:
								{
									pStyle->SetFormat("#,##0");
									break;
								}

								case 4:
								{
									pStyle->SetFormat("#,##0.00");
									break;
								}

								case 9:
								{
									pStyle->SetFormat("0%");
									break;
								}

								case 10:
								{
									pStyle->SetFormat("0.00%");
									break;
								}

								case 11:
								{
									pStyle->SetFormat("0.00E+00");
									break;
								}

								case 12:
								{
									pStyle->SetFormat("# \\?/\\?");
									break;
								}

								case 13:
								{
									pStyle->SetFormat("# \\?\\?/\\?\\?");
									break;
								}

								case 14:
								{
									pStyle->SetFormat("mm-dd-yy");
									break;
								}

								case 15:
								{
									pStyle->SetFormat("d-mmm-yy");
									break;
								}

								case 16:
								{
									pStyle->SetFormat("d-mmm");
									break;
								}

								case 17:
								{
									pStyle->SetFormat("mmm-yy");
									break;
								}

								case 18:
								{
									pStyle->SetFormat("h:mm AM/PM");
									break;
								}

								case 19:
								{
									pStyle->SetFormat("h:mm:ss AM/PM");
									break;
								}

								case 20:
								{
									pStyle->SetFormat("h:mm");
									break;
								}

								case 21:
								{
									pStyle->SetFormat("h:mm:ss");
									break;
								}

								case 22:
								{
									pStyle->SetFormat("m/d/yy h:mm");
									break;
								}

								case 37:
								{
									pStyle->SetFormat("#,##0 ;(#,##0)");
									break;
								}

								case 38:
								{
									pStyle->SetFormat("#,##0 ;[Red](#,##0)");
									break;
								}

								case 39:
								{
									pStyle->SetFormat("#,##0.00;-#,##0.00");
									break;
								}

								case 40:
								{
									pStyle->SetFormat("#,##0.00;[Red](#,##0.00)");
									break;
								}

								case 45:
								{
									pStyle->SetFormat("mm:ss");
									break;
								}

								case 46:
								{
									pStyle->SetFormat("[h]:mm:ss");
									break;
								}

								case 47:
								{
									pStyle->SetFormat("mmss.0");
									break;
								}

								case 48:
								{
									pStyle->SetFormat("##0.0E+0");
									break;
								}

								case 49:
								{
									pStyle->SetFormat("@");
									break;
								}

								default:
								{
									return false;
								}

							}
						}
					}
				}
			}
			return true;
		}

		ColumnInfo::ColumnInfo()
		{
			m_nWidth = 0;
			m_bHidden = false;
		}

		RowInfo::RowInfo()
		{
			m_nHeight = 0;
		}

		Coordinate::Coordinate()
		{
			m_nX = 0;
			m_nY = 0;
			m_bXRelative = false;
			m_bYRelative = false;
			m_nX = 0;
			m_nY = 0;
			m_bXRelative = true;
			m_bYRelative = true;
		}

		Coordinate::Coordinate(unsigned short nX, unsigned short nY, bool bXRelative, bool bYRelative)
		{
			m_nX = 0;
			m_nY = 0;
			m_bXRelative = false;
			m_bYRelative = false;
			nbAssert::Assert(nY <= Worksheet::MAX_ROW);
			nbAssert::Assert(nX <= Worksheet::MAX_COLUMN);
			m_nX = nX;
			m_nY = nY;
			m_bXRelative = bXRelative;
			m_bYRelative = bYRelative;
		}

		Coordinate* Coordinate::CreateClone()
		{
			return new Coordinate(m_nX, m_nY, m_bXRelative, m_bYRelative);
		}

		WorksheetRange::WorksheetRange(unsigned short nFirst, unsigned short nLast)
		{
			m_nFirst = 0;
			m_nLast = 0;
			m_nFirst = nFirst;
			m_nLast = nLast;
		}

		WorksheetRange* WorksheetRange::CreateClone()
		{
			return new WorksheetRange(m_nFirst, m_nLast);
		}

		Coordinate3d::Coordinate3d(unsigned short nWorksheetFirst, unsigned short nWorksheetLast, Coordinate* pCoordinate)
		{
			m_nWorksheetFirst = 0;
			m_nWorksheetLast = 0;
			m_pCoordinate = 0;
			m_nWorksheetFirst = nWorksheetFirst;
			m_nWorksheetLast = nWorksheetLast;
			m_pCoordinate = pCoordinate;
		}

		Coordinate3d* Coordinate3d::CreateClone()
		{
			return new Coordinate3d(m_nWorksheetFirst, m_nWorksheetLast, m_pCoordinate->CreateClone());
		}

		void Coordinate3d::ToString(WorksheetImplementation* pWorksheetImplementation, InternalString* sOut)
		{
			pWorksheetImplementation->WorksheetRangeToAddress(m_nWorksheetFirst, m_nWorksheetLast, sOut);
			sOut->AppendChar('!');
			WorksheetImplementation::CoordinateToAddress(m_pCoordinate, sOut);
		}

		Coordinate3d::~Coordinate3d()
		{
			if (m_pCoordinate) delete m_pCoordinate;
		}

		Area::Area(Coordinate* pTopLeft, Coordinate* pBottomRight)
		{
			m_pTopLeft = 0;
			m_pBottomRight = 0;
			m_pTopLeft = pTopLeft;
			m_pBottomRight = pBottomRight;
		}

		Area* Area::CreateClone()
		{
			return new Area(m_pTopLeft->CreateClone(), m_pBottomRight->CreateClone());
		}

		Area::~Area()
		{
			if (m_pTopLeft) delete m_pTopLeft;
			if (m_pBottomRight) delete m_pBottomRight;
		}

		Area3d::Area3d(unsigned short nWorksheetFirst, unsigned short nWorksheetLast, Area* pArea)
		{
			m_pWorksheetRange = 0;
			m_pArea = 0;
			m_pWorksheetRange = new WorksheetRange(nWorksheetFirst, nWorksheetLast);
			m_pArea = pArea;
		}

		Area3d* Area3d::CreateClone()
		{
			return new Area3d(m_pWorksheetRange->m_nFirst, m_pWorksheetRange->m_nLast, m_pArea->CreateClone());
		}

		Area3d::~Area3d()
		{
			if (m_pWorksheetRange) delete m_pWorksheetRange;
			if (m_pArea) delete m_pArea;
		}

		WorksheetImplementation::WorksheetImplementation(Workbook* pWorkbook, Worksheet* pWorksheet)
		{
			m_pWorkbook = 0;
			m_sName = 0;
			m_eOrientation = Worksheet::Orientation::ORIENTATION_PORTRAIT;
			m_bShowGridlines = false;
			m_bPrintGridlines = false;
			m_pCellTable = 0;
			m_pColumnInfoTable = 0;
			m_pRowInfoTable = 0;
			m_nDefaultRowHeight = 0;
			m_pPictureVector = 0;
			m_pChartVector = 0;
			m_pMergedCellVector = 0;
			m_pWorksheet = 0;
			m_sName = new Secret::InternalString("");
			m_pWorkbook = pWorkbook;
			m_pWorksheet = pWorksheet;
			m_eOrientation = Worksheet::Orientation::ORIENTATION_PORTRAIT;
			m_bPrintGridlines = false;
			m_bShowGridlines = true;
			m_pCellTable = new Table<Cell*>();
			m_pColumnInfoTable = new Table<ColumnInfo*>();
			m_pRowInfoTable = new Table<RowInfo*>();
			m_nDefaultRowHeight = 255;
			m_pPictureVector = new OwnedVector<Picture*>();
			m_pChartVector = new OwnedVector<Chart*>();
			m_pMergedCellVector = new OwnedVector<MergedCell*>();
		}

		WorksheetImplementation::~WorksheetImplementation()
		{
			{
				delete m_pPictureVector;
				m_pPictureVector = 0;
			}
			if (m_sName) delete m_sName;
			if (m_pCellTable) delete m_pCellTable;
			if (m_pColumnInfoTable) delete m_pColumnInfoTable;
			if (m_pRowInfoTable) delete m_pRowInfoTable;
			if (m_pPictureVector) delete m_pPictureVector;
			if (m_pChartVector) delete m_pChartVector;
			if (m_pMergedCellVector) delete m_pMergedCellVector;
		}

		unsigned short WorksheetImplementation::TwipsToPixels(unsigned short nTwips)
		{
			return (unsigned short)(((unsigned int)(nTwips) * 546 + 8190 / 2) / 8190);
		}

		unsigned short WorksheetImplementation::PixelsToTwips(unsigned short nPixels)
		{
			return (unsigned short)((unsigned int)(nPixels) * 8190 / 546);
		}

		void WorksheetImplementation::CoordinateToAddress(Coordinate* pCoordinate, InternalString* sOut)
		{
			if (!pCoordinate->m_bXRelative)
				sOut->AppendChar('$');
			if (pCoordinate->m_nX > 26)
				sOut->AppendChar((unsigned short)('A' + (pCoordinate->m_nX / 26 - 1)));
			sOut->AppendChar((unsigned short)('A' + pCoordinate->m_nX % 26));
			if (!pCoordinate->m_bYRelative)
				sOut->AppendChar('$');
			sOut->AppendUint32((unsigned int)(pCoordinate->m_nY) + 1);
		}

		void WorksheetImplementation::AreaToAddress(Area* pArea, InternalString* sOut)
		{
			CoordinateToAddress(pArea->m_pTopLeft, sOut);
			sOut->AppendChar(':');
			CoordinateToAddress(pArea->m_pBottomRight, sOut);
		}

		Coordinate* WorksheetImplementation::AddressToCoordinate(const char* szAddress)
		{
			unsigned short nX = 0;
			bool bXRelative = true;
			unsigned short nY = 0;
			bool bYRelative = true;
			unsigned short nMultiplier;
			unsigned short nBase;
			int nIndex = 0;
			Vector<int>* nTempVector = new Vector<int>();
			InternalString* sAddress = new InternalString(szAddress);
			if (sAddress->GetChar(nIndex) == '$')
			{
				bXRelative = false;
				nIndex++;
			}
			while (nIndex < sAddress->GetLength())
			{
				unsigned short cChar = sAddress->GetChar(nIndex);
				if (cChar >= 'A' && cChar <= 'Z')
					nTempVector->PushBack(cChar - 'A');
				else if (cChar >= 'a' && cChar <= 'z')
					nTempVector->PushBack(cChar - 'a');
				else
					break;
				nIndex++;
			}
			if (nTempVector->GetSize() == 0)
			{
				{
					delete nTempVector;
					nTempVector = 0;
				}
				{
					delete sAddress;
					sAddress = 0;
				}
				{
					if (nTempVector) delete nTempVector;
					if (sAddress) delete sAddress;
					return 0;
				}
			}
			nMultiplier = 1;
			nBase = 26;
			for (int i = 0; i < nTempVector->GetSize(); i++)
			{
				nX = (unsigned short)(nX + (nTempVector->Get(nTempVector->GetSize() - i - 1) + 1) * nMultiplier);
				nMultiplier = (unsigned short)(nMultiplier * nBase);
			}
			nX--;
			if (sAddress->GetChar(nIndex) == '$')
			{
				bYRelative = false;
				nIndex++;
			}
			nTempVector->Clear();
			while (nIndex < sAddress->GetLength())
			{
				unsigned short cChar = sAddress->GetChar(nIndex);
				if (cChar >= '0' && cChar <= '9')
					nTempVector->PushBack(cChar - '0');
				else
					break;
				nIndex++;
			}
			if (nTempVector->GetSize() == 0)
			{
				{
					if (nTempVector) delete nTempVector;
					if (sAddress) delete sAddress;
					return 0;
				}
			}
			if (nTempVector->GetSize() == 1 && nTempVector->Get(0) == '0')
			{
				{
					if (nTempVector) delete nTempVector;
					if (sAddress) delete sAddress;
					return 0;
				}
			}
			nMultiplier = 1;
			nBase = 10;
			for (int i = 0; i < nTempVector->GetSize(); i++)
			{
				nY = (unsigned short)(nY + nTempVector->Get(nTempVector->GetSize() - i - 1) * nMultiplier);
				nMultiplier = (unsigned short)(nMultiplier * nBase);
			}
			nY--;
			if (sAddress->GetLength() != nIndex)
			{
				{
					if (nTempVector) delete nTempVector;
					if (sAddress) delete sAddress;
					return 0;
				}
			}
			if (nX > 255 || nY > 65535)
			{
				if (nTempVector) delete nTempVector;
				if (sAddress) delete sAddress;
				return 0;
			}
			{
				if (nTempVector) delete nTempVector;
				if (sAddress) delete sAddress;
				return new Coordinate(nX, nY, bXRelative, bYRelative);
			}
		}

		Area* WorksheetImplementation::AddressToArea(const char* szAddress)
		{
			Area* pArea = 0;
			InternalString* sAddress = new InternalString(szAddress);
			int nIndex = sAddress->FindChar(':');
			if (nIndex >= 0)
			{
				InternalString* sFirst = new InternalString(szAddress);
				sFirst->SubStr(0, nIndex);
				InternalString* sSecond = new InternalString(szAddress);
				sSecond->SubStr(nIndex + 1, sSecond->GetLength() - (nIndex + 1));
				Coordinate* pFirst = AddressToCoordinate(sFirst->GetExternalString());
				Coordinate* pSecond = AddressToCoordinate(sSecond->GetExternalString());
				if (pFirst != 0 && pSecond != 0)
				{
					{
						NumberDuck::Secret::Coordinate* __1625950533 = pFirst;
						pFirst = 0;
						{
							NumberDuck::Secret::Coordinate* __3967857369 = pSecond;
							pSecond = 0;
							pArea = new Area(__1625950533, __3967857369);
						}
					}
				}
				if (sFirst) delete sFirst;
				if (sSecond) delete sSecond;
				if (pFirst) delete pFirst;
				if (pSecond) delete pSecond;
			}
			{
				NumberDuck::Secret::Area* __4245081970 = pArea;
				pArea = 0;
				{
					if (sAddress) delete sAddress;
					return __4245081970;
				}
			}
		}

		void WorksheetImplementation::WorksheetRangeToAddress(unsigned short nFirst, unsigned short nLast, InternalString* sOut)
		{
			nbAssert::Assert(nFirst >= 0 && nFirst <= m_pWorkbook->GetNumWorksheet());
			nbAssert::Assert(nLast >= nFirst && nLast <= m_pWorkbook->GetNumWorksheet());
			InternalString* sWorksheetFirst = m_pWorkbook->GetWorksheetByIndex(nFirst)->m_pImpl->m_sName;
			InternalString* sWorksheetLast = m_pWorkbook->GetWorksheetByIndex(nLast)->m_pImpl->m_sName;
			bool bHasSpace = sWorksheetFirst->FindChar(' ') != -1 || (nFirst != nLast && sWorksheetLast->FindChar(' ') != -1);
			if (bHasSpace)
				sOut->AppendChar('\'');
			sOut->AppendString(sWorksheetFirst->GetExternalString());
			if (nFirst != nLast)
			{
				sOut->AppendChar(':');
				sOut->AppendString(sWorksheetLast->GetExternalString());
			}
			if (bHasSpace)
				sOut->AppendChar('\'');
		}

		void WorksheetImplementation::Area3dToAddress(Area3d* pArea3d, InternalString* sOut)
		{
			WorksheetRangeToAddress(pArea3d->m_pWorksheetRange->m_nFirst, pArea3d->m_pWorksheetRange->m_nLast, sOut);
			sOut->AppendChar('!');
			AreaToAddress(pArea3d->m_pArea, sOut);
		}

		WorksheetRange* WorksheetImplementation::ParseWorksheetRange(InternalString* sString)
		{
			if (sString->GetLength() > 2)
			{
				InternalString* sFirst = sString->CreateClone();
				InternalString* sLast = 0;
				unsigned short nFirstChar = sFirst->GetChar(0);
				unsigned short nLastChar = sFirst->GetChar(sFirst->GetLength() - 1);
				if (nFirstChar == '\'' && nLastChar == '\'')
					sFirst->SubStr(1, sFirst->GetLength() - 2);
				sLast = sFirst->CreateClone();
				int nIndex = sFirst->FindChar(':');
				if (nIndex != -1)
				{
					sFirst->SubStr(0, nIndex);
					sLast->SubStr(nIndex + 1, sLast->GetLength() - (nIndex + 1));
				}
				int nWorksheetFirst = -1;
				int nWorksheetLast = -1;
				Workbook* pWorkbook = GetWorkbook();
				for (unsigned short i = 0; i < pWorkbook->GetNumWorksheet(); i++)
				{
					const char* szName = pWorkbook->GetWorksheetByIndex(i)->GetName();
					if (nWorksheetFirst == -1 && ExternalString::Equal(sFirst->GetExternalString(), szName))
						nWorksheetFirst = i;
					if (nWorksheetLast == -1 && ExternalString::Equal(sLast->GetExternalString(), szName))
						nWorksheetLast = i;
				}
				if (nWorksheetFirst >= 0 && nWorksheetLast >= 0)
				{
					if (sFirst) delete sFirst;
					if (sLast) delete sLast;
					return new WorksheetRange((unsigned short)(nWorksheetFirst), (unsigned short)(nWorksheetLast));
				}
				if (sFirst) delete sFirst;
				if (sLast) delete sLast;
			}
			return 0;
		}

		Coordinate3d* WorksheetImplementation::ParseCoordinate3d(InternalString* sString)
		{
			int nIndex = sString->FindChar('!');
			if (nIndex >= 0)
			{
				InternalString* sWorksheetRange = sString->CreateClone();
				sWorksheetRange->SubStr(0, nIndex);
				InternalString* sCell = sString->CreateClone();
				sCell->SubStr(nIndex + 1, sCell->GetLength() - (nIndex + 1));
				WorksheetRange* pWorksheetRange = ParseWorksheetRange(sWorksheetRange);
				if (pWorksheetRange != 0)
				{
					Coordinate* pCoordinate = AddressToCoordinate(sCell->GetExternalString());
					if (pCoordinate != 0)
					{
						Coordinate3d* pCoordinate3d = 0;
						{
							NumberDuck::Secret::Coordinate* __3642692973 = pCoordinate;
							pCoordinate = 0;
							pCoordinate3d = new Coordinate3d(pWorksheetRange->m_nFirst, pWorksheetRange->m_nLast, __3642692973);
						}
						{
							NumberDuck::Secret::Coordinate3d* __1094936853 = pCoordinate3d;
							pCoordinate3d = 0;
							{
								if (pCoordinate) delete pCoordinate;
								if (sWorksheetRange) delete sWorksheetRange;
								if (sCell) delete sCell;
								if (pWorksheetRange) delete pWorksheetRange;
								return __1094936853;
							}
						}
					}
					{
						delete pWorksheetRange;
						pWorksheetRange = 0;
					}
					if (pCoordinate) delete pCoordinate;
				}
				{
					delete sCell;
					sCell = 0;
				}
				{
					delete sWorksheetRange;
					sWorksheetRange = 0;
				}
				if (sWorksheetRange) delete sWorksheetRange;
				if (sCell) delete sCell;
				if (pWorksheetRange) delete pWorksheetRange;
			}
			return 0;
		}

		Area3d* WorksheetImplementation::ParseArea3d(InternalString* sString)
		{
			int nIndex = sString->FindChar('!');
			if (nIndex >= 0)
			{
				InternalString* sWorksheetRange = sString->CreateClone();
				sWorksheetRange->SubStr(0, nIndex);
				InternalString* sArea = sString->CreateClone();
				sArea->SubStr(nIndex + 1, sArea->GetLength() - (nIndex + 1));
				WorksheetRange* pWorksheetRange = ParseWorksheetRange(sWorksheetRange);
				if (pWorksheetRange != 0)
				{
					Area* pArea = AddressToArea(sArea->GetExternalString());
					if (pArea != 0)
					{
						Area3d* pArea3d = 0;
						{
							NumberDuck::Secret::Area* __4245081970 = pArea;
							pArea = 0;
							pArea3d = new Area3d(pWorksheetRange->m_nFirst, pWorksheetRange->m_nLast, __4245081970);
						}
						{
							NumberDuck::Secret::Area3d* __2738670685 = pArea3d;
							pArea3d = 0;
							{
								if (pArea) delete pArea;
								if (sWorksheetRange) delete sWorksheetRange;
								if (sArea) delete sArea;
								if (pWorksheetRange) delete pWorksheetRange;
								return __2738670685;
							}
						}
					}
					if (pArea) delete pArea;
				}
				if (sWorksheetRange) delete sWorksheetRange;
				if (sArea) delete sArea;
				if (pWorksheetRange) delete pWorksheetRange;
			}
			return 0;
		}

		ColumnInfo* WorksheetImplementation::GetColumnInfo(unsigned short nColumn)
		{
			TableElement<ColumnInfo*>* pElement = m_pColumnInfoTable->Get(nColumn, 0);
			if (pElement != 0)
				return pElement->m_xObject;
			return 0;
		}

		ColumnInfo* WorksheetImplementation::GetOrCreateColumnInfo(unsigned short nColumn)
		{
			TableElement<ColumnInfo*>* pElement = m_pColumnInfoTable->GetOrCreate(nColumn, 0);
			if (pElement->m_xObject == 0)
			{
				ColumnInfo* pColumnInfo = new ColumnInfo();
				pColumnInfo->m_bHidden = false;
				pColumnInfo->m_nWidth = Worksheet::DEFAULT_COLUMN_WIDTH;
				{
					NumberDuck::Secret::ColumnInfo* __1173438266 = pColumnInfo;
					pColumnInfo = 0;
					pElement->m_xObject = __1173438266;
				}
				if (pColumnInfo) delete pColumnInfo;
			}
			return pElement->m_xObject;
		}

		RowInfo* WorksheetImplementation::GetRowInfo(unsigned short nRow)
		{
			TableElement<RowInfo*>* pElement = m_pRowInfoTable->Get(0, nRow);
			if (pElement != 0)
				return pElement->m_xObject;
			return 0;
		}

		RowInfo* WorksheetImplementation::GetOrCreateRowInfo(unsigned short nRow)
		{
			TableElement<RowInfo*>* pElement = m_pRowInfoTable->GetOrCreate(0, nRow);
			if (pElement->m_xObject == 0)
			{
				RowInfo* pRowInfo = new RowInfo();
				pRowInfo->m_nHeight = Worksheet::DEFAULT_ROW_HEIGHT;
				{
					NumberDuck::Secret::RowInfo* __3798332131 = pRowInfo;
					pRowInfo = 0;
					pElement->m_xObject = __3798332131;
				}
				if (pRowInfo) delete pRowInfo;
			}
			return pElement->m_xObject;
		}

		Workbook* WorksheetImplementation::GetWorkbook()
		{
			return m_pWorkbook;
		}

		WorkbookImplementation::~WorkbookImplementation()
		{
			while (m_pWorksheetVector->GetSize() > 0)
			{
				Worksheet* pWorksheet = m_pWorksheetVector->Remove(0);
				{
					delete pWorksheet;
					pWorksheet = 0;
				}
				if (pWorksheet) delete pWorksheet;
			}
			if (m_pWorkbookGlobals) delete m_pWorkbookGlobals;
			if (m_pWorksheetVector) delete m_pWorksheetVector;
		}

		WorkbookImplementation::WorkbookImplementation()
		{
			m_pWorkbookGlobals = 0;
			m_pWorksheetVector = 0;
		}

		ValueImplementation::ValueImplementation()
		{
			m_eType = Value::Type::TYPE_EMPTY;
			m_sString = 0;
			m_fFloat = 0;
			m_bBoolean = false;
			m_pFormula = 0;
			m_pWorksheet = 0;
			m_pArea = 0;
			m_pArea3d = 0;
			m_pValue = 0;
			m_pFormula = 0;
			m_pValue = 0;
			m_sString = new InternalString("");
			m_pArea = 0;
			m_pArea3d = 0;
		}

		Value* ValueImplementation::CreateFloatValue(double fFloat)
		{
			Value* pValue = new Value();
			pValue->m_pImpl->SetFloat(fFloat);
			{
				NumberDuck::Value* __482980084 = pValue;
				pValue = 0;
				return __482980084;
			}
		}

		Value* ValueImplementation::CreateStringValue(const char* szString)
		{
			Value* pValue = new Value();
			pValue->m_pImpl->SetString(szString);
			{
				NumberDuck::Value* __482980084 = pValue;
				pValue = 0;
				return __482980084;
			}
		}

		Value* ValueImplementation::CreateBooleanValue(const bool bBoolean)
		{
			Value* pValue = new Value();
			pValue->m_pImpl->SetBoolean(bBoolean);
			{
				NumberDuck::Value* __482980084 = pValue;
				pValue = 0;
				return __482980084;
			}
		}

		Value* ValueImplementation::CreateErrorValue()
		{
			Value* pValue = new Value();
			pValue->m_pImpl->m_eType = Value::Type::TYPE_ERROR;
			{
				NumberDuck::Value* __482980084 = pValue;
				pValue = 0;
				return __482980084;
			}
		}

		Value* ValueImplementation::CreateAreaValue(Area* pArea)
		{
			Value* pValue = new Value();
			pValue->m_pImpl->m_eType = Value::Type::TYPE_AREA;
			pValue->m_pImpl->m_pArea = pArea;
			{
				NumberDuck::Value* __482980084 = pValue;
				pValue = 0;
				return __482980084;
			}
		}

		Value* ValueImplementation::CreateArea3dValue(Area3d* pArea3d)
		{
			Value* pValue = new Value();
			pValue->m_pImpl->m_eType = Value::Type::TYPE_AREA_3D;
			pValue->m_pImpl->m_pArea3d = pArea3d;
			{
				NumberDuck::Value* __482980084 = pValue;
				pValue = 0;
				return __482980084;
			}
		}

		Value* ValueImplementation::CopyValue(const Value* pValue)
		{
			Value* pNewValue = new Value();
			nbAssert::Assert(pValue->m_pImpl->m_eType != Value::Type::TYPE_FORMULA);
			pNewValue->m_pImpl->m_eType = pValue->m_pImpl->m_eType;
			pNewValue->m_pImpl->m_sString->Set(pValue->m_pImpl->m_sString->GetExternalString());
			pNewValue->m_pImpl->m_fFloat = pValue->m_pImpl->m_fFloat;
			pNewValue->m_pImpl->m_bBoolean = pValue->m_pImpl->m_bBoolean;
			if (pValue->m_pImpl->m_pArea != 0)
				pNewValue->m_pImpl->m_pArea = pValue->m_pImpl->m_pArea->CreateClone();
			if (pValue->m_pImpl->m_pArea3d != 0)
				pNewValue->m_pImpl->m_pArea3d = pValue->m_pImpl->m_pArea3d->CreateClone();
			{
				NumberDuck::Value* __4153834605 = pNewValue;
				pNewValue = 0;
				return __4153834605;
			}
		}

		void ValueImplementation::Clear()
		{
			m_eType = Value::Type::TYPE_EMPTY;
		}

		void ValueImplementation::SetString(const char* szString)
		{
			m_eType = Value::Type::TYPE_STRING;
			m_sString->Set(szString);
		}

		void ValueImplementation::SetFloat(double fFloat)
		{
			m_eType = Value::Type::TYPE_FLOAT;
			m_fFloat = fFloat;
		}

		void ValueImplementation::SetBoolean(bool bBoolean)
		{
			m_eType = Value::Type::TYPE_BOOLEAN;
			m_bBoolean = bBoolean;
		}

		void ValueImplementation::SetFormulaFromString(const char* szFormula, Worksheet* pWorksheet)
		{
			SetFormula(new Formula(szFormula, pWorksheet->m_pImpl), pWorksheet);
		}

		void ValueImplementation::SetFormula(Formula* pFormula, Worksheet* pWorksheet)
		{
			nbAssert::Assert(pFormula != 0);
			nbAssert::Assert(pWorksheet != 0);
			m_eType = Value::Type::TYPE_FORMULA;
			if (m_pFormula != 0)
				{
					delete m_pFormula;
					m_pFormula = 0;
				}
			m_pFormula = pFormula;
			m_pWorksheet = pWorksheet;
		}

		ValueImplementation::~ValueImplementation()
		{
			if (m_sString) delete m_sString;
			if (m_pFormula) delete m_pFormula;
			if (m_pArea) delete m_pArea;
			if (m_pArea3d) delete m_pArea3d;
			if (m_pValue) delete m_pValue;
		}

		StyleImplementation::StyleImplementation()
		{
			m_pFont = 0;
			m_eHorizontalAlign = Style::HorizontalAlign::HORIZONTAL_ALIGN_GENERAL;
			m_eVerticalAlign = Style::VerticalAlign::VERTICAL_ALIGN_TOP;
			m_pBackgroundColor = 0;
			m_eFillPattern = Style::FillPattern::FILL_PATTERN_NONE;
			m_pFillPatternColor = 0;
			m_pTopBorderLine = 0;
			m_pRightBorderLine = 0;
			m_pBottomBorderLine = 0;
			m_pLeftBorderLine = 0;
			m_sFormat = 0;
			m_nFormatIndex = 0;
			m_pFont = new Font();
			m_eHorizontalAlign = Style::HorizontalAlign::HORIZONTAL_ALIGN_GENERAL;
			m_eVerticalAlign = Style::VerticalAlign::VERTICAL_ALIGN_BOTTOM;
			m_pBackgroundColor = 0;
			m_eFillPattern = Style::FillPattern::FILL_PATTERN_NONE;
			m_pFillPatternColor = 0;
			m_pTopBorderLine = new Line();
			m_pTopBorderLine->SetType(Line::Type::TYPE_NONE);
			m_pRightBorderLine = new Line();
			m_pRightBorderLine->SetType(Line::Type::TYPE_NONE);
			m_pBottomBorderLine = new Line();
			m_pBottomBorderLine->SetType(Line::Type::TYPE_NONE);
			m_pLeftBorderLine = new Line();
			m_pLeftBorderLine->SetType(Line::Type::TYPE_NONE);
			m_sFormat = new InternalString("General");
		}

		StyleImplementation::~StyleImplementation()
		{
			if (m_pFont) delete m_pFont;
			if (m_pBackgroundColor) delete m_pBackgroundColor;
			if (m_pFillPatternColor) delete m_pFillPatternColor;
			if (m_pTopBorderLine) delete m_pTopBorderLine;
			if (m_pRightBorderLine) delete m_pRightBorderLine;
			if (m_pBottomBorderLine) delete m_pBottomBorderLine;
			if (m_pLeftBorderLine) delete m_pLeftBorderLine;
			if (m_sFormat) delete m_sFormat;
		}

		SharedString::SharedString()
		{
			m_sString = 0;
			m_nChecksum = 0;
			m_nIndex = 0;
		}

		SharedString::~SharedString()
		{
			if (m_sString) delete m_sString;
		}

		SharedStringContainer::SharedStringContainer()
		{
			m_pSharedStringVector = 0;
			m_pSharedStringSortedVector = 0;
			m_pSharedStringVector = new OwnedVector<SharedString*>();
			m_pSharedStringSortedVector = new Vector<SharedString*>();
		}

		SharedStringContainer::~SharedStringContainer()
		{
			if (m_pSharedStringVector) delete m_pSharedStringVector;
			if (m_pSharedStringSortedVector) delete m_pSharedStringSortedVector;
		}

		void SharedStringContainer::Clear()
		{
			m_pSharedStringVector->Clear();
			m_pSharedStringSortedVector->Clear();
		}

		const char* SharedStringContainer::Get(int nIndex)
		{
			return m_pSharedStringVector->Get(nIndex)->m_sString->GetExternalString();
		}

		int SharedStringContainer::GetIndex(const char* sxString)
		{
			int nChecksum = ExternalString::GetChecksum(sxString);
			int i = 0;
			while (i < m_pSharedStringSortedVector->GetSize())
			{
				SharedString* pTest = m_pSharedStringSortedVector->Get(i);
				if (pTest->m_nChecksum > nChecksum)
					break;
				if (pTest->m_nChecksum == nChecksum && ExternalString::Equal(sxString, pTest->m_sString->GetExternalString()))
					return pTest->m_nIndex;
				i++;
			}
			return Push(sxString);
		}

		int SharedStringContainer::Push(const char* sxString)
		{
			int nIndex = m_pSharedStringVector->GetSize();
			SharedString* pSharedString = new SharedString();
			pSharedString->m_sString = new InternalString(sxString);
			pSharedString->m_nIndex = nIndex;
			pSharedString->m_nChecksum = ExternalString::GetChecksum(sxString);
			int i = 0;
			while (i < m_pSharedStringSortedVector->GetSize())
			{
				SharedString* pTest = m_pSharedStringSortedVector->Get(i);
				if (pTest->m_nChecksum >= pSharedString->m_nChecksum)
					break;
				i++;
			}
			m_pSharedStringSortedVector->Insert(i, pSharedString);
			{
				NumberDuck::Secret::SharedString* __3093361001 = pSharedString;
				pSharedString = 0;
				m_pSharedStringVector->PushBack(__3093361001);
			}
			{
				if (pSharedString) delete pSharedString;
				return nIndex;
			}
		}

		int SharedStringContainer::GetSize()
		{
			return m_pSharedStringVector->GetSize();
		}

		SeriesImplementation::SeriesImplementation(Worksheet* pWorksheet, Formula* pValuesFormula)
		{
			m_pWorksheet = 0;
			m_pNameFormula = 0;
			m_pValuesFormula = 0;
			m_pLine = 0;
			m_pFill = 0;
			m_pMarker = 0;
			m_pWorksheet = pWorksheet;
			m_pNameFormula = 0;
			m_pValuesFormula = pValuesFormula;
			m_pLine = new Line();
			m_pFill = new Fill();
			m_pMarker = new Marker();
		}

		void SeriesImplementation::SetNameFormula(Formula* pFormula)
		{
			nbAssert::Assert(pFormula != 0);
			{
				delete m_pNameFormula;
				m_pNameFormula = 0;
			}
			m_pNameFormula = pFormula;
		}

		void SeriesImplementation::SetValuesFormula(Formula* pFormula)
		{
			nbAssert::Assert(pFormula != 0);
			{
				delete m_pValuesFormula;
				m_pValuesFormula = 0;
			}
			m_pValuesFormula = pFormula;
		}

		void SeriesImplementation::SetClassicStyle(Chart::Type eChartType, unsigned short nIndex)
		{
			unsigned short nColorIndex = (unsigned short)(BiffWorkbookGlobals::NUM_DEFAULT_PALETTE_ENTRY + 1 + (24 + nIndex - 1) % (BiffWorkbookGlobals::NUM_CUSTOM_PALETTE_ENTRY - 1));
			m_pLine->GetColor()->SetFromRgba(BiffWorkbookGlobals::GetDefaultPaletteColorByIndex(nColorIndex));
			nColorIndex = (unsigned short)(BiffWorkbookGlobals::NUM_DEFAULT_PALETTE_ENTRY + 1 + (16 + nIndex - 1) % (BiffWorkbookGlobals::NUM_CUSTOM_PALETTE_ENTRY - 1));
			m_pFill->GetForegroundColor()->SetFromRgba(BiffWorkbookGlobals::GetDefaultPaletteColorByIndex(nColorIndex));
			m_pMarker->GetBorderColor(true)->SetFromColor(m_pLine->GetColor());
			m_pMarker->GetFillColor(true)->SetFromColor(m_pLine->GetColor());
			switch (eChartType)
			{
				case Chart::Type::TYPE_COLUMN:
				case Chart::Type::TYPE_COLUMN_STACKED:
				case Chart::Type::TYPE_COLUMN_STACKED_100:
				case Chart::Type::TYPE_BAR:
				case Chart::Type::TYPE_BAR_STACKED:
				case Chart::Type::TYPE_BAR_STACKED_100:
				case Chart::Type::TYPE_AREA:
				case Chart::Type::TYPE_AREA_STACKED:
				case Chart::Type::TYPE_AREA_STACKED_100:
				{
					m_pLine->GetColor()->Set(0x00, 0x00, 0x00);
					break;
				}

				case Chart::Type::TYPE_LINE:
				case Chart::Type::TYPE_LINE_STACKED:
				case Chart::Type::TYPE_LINE_STACKED_100:
				{
					break;
				}

				case Chart::Type::TYPE_SCATTER:
				{
					m_pLine->SetType(Line::Type::TYPE_NONE);
					break;
				}

				default:
				{
					nbAssert::Assert(false);
					break;
				}

			}
			switch (nIndex % 9)
			{
				case 0:
				{
					m_pMarker->SetType(Marker::Type::TYPE_DIAMOND);
					break;
				}

				case 1:
				{
					m_pMarker->SetType(Marker::Type::TYPE_SQUARE);
					break;
				}

				case 2:
				{
					m_pMarker->SetType(Marker::Type::TYPE_TRIANGLE);
					break;
				}

				case 3:
				{
					m_pMarker->SetType(Marker::Type::TYPE_X);
					break;
				}

				case 4:
				{
					m_pMarker->SetType(Marker::Type::TYPE_ASTERISK);
					break;
				}

				case 5:
				{
					m_pMarker->SetType(Marker::Type::TYPE_CIRCULAR);
					break;
				}

				case 6:
				{
					m_pMarker->SetType(Marker::Type::TYPE_PLUS);
					break;
				}

				case 7:
				{
					m_pMarker->SetType(Marker::Type::TYPE_SHORT_BAR);
					break;
				}

				case 8:
				{
					m_pMarker->SetType(Marker::Type::TYPE_LONG_BAR);
					break;
				}

			}
			if (m_pMarker->GetType() == Marker::Type::TYPE_X || m_pMarker->GetType() == Marker::Type::TYPE_ASTERISK || m_pMarker->GetType() == Marker::Type::TYPE_PLUS)
				m_pMarker->ClearFillColor();
		}

		SeriesImplementation::~SeriesImplementation()
		{
			if (m_pNameFormula) delete m_pNameFormula;
			if (m_pValuesFormula) delete m_pValuesFormula;
			if (m_pLine) delete m_pLine;
			if (m_pFill) delete m_pFill;
			if (m_pMarker) delete m_pMarker;
		}

		PictureImplementation::PictureImplementation(Blob* pBlob, Picture::Format eFormat)
		{
			m_nX = 0;
			m_nY = 0;
			m_nSubX = 0;
			m_nSubY = 0;
			m_nWidth = 0;
			m_nHeight = 0;
			m_sUrl = 0;
			m_pBlob = 0;
			m_eFormat = Picture::Format::PNG;
			m_nX = 0;
			m_nY = 0;
			m_nSubX = 0;
			m_nSubY = 0;
			m_nWidth = 200;
			m_nHeight = 100;
			m_sUrl = new InternalString("");
			BlobView* pBlobView = pBlob->GetBlobView();
			pBlobView->SetOffset(0);
			m_pBlob = new Blob(false);
			m_pBlob->Resize(pBlob->GetSize(), false);
			m_pBlob->GetBlobView()->Pack(pBlobView, pBlob->GetSize());
			m_eFormat = eFormat;
		}

		PictureImplementation::~PictureImplementation()
		{
			if (m_sUrl) delete m_sUrl;
			if (m_pBlob) delete m_pBlob;
		}

		MergedCellImplementation::MergedCellImplementation()
		{
			m_nX = 0;
			m_nY = 0;
			m_nWidth = 0;
			m_nHeight = 0;
		}

		MarkerImplementation::MarkerImplementation()
		{
			m_eType = Marker::Type::TYPE_NONE;
			m_pFillColor = 0;
			m_pBorderColor = 0;
			m_nSize = 0;
			m_eType = Marker::Type::TYPE_SQUARE;
			m_nSize = WorksheetImplementation::TwipsToPixels(100);
			m_pFillColor = new Color(255, 0, 255);
			m_pBorderColor = new Color(0, 255, 0);
		}

		bool MarkerImplementation::Equals(const MarkerImplementation* pMarkerImplementation) const
		{
			return pMarkerImplementation != 0 && m_eType == pMarkerImplementation->m_eType && (m_pFillColor == 0 && pMarkerImplementation->m_pFillColor == 0 || m_pFillColor != 0 && m_pFillColor->Equals(pMarkerImplementation->m_pFillColor)) && (m_pBorderColor == 0 && pMarkerImplementation->m_pBorderColor == 0 || m_pBorderColor != 0 && m_pBorderColor->Equals(pMarkerImplementation->m_pBorderColor));
		}

		Marker::Type MarkerImplementation::GetType() const
		{
			return m_eType;
		}

		void MarkerImplementation::SetType(Marker::Type eType)
		{
			if (eType >= Marker::Type::TYPE_NONE && eType < Marker::Type::NUM_TYPE)
				m_eType = eType;
		}

		Color* MarkerImplementation::GetFillColor(bool bCreateIfMissing)
		{
			if (m_pFillColor == 0 && bCreateIfMissing)
				m_pFillColor = new Color(255, 0, 255);
			return m_pFillColor;
		}

		void MarkerImplementation::SetFillColor(const Color* pColor)
		{
			if (m_pFillColor == 0)
				m_pFillColor = new Color(255, 0, 255);
			m_pFillColor->SetFromColor(pColor);
		}

		void MarkerImplementation::ClearFillColor()
		{
			{
				delete m_pFillColor;
				m_pFillColor = 0;
			}
			m_pFillColor = 0;
		}

		Color* MarkerImplementation::GetBorderColor(bool bCreateIfMissing)
		{
			if (m_pBorderColor == 0 && bCreateIfMissing)
				m_pBorderColor = new Color(0, 255, 0);
			return m_pBorderColor;
		}

		void MarkerImplementation::SetBorderColor(const Color* pColor)
		{
			if (m_pBorderColor == 0)
				m_pBorderColor = new Color(0, 255, 0);
			m_pBorderColor->SetFromColor(pColor);
		}

		void MarkerImplementation::ClearBorderColor()
		{
			{
				delete m_pBorderColor;
				m_pBorderColor = 0;
			}
			m_pBorderColor = 0;
		}

		int MarkerImplementation::GetSize() const
		{
			return m_nSize;
		}

		void MarkerImplementation::SetSize(int nSize)
		{
			if (nSize >= WorksheetImplementation::TwipsToPixels(40) && nSize <= WorksheetImplementation::TwipsToPixels(1440))
				m_nSize = nSize;
		}

		MarkerImplementation::~MarkerImplementation()
		{
			if (m_pFillColor) delete m_pFillColor;
			if (m_pBorderColor) delete m_pBorderColor;
		}

		LineImplementation::LineImplementation()
		{
			m_eType = Line::Type::TYPE_NONE;
			m_pColor = 0;
			m_eType = Line::Type::TYPE_THIN;
			m_pColor = new Color(0xFF, 0x00, 0x00);
		}

		bool LineImplementation::Equals(const LineImplementation* pLineImplementation) const
		{
			return pLineImplementation != 0 && m_eType == pLineImplementation->m_eType && m_pColor->Equals(pLineImplementation->m_pColor);
		}

		Line::Type LineImplementation::GetType() const
		{
			return m_eType;
		}

		void LineImplementation::SetType(Line::Type eType)
		{
			if (eType >= Line::Type::TYPE_NONE && eType < Line::Type::NUM_TYPE)
				m_eType = eType;
		}

		LineImplementation::~LineImplementation()
		{
			if (m_pColor) delete m_pColor;
		}

		LegendImplementation::LegendImplementation()
		{
			m_bHidden = false;
			m_pBorderLine = 0;
			m_pFill = 0;
			m_bHidden = false;
			m_pBorderLine = new Line();
			m_pFill = new Fill();
		}

		LegendImplementation::~LegendImplementation()
		{
			if (m_pBorderLine) delete m_pBorderLine;
			if (m_pFill) delete m_pFill;
		}

		FontImplementation::FontImplementation()
		{
			m_sName = 0;
			m_nSizeTwips = 0;
			m_pColor = 0;
			m_bBold = false;
			m_bItalic = false;
			m_eUnderline = Font::Underline::UNDERLINE_NONE;
			m_sName = new InternalString("Arial");
			m_nSizeTwips = 14 * 15;
			m_pColor = 0;
			m_bBold = false;
			m_bItalic = false;
			m_eUnderline = Font::Underline::UNDERLINE_NONE;
		}

		FontImplementation::~FontImplementation()
		{
			if (m_sName) delete m_sName;
			if (m_pColor) delete m_pColor;
		}

		FillImplementation::FillImplementation()
		{
			m_eType = Fill::Type::TYPE_NONE;
			m_pForegroundColor = 0;
			m_pBackgroundColor = 0;
			m_eType = Fill::Type::TYPE_SOLID;
			m_pForegroundColor = new Color(0, 255, 0);
			m_pBackgroundColor = new Color(0, 0, 255);
		}

		bool FillImplementation::Equals(const FillImplementation* pFillImplementation) const
		{
			return pFillImplementation != 0 && m_eType == pFillImplementation->m_eType && m_pForegroundColor->Equals(pFillImplementation->m_pForegroundColor) && m_pBackgroundColor->Equals(pFillImplementation->m_pBackgroundColor);
		}

		Fill::Type FillImplementation::GetType() const
		{
			return m_eType;
		}

		void FillImplementation::SetType(Fill::Type eType)
		{
			if (eType >= Fill::Type::TYPE_NONE && eType < Fill::Type::NUM_TYPE)
				m_eType = eType;
		}

		FillImplementation::~FillImplementation()
		{
			if (m_pForegroundColor) delete m_pForegroundColor;
			if (m_pBackgroundColor) delete m_pBackgroundColor;
		}

		ChartImplementation::ChartImplementation(Worksheet* pWorksheet, Chart::Type eType)
		{
			m_pWorksheet = 0;
			m_nX = 0;
			m_nY = 0;
			m_nSubX = 0;
			m_nSubY = 0;
			m_nWidth = 0;
			m_nHeight = 0;
			m_eType = Chart::Type::TYPE_COLUMN;
			m_pCategoriesFormula = 0;
			m_sTitle = 0;
			m_sHorizontalAxisLabel = 0;
			m_sVerticalAxisLabel = 0;
			m_pLegend = 0;
			m_pFrameBorderLine = 0;
			m_pFrameFill = 0;
			m_pPlotBorderLine = 0;
			m_pPlotFill = 0;
			m_pHorizontalAxisLine = 0;
			m_pHorizontalGridLine = 0;
			m_pVerticalAxisLine = 0;
			m_pVerticalGridLine = 0;
			m_pSeriesVector = 0;
			m_pWorksheet = pWorksheet;
			m_nX = 0;
			m_nY = 0;
			m_nSubX = 0;
			m_nSubY = 0;
			m_nWidth = 200;
			m_nHeight = 100;
			m_eType = Chart::Type::TYPE_COLUMN;
			if (eType >= Chart::Type::TYPE_COLUMN && eType < Chart::Type::NUM_TYPE)
				m_eType = eType;
			m_pCategoriesFormula = 0;
			m_pLegend = new Legend();
			m_sTitle = new InternalString("");
			m_sHorizontalAxisLabel = new InternalString("");
			m_sVerticalAxisLabel = new InternalString("");
			m_pFrameBorderLine = new Line();
			m_pFrameFill = new Fill();
			m_pPlotBorderLine = new Line();
			m_pPlotFill = new Fill();
			m_pHorizontalAxisLine = new Line();
			m_pHorizontalGridLine = new Line();
			m_pVerticalAxisLine = new Line();
			m_pVerticalGridLine = new Line();
			SetClassicStyle();
			m_pLegend->SetHidden(false);
			m_pLegend->GetBorderLine()->GetColor()->Set(0x00, 0x00, 0x00);
			m_pLegend->GetFill()->GetForegroundColor()->Set(0xFF, 0xFF, 0xFF);
			m_pSeriesVector = new OwnedVector<Series*>();
		}

		Series* ChartImplementation::CreateSeries(Formula* pValuesFormula)
		{
			nbAssert::Assert(pValuesFormula != 0);
			Series* pSeries = new Series(m_pWorksheet, pValuesFormula);
			pSeries->m_pImpl->SetClassicStyle(m_eType, (unsigned short)(m_pSeriesVector->GetSize()));
			Series* pTemp = pSeries;
			{
				NumberDuck::Series* __1756674346 = pSeries;
				pSeries = 0;
				m_pSeriesVector->PushBack(__1756674346);
			}
			{
				if (pSeries) delete pSeries;
				return pTemp;
			}
		}

		void ChartImplementation::PurgeSeries(int nIndex)
		{
			if (nIndex >= 0 && nIndex < m_pSeriesVector->GetSize())
			{
				m_pSeriesVector->Erase(nIndex);
			}
		}

		void ChartImplementation::SetCategoriesFormula(Formula* pCategoriesFormula)
		{
			nbAssert::Assert(pCategoriesFormula != 0);
			{
				delete m_pCategoriesFormula;
				m_pCategoriesFormula = 0;
			}
			m_pCategoriesFormula = pCategoriesFormula;
		}

		void ChartImplementation::SetClassicStyle()
		{
			m_pFrameBorderLine->GetColor()->Set(0xFF, 0xFF, 0xFF);
			m_pFrameFill->GetForegroundColor()->Set(0xFF, 0xFF, 0xFF);
			m_pPlotBorderLine->GetColor()->Set(0x84, 0x84, 0x84);
			m_pPlotFill->GetForegroundColor()->Set(0xD0, 0xD0, 0xD0);
			m_pHorizontalAxisLine->GetColor()->Set(0x00, 0x00, 0x00);
			m_pHorizontalGridLine->SetType(Line::Type::TYPE_NONE);
			m_pVerticalAxisLine->GetColor()->Set(0x00, 0x00, 0x00);
			m_pVerticalGridLine->SetType(Line::Type::TYPE_NONE);
			m_pLegend->SetHidden(true);
			m_pLegend->GetBorderLine()->GetColor()->Set(0x00, 0x00, 0x00);
			m_pLegend->GetFill()->GetForegroundColor()->Set(0xFF, 0xFF, 0xFF);
		}

		void ChartImplementation::InsertColumn(unsigned short nWorksheet, unsigned short nColumn)
		{
			if (m_pCategoriesFormula != 0)
				m_pCategoriesFormula->InsertColumn(nWorksheet, nColumn);
			for (int i = 0; i < m_pSeriesVector->GetSize(); i++)
			{
				Series* pSeries = m_pSeriesVector->Get(i);
				pSeries->m_pImpl->m_pNameFormula->InsertColumn(nWorksheet, nColumn);
				pSeries->m_pImpl->m_pValuesFormula->InsertColumn(nWorksheet, nColumn);
			}
		}

		void ChartImplementation::DeleteColumn(unsigned short nWorksheet, unsigned short nColumn)
		{
			if (m_pCategoriesFormula != 0)
				m_pCategoriesFormula->DeleteColumn(nWorksheet, nColumn);
			for (int i = 0; i < m_pSeriesVector->GetSize(); i++)
			{
				Series* pSeries = m_pSeriesVector->Get(i);
				pSeries->m_pImpl->m_pNameFormula->DeleteColumn(nWorksheet, nColumn);
				pSeries->m_pImpl->m_pValuesFormula->DeleteColumn(nWorksheet, nColumn);
			}
		}

		void ChartImplementation::InsertRow(unsigned short nWorksheet, unsigned short nRow)
		{
			if (m_pCategoriesFormula != 0)
				m_pCategoriesFormula->InsertRow(nWorksheet, nRow);
			for (int i = 0; i < m_pSeriesVector->GetSize(); i++)
			{
				Series* pSeries = m_pSeriesVector->Get(i);
				pSeries->m_pImpl->m_pNameFormula->InsertRow(nWorksheet, nRow);
				pSeries->m_pImpl->m_pValuesFormula->InsertRow(nWorksheet, nRow);
			}
		}

		void ChartImplementation::DeleteRow(unsigned short nWorksheet, unsigned short nRow)
		{
			if (m_pCategoriesFormula != 0)
				m_pCategoriesFormula->DeleteRow(nWorksheet, nRow);
			for (int i = 0; i < m_pSeriesVector->GetSize(); i++)
			{
				Series* pSeries = m_pSeriesVector->Get(i);
				pSeries->m_pImpl->m_pNameFormula->DeleteRow(nWorksheet, nRow);
				pSeries->m_pImpl->m_pValuesFormula->DeleteRow(nWorksheet, nRow);
			}
		}

		ChartImplementation::~ChartImplementation()
		{
			if (m_pCategoriesFormula) delete m_pCategoriesFormula;
			if (m_sTitle) delete m_sTitle;
			if (m_sHorizontalAxisLabel) delete m_sHorizontalAxisLabel;
			if (m_sVerticalAxisLabel) delete m_sVerticalAxisLabel;
			if (m_pLegend) delete m_pLegend;
			if (m_pFrameBorderLine) delete m_pFrameBorderLine;
			if (m_pFrameFill) delete m_pFrameFill;
			if (m_pPlotBorderLine) delete m_pPlotBorderLine;
			if (m_pPlotFill) delete m_pPlotFill;
			if (m_pHorizontalAxisLine) delete m_pHorizontalAxisLine;
			if (m_pHorizontalGridLine) delete m_pHorizontalGridLine;
			if (m_pVerticalAxisLine) delete m_pVerticalAxisLine;
			if (m_pVerticalGridLine) delete m_pVerticalGridLine;
			if (m_pSeriesVector) delete m_pSeriesVector;
		}

		Workbook* CellImplementation::GetWorkbook()
		{
			return m_pWorksheet->m_pImpl->GetWorkbook();
		}

		void CellImplementation::SetFormula(Formula* pFormula)
		{
			m_pValue->m_pImpl->SetFormula(pFormula, m_pWorksheet);
		}

		CellImplementation::CellImplementation()
		{
			m_pWorksheet = 0;
			m_pValue = 0;
			m_pStyle = 0;
		}

		CellImplementation::~CellImplementation()
		{
			if (m_pValue) delete m_pValue;
		}

																			}
}

